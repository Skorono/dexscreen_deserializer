var FOe = Object.defineProperty;
var UOe = (t, e, r) => e in t ? FOe(t, e, {enumerable: !0, configurable: !0, writable: !0, value: r}) : t[e] = r;
var Ft = (t, e, r) => (UOe(t, typeof e != "symbol" ? e + "" : e, r), r);
import {p as Ve, _ as na} from "../chunks/preload-helper-Jimfoxkq.js";


var window = {};
var document = {};
document.querySelectorAll = () => [];
window.__DS_ENV = {
    "DS_WEB_URL": "https:\u002F\u002Fdexscreener.com",
    "DS_WEB_PAIR_DETAILS_SERVER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_WEB_DEX_TRENDING_SERVER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_WEB_DEX_SCREENER_WSS_HOST": "wss:\u002F\u002Fio.dexscreener.com",
    "DS_WEB_PLAUSIBLE_ENABLED": true,
    "DS_WEB_PLAUSIBLE_DOMAIN": "dexscreener.com",
    "DS_WEB_PLAUSIBLE_HOST": "https:\u002F\u002Fpl.dexscreener.com",
    "DS_WEB_WORKER_LOG_APP_NAME": "ds-web",
    "DS_WEB_WORKER_LOG_ENDPOINT": "",
    "DS_WEB_WORKER_LOG_STDOUT_ENABLED": false,
    "DS_WEB_CFW_ADS_HOST": "https:\u002F\u002Fcfw.dexscreener.com",
    "DS_WEB_SCREENSHOTS_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DATA_SERVER_PUBLIC_ORIGIN": "https:\u002F\u002Fdd.dexscreener.com",
    "DS_WEB_ASSETS_HOST": "https:\u002F\u002Fcdn.dexscreener.com",
    "DS_WEB_NEWS_SERVER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_WEB_HYPE_SERVER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_WEB_BALANCE_SERVER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_WEB_ADS_PAGES_PUBLIC_ORIGIN": "https:\u002F\u002Fa.dexscreen.com",
    "DS_WEB_MOONSHOT_SERVER_HOST": "https:\u002F\u002Fms.dexscreener.com",
    "DS_WEB_MAX_TRENDING_BAR_ADS_AMOUNT": 5,
    "DS_WEB_SOLANA_WALLET_ADAPTER_NETWORK": "mainnet-beta",
    "DS_WEB_SOLANA_WALLET_ADAPTER_RPC_URL": "https:\u002F\u002Fjupiter-terminal-rpc.dexscreener.com",
    "DS_WEB_RECAPTCHA_ENTERPRISE_SCORE_SITE_KEY": "6LfCZxsqAAAAAEyRjvOgA-AXiNRpUBRF-1KSoBY0",
    "DS_WEB_RECAPTCHA_ENTERPRISE_CHECKBOX_SITE_KEY": "6Lf3YhsqAAAAAD6M_RUYY6XB_RIwVZFqvCdNnX5G",
    "DS_WEB_FIREBASE_ENABLED": false,
    "DS_WEB_FIREBASE_API_KEY": "AIzaSyD1Dr_T9bFDX2Vc7BK1s-uEeVxskk_qtvA",
    "DS_WEB_FIREBASE_APP_ID": "1:592900011890:web:6c46b518a66d5656548feb",
    "DS_WEB_FIREBASE_AUTH_DOMAIN": "dex-screener-16543.firebaseapp.com",
    "DS_WEB_FIREBASE_MESSAGING_SENDER_ID": "592900011890",
    "DS_WEB_FIREBASE_PROJECT_ID": "dex-screener-16543",
    "DS_WEB_FIREBASE_STORAGE_BUCKET": "dex-screener-16543.appspot.com",
    "DS_WEB_FIREBASE_ANALYTICS_ENABLED": true,
    "DS_WEB_FIREBASE_MEASUREMENT_ID": "G-532KFVB4WT",
    "DS_WEB_UNISWAP_SCREENER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_LOG_AMM_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_LOG_BALANCER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_LOG_OSMOSIS_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_LOG_UNISWAP_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_CHART_AMM_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_CHART_BALANCER_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_CHART_OSMOSIS_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_CHART_UNISWAP_HOST": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DEX_SCREENER_SEARCH_PUBLIC_ORIGIN": "https:\u002F\u002Fio.dexscreener.com",
    "DS_DATA_TIME_TO_STALE_IN_MS": 60000,
    "DS_MOONSHOT_TOKEN_NAME_SIZE_IN_BYTES": 32,
    "DS_MOONSHOT_TOKEN_SYMBOL_SIZE_IN_BYTES": 10,
    "DS_MOONSHOT_TOKEN_DESCRIPTION_LENGTH": 2000,
    "DS_MOONSHOT_DEFAULT_CHAIN_ID": "solana",
    "DS_MOONSHOT_TOKEN_HEADER_MAX_SIZE_IN_BYTES": 5242880,
    "DS_MOONSHOT_TOKEN_ICON_MAX_SIZE_IN_BYTES": 2097152,
    "DS_DEX_API_PUBLIC_ORIGIN": "https:\u002F\u002Fapi.dexscreener.com",
    "DS_TENOR_API_KEY": "AIzaSyAm2pTjr-XlnTYJkekjC-D348uFWc7OB-E",
    "DS_MOONSHOT_API_PUBLIC_ORIGIN": "https:\u002F\u002Fapi.moonshot.cc"
}
function jOe(t, e) {
    
    for (var r = 0; r < e.length; r++) {
        const n = e[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for (const i in n) if (i !== "default" && !(i in t)) {
                const a = Object.getOwnPropertyDescriptor(n, i);
                a && Object.defineProperty(t, i, a.get ? a : {enumerable: !0, get: () => n[i]})
            }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}))
}

var tn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function za(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function $P(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        r.prototype = e.prototype
    } else r = {};
    return Object.defineProperty(r, "__esModule", {value: !0}), Object.keys(t).forEach(function (n) {
        var i = Object.getOwnPropertyDescriptor(t, n);
        Object.defineProperty(r, n, i.get ? i : {
            enumerable: !0, get: function () {
                return t[n]
            }
        })
    }), r
}

var bW = {exports: {}}, M5 = {}, B9 = {exports: {}}, Zn = {};
var Qae;

function zOe() {
    if (Qae) return Zn;
    Qae = 1;
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"),
        n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"),
        o = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"),
        f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.iterator;

    function g(R) {
        return R === null || typeof R != "object" ? null : (R = p && R[p] || R["@@iterator"], typeof R == "function" ? R : null)
    }

    var b = {
        isMounted: function () {
            return !1
        }, enqueueForceUpdate: function () {
        }, enqueueReplaceState: function () {
        }, enqueueSetState: function () {
        }
    }, S = Object.assign, T = {};

    function I(R, k, Q) {
        this.props = R, this.context = k, this.refs = T, this.updater = Q || b
    }

    I.prototype.isReactComponent = {}, I.prototype.setState = function (R, k) {
        if (typeof R != "object" && typeof R != "function" && R != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, R, k, "setState")
    }, I.prototype.forceUpdate = function (R) {
        this.updater.enqueueForceUpdate(this, R, "forceUpdate")
    };

    function N() {
    }

    N.prototype = I.prototype;

    function P(R, k, Q) {
        this.props = R, this.context = k, this.refs = T, this.updater = Q || b
    }

    var F = P.prototype = new N;
    F.constructor = P, S(F, I.prototype), F.isPureReactComponent = !0;
    var V = Array.isArray, Y = Object.prototype.hasOwnProperty, ee = {current: null},
        oe = {key: !0, ref: !0, __self: !0, __source: !0};

    function G(R, k, Q) {
        var fe, ye = {}, ue = null, me = null;
        if (k != null) for (fe in k.ref !== void 0 && (me = k.ref), k.key !== void 0 && (ue = "" + k.key), k) Y.call(k, fe) && !oe.hasOwnProperty(fe) && (ye[fe] = k[fe]);
        var Se = arguments.length - 2;
        if (Se === 1) ye.children = Q; else if (1 < Se) {
            for (var Ce = Array(Se), Me = 0; Me < Se; Me++) Ce[Me] = arguments[Me + 2];
            ye.children = Ce
        }
        if (R && R.defaultProps) for (fe in Se = R.defaultProps, Se) ye[fe] === void 0 && (ye[fe] = Se[fe]);
        return {$$typeof: t, type: R, key: ue, ref: me, props: ye, _owner: ee.current}
    }

    function J(R, k) {
        return {$$typeof: t, type: R.type, key: k, ref: R.ref, props: R.props, _owner: R._owner}
    }

    function ce(R) {
        return typeof R == "object" && R !== null && R.$$typeof === t
    }

    function re(R) {
        var k = {"=": "=0", ":": "=2"};
        return "$" + R.replace(/[=:]/g, function (Q) {
            return k[Q]
        })
    }

    var M = /\/+/g;

    function D(R, k) {
        return typeof R == "object" && R !== null && R.key != null ? re("" + R.key) : k.toString(36)
    }

    function x(R, k, Q, fe, ye) {
        var ue = typeof R;
        (ue === "undefined" || ue === "boolean") && (R = null);
        var me = !1;
        if (R === null) me = !0; else switch (ue) {
            case"string":
            case"number":
                me = !0;
                break;
            case"object":
                switch (R.$$typeof) {
                    case t:
                    case e:
                        me = !0
                }
        }
        if (me) return me = R, ye = ye(me), R = fe === "" ? "." + D(me, 0) : fe, V(ye) ? (Q = "", R != null && (Q = R.replace(M, "$&/") + "/"), x(ye, k, Q, "", function (Me) {
            return Me
        })) : ye != null && (ce(ye) && (ye = J(ye, Q + (!ye.key || me && me.key === ye.key ? "" : ("" + ye.key).replace(M, "$&/") + "/") + R)), k.push(ye)), 1;
        if (me = 0, fe = fe === "" ? "." : fe + ":", V(R)) for (var Se = 0; Se < R.length; Se++) {
            ue = R[Se];
            var Ce = fe + D(ue, Se);
            me += x(ue, k, Q, Ce, ye)
        } else if (Ce = g(R), typeof Ce == "function") for (R = Ce.call(R), Se = 0; !(ue = R.next()).done;) ue = ue.value, Ce = fe + D(ue, Se++), me += x(ue, k, Q, Ce, ye); else if (ue === "object") throw k = String(R), Error("Objects are not valid as a React child (found: " + (k === "[object Object]" ? "object with keys {" + Object.keys(R).join(", ") + "}" : k) + "). If you meant to render a collection of children, use an array instead.");
        return me
    }

    function A(R, k, Q) {
        if (R == null) return R;
        var fe = [], ye = 0;
        return x(R, fe, "", "", function (ue) {
            return k.call(Q, ue, ye++)
        }), fe
    }

    function B(R) {
        if (R._status === -1) {
            var k = R._result;
            k = k(), k.then(function (Q) {
                (R._status === 0 || R._status === -1) && (R._status = 1, R._result = Q)
            }, function (Q) {
                (R._status === 0 || R._status === -1) && (R._status = 2, R._result = Q)
            }), R._status === -1 && (R._status = 0, R._result = k)
        }
        if (R._status === 1) return R._result.default;
        throw R._result
    }

    var z = {current: null}, j = {transition: null},
        $ = {ReactCurrentDispatcher: z, ReactCurrentBatchConfig: j, ReactCurrentOwner: ee};

    function C() {
        throw Error("act(...) is not supported in production builds of React.")
    }

    return Zn.Children = {
        map: A, forEach: function (R, k, Q) {
            A(R, function () {
                k.apply(this, arguments)
            }, Q)
        }, count: function (R) {
            var k = 0;
            return A(R, function () {
                k++
            }), k
        }, toArray: function (R) {
            return A(R, function (k) {
                return k
            }) || []
        }, only: function (R) {
            if (!ce(R)) throw Error("React.Children.only expected to receive a single React element child.");
            return R
        }
    }, Zn.Component = I, Zn.Fragment = r, Zn.Profiler = i, Zn.PureComponent = P, Zn.StrictMode = n, Zn.Suspense = l, Zn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $, Zn.act = C, Zn.cloneElement = function (R, k, Q) {
        if (R == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + R + ".");
        var fe = S({}, R.props), ye = R.key, ue = R.ref, me = R._owner;
        if (k != null) {
            if (k.ref !== void 0 && (ue = k.ref, me = ee.current), k.key !== void 0 && (ye = "" + k.key), R.type && R.type.defaultProps) var Se = R.type.defaultProps;
            for (Ce in k) Y.call(k, Ce) && !oe.hasOwnProperty(Ce) && (fe[Ce] = k[Ce] === void 0 && Se !== void 0 ? Se[Ce] : k[Ce])
        }
        var Ce = arguments.length - 2;
        if (Ce === 1) fe.children = Q; else if (1 < Ce) {
            Se = Array(Ce);
            for (var Me = 0; Me < Ce; Me++) Se[Me] = arguments[Me + 2];
            fe.children = Se
        }
        return {$$typeof: t, type: R.type, key: ye, ref: ue, props: fe, _owner: me}
    }, Zn.createContext = function (R) {
        return R = {
            $$typeof: o,
            _currentValue: R,
            _currentValue2: R,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        }, R.Provider = {$$typeof: a, _context: R}, R.Consumer = R
    }, Zn.createElement = G, Zn.createFactory = function (R) {
        var k = G.bind(null, R);
        return k.type = R, k
    }, Zn.createRef = function () {
        return {current: null}
    }, Zn.forwardRef = function (R) {
        return {$$typeof: s, render: R}
    }, Zn.isValidElement = ce, Zn.lazy = function (R) {
        return {$$typeof: d, _payload: {_status: -1, _result: R}, _init: B}
    }, Zn.memo = function (R, k) {
        return {$$typeof: f, type: R, compare: k === void 0 ? null : k}
    }, Zn.startTransition = function (R) {
        var k = j.transition;
        j.transition = {};
        try {
            R()
        } finally {
            j.transition = k
        }
    }, Zn.unstable_act = C, Zn.useCallback = function (R, k) {
        return z.current.useCallback(R, k)
    }, Zn.useContext = function (R) {
        return z.current.useContext(R)
    }, Zn.useDebugValue = function () {
    }, Zn.useDeferredValue = function (R) {
        return z.current.useDeferredValue(R)
    }, Zn.useEffect = function (R, k) {
        return z.current.useEffect(R, k)
    }, Zn.useId = function () {
        return z.current.useId()
    }, Zn.useImperativeHandle = function (R, k, Q) {
        return z.current.useImperativeHandle(R, k, Q)
    }, Zn.useInsertionEffect = function (R, k) {
        return z.current.useInsertionEffect(R, k)
    }, Zn.useLayoutEffect = function (R, k) {
        return z.current.useLayoutEffect(R, k)
    }, Zn.useMemo = function (R, k) {
        return z.current.useMemo(R, k)
    }, Zn.useReducer = function (R, k, Q) {
        return z.current.useReducer(R, k, Q)
    }, Zn.useRef = function (R) {
        return z.current.useRef(R)
    }, Zn.useState = function (R) {
        return z.current.useState(R)
    }, Zn.useSyncExternalStore = function (R, k, Q) {
        return z.current.useSyncExternalStore(R, k, Q)
    }, Zn.useTransition = function () {
        return z.current.useTransition()
    }, Zn.version = "18.3.1", Zn
}

var $9 = {exports: {}}, Zae;

function VOe() {
    return Zae || (Zae = 1, function (t, e) {
        Ve.env.NODE_ENV !== "production" && function () {
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
            var r = "18.3.1", n = Symbol.for("react.element"), i = Symbol.for("react.portal"),
                a = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"),
                l = Symbol.for("react.provider"), f = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"),
                p = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"),
                S = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), I = Symbol.iterator, N = "@@iterator";

            function P(de) {
                if (de === null || typeof de != "object") return null;
                var Ie = I && de[I] || de[N];
                return typeof Ie == "function" ? Ie : null
            }

            var F = {current: null}, V = {transition: null},
                Y = {current: null, isBatchingLegacy: !1, didScheduleLegacyUpdate: !1}, ee = {current: null}, oe = {},
                G = null;

            function J(de) {
                G = de
            }

            oe.setExtraStackFrame = function (de) {
                G = de
            }, oe.getCurrentStack = null, oe.getStackAddendum = function () {
                var de = "";
                G && (de += G);
                var Ie = oe.getCurrentStack;
                return Ie && (de += Ie() || ""), de
            };
            var ce = !1, re = !1, M = !1, D = !1, x = !1,
                A = {ReactCurrentDispatcher: F, ReactCurrentBatchConfig: V, ReactCurrentOwner: ee};
            A.ReactDebugCurrentFrame = oe, A.ReactCurrentActQueue = Y;

            function B(de) {
                {
                    for (var Ie = arguments.length, Ye = new Array(Ie > 1 ? Ie - 1 : 0), rt = 1; rt < Ie; rt++) Ye[rt - 1] = arguments[rt];
                    j("warn", de, Ye)
                }
            }

            function z(de) {
                {
                    for (var Ie = arguments.length, Ye = new Array(Ie > 1 ? Ie - 1 : 0), rt = 1; rt < Ie; rt++) Ye[rt - 1] = arguments[rt];
                    j("error", de, Ye)
                }
            }

            function j(de, Ie, Ye) {
                {
                    var rt = A.ReactDebugCurrentFrame, Et = rt.getStackAddendum();
                    Et !== "" && (Ie += "%s", Ye = Ye.concat([Et]));
                    var Dr = Ye.map(function (Nt) {
                        return String(Nt)
                    });
                    Dr.unshift("Warning: " + Ie), Function.prototype.apply.call(console[de], console, Dr)
                }
            }

            var $ = {};

            function C(de, Ie) {
                {
                    var Ye = de.constructor, rt = Ye && (Ye.displayName || Ye.name) || "ReactClass", Et = rt + "." + Ie;
                    if ($[Et]) return;
                    z("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Ie, rt), $[Et] = !0
                }
            }

            var R = {
                isMounted: function (de) {
                    return !1
                }, enqueueForceUpdate: function (de, Ie, Ye) {
                    C(de, "forceUpdate")
                }, enqueueReplaceState: function (de, Ie, Ye, rt) {
                    C(de, "replaceState")
                }, enqueueSetState: function (de, Ie, Ye, rt) {
                    C(de, "setState")
                }
            }, k = Object.assign, Q = {};
            Object.freeze(Q);

            function fe(de, Ie, Ye) {
                this.props = de, this.context = Ie, this.refs = Q, this.updater = Ye || R
            }

            fe.prototype.isReactComponent = {}, fe.prototype.setState = function (de, Ie) {
                if (typeof de != "object" && typeof de != "function" && de != null) throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                this.updater.enqueueSetState(this, de, Ie, "setState")
            }, fe.prototype.forceUpdate = function (de) {
                this.updater.enqueueForceUpdate(this, de, "forceUpdate")
            };
            {
                var ye = {
                    isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
                    replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
                }, ue = function (de, Ie) {
                    Object.defineProperty(fe.prototype, de, {
                        get: function () {
                            B("%s(...) is deprecated in plain JavaScript React classes. %s", Ie[0], Ie[1])
                        }
                    })
                };
                for (var me in ye) ye.hasOwnProperty(me) && ue(me, ye[me])
            }

            function Se() {
            }

            Se.prototype = fe.prototype;

            function Ce(de, Ie, Ye) {
                this.props = de, this.context = Ie, this.refs = Q, this.updater = Ye || R
            }

            var Me = Ce.prototype = new Se;
            Me.constructor = Ce, k(Me, fe.prototype), Me.isPureReactComponent = !0;

            function ve() {
                var de = {current: null};
                return Object.seal(de), de
            }

            var ne = Array.isArray;

            function be(de) {
                return ne(de)
            }

            function Ee(de) {
                {
                    var Ie = typeof Symbol == "function" && Symbol.toStringTag,
                        Ye = Ie && de[Symbol.toStringTag] || de.constructor.name || "Object";
                    return Ye
                }
            }

            function Oe(de) {
                try {
                    return !1
                } catch {
                    return !0
                }
            }

            function ze(de) {
                return "" + de
            }

            function Be(de) {
                if (Oe()) return z("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ee(de)), ze(de)
            }

            function it(de, Ie, Ye) {
                var rt = de.displayName;
                if (rt) return rt;
                var Et = Ie.displayName || Ie.name || "";
                return Et !== "" ? Ye + "(" + Et + ")" : Ye
            }

            function Ue(de) {
                return de.displayName || "Context"
            }

            function bt(de) {
                if (de == null) return null;
                if (typeof de.tag == "number" && z("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof de == "function") return de.displayName || de.name || null;
                if (typeof de == "string") return de;
                switch (de) {
                    case a:
                        return "Fragment";
                    case i:
                        return "Portal";
                    case s:
                        return "Profiler";
                    case o:
                        return "StrictMode";
                    case p:
                        return "Suspense";
                    case g:
                        return "SuspenseList"
                }
                if (typeof de == "object") switch (de.$$typeof) {
                    case f:
                        var Ie = de;
                        return Ue(Ie) + ".Consumer";
                    case l:
                        var Ye = de;
                        return Ue(Ye._context) + ".Provider";
                    case d:
                        return it(de, de.render, "ForwardRef");
                    case b:
                        var rt = de.displayName || null;
                        return rt !== null ? rt : bt(de.type) || "Memo";
                    case S: {
                        var Et = de, Dr = Et._payload, Nt = Et._init;
                        try {
                            return bt(Nt(Dr))
                        } catch {
                            return null
                        }
                    }
                }
                return null
            }

            var gt = Object.prototype.hasOwnProperty, Ot = {key: !0, ref: !0, __self: !0, __source: !0}, zt, _t, Dt;
            Dt = {};

            function rr(de) {
                if (gt.call(de, "ref")) {
                    var Ie = Object.getOwnPropertyDescriptor(de, "ref").get;
                    if (Ie && Ie.isReactWarning) return !1
                }
                return de.ref !== void 0
            }

            function pe(de) {
                if (gt.call(de, "key")) {
                    var Ie = Object.getOwnPropertyDescriptor(de, "key").get;
                    if (Ie && Ie.isReactWarning) return !1
                }
                return de.key !== void 0
            }

            function te(de, Ie) {
                var Ye = function () {
                    zt || (zt = !0, z("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ie))
                };
                Ye.isReactWarning = !0, Object.defineProperty(de, "key", {get: Ye, configurable: !0})
            }

            function X(de, Ie) {
                var Ye = function () {
                    _t || (_t = !0, z("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ie))
                };
                Ye.isReactWarning = !0, Object.defineProperty(de, "ref", {get: Ye, configurable: !0})
            }

            function H(de) {
                if (typeof de.ref == "string" && ee.current && de.__self && ee.current.stateNode !== de.__self) {
                    var Ie = bt(ee.current.type);
                    Dt[Ie] || (z('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ie, de.ref), Dt[Ie] = !0)
                }
            }

            var U = function (de, Ie, Ye, rt, Et, Dr, Nt) {
                var Br = {$$typeof: n, type: de, key: Ie, ref: Ye, props: Nt, _owner: Dr};
                return Br._store = {}, Object.defineProperty(Br._store, "validated", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(Br, "_self", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !1,
                    value: rt
                }), Object.defineProperty(Br, "_source", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !1,
                    value: Et
                }), Object.freeze && (Object.freeze(Br.props), Object.freeze(Br)), Br
            };

            function q(de, Ie, Ye) {
                var rt, Et = {}, Dr = null, Nt = null, Br = null, Rn = null;
                if (Ie != null) {
                    rr(Ie) && (Nt = Ie.ref, H(Ie)), pe(Ie) && (Be(Ie.key), Dr = "" + Ie.key), Br = Ie.__self === void 0 ? null : Ie.__self, Rn = Ie.__source === void 0 ? null : Ie.__source;
                    for (rt in Ie) gt.call(Ie, rt) && !Ot.hasOwnProperty(rt) && (Et[rt] = Ie[rt])
                }
                var hi = arguments.length - 2;
                if (hi === 1) Et.children = Ye; else if (hi > 1) {
                    for (var sa = Array(hi), wn = 0; wn < hi; wn++) sa[wn] = arguments[wn + 2];
                    Object.freeze && Object.freeze(sa), Et.children = sa
                }
                if (de && de.defaultProps) {
                    var Ui = de.defaultProps;
                    for (rt in Ui) Et[rt] === void 0 && (Et[rt] = Ui[rt])
                }
                if (Dr || Nt) {
                    var Ji = typeof de == "function" ? de.displayName || de.name || "Unknown" : de;
                    Dr && te(Et, Ji), Nt && X(Et, Ji)
                }
                return U(de, Dr, Nt, Br, Rn, ee.current, Et)
            }

            function le(de, Ie) {
                var Ye = U(de.type, Ie, de.ref, de._self, de._source, de._owner, de.props);
                return Ye
            }

            function xe(de, Ie, Ye) {
                if (de == null) throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + de + ".");
                var rt, Et = k({}, de.props), Dr = de.key, Nt = de.ref, Br = de._self, Rn = de._source, hi = de._owner;
                if (Ie != null) {
                    rr(Ie) && (Nt = Ie.ref, hi = ee.current), pe(Ie) && (Be(Ie.key), Dr = "" + Ie.key);
                    var sa;
                    de.type && de.type.defaultProps && (sa = de.type.defaultProps);
                    for (rt in Ie) gt.call(Ie, rt) && !Ot.hasOwnProperty(rt) && (Ie[rt] === void 0 && sa !== void 0 ? Et[rt] = sa[rt] : Et[rt] = Ie[rt])
                }
                var wn = arguments.length - 2;
                if (wn === 1) Et.children = Ye; else if (wn > 1) {
                    for (var Ui = Array(wn), Ji = 0; Ji < wn; Ji++) Ui[Ji] = arguments[Ji + 2];
                    Et.children = Ui
                }
                return U(de.type, Dr, Nt, Br, Rn, hi, Et)
            }

            function Ae(de) {
                return typeof de == "object" && de !== null && de.$$typeof === n
            }

            var De = ".", Ze = ":";

            function ft(de) {
                var Ie = /[=:]/g, Ye = {"=": "=0", ":": "=2"}, rt = de.replace(Ie, function (Et) {
                    return Ye[Et]
                });
                return "$" + rt
            }

            var ht = !1, cr = /\/+/g;

            function Rt(de) {
                return de.replace(cr, "$&/")
            }

            function Gt(de, Ie) {
                return typeof de == "object" && de !== null && de.key != null ? (Be(de.key), ft("" + de.key)) : Ie.toString(36)
            }

            function sn(de, Ie, Ye, rt, Et) {
                var Dr = typeof de;
                (Dr === "undefined" || Dr === "boolean") && (de = null);
                var Nt = !1;
                if (de === null) Nt = !0; else switch (Dr) {
                    case"string":
                    case"number":
                        Nt = !0;
                        break;
                    case"object":
                        switch (de.$$typeof) {
                            case n:
                            case i:
                                Nt = !0
                        }
                }
                if (Nt) {
                    var Br = de, Rn = Et(Br), hi = rt === "" ? De + Gt(Br, 0) : rt;
                    if (be(Rn)) {
                        var sa = "";
                        hi != null && (sa = Rt(hi) + "/"), sn(Rn, Ie, sa, "", function (o2) {
                            return o2
                        })
                    } else Rn != null && (Ae(Rn) && (Rn.key && (!Br || Br.key !== Rn.key) && Be(Rn.key), Rn = le(Rn, Ye + (Rn.key && (!Br || Br.key !== Rn.key) ? Rt("" + Rn.key) + "/" : "") + hi)), Ie.push(Rn));
                    return 1
                }
                var wn, Ui, Ji = 0, Na = rt === "" ? De : rt + Ze;
                if (be(de)) for (var lm = 0; lm < de.length; lm++) wn = de[lm], Ui = Na + Gt(wn, lm), Ji += sn(wn, Ie, Ye, Ui, Et); else {
                    var sd = P(de);
                    if (typeof sd == "function") {
                        var fg = de;
                        sd === fg.entries && (ht || B("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ht = !0);
                        for (var i2 = sd.call(fg), dg, D3 = 0; !(dg = i2.next()).done;) wn = dg.value, Ui = Na + Gt(wn, D3++), Ji += sn(wn, Ie, Ye, Ui, Et)
                    } else if (Dr === "object") {
                        var a2 = String(de);
                        throw new Error("Objects are not valid as a React child (found: " + (a2 === "[object Object]" ? "object with keys {" + Object.keys(de).join(", ") + "}" : a2) + "). If you meant to render a collection of children, use an array instead.")
                    }
                }
                return Ji
            }

            function Yr(de, Ie, Ye) {
                if (de == null) return de;
                var rt = [], Et = 0;
                return sn(de, rt, "", "", function (Dr) {
                    return Ie.call(Ye, Dr, Et++)
                }), rt
            }

            function br(de) {
                var Ie = 0;
                return Yr(de, function () {
                    Ie++
                }), Ie
            }

            function hn(de, Ie, Ye) {
                Yr(de, function () {
                    Ie.apply(this, arguments)
                }, Ye)
            }

            function En(de) {
                return Yr(de, function (Ie) {
                    return Ie
                }) || []
            }

            function _r(de) {
                if (!Ae(de)) throw new Error("React.Children.only expected to receive a single React element child.");
                return de
            }

            function _n(de) {
                var Ie = {
                    $$typeof: f,
                    _currentValue: de,
                    _currentValue2: de,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _defaultValue: null,
                    _globalName: null
                };
                Ie.Provider = {$$typeof: l, _context: Ie};
                var Ye = !1, rt = !1, Et = !1;
                {
                    var Dr = {$$typeof: f, _context: Ie};
                    Object.defineProperties(Dr, {
                        Provider: {
                            get: function () {
                                return rt || (rt = !0, z("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Ie.Provider
                            }, set: function (Nt) {
                                Ie.Provider = Nt
                            }
                        }, _currentValue: {
                            get: function () {
                                return Ie._currentValue
                            }, set: function (Nt) {
                                Ie._currentValue = Nt
                            }
                        }, _currentValue2: {
                            get: function () {
                                return Ie._currentValue2
                            }, set: function (Nt) {
                                Ie._currentValue2 = Nt
                            }
                        }, _threadCount: {
                            get: function () {
                                return Ie._threadCount
                            }, set: function (Nt) {
                                Ie._threadCount = Nt
                            }
                        }, Consumer: {
                            get: function () {
                                return Ye || (Ye = !0, z("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Ie.Consumer
                            }
                        }, displayName: {
                            get: function () {
                                return Ie.displayName
                            }, set: function (Nt) {
                                Et || (B("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Nt), Et = !0)
                            }
                        }
                    }), Ie.Consumer = Dr
                }
                return Ie._currentRenderer = null, Ie._currentRenderer2 = null, Ie
            }

            var Nr = -1, mr = 0, fn = 1, Hn = 2;

            function Cr(de) {
                if (de._status === Nr) {
                    var Ie = de._result, Ye = Ie();
                    if (Ye.then(function (Dr) {
                        if (de._status === mr || de._status === Nr) {
                            var Nt = de;
                            Nt._status = fn, Nt._result = Dr
                        }
                    }, function (Dr) {
                        if (de._status === mr || de._status === Nr) {
                            var Nt = de;
                            Nt._status = Hn, Nt._result = Dr
                        }
                    }), de._status === Nr) {
                        var rt = de;
                        rt._status = mr, rt._result = Ye
                    }
                }
                if (de._status === fn) {
                    var Et = de._result;
                    return Et === void 0 && z(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Et), "default" in Et || z(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Et), Et.default
                } else throw de._result
            }

            function An(de) {
                var Ie = {_status: Nr, _result: de}, Ye = {$$typeof: S, _payload: Ie, _init: Cr};
                {
                    var rt, Et;
                    Object.defineProperties(Ye, {
                        defaultProps: {
                            configurable: !0, get: function () {
                                return rt
                            }, set: function (Dr) {
                                z("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), rt = Dr, Object.defineProperty(Ye, "defaultProps", {enumerable: !0})
                            }
                        }, propTypes: {
                            configurable: !0, get: function () {
                                return Et
                            }, set: function (Dr) {
                                z("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Et = Dr, Object.defineProperty(Ye, "propTypes", {enumerable: !0})
                            }
                        }
                    })
                }
                return Ye
            }

            function pn(de) {
                de != null && de.$$typeof === b ? z("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof de != "function" ? z("forwardRef requires a render function but was given %s.", de === null ? "null" : typeof de) : de.length !== 0 && de.length !== 2 && z("forwardRef render functions accept exactly two parameters: props and ref. %s", de.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), de != null && (de.defaultProps != null || de.propTypes != null) && z("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                var Ie = {$$typeof: d, render: de};
                {
                    var Ye;
                    Object.defineProperty(Ie, "displayName", {
                        enumerable: !1, configurable: !0, get: function () {
                            return Ye
                        }, set: function (rt) {
                            Ye = rt, !de.name && !de.displayName && (de.displayName = rt)
                        }
                    })
                }
                return Ie
            }

            var wr;
            wr = Symbol.for("react.module.reference");

            function ke(de) {
                return !!(typeof de == "string" || typeof de == "function" || de === a || de === s || x || de === o || de === p || de === g || D || de === T || ce || re || M || typeof de == "object" && de !== null && (de.$$typeof === S || de.$$typeof === b || de.$$typeof === l || de.$$typeof === f || de.$$typeof === d || de.$$typeof === wr || de.getModuleId !== void 0))
            }

            function st(de, Ie) {
                ke(de) || z("memo: The first argument must be a component. Instead received: %s", de === null ? "null" : typeof de);
                var Ye = {$$typeof: b, type: de, compare: Ie === void 0 ? null : Ie};
                {
                    var rt;
                    Object.defineProperty(Ye, "displayName", {
                        enumerable: !1, configurable: !0, get: function () {
                            return rt
                        }, set: function (Et) {
                            rt = Et, !de.name && !de.displayName && (de.displayName = Et)
                        }
                    })
                }
                return Ye
            }

            function ot() {
                var de = F.current;
                return de === null && z(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), de
            }

            function xt(de) {
                var Ie = ot();
                if (de._context !== void 0) {
                    var Ye = de._context;
                    Ye.Consumer === de ? z("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : Ye.Provider === de && z("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?")
                }
                return Ie.useContext(de)
            }

            function Yt(de) {
                var Ie = ot();
                return Ie.useState(de)
            }

            function vr(de, Ie, Ye) {
                var rt = ot();
                return rt.useReducer(de, Ie, Ye)
            }

            function Vr(de) {
                var Ie = ot();
                return Ie.useRef(de)
            }

            function Ur(de, Ie) {
                var Ye = ot();
                return Ye.useEffect(de, Ie)
            }

            function fi(de, Ie) {
                var Ye = ot();
                return Ye.useInsertionEffect(de, Ie)
            }

            function In(de, Ie) {
                var Ye = ot();
                return Ye.useLayoutEffect(de, Ie)
            }

            function kn(de, Ie) {
                var Ye = ot();
                return Ye.useCallback(de, Ie)
            }

            function Ai(de, Ie) {
                var Ye = ot();
                return Ye.useMemo(de, Ie)
            }

            function Fi(de, Ie, Ye) {
                var rt = ot();
                return rt.useImperativeHandle(de, Ie, Ye)
            }

            function Pt(de, Ie) {
                {
                    var Ye = ot();
                    return Ye.useDebugValue(de, Ie)
                }
            }

            function Wn() {
                var de = ot();
                return de.useTransition()
            }

            function Da(de) {
                var Ie = ot();
                return Ie.useDeferredValue(de)
            }

            function Ma() {
                var de = ot();
                return de.useId()
            }

            function Oa(de, Ie, Ye) {
                var rt = ot();
                return rt.useSyncExternalStore(de, Ie, Ye)
            }

            var Za = 0, Po, Ja, qi, Ko, Pa, Dl, df;

            function hf() {
            }

            hf.__reactDisabledLog = !0;

            function Yo() {
                {
                    if (Za === 0) {
                        Po = console.log, Ja = console.info, qi = console.warn, Ko = console.error, Pa = console.group, Dl = console.groupCollapsed, df = console.groupEnd;
                        var de = {configurable: !0, enumerable: !0, value: hf, writable: !0};
                        Object.defineProperties(console, {
                            info: de,
                            log: de,
                            warn: de,
                            error: de,
                            group: de,
                            groupCollapsed: de,
                            groupEnd: de
                        })
                    }
                    Za++
                }
            }

            function Ml() {
                {
                    if (Za--, Za === 0) {
                        var de = {configurable: !0, enumerable: !0, writable: !0};
                        Object.defineProperties(console, {
                            log: k({}, de, {value: Po}),
                            info: k({}, de, {value: Ja}),
                            warn: k({}, de, {value: qi}),
                            error: k({}, de, {value: Ko}),
                            group: k({}, de, {value: Pa}),
                            groupCollapsed: k({}, de, {value: Dl}),
                            groupEnd: k({}, de, {value: df})
                        })
                    }
                    Za < 0 && z("disabledDepth fell below zero. This is a bug in React. Please file an issue.")
                }
            }

            var us = A.ReactCurrentDispatcher, Ol;

            function Pl(de, Ie, Ye) {
                {
                    if (Ol === void 0) try {
                        throw Error()
                    } catch (Et) {
                        var rt = Et.stack.trim().match(/\n( *(at )?)/);
                        Ol = rt && rt[1] || ""
                    }
                    return `
` + Ol + de
                }
            }

            var Nl = !1, fs;
            {
                var lh = typeof WeakMap == "function" ? WeakMap : Map;
                fs = new lh
            }

            function Ll(de, Ie) {
                if (!de || Nl) return "";
                {
                    var Ye = fs.get(de);
                    if (Ye !== void 0) return Ye
                }
                var rt;
                Nl = !0;
                var Et = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                var Dr;
                Dr = us.current, us.current = null, Yo();
                try {
                    if (Ie) {
                        var Nt = function () {
                            throw Error()
                        };
                        if (Object.defineProperty(Nt.prototype, "props", {
                            set: function () {
                                throw Error()
                            }
                        }), typeof Reflect == "object" && Reflect.construct) {
                            try {
                                Reflect.construct(Nt, [])
                            } catch (Na) {
                                rt = Na
                            }
                            Reflect.construct(de, [], Nt)
                        } else {
                            try {
                                Nt.call()
                            } catch (Na) {
                                rt = Na
                            }
                            de.call(Nt.prototype)
                        }
                    } else {
                        try {
                            throw Error()
                        } catch (Na) {
                            rt = Na
                        }
                        de()
                    }
                } catch (Na) {
                    if (Na && rt && typeof Na.stack == "string") {
                        for (var Br = Na.stack.split(`
`), Rn = rt.stack.split(`
`), hi = Br.length - 1, sa = Rn.length - 1; hi >= 1 && sa >= 0 && Br[hi] !== Rn[sa];) sa--;
                        for (; hi >= 1 && sa >= 0; hi--, sa--) if (Br[hi] !== Rn[sa]) {
                            if (hi !== 1 || sa !== 1) do if (hi--, sa--, sa < 0 || Br[hi] !== Rn[sa]) {
                                var wn = `
` + Br[hi].replace(" at new ", " at ");
                                return de.displayName && wn.includes("<anonymous>") && (wn = wn.replace("<anonymous>", de.displayName)), typeof de == "function" && fs.set(de, wn), wn
                            } while (hi >= 1 && sa >= 0);
                            break
                        }
                    }
                } finally {
                    Nl = !1, us.current = Dr, Ml(), Error.prepareStackTrace = Et
                }
                var Ui = de ? de.displayName || de.name : "", Ji = Ui ? Pl(Ui) : "";
                return typeof de == "function" && fs.set(de, Ji), Ji
            }

            function Bl(de, Ie, Ye) {
                return Ll(de, !1)
            }

            function uh(de) {
                var Ie = de.prototype;
                return !!(Ie && Ie.isReactComponent)
            }

            function $l(de, Ie, Ye) {
                if (de == null) return "";
                if (typeof de == "function") return Ll(de, uh(de));
                if (typeof de == "string") return Pl(de);
                switch (de) {
                    case p:
                        return Pl("Suspense");
                    case g:
                        return Pl("SuspenseList")
                }
                if (typeof de == "object") switch (de.$$typeof) {
                    case d:
                        return Bl(de.render);
                    case b:
                        return $l(de.type);
                    case S: {
                        var rt = de, Et = rt._payload, Dr = rt._init;
                        try {
                            return $l(Dr(Et))
                        } catch {
                        }
                    }
                }
                return ""
            }

            var Bn = {}, $n = A.ReactDebugCurrentFrame;

            function Eu(de) {
                if (de) {
                    var Ie = $l(de.type);
                    $n.setExtraStackFrame(Ie)
                } else $n.setExtraStackFrame(null)
            }

            function pf(de, Ie, Ye, rt, Et) {
                {
                    var Dr = Function.call.bind(gt);
                    for (var Nt in de) if (Dr(de, Nt)) {
                        var Br = void 0;
                        try {
                            if (typeof de[Nt] != "function") {
                                var Rn = Error((rt || "React class") + ": " + Ye + " type `" + Nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof de[Nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                                throw Rn.name = "Invariant Violation", Rn
                            }
                            Br = de[Nt](Ie, Nt, rt, Ye, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")
                        } catch (hi) {
                            Br = hi
                        }
                        Br && !(Br instanceof Error) && (Eu(Et), z("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", rt || "React class", Ye, Nt, typeof Br), Eu(null)), Br instanceof Error && !(Br.message in Bn) && (Bn[Br.message] = !0, Eu(Et), z("Failed %s type: %s", Ye, Br.message), Eu(null))
                    }
                }
            }

            function Lr(de) {
                if (de) {
                    var Ie = $l(de.type);
                    J(Ie)
                } else J(null)
            }

            var Yc;
            Yc = !1;

            function Va() {
                if (ee.current) {
                    var de = bt(ee.current.type);
                    if (de) return `

Check the render method of \`` + de + "`."
                }
                return ""
            }

            function Xc(de) {
                if (de !== void 0) {
                    var Ie = de.fileName.replace(/^.*[\\\/]/, ""), Ye = de.lineNumber;
                    return `

Check your code at ` + Ie + ":" + Ye + "."
                }
                return ""
            }

            function fc(de) {
                return de != null ? Xc(de.__source) : ""
            }

            var No = {};

            function Ii(de) {
                var Ie = Va();
                if (!Ie) {
                    var Ye = typeof de == "string" ? de : de.displayName || de.name;
                    Ye && (Ie = `

Check the top-level render call using <` + Ye + ">.")
                }
                return Ie
            }

            function Fn(de, Ie) {
                if (!(!de._store || de._store.validated || de.key != null)) {
                    de._store.validated = !0;
                    var Ye = Ii(Ie);
                    if (!No[Ye]) {
                        No[Ye] = !0;
                        var rt = "";
                        de && de._owner && de._owner !== ee.current && (rt = " It was passed a child from " + bt(de._owner.type) + "."), Lr(de), z('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ye, rt), Lr(null)
                    }
                }
            }

            function Tu(de, Ie) {
                if (typeof de == "object") {
                    if (be(de)) for (var Ye = 0; Ye < de.length; Ye++) {
                        var rt = de[Ye];
                        Ae(rt) && Fn(rt, Ie)
                    } else if (Ae(de)) de._store && (de._store.validated = !0); else if (de) {
                        var Et = P(de);
                        if (typeof Et == "function" && Et !== de.entries) for (var Dr = Et.call(de), Nt; !(Nt = Dr.next()).done;) Ae(Nt.value) && Fn(Nt.value, Ie)
                    }
                }
            }

            function Lo(de) {
                {
                    var Ie = de.type;
                    if (Ie == null || typeof Ie == "string") return;
                    var Ye;
                    if (typeof Ie == "function") Ye = Ie.propTypes; else if (typeof Ie == "object" && (Ie.$$typeof === d || Ie.$$typeof === b)) Ye = Ie.propTypes; else return;
                    if (Ye) {
                        var rt = bt(Ie);
                        pf(Ye, de.props, "prop", rt, de)
                    } else if (Ie.PropTypes !== void 0 && !Yc) {
                        Yc = !0;
                        var Et = bt(Ie);
                        z("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Et || "Unknown")
                    }
                    typeof Ie.getDefaultProps == "function" && !Ie.getDefaultProps.isReactClassApproved && z("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")
                }
            }

            function ba(de) {
                {
                    for (var Ie = Object.keys(de.props), Ye = 0; Ye < Ie.length; Ye++) {
                        var rt = Ie[Ye];
                        if (rt !== "children" && rt !== "key") {
                            Lr(de), z("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", rt), Lr(null);
                            break
                        }
                    }
                    de.ref !== null && (Lr(de), z("Invalid attribute `ref` supplied to `React.Fragment`."), Lr(null))
                }
            }

            function dc(de, Ie, Ye) {
                var rt = ke(de);
                if (!rt) {
                    var Et = "";
                    (de === void 0 || typeof de == "object" && de !== null && Object.keys(de).length === 0) && (Et += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                    var Dr = fc(Ie);
                    Dr ? Et += Dr : Et += Va();
                    var Nt;
                    de === null ? Nt = "null" : be(de) ? Nt = "array" : de !== void 0 && de.$$typeof === n ? (Nt = "<" + (bt(de.type) || "Unknown") + " />", Et = " Did you accidentally export a JSX literal instead of a component?") : Nt = typeof de, z("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Nt, Et)
                }
                var Br = q.apply(this, arguments);
                if (Br == null) return Br;
                if (rt) for (var Rn = 2; Rn < arguments.length; Rn++) Tu(arguments[Rn], de);
                return de === a ? ba(Br) : Lo(Br), Br
            }

            var kp = !1;

            function ds(de) {
                var Ie = dc.bind(null, de);
                return Ie.type = de, kp || (kp = !0, B("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Ie, "type", {
                    enumerable: !1,
                    get: function () {
                        return B("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {value: de}), de
                    }
                }), Ie
            }

            function ad(de, Ie, Ye) {
                for (var rt = xe.apply(this, arguments), Et = 2; Et < arguments.length; Et++) Tu(arguments[Et], rt.type);
                return Lo(rt), rt
            }

            function cm(de, Ie) {
                var Ye = V.transition;
                V.transition = {};
                var rt = V.transition;
                V.transition._updatedFibers = new Set;
                try {
                    de()
                } finally {
                    if (V.transition = Ye, Ye === null && rt._updatedFibers) {
                        var Et = rt._updatedFibers.size;
                        Et > 10 && B("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), rt._updatedFibers.clear()
                    }
                }
            }

            var od = !1, fh = null;

            function ug(de) {
                if (fh === null) try {
                    var Ie = ("require" + Math.random()).slice(0, 7), Ye = t && t[Ie];
                    fh = Ye.call(t, "timers").setImmediate
                } catch {
                    fh = function (Et) {
                        od === !1 && (od = !0, typeof MessageChannel > "u" && z("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
                        var Dr = new MessageChannel;
                        Dr.port1.onmessage = Et, Dr.port2.postMessage(void 0)
                    }
                }
                return fh(de)
            }

            var hs = 0, mf = !1;

            function hc(de) {
                {
                    var Ie = hs;
                    hs++, Y.current === null && (Y.current = []);
                    var Ye = Y.isBatchingLegacy, rt;
                    try {
                        if (Y.isBatchingLegacy = !0, rt = de(), !Ye && Y.didScheduleLegacyUpdate) {
                            var Et = Y.current;
                            Et !== null && (Y.didScheduleLegacyUpdate = !1, Xe(Et))
                        }
                    } catch (Ui) {
                        throw Cu(Ie), Ui
                    } finally {
                        Y.isBatchingLegacy = Ye
                    }
                    if (rt !== null && typeof rt == "object" && typeof rt.then == "function") {
                        var Dr = rt, Nt = !1, Br = {
                            then: function (Ui, Ji) {
                                Nt = !0, Dr.then(function (Na) {
                                    Cu(Ie), hs === 0 ? Te(Na, Ui, Ji) : Ui(Na)
                                }, function (Na) {
                                    Cu(Ie), Ji(Na)
                                })
                            }
                        };
                        return !mf && typeof Promise < "u" && Promise.resolve().then(function () {
                        }).then(function () {
                            Nt || (mf = !0, z("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"))
                        }), Br
                    } else {
                        var Rn = rt;
                        if (Cu(Ie), hs === 0) {
                            var hi = Y.current;
                            hi !== null && (Xe(hi), Y.current = null);
                            var sa = {
                                then: function (Ui, Ji) {
                                    Y.current === null ? (Y.current = [], Te(Rn, Ui, Ji)) : Ui(Rn)
                                }
                            };
                            return sa
                        } else {
                            var wn = {
                                then: function (Ui, Ji) {
                                    Ui(Rn)
                                }
                            };
                            return wn
                        }
                    }
                }
            }

            function Cu(de) {
                de !== hs - 1 && z("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), hs = de
            }

            function Te(de, Ie, Ye) {
                {
                    var rt = Y.current;
                    if (rt !== null) try {
                        Xe(rt), ug(function () {
                            rt.length === 0 ? (Y.current = null, Ie(de)) : Te(de, Ie, Ye)
                        })
                    } catch (Et) {
                        Ye(Et)
                    } else Ie(de)
                }
            }

            var Ne = !1;

            function Xe(de) {
                if (!Ne) {
                    Ne = !0;
                    var Ie = 0;
                    try {
                        for (; Ie < de.length; Ie++) {
                            var Ye = de[Ie];
                            do Ye = Ye(!0); while (Ye !== null)
                        }
                        de.length = 0
                    } catch (rt) {
                        throw de = de.slice(Ie + 1), rt
                    } finally {
                        Ne = !1
                    }
                }
            }

            var Vt = dc, bn = ad, di = ds, Qn = {map: Yr, forEach: hn, count: br, toArray: En, only: _r};
            e.Children = Qn, e.Component = fe, e.Fragment = a, e.Profiler = s, e.PureComponent = Ce, e.StrictMode = o, e.Suspense = p, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = A, e.act = hc, e.cloneElement = bn, e.createContext = _n, e.createElement = Vt, e.createFactory = di, e.createRef = ve, e.forwardRef = pn, e.isValidElement = Ae, e.lazy = An, e.memo = st, e.startTransition = cm, e.unstable_act = hc, e.useCallback = kn, e.useContext = xt, e.useDebugValue = Pt, e.useDeferredValue = Da, e.useEffect = Ur, e.useId = Ma, e.useImperativeHandle = Fi, e.useInsertionEffect = fi, e.useLayoutEffect = In, e.useMemo = Ai, e.useReducer = vr, e.useRef = Vr, e.useState = Yt, e.useSyncExternalStore = Oa, e.useTransition = Wn, e.version = r, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)
        }()
    }($9, $9.exports)), $9.exports
}

var Jae;

function Kv() {
    return Jae || (Jae = 1, Ve.env.NODE_ENV === "production" ? B9.exports = zOe() : B9.exports = VOe()), B9.exports
}

var eoe;

function HOe() {
    if (eoe) return M5;
    eoe = 1;
    var t = Kv(), e = Symbol.for("react.element"), r = Symbol.for("react.fragment"),
        n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
        a = {key: !0, ref: !0, __self: !0, __source: !0};

    function o(s, l, f) {
        var d, p = {}, g = null, b = null;
        f !== void 0 && (g = "" + f), l.key !== void 0 && (g = "" + l.key), l.ref !== void 0 && (b = l.ref);
        for (d in l) n.call(l, d) && !a.hasOwnProperty(d) && (p[d] = l[d]);
        if (s && s.defaultProps) for (d in l = s.defaultProps, l) p[d] === void 0 && (p[d] = l[d]);
        return {$$typeof: e, type: s, key: g, ref: b, props: p, _owner: i.current}
    }

    return M5.Fragment = r, M5.jsx = o, M5.jsxs = o, M5
}

var O5 = {}, toe;

function WOe() {
    return toe || (toe = 1, Ve.env.NODE_ENV !== "production" && function () {
        var t = Kv(), e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"),
            i = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"),
            s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"),
            d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), g = Symbol.for("react.lazy"),
            b = Symbol.for("react.offscreen"), S = Symbol.iterator, T = "@@iterator";

        function I(ke) {
            if (ke === null || typeof ke != "object") return null;
            var st = S && ke[S] || ke[T];
            return typeof st == "function" ? st : null
        }

        var N = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

        function P(ke) {
            {
                for (var st = arguments.length, ot = new Array(st > 1 ? st - 1 : 0), xt = 1; xt < st; xt++) ot[xt - 1] = arguments[xt];
                F("error", ke, ot)
            }
        }

        function F(ke, st, ot) {
            {
                var xt = N.ReactDebugCurrentFrame, Yt = xt.getStackAddendum();
                Yt !== "" && (st += "%s", ot = ot.concat([Yt]));
                var vr = ot.map(function (Vr) {
                    return String(Vr)
                });
                vr.unshift("Warning: " + st), Function.prototype.apply.call(console[ke], console, vr)
            }
        }

        var V = !1, Y = !1, ee = !1, oe = !1, G = !1, J;
        J = Symbol.for("react.module.reference");

        function ce(ke) {
            return !!(typeof ke == "string" || typeof ke == "function" || ke === n || ke === a || G || ke === i || ke === f || ke === d || oe || ke === b || V || Y || ee || typeof ke == "object" && ke !== null && (ke.$$typeof === g || ke.$$typeof === p || ke.$$typeof === o || ke.$$typeof === s || ke.$$typeof === l || ke.$$typeof === J || ke.getModuleId !== void 0))
        }

        function re(ke, st, ot) {
            var xt = ke.displayName;
            if (xt) return xt;
            var Yt = st.displayName || st.name || "";
            return Yt !== "" ? ot + "(" + Yt + ")" : ot
        }

        function M(ke) {
            return ke.displayName || "Context"
        }

        function D(ke) {
            if (ke == null) return null;
            if (typeof ke.tag == "number" && P("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ke == "function") return ke.displayName || ke.name || null;
            if (typeof ke == "string") return ke;
            switch (ke) {
                case n:
                    return "Fragment";
                case r:
                    return "Portal";
                case a:
                    return "Profiler";
                case i:
                    return "StrictMode";
                case f:
                    return "Suspense";
                case d:
                    return "SuspenseList"
            }
            if (typeof ke == "object") switch (ke.$$typeof) {
                case s:
                    var st = ke;
                    return M(st) + ".Consumer";
                case o:
                    var ot = ke;
                    return M(ot._context) + ".Provider";
                case l:
                    return re(ke, ke.render, "ForwardRef");
                case p:
                    var xt = ke.displayName || null;
                    return xt !== null ? xt : D(ke.type) || "Memo";
                case g: {
                    var Yt = ke, vr = Yt._payload, Vr = Yt._init;
                    try {
                        return D(Vr(vr))
                    } catch {
                        return null
                    }
                }
            }
            return null
        }

        var x = Object.assign, A = 0, B, z, j, $, C, R, k;

        function Q() {
        }

        Q.__reactDisabledLog = !0;

        function fe() {
            {
                if (A === 0) {
                    B = console.log, z = console.info, j = console.warn, $ = console.error, C = console.group, R = console.groupCollapsed, k = console.groupEnd;
                    var ke = {configurable: !0, enumerable: !0, value: Q, writable: !0};
                    Object.defineProperties(console, {
                        info: ke,
                        log: ke,
                        warn: ke,
                        error: ke,
                        group: ke,
                        groupCollapsed: ke,
                        groupEnd: ke
                    })
                }
                A++
            }
        }

        function ye() {
            {
                if (A--, A === 0) {
                    var ke = {configurable: !0, enumerable: !0, writable: !0};
                    Object.defineProperties(console, {
                        log: x({}, ke, {value: B}),
                        info: x({}, ke, {value: z}),
                        warn: x({}, ke, {value: j}),
                        error: x({}, ke, {value: $}),
                        group: x({}, ke, {value: C}),
                        groupCollapsed: x({}, ke, {value: R}),
                        groupEnd: x({}, ke, {value: k})
                    })
                }
                A < 0 && P("disabledDepth fell below zero. This is a bug in React. Please file an issue.")
            }
        }

        var ue = N.ReactCurrentDispatcher, me;

        function Se(ke, st, ot) {
            {
                if (me === void 0) try {
                    throw Error()
                } catch (Yt) {
                    var xt = Yt.stack.trim().match(/\n( *(at )?)/);
                    me = xt && xt[1] || ""
                }
                return `
` + me + ke
            }
        }

        var Ce = !1, Me;
        {
            var ve = typeof WeakMap == "function" ? WeakMap : Map;
            Me = new ve
        }

        function ne(ke, st) {
            if (!ke || Ce) return "";
            {
                var ot = Me.get(ke);
                if (ot !== void 0) return ot
            }
            var xt;
            Ce = !0;
            var Yt = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var vr;
            vr = ue.current, ue.current = null, fe();
            try {
                if (st) {
                    var Vr = function () {
                        throw Error()
                    };
                    if (Object.defineProperty(Vr.prototype, "props", {
                        set: function () {
                            throw Error()
                        }
                    }), typeof Reflect == "object" && Reflect.construct) {
                        try {
                            Reflect.construct(Vr, [])
                        } catch (Wn) {
                            xt = Wn
                        }
                        Reflect.construct(ke, [], Vr)
                    } else {
                        try {
                            Vr.call()
                        } catch (Wn) {
                            xt = Wn
                        }
                        ke.call(Vr.prototype)
                    }
                } else {
                    try {
                        throw Error()
                    } catch (Wn) {
                        xt = Wn
                    }
                    ke()
                }
            } catch (Wn) {
                if (Wn && xt && typeof Wn.stack == "string") {
                    for (var Ur = Wn.stack.split(`
`), fi = xt.stack.split(`
`), In = Ur.length - 1, kn = fi.length - 1; In >= 1 && kn >= 0 && Ur[In] !== fi[kn];) kn--;
                    for (; In >= 1 && kn >= 0; In--, kn--) if (Ur[In] !== fi[kn]) {
                        if (In !== 1 || kn !== 1) do if (In--, kn--, kn < 0 || Ur[In] !== fi[kn]) {
                            var Ai = `
` + Ur[In].replace(" at new ", " at ");
                            return ke.displayName && Ai.includes("<anonymous>") && (Ai = Ai.replace("<anonymous>", ke.displayName)), typeof ke == "function" && Me.set(ke, Ai), Ai
                        } while (In >= 1 && kn >= 0);
                        break
                    }
                }
            } finally {
                Ce = !1, ue.current = vr, ye(), Error.prepareStackTrace = Yt
            }
            var Fi = ke ? ke.displayName || ke.name : "", Pt = Fi ? Se(Fi) : "";
            return typeof ke == "function" && Me.set(ke, Pt), Pt
        }

        function be(ke, st, ot) {
            return ne(ke, !1)
        }

        function Ee(ke) {
            var st = ke.prototype;
            return !!(st && st.isReactComponent)
        }

        function Oe(ke, st, ot) {
            if (ke == null) return "";
            if (typeof ke == "function") return ne(ke, Ee(ke));
            if (typeof ke == "string") return Se(ke);
            switch (ke) {
                case f:
                    return Se("Suspense");
                case d:
                    return Se("SuspenseList")
            }
            if (typeof ke == "object") switch (ke.$$typeof) {
                case l:
                    return be(ke.render);
                case p:
                    return Oe(ke.type);
                case g: {
                    var xt = ke, Yt = xt._payload, vr = xt._init;
                    try {
                        return Oe(vr(Yt))
                    } catch {
                    }
                }
            }
            return ""
        }

        var ze = Object.prototype.hasOwnProperty, Be = {}, it = N.ReactDebugCurrentFrame;

        function Ue(ke) {
            if (ke) {
                var st = Oe(ke.type);
                it.setExtraStackFrame(st)
            } else it.setExtraStackFrame(null)
        }

        function bt(ke, st, ot, xt, Yt) {
            {
                var vr = Function.call.bind(ze);
                for (var Vr in ke) if (vr(ke, Vr)) {
                    var Ur = void 0;
                    try {
                        if (typeof ke[Vr] != "function") {
                            var fi = Error((xt || "React class") + ": " + ot + " type `" + Vr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ke[Vr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                            throw fi.name = "Invariant Violation", fi
                        }
                        Ur = ke[Vr](st, Vr, xt, ot, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")
                    } catch (In) {
                        Ur = In
                    }
                    Ur && !(Ur instanceof Error) && (Ue(Yt), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", xt || "React class", ot, Vr, typeof Ur), Ue(null)), Ur instanceof Error && !(Ur.message in Be) && (Be[Ur.message] = !0, Ue(Yt), P("Failed %s type: %s", ot, Ur.message), Ue(null))
                }
            }
        }

        var gt = Array.isArray;

        function Ot(ke) {
            return gt(ke)
        }

        function zt(ke) {
            {
                var st = typeof Symbol == "function" && Symbol.toStringTag,
                    ot = st && ke[Symbol.toStringTag] || ke.constructor.name || "Object";
                return ot
            }
        }

        function _t(ke) {
            try {
                return !1
            } catch {
                return !0
            }
        }

        function Dt(ke) {
            return "" + ke
        }

        function rr(ke) {
            if (_t()) return P("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", zt(ke)), Dt(ke)
        }

        var pe = N.ReactCurrentOwner, te = {key: !0, ref: !0, __self: !0, __source: !0}, X, H, U;
        U = {};

        function q(ke) {
            if (ze.call(ke, "ref")) {
                var st = Object.getOwnPropertyDescriptor(ke, "ref").get;
                if (st && st.isReactWarning) return !1
            }
            return ke.ref !== void 0
        }

        function le(ke) {
            if (ze.call(ke, "key")) {
                var st = Object.getOwnPropertyDescriptor(ke, "key").get;
                if (st && st.isReactWarning) return !1
            }
            return ke.key !== void 0
        }

        function xe(ke, st) {
            if (typeof ke.ref == "string" && pe.current && st && pe.current.stateNode !== st) {
                var ot = D(pe.current.type);
                U[ot] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', D(pe.current.type), ke.ref), U[ot] = !0)
            }
        }

        function Ae(ke, st) {
            {
                var ot = function () {
                    X || (X = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", st))
                };
                ot.isReactWarning = !0, Object.defineProperty(ke, "key", {get: ot, configurable: !0})
            }
        }

        function De(ke, st) {
            {
                var ot = function () {
                    H || (H = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", st))
                };
                ot.isReactWarning = !0, Object.defineProperty(ke, "ref", {get: ot, configurable: !0})
            }
        }

        var Ze = function (ke, st, ot, xt, Yt, vr, Vr) {
            var Ur = {$$typeof: e, type: ke, key: st, ref: ot, props: Vr, _owner: vr};
            return Ur._store = {}, Object.defineProperty(Ur._store, "validated", {
                configurable: !1,
                enumerable: !1,
                writable: !0,
                value: !1
            }), Object.defineProperty(Ur, "_self", {
                configurable: !1,
                enumerable: !1,
                writable: !1,
                value: xt
            }), Object.defineProperty(Ur, "_source", {
                configurable: !1,
                enumerable: !1,
                writable: !1,
                value: Yt
            }), Object.freeze && (Object.freeze(Ur.props), Object.freeze(Ur)), Ur
        };

        function ft(ke, st, ot, xt, Yt) {
            {
                var vr, Vr = {}, Ur = null, fi = null;
                ot !== void 0 && (rr(ot), Ur = "" + ot), le(st) && (rr(st.key), Ur = "" + st.key), q(st) && (fi = st.ref, xe(st, Yt));
                for (vr in st) ze.call(st, vr) && !te.hasOwnProperty(vr) && (Vr[vr] = st[vr]);
                if (ke && ke.defaultProps) {
                    var In = ke.defaultProps;
                    for (vr in In) Vr[vr] === void 0 && (Vr[vr] = In[vr])
                }
                if (Ur || fi) {
                    var kn = typeof ke == "function" ? ke.displayName || ke.name || "Unknown" : ke;
                    Ur && Ae(Vr, kn), fi && De(Vr, kn)
                }
                return Ze(ke, Ur, fi, Yt, xt, pe.current, Vr)
            }
        }

        var ht = N.ReactCurrentOwner, cr = N.ReactDebugCurrentFrame;

        function Rt(ke) {
            if (ke) {
                var st = Oe(ke.type);
                cr.setExtraStackFrame(st)
            } else cr.setExtraStackFrame(null)
        }

        var Gt;
        Gt = !1;

        function sn(ke) {
            return typeof ke == "object" && ke !== null && ke.$$typeof === e
        }

        function Yr() {
            {
                if (ht.current) {
                    var ke = D(ht.current.type);
                    if (ke) return `

Check the render method of \`` + ke + "`."
                }
                return ""
            }
        }

        function br(ke) {
            {
                if (ke !== void 0) {
                    var st = ke.fileName.replace(/^.*[\\\/]/, ""), ot = ke.lineNumber;
                    return `

Check your code at ` + st + ":" + ot + "."
                }
                return ""
            }
        }

        var hn = {};

        function En(ke) {
            {
                var st = Yr();
                if (!st) {
                    var ot = typeof ke == "string" ? ke : ke.displayName || ke.name;
                    ot && (st = `

Check the top-level render call using <` + ot + ">.")
                }
                return st
            }
        }

        function _r(ke, st) {
            {
                if (!ke._store || ke._store.validated || ke.key != null) return;
                ke._store.validated = !0;
                var ot = En(st);
                if (hn[ot]) return;
                hn[ot] = !0;
                var xt = "";
                ke && ke._owner && ke._owner !== ht.current && (xt = " It was passed a child from " + D(ke._owner.type) + "."), Rt(ke), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ot, xt), Rt(null)
            }
        }

        function _n(ke, st) {
            {
                if (typeof ke != "object") return;
                if (Ot(ke)) for (var ot = 0; ot < ke.length; ot++) {
                    var xt = ke[ot];
                    sn(xt) && _r(xt, st)
                } else if (sn(ke)) ke._store && (ke._store.validated = !0); else if (ke) {
                    var Yt = I(ke);
                    if (typeof Yt == "function" && Yt !== ke.entries) for (var vr = Yt.call(ke), Vr; !(Vr = vr.next()).done;) sn(Vr.value) && _r(Vr.value, st)
                }
            }
        }

        function Nr(ke) {
            {
                var st = ke.type;
                if (st == null || typeof st == "string") return;
                var ot;
                if (typeof st == "function") ot = st.propTypes; else if (typeof st == "object" && (st.$$typeof === l || st.$$typeof === p)) ot = st.propTypes; else return;
                if (ot) {
                    var xt = D(st);
                    bt(ot, ke.props, "prop", xt, ke)
                } else if (st.PropTypes !== void 0 && !Gt) {
                    Gt = !0;
                    var Yt = D(st);
                    P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Yt || "Unknown")
                }
                typeof st.getDefaultProps == "function" && !st.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")
            }
        }

        function mr(ke) {
            {
                for (var st = Object.keys(ke.props), ot = 0; ot < st.length; ot++) {
                    var xt = st[ot];
                    if (xt !== "children" && xt !== "key") {
                        Rt(ke), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", xt), Rt(null);
                        break
                    }
                }
                ke.ref !== null && (Rt(ke), P("Invalid attribute `ref` supplied to `React.Fragment`."), Rt(null))
            }
        }

        var fn = {};

        function Hn(ke, st, ot, xt, Yt, vr) {
            {
                var Vr = ce(ke);
                if (!Vr) {
                    var Ur = "";
                    (ke === void 0 || typeof ke == "object" && ke !== null && Object.keys(ke).length === 0) && (Ur += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                    var fi = br(Yt);
                    fi ? Ur += fi : Ur += Yr();
                    var In;
                    ke === null ? In = "null" : Ot(ke) ? In = "array" : ke !== void 0 && ke.$$typeof === e ? (In = "<" + (D(ke.type) || "Unknown") + " />", Ur = " Did you accidentally export a JSX literal instead of a component?") : In = typeof ke, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", In, Ur)
                }
                var kn = ft(ke, st, ot, Yt, vr);
                if (kn == null) return kn;
                if (Vr) {
                    var Ai = st.children;
                    if (Ai !== void 0) if (xt) if (Ot(Ai)) {
                        for (var Fi = 0; Fi < Ai.length; Fi++) _n(Ai[Fi], ke);
                        Object.freeze && Object.freeze(Ai)
                    } else P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."); else _n(Ai, ke)
                }
                if (ze.call(st, "key")) {
                    var Pt = D(ke), Wn = Object.keys(st).filter(function (Oa) {
                        return Oa !== "key"
                    }), Da = Wn.length > 0 ? "{key: someKey, " + Wn.join(": ..., ") + ": ...}" : "{key: someKey}";
                    if (!fn[Pt + Da]) {
                        var Ma = Wn.length > 0 ? "{" + Wn.join(": ..., ") + ": ...}" : "{}";
                        P(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Da, Pt, Ma, Pt), fn[Pt + Da] = !0
                    }
                }
                return ke === n ? mr(kn) : Nr(kn), kn
            }
        }

        function Cr(ke, st, ot) {
            return Hn(ke, st, ot, !0)
        }

        function An(ke, st, ot) {
            return Hn(ke, st, ot, !1)
        }

        var pn = An, wr = Cr;
        O5.Fragment = n, O5.jsx = pn, O5.jsxs = wr
    }()), O5
}

Ve.env.NODE_ENV === "production" ? bW.exports = HOe() : bW.exports = WOe();
var ie = bW.exports;
const Os = globalThis || void 0 || self;
var F9 = function (t) {
        return t && t.Math == Math && t
    },
    Yv = F9(typeof globalThis == "object" && globalThis) || F9(typeof window == "object" && window) || F9(typeof self == "object" && self) || F9(typeof tn == "object" && tn) || function () {
        return this
    }() || Function("return this")(), zY = {}, h1 = function (t) {
        try {
            return !!t()
        } catch {
            return !0
        }
    }, qOe = h1, p1 = !qOe(function () {
        return Object.defineProperty({}, 1, {
            get: function () {
                return 7
            }
        })[1] != 7
    }), GOe = h1, Ave = !GOe(function () {
        var t = (function () {
        }).bind();
        return typeof t != "function" || t.hasOwnProperty("prototype")
    }), KOe = Ave, U9 = Function.prototype.call, u8 = KOe ? U9.bind(U9) : function () {
        return U9.apply(U9, arguments)
    }, Ive = {}, kve = {}.propertyIsEnumerable, Rve = Object.getOwnPropertyDescriptor, YOe = Rve && !kve.call({1: 2}, 1);
Ive.f = YOe ? function (e) {
    var r = Rve(this, e);
    return !!r && r.enumerable
} : kve;
var Dve = function (t, e) {
        return {enumerable: !(t & 1), configurable: !(t & 2), writable: !(t & 4), value: e}
    }, Mve = Ave, Ove = Function.prototype, wW = Ove.call, XOe = Mve && Ove.bind.bind(wW, wW),
    gp = Mve ? XOe : function (t) {
        return function () {
            return wW.apply(t, arguments)
        }
    }, Pve = gp, QOe = Pve({}.toString), ZOe = Pve("".slice), VY = function (t) {
        return ZOe(QOe(t), 8, -1)
    }, JOe = gp, ePe = h1, tPe = VY, XU = Object, rPe = JOe("".split), nPe = ePe(function () {
        return !XU("z").propertyIsEnumerable(0)
    }) ? function (t) {
        return tPe(t) == "String" ? rPe(t, "") : XU(t)
    } : XU, HY = function (t) {
        return t == null
    }, iPe = HY, aPe = TypeError, WY = function (t) {
        if (iPe(t)) throw aPe("Can't call method on " + t);
        return t
    }, oPe = nPe, sPe = WY, FP = function (t) {
        return oPe(sPe(t))
    }, SW = typeof document == "object" && document.all, cPe = typeof SW > "u" && SW !== void 0,
    Nve = {all: SW, IS_HTMLDDA: cPe}, Lve = Nve, lPe = Lve.all, th = Lve.IS_HTMLDDA ? function (t) {
        return typeof t == "function" || t === lPe
    } : function (t) {
        return typeof t == "function"
    }, roe = th, Bve = Nve, uPe = Bve.all, IE = Bve.IS_HTMLDDA ? function (t) {
        return typeof t == "object" ? t !== null : roe(t) || t === uPe
    } : function (t) {
        return typeof t == "object" ? t !== null : roe(t)
    }, QU = Yv, fPe = th, dPe = function (t) {
        return fPe(t) ? t : void 0
    }, qY = function (t, e) {
        return arguments.length < 2 ? dPe(QU[t]) : QU[t] && QU[t][e]
    }, hPe = gp, $ve = hPe({}.isPrototypeOf), pPe = typeof navigator < "u" && String(navigator.userAgent) || "", Fve = Yv,
    ZU = pPe, noe = Fve.process, ioe = Fve.Deno, aoe = noe && noe.versions || ioe && ioe.version, ooe = aoe && aoe.v8,
    Hh, wM;
ooe && (Hh = ooe.split("."), wM = Hh[0] > 0 && Hh[0] < 4 ? 1 : +(Hh[0] + Hh[1]));
!wM && ZU && (Hh = ZU.match(/Edge\/(\d+)/), (!Hh || Hh[1] >= 74) && (Hh = ZU.match(/Chrome\/(\d+)/), Hh && (wM = +Hh[1])));
var mPe = wM, soe = mPe, vPe = h1, Uve = !!Object.getOwnPropertySymbols && !vPe(function () {
        var t = Symbol();
        return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && soe && soe < 41
    }), gPe = Uve, jve = gPe && !Symbol.sham && typeof Symbol.iterator == "symbol", yPe = qY, bPe = th, wPe = $ve,
    SPe = jve, _Pe = Object, zve = SPe ? function (t) {
        return typeof t == "symbol"
    } : function (t) {
        var e = yPe("Symbol");
        return bPe(e) && wPe(e.prototype, _Pe(t))
    }, xPe = String, EPe = function (t) {
        try {
            return xPe(t)
        } catch {
            return "Object"
        }
    }, TPe = th, CPe = EPe, APe = TypeError, IPe = function (t) {
        if (TPe(t)) return t;
        throw APe(CPe(t) + " is not a function")
    }, kPe = IPe, RPe = HY, Vve = function (t, e) {
        var r = t[e];
        return RPe(r) ? void 0 : kPe(r)
    }, JU = u8, ej = th, tj = IE, DPe = TypeError, MPe = function (t, e) {
        var r, n;
        if (e === "string" && ej(r = t.toString) && !tj(n = JU(r, t)) || ej(r = t.valueOf) && !tj(n = JU(r, t)) || e !== "string" && ej(r = t.toString) && !tj(n = JU(r, t))) return n;
        throw DPe("Can't convert object to primitive value")
    }, Hve = {exports: {}}, coe = Yv, OPe = Object.defineProperty, GY = function (t, e) {
        try {
            OPe(coe, t, {value: e, configurable: !0, writable: !0})
        } catch {
            coe[t] = e
        }
        return e
    }, PPe = Yv, NPe = GY, loe = "__core-js_shared__", LPe = PPe[loe] || NPe(loe, {}), KY = LPe, uoe = KY;
(Hve.exports = function (t, e) {
    return uoe[t] || (uoe[t] = e !== void 0 ? e : {})
})("versions", []).push({
    version: "3.28.0",
    mode: "global",
    copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.28.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
});
var Wve = Hve.exports, BPe = WY, $Pe = Object, YY = function (t) {
        return $Pe(BPe(t))
    }, FPe = gp, UPe = YY, jPe = FPe({}.hasOwnProperty), m1 = Object.hasOwn || function (e, r) {
        return jPe(UPe(e), r)
    }, zPe = gp, VPe = 0, HPe = Math.random(), WPe = zPe(1.1.toString), qve = function (t) {
        return "Symbol(" + (t === void 0 ? "" : t) + ")_" + WPe(++VPe + HPe, 36)
    }, qPe = Yv, GPe = Wve, foe = m1, KPe = qve, YPe = Uve, XPe = jve, _x = qPe.Symbol, rj = GPe("wks"),
    QPe = XPe ? _x.for || _x : _x && _x.withoutSetter || KPe, kE = function (t) {
        return foe(rj, t) || (rj[t] = YPe && foe(_x, t) ? _x[t] : QPe("Symbol." + t)), rj[t]
    }, ZPe = u8, doe = IE, hoe = zve, JPe = Vve, eNe = MPe, tNe = kE, rNe = TypeError, nNe = tNe("toPrimitive"),
    iNe = function (t, e) {
        if (!doe(t) || hoe(t)) return t;
        var r = JPe(t, nNe), n;
        if (r) {
            if (e === void 0 && (e = "default"), n = ZPe(r, t, e), !doe(n) || hoe(n)) return n;
            throw rNe("Can't convert object to primitive value")
        }
        return e === void 0 && (e = "number"), eNe(t, e)
    }, aNe = iNe, oNe = zve, Gve = function (t) {
        var e = aNe(t, "string");
        return oNe(e) ? e : e + ""
    }, sNe = Yv, poe = IE, _W = sNe.document, cNe = poe(_W) && poe(_W.createElement), Kve = function (t) {
        return cNe ? _W.createElement(t) : {}
    }, lNe = p1, uNe = h1, fNe = Kve, Yve = !lNe && !uNe(function () {
        return Object.defineProperty(fNe("div"), "a", {
            get: function () {
                return 7
            }
        }).a != 7
    }), dNe = p1, hNe = u8, pNe = Ive, mNe = Dve, vNe = FP, gNe = Gve, yNe = m1, bNe = Yve,
    moe = Object.getOwnPropertyDescriptor;
zY.f = dNe ? moe : function (e, r) {
    if (e = vNe(e), r = gNe(r), bNe) try {
        return moe(e, r)
    } catch {
    }
    if (yNe(e, r)) return mNe(!hNe(pNe.f, e, r), e[r])
};
var RE = {}, wNe = p1, SNe = h1, Xve = wNe && SNe(function () {
        return Object.defineProperty(function () {
        }, "prototype", {value: 42, writable: !1}).prototype != 42
    }), _Ne = IE, xNe = String, ENe = TypeError, f8 = function (t) {
        if (_Ne(t)) return t;
        throw ENe(xNe(t) + " is not an object")
    }, TNe = p1, CNe = Yve, ANe = Xve, j9 = f8, voe = Gve, INe = TypeError, nj = Object.defineProperty,
    kNe = Object.getOwnPropertyDescriptor, ij = "enumerable", aj = "configurable", oj = "writable";
RE.f = TNe ? ANe ? function (e, r, n) {
    if (j9(e), r = voe(r), j9(n), typeof e == "function" && r === "prototype" && "value" in n && oj in n && !n[oj]) {
        var i = kNe(e, r);
        i && i[oj] && (e[r] = n.value, n = {
            configurable: aj in n ? n[aj] : i[aj],
            enumerable: ij in n ? n[ij] : i[ij],
            writable: !1
        })
    }
    return nj(e, r, n)
} : nj : function (e, r, n) {
    if (j9(e), r = voe(r), j9(n), CNe) try {
        return nj(e, r, n)
    } catch {
    }
    if ("get" in n || "set" in n) throw INe("Accessors not supported");
    return "value" in n && (e[r] = n.value), e
};
var RNe = p1, DNe = RE, MNe = Dve, Qve = RNe ? function (t, e, r) {
        return DNe.f(t, e, MNe(1, r))
    } : function (t, e, r) {
        return t[e] = r, t
    }, Zve = {exports: {}}, xW = p1, ONe = m1, Jve = Function.prototype, PNe = xW && Object.getOwnPropertyDescriptor,
    XY = ONe(Jve, "name"), NNe = XY && (function () {
    }).name === "something", LNe = XY && (!xW || xW && PNe(Jve, "name").configurable),
    BNe = {EXISTS: XY, PROPER: NNe, CONFIGURABLE: LNe}, $Ne = gp, FNe = th, EW = KY, UNe = $Ne(Function.toString);
FNe(EW.inspectSource) || (EW.inspectSource = function (t) {
    return UNe(t)
});
var jNe = EW.inspectSource, zNe = Yv, VNe = th, goe = zNe.WeakMap, HNe = VNe(goe) && /native code/.test(String(goe)),
    WNe = Wve, qNe = qve, yoe = WNe("keys"), ege = function (t) {
        return yoe[t] || (yoe[t] = qNe(t))
    }, QY = {}, GNe = HNe, tge = Yv, KNe = IE, YNe = Qve, sj = m1, cj = KY, XNe = ege, QNe = QY,
    boe = "Object already initialized", TW = tge.TypeError, ZNe = tge.WeakMap, SM, FC, _M, JNe = function (t) {
        return _M(t) ? FC(t) : SM(t, {})
    }, eLe = function (t) {
        return function (e) {
            var r;
            if (!KNe(e) || (r = FC(e)).type !== t) throw TW("Incompatible receiver, " + t + " required");
            return r
        }
    };
if (GNe || cj.state) {
    var s0 = cj.state || (cj.state = new ZNe);
    s0.get = s0.get, s0.has = s0.has, s0.set = s0.set, SM = function (t, e) {
        if (s0.has(t)) throw TW(boe);
        return e.facade = t, s0.set(t, e), e
    }, FC = function (t) {
        return s0.get(t) || {}
    }, _M = function (t) {
        return s0.has(t)
    }
} else {
    var V_ = XNe("state");
    QNe[V_] = !0, SM = function (t, e) {
        if (sj(t, V_)) throw TW(boe);
        return e.facade = t, YNe(t, V_, e), e
    }, FC = function (t) {
        return sj(t, V_) ? t[V_] : {}
    }, _M = function (t) {
        return sj(t, V_)
    }
}
var tLe = {set: SM, get: FC, has: _M, enforce: JNe, getterFor: eLe}, ZY = gp, rLe = h1, nLe = th, z9 = m1, CW = p1,
    iLe = BNe.CONFIGURABLE, aLe = jNe, rge = tLe, oLe = rge.enforce, sLe = rge.get, woe = String,
    cD = Object.defineProperty, cLe = ZY("".slice), lLe = ZY("".replace), uLe = ZY([].join),
    fLe = CW && !rLe(function () {
        return cD(function () {
        }, "length", {value: 8}).length !== 8
    }), dLe = String(String).split("String"), hLe = Zve.exports = function (t, e, r) {
        cLe(woe(e), 0, 7) === "Symbol(" && (e = "[" + lLe(woe(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), r && r.getter && (e = "get " + e), r && r.setter && (e = "set " + e), (!z9(t, "name") || iLe && t.name !== e) && (CW ? cD(t, "name", {
            value: e,
            configurable: !0
        }) : t.name = e), fLe && r && z9(r, "arity") && t.length !== r.arity && cD(t, "length", {value: r.arity});
        try {
            r && z9(r, "constructor") && r.constructor ? CW && cD(t, "prototype", {writable: !1}) : t.prototype && (t.prototype = void 0)
        } catch {
        }
        var n = oLe(t);
        return z9(n, "source") || (n.source = uLe(dLe, typeof e == "string" ? e : "")), t
    };
Function.prototype.toString = hLe(function () {
    return nLe(this) && sLe(this).source || aLe(this)
}, "toString");
var pLe = Zve.exports, mLe = th, vLe = RE, gLe = pLe, yLe = GY, bLe = function (t, e, r, n) {
        n || (n = {});
        var i = n.enumerable, a = n.name !== void 0 ? n.name : e;
        if (mLe(r) && gLe(r, a, n), n.global) i ? t[e] = r : yLe(e, r); else {
            try {
                n.unsafe ? t[e] && (i = !0) : delete t[e]
            } catch {
            }
            i ? t[e] = r : vLe.f(t, e, {
                value: r,
                enumerable: !1,
                configurable: !n.nonConfigurable,
                writable: !n.nonWritable
            })
        }
        return t
    }, nge = {}, wLe = Math.ceil, SLe = Math.floor, _Le = Math.trunc || function (e) {
        var r = +e;
        return (r > 0 ? SLe : wLe)(r)
    }, xLe = _Le, JY = function (t) {
        var e = +t;
        return e !== e || e === 0 ? 0 : xLe(e)
    }, ELe = JY, TLe = Math.max, CLe = Math.min, ALe = function (t, e) {
        var r = ELe(t);
        return r < 0 ? TLe(r + e, 0) : CLe(r, e)
    }, ILe = JY, kLe = Math.min, RLe = function (t) {
        return t > 0 ? kLe(ILe(t), 9007199254740991) : 0
    }, DLe = RLe, ige = function (t) {
        return DLe(t.length)
    }, MLe = FP, OLe = ALe, PLe = ige, Soe = function (t) {
        return function (e, r, n) {
            var i = MLe(e), a = PLe(i), o = OLe(n, a), s;
            if (t && r != r) {
                for (; a > o;) if (s = i[o++], s != s) return !0
            } else for (; a > o; o++) if ((t || o in i) && i[o] === r) return t || o || 0;
            return !t && -1
        }
    }, NLe = {includes: Soe(!0), indexOf: Soe(!1)}, LLe = gp, lj = m1, BLe = FP, $Le = NLe.indexOf, FLe = QY,
    _oe = LLe([].push), age = function (t, e) {
        var r = BLe(t), n = 0, i = [], a;
        for (a in r) !lj(FLe, a) && lj(r, a) && _oe(i, a);
        for (; e.length > n;) lj(r, a = e[n++]) && (~$Le(i, a) || _oe(i, a));
        return i
    },
    eX = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
    ULe = age, jLe = eX, zLe = jLe.concat("length", "prototype");
nge.f = Object.getOwnPropertyNames || function (e) {
    return ULe(e, zLe)
};
var oge = {};
oge.f = Object.getOwnPropertySymbols;
var VLe = qY, HLe = gp, WLe = nge, qLe = oge, GLe = f8, KLe = HLe([].concat),
    YLe = VLe("Reflect", "ownKeys") || function (e) {
        var r = WLe.f(GLe(e)), n = qLe.f;
        return n ? KLe(r, n(e)) : r
    }, xoe = m1, XLe = YLe, QLe = zY, ZLe = RE, JLe = function (t, e, r) {
        for (var n = XLe(e), i = ZLe.f, a = QLe.f, o = 0; o < n.length; o++) {
            var s = n[o];
            !xoe(t, s) && !(r && xoe(r, s)) && i(t, s, a(e, s))
        }
    }, eBe = h1, tBe = th, rBe = /#|\.prototype\./, d8 = function (t, e) {
        var r = iBe[nBe(t)];
        return r == oBe ? !0 : r == aBe ? !1 : tBe(e) ? eBe(e) : !!e
    }, nBe = d8.normalize = function (t) {
        return String(t).replace(rBe, ".").toLowerCase()
    }, iBe = d8.data = {}, aBe = d8.NATIVE = "N", oBe = d8.POLYFILL = "P", sBe = d8, uj = Yv, cBe = zY.f, lBe = Qve,
    uBe = bLe, fBe = GY, dBe = JLe, hBe = sBe, sge = function (t, e) {
        var r = t.target, n = t.global, i = t.stat, a, o, s, l, f, d;
        if (n ? o = uj : i ? o = uj[r] || fBe(r, {}) : o = (uj[r] || {}).prototype, o) for (s in e) {
            if (f = e[s], t.dontCallGetSet ? (d = cBe(o, s), l = d && d.value) : l = o[s], a = hBe(n ? s : r + (i ? "." : "#") + s, t.forced), !a && l !== void 0) {
                if (typeof f == typeof l) continue;
                dBe(f, l)
            }
            (t.sham || l && l.sham) && lBe(f, "sham", !0), uBe(o, s, f, t)
        }
    }, cge = {}, pBe = age, mBe = eX, vBe = Object.keys || function (e) {
        return pBe(e, mBe)
    }, gBe = p1, yBe = Xve, bBe = RE, wBe = f8, SBe = FP, _Be = vBe;
cge.f = gBe && !yBe ? Object.defineProperties : function (e, r) {
    wBe(e);
    for (var n = SBe(r), i = _Be(r), a = i.length, o = 0, s; a > o;) bBe.f(e, s = i[o++], n[s]);
    return e
};
var xBe = qY, EBe = xBe("document", "documentElement"), TBe = f8, CBe = cge, Eoe = eX, ABe = QY, IBe = EBe, kBe = Kve,
    RBe = ege, Toe = ">", Coe = "<", AW = "prototype", IW = "script", lge = RBe("IE_PROTO"), fj = function () {
    }, uge = function (t) {
        return Coe + IW + Toe + t + Coe + "/" + IW + Toe
    }, Aoe = function (t) {
        t.write(uge("")), t.close();
        var e = t.parentWindow.Object;
        return t = null, e
    }, DBe = function () {
        var t = kBe("iframe"), e = "java" + IW + ":", r;
        return t.style.display = "none", IBe.appendChild(t), t.src = String(e), r = t.contentWindow.document, r.open(), r.write(uge("document.F=Object")), r.close(), r.F
    }, V9, lD = function () {
        try {
            V9 = new ActiveXObject("htmlfile")
        } catch {
        }
        lD = typeof document < "u" ? document.domain && V9 ? Aoe(V9) : DBe() : Aoe(V9);
        for (var t = Eoe.length; t--;) delete lD[AW][Eoe[t]];
        return lD()
    };
ABe[lge] = !0;
var MBe = Object.create || function (e, r) {
    var n;
    return e !== null ? (fj[AW] = TBe(e), n = new fj, fj[AW] = null, n[lge] = e) : n = lD(), r === void 0 ? n : CBe.f(n, r)
}, OBe = kE, PBe = MBe, NBe = RE.f, kW = OBe("unscopables"), RW = Array.prototype;
RW[kW] == null && NBe(RW, kW, {configurable: !0, value: PBe(null)});
var LBe = function (t) {
    RW[kW][t] = !0
}, BBe = sge, $Be = YY, FBe = ige, UBe = JY, jBe = LBe;
BBe({target: "Array", proto: !0}, {
    at: function (e) {
        var r = $Be(this), n = FBe(r), i = UBe(e), a = i >= 0 ? i : n + i;
        return a < 0 || a >= n ? void 0 : r[a]
    }
});
jBe("at");
var zBe = IE, VBe = VY, HBe = kE, WBe = HBe("match"), qBe = function (t) {
    var e;
    return zBe(t) && ((e = t[WBe]) !== void 0 ? !!e : VBe(t) == "RegExp")
}, GBe = kE, KBe = GBe("toStringTag"), fge = {};
fge[KBe] = "z";
var YBe = String(fge) === "[object z]", XBe = YBe, QBe = th, uD = VY, ZBe = kE, JBe = ZBe("toStringTag"), e$e = Object,
    t$e = uD(function () {
        return arguments
    }()) == "Arguments", r$e = function (t, e) {
        try {
            return t[e]
        } catch {
        }
    }, n$e = XBe ? uD : function (t) {
        var e, r, n;
        return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (r = r$e(e = e$e(t), JBe)) == "string" ? r : t$e ? uD(e) : (n = uD(e)) == "Object" && QBe(e.callee) ? "Arguments" : n
    }, i$e = n$e, a$e = String, o$e = function (t) {
        if (i$e(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
        return a$e(t)
    }, s$e = f8, c$e = function () {
        var t = s$e(this), e = "";
        return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e
    }, l$e = u8, u$e = m1, f$e = $ve, d$e = c$e, Ioe = RegExp.prototype, h$e = function (t) {
        var e = t.flags;
        return e === void 0 && !("flags" in Ioe) && !u$e(t, "flags") && f$e(Ioe, t) ? l$e(d$e, t) : e
    }, tX = gp, p$e = YY, m$e = Math.floor, dj = tX("".charAt), v$e = tX("".replace), hj = tX("".slice),
    g$e = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, y$e = /\$([$&'`]|\d{1,2})/g, b$e = function (t, e, r, n, i, a) {
        var o = r + t.length, s = n.length, l = y$e;
        return i !== void 0 && (i = p$e(i), l = g$e), v$e(a, l, function (f, d) {
            var p;
            switch (dj(d, 0)) {
                case"$":
                    return "$";
                case"&":
                    return t;
                case"`":
                    return hj(e, 0, r);
                case"'":
                    return hj(e, o);
                case"<":
                    p = i[hj(d, 1, -1)];
                    break;
                default:
                    var g = +d;
                    if (g === 0) return f;
                    if (g > s) {
                        var b = m$e(g / 10);
                        return b === 0 ? f : b <= s ? n[b - 1] === void 0 ? dj(d, 1) : n[b - 1] + dj(d, 1) : f
                    }
                    p = n[g - 1]
            }
            return p === void 0 ? "" : p
        })
    }, w$e = sge, S$e = u8, rX = gp, koe = WY, _$e = th, x$e = HY, E$e = qBe, P5 = o$e, T$e = Vve, C$e = h$e, A$e = b$e,
    I$e = kE, k$e = I$e("replace"), R$e = TypeError, dge = rX("".indexOf);
rX("".replace);
var Roe = rX("".slice), D$e = Math.max, Doe = function (t, e, r) {
    return r > t.length ? -1 : e === "" ? r : dge(t, e, r)
};
w$e({target: "String", proto: !0}, {
    replaceAll: function (e, r) {
        var n = koe(this), i, a, o, s, l, f, d, p, g, b = 0, S = 0, T = "";
        if (!x$e(e)) {
            if (i = E$e(e), i && (a = P5(koe(C$e(e))), !~dge(a, "g"))) throw R$e("`.replaceAll` does not allow non-global regexes");
            if (o = T$e(e, k$e), o) return S$e(o, e, n, r)
        }
        for (s = P5(n), l = P5(e), f = _$e(r), f || (r = P5(r)), d = l.length, p = D$e(1, d), b = Doe(s, l, 0); b !== -1;) g = f ? P5(r(l, b, s)) : A$e(l, s, b, [], void 0, r), T += Roe(s, S, b) + g, S = b + d, b = Doe(s, l, b + p);
        return S < s.length && (T += Roe(s, S)), T
    }
});
var qr = {}, UP = {};
UP.byteLength = P$e;
UP.toByteArray = L$e;
UP.fromByteArray = F$e;
var b0 = [], Ld = [], M$e = typeof Uint8Array < "u" ? Uint8Array : Array,
    pj = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var H_ = 0, O$e = pj.length; H_ < O$e; ++H_) b0[H_] = pj[H_], Ld[pj.charCodeAt(H_)] = H_;
Ld[45] = 62;
Ld[95] = 63;

function hge(t) {
    var e = t.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t.indexOf("=");
    r === -1 && (r = e);
    var n = r === e ? 0 : 4 - r % 4;
    return [r, n]
}

function P$e(t) {
    var e = hge(t), r = e[0], n = e[1];
    return (r + n) * 3 / 4 - n
}

function N$e(t, e, r) {
    return (e + r) * 3 / 4 - r
}

function L$e(t) {
    var e, r = hge(t), n = r[0], i = r[1], a = new M$e(N$e(t, n, i)), o = 0, s = i > 0 ? n - 4 : n, l;
    for (l = 0; l < s; l += 4) e = Ld[t.charCodeAt(l)] << 18 | Ld[t.charCodeAt(l + 1)] << 12 | Ld[t.charCodeAt(l + 2)] << 6 | Ld[t.charCodeAt(l + 3)], a[o++] = e >> 16 & 255, a[o++] = e >> 8 & 255, a[o++] = e & 255;
    return i === 2 && (e = Ld[t.charCodeAt(l)] << 2 | Ld[t.charCodeAt(l + 1)] >> 4, a[o++] = e & 255), i === 1 && (e = Ld[t.charCodeAt(l)] << 10 | Ld[t.charCodeAt(l + 1)] << 4 | Ld[t.charCodeAt(l + 2)] >> 2, a[o++] = e >> 8 & 255, a[o++] = e & 255), a
}

function B$e(t) {
    return b0[t >> 18 & 63] + b0[t >> 12 & 63] + b0[t >> 6 & 63] + b0[t & 63]
}

function $$e(t, e, r) {
    for (var n, i = [], a = e; a < r; a += 3) n = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (t[a + 2] & 255), i.push(B$e(n));
    return i.join("")
}

function F$e(t) {
    for (var e, r = t.length, n = r % 3, i = [], a = 16383, o = 0, s = r - n; o < s; o += a) i.push($$e(t, o, o + a > s ? s : o + a));
    return n === 1 ? (e = t[r - 1], i.push(b0[e >> 2] + b0[e << 4 & 63] + "==")) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(b0[e >> 10] + b0[e >> 4 & 63] + b0[e << 2 & 63] + "=")), i.join("")
}

var nX = {};
nX.read = function (t, e, r, n, i) {
    var a, o, s = i * 8 - n - 1, l = (1 << s) - 1, f = l >> 1, d = -7, p = r ? i - 1 : 0, g = r ? -1 : 1, b = t[e + p];
    for (p += g, a = b & (1 << -d) - 1, b >>= -d, d += s; d > 0; a = a * 256 + t[e + p], p += g, d -= 8) ;
    for (o = a & (1 << -d) - 1, a >>= -d, d += n; d > 0; o = o * 256 + t[e + p], p += g, d -= 8) ;
    if (a === 0) a = 1 - f; else {
        if (a === l) return o ? NaN : (b ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, n), a = a - f
    }
    return (b ? -1 : 1) * o * Math.pow(2, a - n)
};
nX.write = function (t, e, r, n, i, a) {
    var o, s, l, f = a * 8 - i - 1, d = (1 << f) - 1, p = d >> 1,
        g = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, b = n ? 0 : a - 1, S = n ? 1 : -1,
        T = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = d) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + p >= 1 ? e += g / l : e += g * Math.pow(2, 1 - p), e * l >= 2 && (o++, l /= 2), o + p >= d ? (s = 0, o = d) : o + p >= 1 ? (s = (e * l - 1) * Math.pow(2, i), o = o + p) : (s = e * Math.pow(2, p - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + b] = s & 255, b += S, s /= 256, i -= 8) ;
    for (o = o << i | s, f += i; f > 0; t[r + b] = o & 255, b += S, o /= 256, f -= 8) ;
    t[r + b - S] |= T * 128
};
(function (t) {
    const e = UP, r = nX,
        n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = s, t.SlowBuffer = P, t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = a(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function a() {
        try {
            const pe = new Uint8Array(1), te = {
                foo: function () {
                    return 42
                }
            };
            return Object.setPrototypeOf(te, Uint8Array.prototype), Object.setPrototypeOf(pe, te), pe.foo() === 42
        } catch {
            return !1
        }
    }

    Object.defineProperty(s.prototype, "parent", {
        enumerable: !0, get: function () {
            if (s.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(s.prototype, "offset", {
        enumerable: !0, get: function () {
            if (s.isBuffer(this)) return this.byteOffset
        }
    });

    function o(pe) {
        if (pe > i) throw new RangeError('The value "' + pe + '" is invalid for option "size"');
        const te = new Uint8Array(pe);
        return Object.setPrototypeOf(te, s.prototype), te
    }

    function s(pe, te, X) {
        if (typeof pe == "number") {
            if (typeof te == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return p(pe)
        }
        return l(pe, te, X)
    }

    s.poolSize = 8192;

    function l(pe, te, X) {
        if (typeof pe == "string") return g(pe, te);
        if (ArrayBuffer.isView(pe)) return S(pe);
        if (pe == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof pe);
        if (Ot(pe, ArrayBuffer) || pe && Ot(pe.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ot(pe, SharedArrayBuffer) || pe && Ot(pe.buffer, SharedArrayBuffer))) return T(pe, te, X);
        if (typeof pe == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const H = pe.valueOf && pe.valueOf();
        if (H != null && H !== pe) return s.from(H, te, X);
        const U = I(pe);
        if (U) return U;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof pe[Symbol.toPrimitive] == "function") return s.from(pe[Symbol.toPrimitive]("string"), te, X);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof pe)
    }

    s.from = function (pe, te, X) {
        return l(pe, te, X)
    }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);

    function f(pe) {
        if (typeof pe != "number") throw new TypeError('"size" argument must be of type number');
        if (pe < 0) throw new RangeError('The value "' + pe + '" is invalid for option "size"')
    }

    function d(pe, te, X) {
        return f(pe), pe <= 0 ? o(pe) : te !== void 0 ? typeof X == "string" ? o(pe).fill(te, X) : o(pe).fill(te) : o(pe)
    }

    s.alloc = function (pe, te, X) {
        return d(pe, te, X)
    };

    function p(pe) {
        return f(pe), o(pe < 0 ? 0 : N(pe) | 0)
    }

    s.allocUnsafe = function (pe) {
        return p(pe)
    }, s.allocUnsafeSlow = function (pe) {
        return p(pe)
    };

    function g(pe, te) {
        if ((typeof te != "string" || te === "") && (te = "utf8"), !s.isEncoding(te)) throw new TypeError("Unknown encoding: " + te);
        const X = F(pe, te) | 0;
        let H = o(X);
        const U = H.write(pe, te);
        return U !== X && (H = H.slice(0, U)), H
    }

    function b(pe) {
        const te = pe.length < 0 ? 0 : N(pe.length) | 0, X = o(te);
        for (let H = 0; H < te; H += 1) X[H] = pe[H] & 255;
        return X
    }

    function S(pe) {
        if (Ot(pe, Uint8Array)) {
            const te = new Uint8Array(pe);
            return T(te.buffer, te.byteOffset, te.byteLength)
        }
        return b(pe)
    }

    function T(pe, te, X) {
        if (te < 0 || pe.byteLength < te) throw new RangeError('"offset" is outside of buffer bounds');
        if (pe.byteLength < te + (X || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let H;
        return te === void 0 && X === void 0 ? H = new Uint8Array(pe) : X === void 0 ? H = new Uint8Array(pe, te) : H = new Uint8Array(pe, te, X), Object.setPrototypeOf(H, s.prototype), H
    }

    function I(pe) {
        if (s.isBuffer(pe)) {
            const te = N(pe.length) | 0, X = o(te);
            return X.length === 0 || pe.copy(X, 0, 0, te), X
        }
        if (pe.length !== void 0) return typeof pe.length != "number" || zt(pe.length) ? o(0) : b(pe);
        if (pe.type === "Buffer" && Array.isArray(pe.data)) return b(pe.data)
    }

    function N(pe) {
        if (pe >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return pe | 0
    }

    function P(pe) {
        return +pe != pe && (pe = 0), s.alloc(+pe)
    }

    s.isBuffer = function (te) {
        return te != null && te._isBuffer === !0 && te !== s.prototype
    }, s.compare = function (te, X) {
        if (Ot(te, Uint8Array) && (te = s.from(te, te.offset, te.byteLength)), Ot(X, Uint8Array) && (X = s.from(X, X.offset, X.byteLength)), !s.isBuffer(te) || !s.isBuffer(X)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (te === X) return 0;
        let H = te.length, U = X.length;
        for (let q = 0, le = Math.min(H, U); q < le; ++q) if (te[q] !== X[q]) {
            H = te[q], U = X[q];
            break
        }
        return H < U ? -1 : U < H ? 1 : 0
    }, s.isEncoding = function (te) {
        switch (String(te).toLowerCase()) {
            case"hex":
            case"utf8":
            case"utf-8":
            case"ascii":
            case"latin1":
            case"binary":
            case"base64":
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return !0;
            default:
                return !1
        }
    }, s.concat = function (te, X) {
        if (!Array.isArray(te)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (te.length === 0) return s.alloc(0);
        let H;
        if (X === void 0) for (X = 0, H = 0; H < te.length; ++H) X += te[H].length;
        const U = s.allocUnsafe(X);
        let q = 0;
        for (H = 0; H < te.length; ++H) {
            let le = te[H];
            if (Ot(le, Uint8Array)) q + le.length > U.length ? (s.isBuffer(le) || (le = s.from(le)), le.copy(U, q)) : Uint8Array.prototype.set.call(U, le, q); else if (s.isBuffer(le)) le.copy(U, q); else throw new TypeError('"list" argument must be an Array of Buffers');
            q += le.length
        }
        return U
    };

    function F(pe, te) {
        if (s.isBuffer(pe)) return pe.length;
        if (ArrayBuffer.isView(pe) || Ot(pe, ArrayBuffer)) return pe.byteLength;
        if (typeof pe != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof pe);
        const X = pe.length, H = arguments.length > 2 && arguments[2] === !0;
        if (!H && X === 0) return 0;
        let U = !1;
        for (; ;) switch (te) {
            case"ascii":
            case"latin1":
            case"binary":
                return X;
            case"utf8":
            case"utf-8":
                return Be(pe).length;
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return X * 2;
            case"hex":
                return X >>> 1;
            case"base64":
                return bt(pe).length;
            default:
                if (U) return H ? -1 : Be(pe).length;
                te = ("" + te).toLowerCase(), U = !0
        }
    }

    s.byteLength = F;

    function V(pe, te, X) {
        let H = !1;
        if ((te === void 0 || te < 0) && (te = 0), te > this.length || ((X === void 0 || X > this.length) && (X = this.length), X <= 0) || (X >>>= 0, te >>>= 0, X <= te)) return "";
        for (pe || (pe = "utf8"); ;) switch (pe) {
            case"hex":
                return $(this, te, X);
            case"utf8":
            case"utf-8":
                return x(this, te, X);
            case"ascii":
                return z(this, te, X);
            case"latin1":
            case"binary":
                return j(this, te, X);
            case"base64":
                return D(this, te, X);
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return C(this, te, X);
            default:
                if (H) throw new TypeError("Unknown encoding: " + pe);
                pe = (pe + "").toLowerCase(), H = !0
        }
    }

    s.prototype._isBuffer = !0;

    function Y(pe, te, X) {
        const H = pe[te];
        pe[te] = pe[X], pe[X] = H
    }

    s.prototype.swap16 = function () {
        const te = this.length;
        if (te % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let X = 0; X < te; X += 2) Y(this, X, X + 1);
        return this
    }, s.prototype.swap32 = function () {
        const te = this.length;
        if (te % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let X = 0; X < te; X += 4) Y(this, X, X + 3), Y(this, X + 1, X + 2);
        return this
    }, s.prototype.swap64 = function () {
        const te = this.length;
        if (te % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let X = 0; X < te; X += 8) Y(this, X, X + 7), Y(this, X + 1, X + 6), Y(this, X + 2, X + 5), Y(this, X + 3, X + 4);
        return this
    }, s.prototype.toString = function () {
        const te = this.length;
        return te === 0 ? "" : arguments.length === 0 ? x(this, 0, te) : V.apply(this, arguments)
    }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function (te) {
        if (!s.isBuffer(te)) throw new TypeError("Argument must be a Buffer");
        return this === te ? !0 : s.compare(this, te) === 0
    }, s.prototype.inspect = function () {
        let te = "";
        const X = t.INSPECT_MAX_BYTES;
        return te = this.toString("hex", 0, X).replace(/(.{2})/g, "$1 ").trim(), this.length > X && (te += " ... "), "<Buffer " + te + ">"
    }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function (te, X, H, U, q) {
        if (Ot(te, Uint8Array) && (te = s.from(te, te.offset, te.byteLength)), !s.isBuffer(te)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof te);
        if (X === void 0 && (X = 0), H === void 0 && (H = te ? te.length : 0), U === void 0 && (U = 0), q === void 0 && (q = this.length), X < 0 || H > te.length || U < 0 || q > this.length) throw new RangeError("out of range index");
        if (U >= q && X >= H) return 0;
        if (U >= q) return -1;
        if (X >= H) return 1;
        if (X >>>= 0, H >>>= 0, U >>>= 0, q >>>= 0, this === te) return 0;
        let le = q - U, xe = H - X;
        const Ae = Math.min(le, xe), De = this.slice(U, q), Ze = te.slice(X, H);
        for (let ft = 0; ft < Ae; ++ft) if (De[ft] !== Ze[ft]) {
            le = De[ft], xe = Ze[ft];
            break
        }
        return le < xe ? -1 : xe < le ? 1 : 0
    };

    function ee(pe, te, X, H, U) {
        if (pe.length === 0) return -1;
        if (typeof X == "string" ? (H = X, X = 0) : X > 2147483647 ? X = 2147483647 : X < -2147483648 && (X = -2147483648), X = +X, zt(X) && (X = U ? 0 : pe.length - 1), X < 0 && (X = pe.length + X), X >= pe.length) {
            if (U) return -1;
            X = pe.length - 1
        } else if (X < 0) if (U) X = 0; else return -1;
        if (typeof te == "string" && (te = s.from(te, H)), s.isBuffer(te)) return te.length === 0 ? -1 : oe(pe, te, X, H, U);
        if (typeof te == "number") return te = te & 255, typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(pe, te, X) : Uint8Array.prototype.lastIndexOf.call(pe, te, X) : oe(pe, [te], X, H, U);
        throw new TypeError("val must be string, number or Buffer")
    }

    function oe(pe, te, X, H, U) {
        let q = 1, le = pe.length, xe = te.length;
        if (H !== void 0 && (H = String(H).toLowerCase(), H === "ucs2" || H === "ucs-2" || H === "utf16le" || H === "utf-16le")) {
            if (pe.length < 2 || te.length < 2) return -1;
            q = 2, le /= 2, xe /= 2, X /= 2
        }

        function Ae(Ze, ft) {
            return q === 1 ? Ze[ft] : Ze.readUInt16BE(ft * q)
        }

        let De;
        if (U) {
            let Ze = -1;
            for (De = X; De < le; De++) if (Ae(pe, De) === Ae(te, Ze === -1 ? 0 : De - Ze)) {
                if (Ze === -1 && (Ze = De), De - Ze + 1 === xe) return Ze * q
            } else Ze !== -1 && (De -= De - Ze), Ze = -1
        } else for (X + xe > le && (X = le - xe), De = X; De >= 0; De--) {
            let Ze = !0;
            for (let ft = 0; ft < xe; ft++) if (Ae(pe, De + ft) !== Ae(te, ft)) {
                Ze = !1;
                break
            }
            if (Ze) return De
        }
        return -1
    }

    s.prototype.includes = function (te, X, H) {
        return this.indexOf(te, X, H) !== -1
    }, s.prototype.indexOf = function (te, X, H) {
        return ee(this, te, X, H, !0)
    }, s.prototype.lastIndexOf = function (te, X, H) {
        return ee(this, te, X, H, !1)
    };

    function G(pe, te, X, H) {
        X = Number(X) || 0;
        const U = pe.length - X;
        H ? (H = Number(H), H > U && (H = U)) : H = U;
        const q = te.length;
        H > q / 2 && (H = q / 2);
        let le;
        for (le = 0; le < H; ++le) {
            const xe = parseInt(te.substr(le * 2, 2), 16);
            if (zt(xe)) return le;
            pe[X + le] = xe
        }
        return le
    }

    function J(pe, te, X, H) {
        return gt(Be(te, pe.length - X), pe, X, H)
    }

    function ce(pe, te, X, H) {
        return gt(it(te), pe, X, H)
    }

    function re(pe, te, X, H) {
        return gt(bt(te), pe, X, H)
    }

    function M(pe, te, X, H) {
        return gt(Ue(te, pe.length - X), pe, X, H)
    }

    s.prototype.write = function (te, X, H, U) {
        if (X === void 0) U = "utf8", H = this.length, X = 0; else if (H === void 0 && typeof X == "string") U = X, H = this.length, X = 0; else if (isFinite(X)) X = X >>> 0, isFinite(H) ? (H = H >>> 0, U === void 0 && (U = "utf8")) : (U = H, H = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const q = this.length - X;
        if ((H === void 0 || H > q) && (H = q), te.length > 0 && (H < 0 || X < 0) || X > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        U || (U = "utf8");
        let le = !1;
        for (; ;) switch (U) {
            case"hex":
                return G(this, te, X, H);
            case"utf8":
            case"utf-8":
                return J(this, te, X, H);
            case"ascii":
            case"latin1":
            case"binary":
                return ce(this, te, X, H);
            case"base64":
                return re(this, te, X, H);
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return M(this, te, X, H);
            default:
                if (le) throw new TypeError("Unknown encoding: " + U);
                U = ("" + U).toLowerCase(), le = !0
        }
    }, s.prototype.toJSON = function () {
        return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
    };

    function D(pe, te, X) {
        return te === 0 && X === pe.length ? e.fromByteArray(pe) : e.fromByteArray(pe.slice(te, X))
    }

    function x(pe, te, X) {
        X = Math.min(pe.length, X);
        const H = [];
        let U = te;
        for (; U < X;) {
            const q = pe[U];
            let le = null, xe = q > 239 ? 4 : q > 223 ? 3 : q > 191 ? 2 : 1;
            if (U + xe <= X) {
                let Ae, De, Ze, ft;
                switch (xe) {
                    case 1:
                        q < 128 && (le = q);
                        break;
                    case 2:
                        Ae = pe[U + 1], (Ae & 192) === 128 && (ft = (q & 31) << 6 | Ae & 63, ft > 127 && (le = ft));
                        break;
                    case 3:
                        Ae = pe[U + 1], De = pe[U + 2], (Ae & 192) === 128 && (De & 192) === 128 && (ft = (q & 15) << 12 | (Ae & 63) << 6 | De & 63, ft > 2047 && (ft < 55296 || ft > 57343) && (le = ft));
                        break;
                    case 4:
                        Ae = pe[U + 1], De = pe[U + 2], Ze = pe[U + 3], (Ae & 192) === 128 && (De & 192) === 128 && (Ze & 192) === 128 && (ft = (q & 15) << 18 | (Ae & 63) << 12 | (De & 63) << 6 | Ze & 63, ft > 65535 && ft < 1114112 && (le = ft))
                }
            }
            le === null ? (le = 65533, xe = 1) : le > 65535 && (le -= 65536, H.push(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), H.push(le), U += xe
        }
        return B(H)
    }

    const A = 4096;

    function B(pe) {
        const te = pe.length;
        if (te <= A) return String.fromCharCode.apply(String, pe);
        let X = "", H = 0;
        for (; H < te;) X += String.fromCharCode.apply(String, pe.slice(H, H += A));
        return X
    }

    function z(pe, te, X) {
        let H = "";
        X = Math.min(pe.length, X);
        for (let U = te; U < X; ++U) H += String.fromCharCode(pe[U] & 127);
        return H
    }

    function j(pe, te, X) {
        let H = "";
        X = Math.min(pe.length, X);
        for (let U = te; U < X; ++U) H += String.fromCharCode(pe[U]);
        return H
    }

    function $(pe, te, X) {
        const H = pe.length;
        (!te || te < 0) && (te = 0), (!X || X < 0 || X > H) && (X = H);
        let U = "";
        for (let q = te; q < X; ++q) U += _t[pe[q]];
        return U
    }

    function C(pe, te, X) {
        const H = pe.slice(te, X);
        let U = "";
        for (let q = 0; q < H.length - 1; q += 2) U += String.fromCharCode(H[q] + H[q + 1] * 256);
        return U
    }

    s.prototype.slice = function (te, X) {
        const H = this.length;
        te = ~~te, X = X === void 0 ? H : ~~X, te < 0 ? (te += H, te < 0 && (te = 0)) : te > H && (te = H), X < 0 ? (X += H, X < 0 && (X = 0)) : X > H && (X = H), X < te && (X = te);
        const U = this.subarray(te, X);
        return Object.setPrototypeOf(U, s.prototype), U
    };

    function R(pe, te, X) {
        if (pe % 1 !== 0 || pe < 0) throw new RangeError("offset is not uint");
        if (pe + te > X) throw new RangeError("Trying to access beyond buffer length")
    }

    s.prototype.readUintLE = s.prototype.readUIntLE = function (te, X, H) {
        te = te >>> 0, X = X >>> 0, H || R(te, X, this.length);
        let U = this[te], q = 1, le = 0;
        for (; ++le < X && (q *= 256);) U += this[te + le] * q;
        return U
    }, s.prototype.readUintBE = s.prototype.readUIntBE = function (te, X, H) {
        te = te >>> 0, X = X >>> 0, H || R(te, X, this.length);
        let U = this[te + --X], q = 1;
        for (; X > 0 && (q *= 256);) U += this[te + --X] * q;
        return U
    }, s.prototype.readUint8 = s.prototype.readUInt8 = function (te, X) {
        return te = te >>> 0, X || R(te, 1, this.length), this[te]
    }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function (te, X) {
        return te = te >>> 0, X || R(te, 2, this.length), this[te] | this[te + 1] << 8
    }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function (te, X) {
        return te = te >>> 0, X || R(te, 2, this.length), this[te] << 8 | this[te + 1]
    }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function (te, X) {
        return te = te >>> 0, X || R(te, 4, this.length), (this[te] | this[te + 1] << 8 | this[te + 2] << 16) + this[te + 3] * 16777216
    }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function (te, X) {
        return te = te >>> 0, X || R(te, 4, this.length), this[te] * 16777216 + (this[te + 1] << 16 | this[te + 2] << 8 | this[te + 3])
    }, s.prototype.readBigUInt64LE = Dt(function (te) {
        te = te >>> 0, be(te, "offset");
        const X = this[te], H = this[te + 7];
        (X === void 0 || H === void 0) && Ee(te, this.length - 8);
        const U = X + this[++te] * 2 ** 8 + this[++te] * 2 ** 16 + this[++te] * 2 ** 24,
            q = this[++te] + this[++te] * 2 ** 8 + this[++te] * 2 ** 16 + H * 2 ** 24;
        return BigInt(U) + (BigInt(q) << BigInt(32))
    }), s.prototype.readBigUInt64BE = Dt(function (te) {
        te = te >>> 0, be(te, "offset");
        const X = this[te], H = this[te + 7];
        (X === void 0 || H === void 0) && Ee(te, this.length - 8);
        const U = X * 2 ** 24 + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + this[++te],
            q = this[++te] * 2 ** 24 + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + H;
        return (BigInt(U) << BigInt(32)) + BigInt(q)
    }), s.prototype.readIntLE = function (te, X, H) {
        te = te >>> 0, X = X >>> 0, H || R(te, X, this.length);
        let U = this[te], q = 1, le = 0;
        for (; ++le < X && (q *= 256);) U += this[te + le] * q;
        return q *= 128, U >= q && (U -= Math.pow(2, 8 * X)), U
    }, s.prototype.readIntBE = function (te, X, H) {
        te = te >>> 0, X = X >>> 0, H || R(te, X, this.length);
        let U = X, q = 1, le = this[te + --U];
        for (; U > 0 && (q *= 256);) le += this[te + --U] * q;
        return q *= 128, le >= q && (le -= Math.pow(2, 8 * X)), le
    }, s.prototype.readInt8 = function (te, X) {
        return te = te >>> 0, X || R(te, 1, this.length), this[te] & 128 ? (255 - this[te] + 1) * -1 : this[te]
    }, s.prototype.readInt16LE = function (te, X) {
        te = te >>> 0, X || R(te, 2, this.length);
        const H = this[te] | this[te + 1] << 8;
        return H & 32768 ? H | 4294901760 : H
    }, s.prototype.readInt16BE = function (te, X) {
        te = te >>> 0, X || R(te, 2, this.length);
        const H = this[te + 1] | this[te] << 8;
        return H & 32768 ? H | 4294901760 : H
    }, s.prototype.readInt32LE = function (te, X) {
        return te = te >>> 0, X || R(te, 4, this.length), this[te] | this[te + 1] << 8 | this[te + 2] << 16 | this[te + 3] << 24
    }, s.prototype.readInt32BE = function (te, X) {
        return te = te >>> 0, X || R(te, 4, this.length), this[te] << 24 | this[te + 1] << 16 | this[te + 2] << 8 | this[te + 3]
    }, s.prototype.readBigInt64LE = Dt(function (te) {
        te = te >>> 0, be(te, "offset");
        const X = this[te], H = this[te + 7];
        (X === void 0 || H === void 0) && Ee(te, this.length - 8);
        const U = this[te + 4] + this[te + 5] * 2 ** 8 + this[te + 6] * 2 ** 16 + (H << 24);
        return (BigInt(U) << BigInt(32)) + BigInt(X + this[++te] * 2 ** 8 + this[++te] * 2 ** 16 + this[++te] * 2 ** 24)
    }), s.prototype.readBigInt64BE = Dt(function (te) {
        te = te >>> 0, be(te, "offset");
        const X = this[te], H = this[te + 7];
        (X === void 0 || H === void 0) && Ee(te, this.length - 8);
        const U = (X << 24) + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + this[++te];
        return (BigInt(U) << BigInt(32)) + BigInt(this[++te] * 2 ** 24 + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + H)
    }), s.prototype.readFloatLE = function (te, X) {
        return te = te >>> 0, X || R(te, 4, this.length), r.read(this, te, !0, 23, 4)
    }, s.prototype.readFloatBE = function (te, X) {
        return te = te >>> 0, X || R(te, 4, this.length), r.read(this, te, !1, 23, 4)
    }, s.prototype.readDoubleLE = function (te, X) {
        return te = te >>> 0, X || R(te, 8, this.length), r.read(this, te, !0, 52, 8)
    }, s.prototype.readDoubleBE = function (te, X) {
        return te = te >>> 0, X || R(te, 8, this.length), r.read(this, te, !1, 52, 8)
    };

    function k(pe, te, X, H, U, q) {
        if (!s.isBuffer(pe)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (te > U || te < q) throw new RangeError('"value" argument is out of bounds');
        if (X + H > pe.length) throw new RangeError("Index out of range")
    }

    s.prototype.writeUintLE = s.prototype.writeUIntLE = function (te, X, H, U) {
        if (te = +te, X = X >>> 0, H = H >>> 0, !U) {
            const xe = Math.pow(2, 8 * H) - 1;
            k(this, te, X, H, xe, 0)
        }
        let q = 1, le = 0;
        for (this[X] = te & 255; ++le < H && (q *= 256);) this[X + le] = te / q & 255;
        return X + H
    }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function (te, X, H, U) {
        if (te = +te, X = X >>> 0, H = H >>> 0, !U) {
            const xe = Math.pow(2, 8 * H) - 1;
            k(this, te, X, H, xe, 0)
        }
        let q = H - 1, le = 1;
        for (this[X + q] = te & 255; --q >= 0 && (le *= 256);) this[X + q] = te / le & 255;
        return X + H
    }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 1, 255, 0), this[X] = te & 255, X + 1
    }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 2, 65535, 0), this[X] = te & 255, this[X + 1] = te >>> 8, X + 2
    }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 2, 65535, 0), this[X] = te >>> 8, this[X + 1] = te & 255, X + 2
    }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 4, 4294967295, 0), this[X + 3] = te >>> 24, this[X + 2] = te >>> 16, this[X + 1] = te >>> 8, this[X] = te & 255, X + 4
    }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 4, 4294967295, 0), this[X] = te >>> 24, this[X + 1] = te >>> 16, this[X + 2] = te >>> 8, this[X + 3] = te & 255, X + 4
    };

    function Q(pe, te, X, H, U) {
        ne(te, H, U, pe, X, 7);
        let q = Number(te & BigInt(4294967295));
        pe[X++] = q, q = q >> 8, pe[X++] = q, q = q >> 8, pe[X++] = q, q = q >> 8, pe[X++] = q;
        let le = Number(te >> BigInt(32) & BigInt(4294967295));
        return pe[X++] = le, le = le >> 8, pe[X++] = le, le = le >> 8, pe[X++] = le, le = le >> 8, pe[X++] = le, X
    }

    function fe(pe, te, X, H, U) {
        ne(te, H, U, pe, X, 7);
        let q = Number(te & BigInt(4294967295));
        pe[X + 7] = q, q = q >> 8, pe[X + 6] = q, q = q >> 8, pe[X + 5] = q, q = q >> 8, pe[X + 4] = q;
        let le = Number(te >> BigInt(32) & BigInt(4294967295));
        return pe[X + 3] = le, le = le >> 8, pe[X + 2] = le, le = le >> 8, pe[X + 1] = le, le = le >> 8, pe[X] = le, X + 8
    }

    s.prototype.writeBigUInt64LE = Dt(function (te, X = 0) {
        return Q(this, te, X, BigInt(0), BigInt("0xffffffffffffffff"))
    }), s.prototype.writeBigUInt64BE = Dt(function (te, X = 0) {
        return fe(this, te, X, BigInt(0), BigInt("0xffffffffffffffff"))
    }), s.prototype.writeIntLE = function (te, X, H, U) {
        if (te = +te, X = X >>> 0, !U) {
            const Ae = Math.pow(2, 8 * H - 1);
            k(this, te, X, H, Ae - 1, -Ae)
        }
        let q = 0, le = 1, xe = 0;
        for (this[X] = te & 255; ++q < H && (le *= 256);) te < 0 && xe === 0 && this[X + q - 1] !== 0 && (xe = 1), this[X + q] = (te / le >> 0) - xe & 255;
        return X + H
    }, s.prototype.writeIntBE = function (te, X, H, U) {
        if (te = +te, X = X >>> 0, !U) {
            const Ae = Math.pow(2, 8 * H - 1);
            k(this, te, X, H, Ae - 1, -Ae)
        }
        let q = H - 1, le = 1, xe = 0;
        for (this[X + q] = te & 255; --q >= 0 && (le *= 256);) te < 0 && xe === 0 && this[X + q + 1] !== 0 && (xe = 1), this[X + q] = (te / le >> 0) - xe & 255;
        return X + H
    }, s.prototype.writeInt8 = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 1, 127, -128), te < 0 && (te = 255 + te + 1), this[X] = te & 255, X + 1
    }, s.prototype.writeInt16LE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 2, 32767, -32768), this[X] = te & 255, this[X + 1] = te >>> 8, X + 2
    }, s.prototype.writeInt16BE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 2, 32767, -32768), this[X] = te >>> 8, this[X + 1] = te & 255, X + 2
    }, s.prototype.writeInt32LE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 4, 2147483647, -2147483648), this[X] = te & 255, this[X + 1] = te >>> 8, this[X + 2] = te >>> 16, this[X + 3] = te >>> 24, X + 4
    }, s.prototype.writeInt32BE = function (te, X, H) {
        return te = +te, X = X >>> 0, H || k(this, te, X, 4, 2147483647, -2147483648), te < 0 && (te = 4294967295 + te + 1), this[X] = te >>> 24, this[X + 1] = te >>> 16, this[X + 2] = te >>> 8, this[X + 3] = te & 255, X + 4
    }, s.prototype.writeBigInt64LE = Dt(function (te, X = 0) {
        return Q(this, te, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), s.prototype.writeBigInt64BE = Dt(function (te, X = 0) {
        return fe(this, te, X, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function ye(pe, te, X, H, U, q) {
        if (X + H > pe.length) throw new RangeError("Index out of range");
        if (X < 0) throw new RangeError("Index out of range")
    }

    function ue(pe, te, X, H, U) {
        return te = +te, X = X >>> 0, U || ye(pe, te, X, 4), r.write(pe, te, X, H, 23, 4), X + 4
    }

    s.prototype.writeFloatLE = function (te, X, H) {
        return ue(this, te, X, !0, H)
    }, s.prototype.writeFloatBE = function (te, X, H) {
        return ue(this, te, X, !1, H)
    };

    function me(pe, te, X, H, U) {
        return te = +te, X = X >>> 0, U || ye(pe, te, X, 8), r.write(pe, te, X, H, 52, 8), X + 8
    }

    s.prototype.writeDoubleLE = function (te, X, H) {
        return me(this, te, X, !0, H)
    }, s.prototype.writeDoubleBE = function (te, X, H) {
        return me(this, te, X, !1, H)
    }, s.prototype.copy = function (te, X, H, U) {
        if (!s.isBuffer(te)) throw new TypeError("argument should be a Buffer");
        if (H || (H = 0), !U && U !== 0 && (U = this.length), X >= te.length && (X = te.length), X || (X = 0), U > 0 && U < H && (U = H), U === H || te.length === 0 || this.length === 0) return 0;
        if (X < 0) throw new RangeError("targetStart out of bounds");
        if (H < 0 || H >= this.length) throw new RangeError("Index out of range");
        if (U < 0) throw new RangeError("sourceEnd out of bounds");
        U > this.length && (U = this.length), te.length - X < U - H && (U = te.length - X + H);
        const q = U - H;
        return this === te && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(X, H, U) : Uint8Array.prototype.set.call(te, this.subarray(H, U), X), q
    }, s.prototype.fill = function (te, X, H, U) {
        if (typeof te == "string") {
            if (typeof X == "string" ? (U = X, X = 0, H = this.length) : typeof H == "string" && (U = H, H = this.length), U !== void 0 && typeof U != "string") throw new TypeError("encoding must be a string");
            if (typeof U == "string" && !s.isEncoding(U)) throw new TypeError("Unknown encoding: " + U);
            if (te.length === 1) {
                const le = te.charCodeAt(0);
                (U === "utf8" && le < 128 || U === "latin1") && (te = le)
            }
        } else typeof te == "number" ? te = te & 255 : typeof te == "boolean" && (te = Number(te));
        if (X < 0 || this.length < X || this.length < H) throw new RangeError("Out of range index");
        if (H <= X) return this;
        X = X >>> 0, H = H === void 0 ? this.length : H >>> 0, te || (te = 0);
        let q;
        if (typeof te == "number") for (q = X; q < H; ++q) this[q] = te; else {
            const le = s.isBuffer(te) ? te : s.from(te, U), xe = le.length;
            if (xe === 0) throw new TypeError('The value "' + te + '" is invalid for argument "value"');
            for (q = 0; q < H - X; ++q) this[q + X] = le[q % xe]
        }
        return this
    };
    const Se = {};

    function Ce(pe, te, X) {
        Se[pe] = class extends X {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: te.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${pe}]`, delete this.name
            }

            get code() {
                return pe
            }

            set code(U) {
                Object.defineProperty(this, "code", {configurable: !0, enumerable: !0, value: U, writable: !0})
            }

            toString() {
                return `${this.name} [${pe}]: ${this.message}`
            }
        }
    }

    Ce("ERR_BUFFER_OUT_OF_BOUNDS", function (pe) {
        return pe ? `${pe} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), Ce("ERR_INVALID_ARG_TYPE", function (pe, te) {
        return `The "${pe}" argument must be of type number. Received type ${typeof te}`
    }, TypeError), Ce("ERR_OUT_OF_RANGE", function (pe, te, X) {
        let H = `The value of "${pe}" is out of range.`, U = X;
        return Number.isInteger(X) && Math.abs(X) > 2 ** 32 ? U = Me(String(X)) : typeof X == "bigint" && (U = String(X), (X > BigInt(2) ** BigInt(32) || X < -(BigInt(2) ** BigInt(32))) && (U = Me(U)), U += "n"), H += ` It must be ${te}. Received ${U}`, H
    }, RangeError);

    function Me(pe) {
        let te = "", X = pe.length;
        const H = pe[0] === "-" ? 1 : 0;
        for (; X >= H + 4; X -= 3) te = `_${pe.slice(X - 3, X)}${te}`;
        return `${pe.slice(0, X)}${te}`
    }

    function ve(pe, te, X) {
        be(te, "offset"), (pe[te] === void 0 || pe[te + X] === void 0) && Ee(te, pe.length - (X + 1))
    }

    function ne(pe, te, X, H, U, q) {
        if (pe > X || pe < te) {
            const le = typeof te == "bigint" ? "n" : "";
            let xe;
            throw q > 3 ? te === 0 || te === BigInt(0) ? xe = `>= 0${le} and < 2${le} ** ${(q + 1) * 8}${le}` : xe = `>= -(2${le} ** ${(q + 1) * 8 - 1}${le}) and < 2 ** ${(q + 1) * 8 - 1}${le}` : xe = `>= ${te}${le} and <= ${X}${le}`, new Se.ERR_OUT_OF_RANGE("value", xe, pe)
        }
        ve(H, U, q)
    }

    function be(pe, te) {
        if (typeof pe != "number") throw new Se.ERR_INVALID_ARG_TYPE(te, "number", pe)
    }

    function Ee(pe, te, X) {
        throw Math.floor(pe) !== pe ? (be(pe, X), new Se.ERR_OUT_OF_RANGE(X || "offset", "an integer", pe)) : te < 0 ? new Se.ERR_BUFFER_OUT_OF_BOUNDS : new Se.ERR_OUT_OF_RANGE(X || "offset", `>= ${X ? 1 : 0} and <= ${te}`, pe)
    }

    const Oe = /[^+/0-9A-Za-z-_]/g;

    function ze(pe) {
        if (pe = pe.split("=")[0], pe = pe.trim().replace(Oe, ""), pe.length < 2) return "";
        for (; pe.length % 4 !== 0;) pe = pe + "=";
        return pe
    }

    function Be(pe, te) {
        te = te || 1 / 0;
        let X;
        const H = pe.length;
        let U = null;
        const q = [];
        for (let le = 0; le < H; ++le) {
            if (X = pe.charCodeAt(le), X > 55295 && X < 57344) {
                if (!U) {
                    if (X > 56319) {
                        (te -= 3) > -1 && q.push(239, 191, 189);
                        continue
                    } else if (le + 1 === H) {
                        (te -= 3) > -1 && q.push(239, 191, 189);
                        continue
                    }
                    U = X;
                    continue
                }
                if (X < 56320) {
                    (te -= 3) > -1 && q.push(239, 191, 189), U = X;
                    continue
                }
                X = (U - 55296 << 10 | X - 56320) + 65536
            } else U && (te -= 3) > -1 && q.push(239, 191, 189);
            if (U = null, X < 128) {
                if ((te -= 1) < 0) break;
                q.push(X)
            } else if (X < 2048) {
                if ((te -= 2) < 0) break;
                q.push(X >> 6 | 192, X & 63 | 128)
            } else if (X < 65536) {
                if ((te -= 3) < 0) break;
                q.push(X >> 12 | 224, X >> 6 & 63 | 128, X & 63 | 128)
            } else if (X < 1114112) {
                if ((te -= 4) < 0) break;
                q.push(X >> 18 | 240, X >> 12 & 63 | 128, X >> 6 & 63 | 128, X & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return q
    }

    function it(pe) {
        const te = [];
        for (let X = 0; X < pe.length; ++X) te.push(pe.charCodeAt(X) & 255);
        return te
    }

    function Ue(pe, te) {
        let X, H, U;
        const q = [];
        for (let le = 0; le < pe.length && !((te -= 2) < 0); ++le) X = pe.charCodeAt(le), H = X >> 8, U = X % 256, q.push(U), q.push(H);
        return q
    }

    function bt(pe) {
        return e.toByteArray(ze(pe))
    }

    function gt(pe, te, X, H) {
        let U;
        for (U = 0; U < H && !(U + X >= te.length || U >= pe.length); ++U) te[U + X] = pe[U];
        return U
    }

    function Ot(pe, te) {
        return pe instanceof te || pe != null && pe.constructor != null && pe.constructor.name != null && pe.constructor.name === te.name
    }

    function zt(pe) {
        return pe !== pe
    }

    const _t = function () {
        const pe = "0123456789abcdef", te = new Array(256);
        for (let X = 0; X < 16; ++X) {
            const H = X * 16;
            for (let U = 0; U < 16; ++U) te[H + U] = pe[X] + pe[U]
        }
        return te
    }();

    function Dt(pe) {
        return typeof BigInt > "u" ? rr : pe
    }

    function rr() {
        throw new Error("BigInt not supported")
    }
})(qr);
const pge = za(qr);
typeof Os < "u" && typeof Os.WebSocket > "u" && Object.assign(Os, {WebSocket: window.WebSocket});
typeof Os < "u" && typeof Os.crypto > "u" && Object.assign(Os, {crypto: window.crypto});
typeof Os < "u" && typeof Os.Buffer > "u" && Object.assign(Os, {Buffer: pge.Buffer});
typeof globalThis < "u" && typeof globalThis.Buffer > "u" && Object.assign(globalThis, {Buffer: pge.Buffer});
var DW = {exports: {}}, Uu = {}, H9 = {exports: {}}, mj = {};
var Moe;

function U$e() {
    return Moe || (Moe = 1, function (t) {
        function e(j, $) {
            var C = j.length;
            j.push($);
            e:for (; 0 < C;) {
                var R = C - 1 >>> 1, k = j[R];
                if (0 < i(k, $)) j[R] = $, j[C] = k, C = R; else break e
            }
        }

        function r(j) {
            return j.length === 0 ? null : j[0]
        }

        function n(j) {
            if (j.length === 0) return null;
            var $ = j[0], C = j.pop();
            if (C !== $) {
                j[0] = C;
                e:for (var R = 0, k = j.length, Q = k >>> 1; R < Q;) {
                    var fe = 2 * (R + 1) - 1, ye = j[fe], ue = fe + 1, me = j[ue];
                    if (0 > i(ye, C)) ue < k && 0 > i(me, ye) ? (j[R] = me, j[ue] = C, R = ue) : (j[R] = ye, j[fe] = C, R = fe); else if (ue < k && 0 > i(me, C)) j[R] = me, j[ue] = C, R = ue; else break e
                }
            }
            return $
        }

        function i(j, $) {
            var C = j.sortIndex - $.sortIndex;
            return C !== 0 ? C : j.id - $.id
        }

        if (typeof performance == "object" && typeof performance.now == "function") {
            var a = performance;
            t.unstable_now = function () {
                return a.now()
            }
        } else {
            var o = Date, s = o.now();
            t.unstable_now = function () {
                return o.now() - s
            }
        }
        var l = [], f = [], d = 1, p = null, g = 3, b = !1, S = !1, T = !1,
            I = typeof setTimeout == "function" ? setTimeout : null,
            N = typeof clearTimeout == "function" ? clearTimeout : null,
            P = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

        function F(j) {
            for (var $ = r(f); $ !== null;) {
                if ($.callback === null) n(f); else if ($.startTime <= j) n(f), $.sortIndex = $.expirationTime, e(l, $); else break;
                $ = r(f)
            }
        }

        function V(j) {
            if (T = !1, F(j), !S) if (r(l) !== null) S = !0, B(Y); else {
                var $ = r(f);
                $ !== null && z(V, $.startTime - j)
            }
        }

        function Y(j, $) {
            S = !1, T && (T = !1, N(G), G = -1), b = !0;
            var C = g;
            try {
                for (F($), p = r(l); p !== null && (!(p.expirationTime > $) || j && !re());) {
                    var R = p.callback;
                    if (typeof R == "function") {
                        p.callback = null, g = p.priorityLevel;
                        var k = R(p.expirationTime <= $);
                        $ = t.unstable_now(), typeof k == "function" ? p.callback = k : p === r(l) && n(l), F($)
                    } else n(l);
                    p = r(l)
                }
                if (p !== null) var Q = !0; else {
                    var fe = r(f);
                    fe !== null && z(V, fe.startTime - $), Q = !1
                }
                return Q
            } finally {
                p = null, g = C, b = !1
            }
        }

        var ee = !1, oe = null, G = -1, J = 5, ce = -1;

        function re() {
            return !(t.unstable_now() - ce < J)
        }

        function M() {
            if (oe !== null) {
                var j = t.unstable_now();
                ce = j;
                var $ = !0;
                try {
                    $ = oe(!0, j)
                } finally {
                    $ ? D() : (ee = !1, oe = null)
                }
            } else ee = !1
        }

        var D;
        if (typeof P == "function") D = function () {
            P(M)
        }; else if (typeof MessageChannel < "u") {
            var x = new MessageChannel, A = x.port2;
            x.port1.onmessage = M, D = function () {
                A.postMessage(null)
            }
        } else D = function () {
            I(M, 0)
        };

        function B(j) {
            oe = j, ee || (ee = !0, D())
        }

        function z(j, $) {
            G = I(function () {
                j(t.unstable_now())
            }, $)
        }

        t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (j) {
            j.callback = null
        }, t.unstable_continueExecution = function () {
            S || b || (S = !0, B(Y))
        }, t.unstable_forceFrameRate = function (j) {
            0 > j || 125 < j ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < j ? Math.floor(1e3 / j) : 5
        }, t.unstable_getCurrentPriorityLevel = function () {
            return g
        }, t.unstable_getFirstCallbackNode = function () {
            return r(l)
        }, t.unstable_next = function (j) {
            switch (g) {
                case 1:
                case 2:
                case 3:
                    var $ = 3;
                    break;
                default:
                    $ = g
            }
            var C = g;
            g = $;
            try {
                return j()
            } finally {
                g = C
            }
        }, t.unstable_pauseExecution = function () {
        }, t.unstable_requestPaint = function () {
        }, t.unstable_runWithPriority = function (j, $) {
            switch (j) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    j = 3
            }
            var C = g;
            g = j;
            try {
                return $()
            } finally {
                g = C
            }
        }, t.unstable_scheduleCallback = function (j, $, C) {
            var R = t.unstable_now();
            switch (typeof C == "object" && C !== null ? (C = C.delay, C = typeof C == "number" && 0 < C ? R + C : R) : C = R, j) {
                case 1:
                    var k = -1;
                    break;
                case 2:
                    k = 250;
                    break;
                case 5:
                    k = 1073741823;
                    break;
                case 4:
                    k = 1e4;
                    break;
                default:
                    k = 5e3
            }
            return k = C + k, j = {
                id: d++,
                callback: $,
                priorityLevel: j,
                startTime: C,
                expirationTime: k,
                sortIndex: -1
            }, C > R ? (j.sortIndex = C, e(f, j), r(l) === null && j === r(f) && (T ? (N(G), G = -1) : T = !0, z(V, C - R))) : (j.sortIndex = k, e(l, j), S || b || (S = !0, B(Y))), j
        }, t.unstable_shouldYield = re, t.unstable_wrapCallback = function (j) {
            var $ = g;
            return function () {
                var C = g;
                g = $;
                try {
                    return j.apply(this, arguments)
                } finally {
                    g = C
                }
            }
        }
    }(mj)), mj
}

var vj = {}, Ooe;

function j$e() {
    return Ooe || (Ooe = 1, function (t) {
        Ve.env.NODE_ENV !== "production" && function () {
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
            var e = !1, r = 5;

            function n(X, H) {
                var U = X.length;
                X.push(H), o(X, H, U)
            }

            function i(X) {
                return X.length === 0 ? null : X[0]
            }

            function a(X) {
                if (X.length === 0) return null;
                var H = X[0], U = X.pop();
                return U !== H && (X[0] = U, s(X, U, 0)), H
            }

            function o(X, H, U) {
                for (var q = U; q > 0;) {
                    var le = q - 1 >>> 1, xe = X[le];
                    if (l(xe, H) > 0) X[le] = H, X[q] = xe, q = le; else return
                }
            }

            function s(X, H, U) {
                for (var q = U, le = X.length, xe = le >>> 1; q < xe;) {
                    var Ae = (q + 1) * 2 - 1, De = X[Ae], Ze = Ae + 1, ft = X[Ze];
                    if (l(De, H) < 0) Ze < le && l(ft, De) < 0 ? (X[q] = ft, X[Ze] = H, q = Ze) : (X[q] = De, X[Ae] = H, q = Ae); else if (Ze < le && l(ft, H) < 0) X[q] = ft, X[Ze] = H, q = Ze; else return
                }
            }

            function l(X, H) {
                var U = X.sortIndex - H.sortIndex;
                return U !== 0 ? U : X.id - H.id
            }

            var f = 1, d = 2, p = 3, g = 4, b = 5,
                S = typeof performance == "object" && typeof performance.now == "function";
            if (S) {
                var T = performance;
                t.unstable_now = function () {
                    return T.now()
                }
            } else {
                var I = Date, N = I.now();
                t.unstable_now = function () {
                    return I.now() - N
                }
            }
            var P = 1073741823, F = -1, V = 250, Y = 5e3, ee = 1e4, oe = P, G = [], J = [], ce = 1, re = null, M = p,
                D = !1, x = !1, A = !1, B = typeof setTimeout == "function" ? setTimeout : null,
                z = typeof clearTimeout == "function" ? clearTimeout : null,
                j = typeof setImmediate < "u" ? setImmediate : null;
            typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

            function $(X) {
                for (var H = i(J); H !== null;) {
                    if (H.callback === null) a(J); else if (H.startTime <= X) a(J), H.sortIndex = H.expirationTime, n(G, H); else return;
                    H = i(J)
                }
            }

            function C(X) {
                if (A = !1, $(X), !x) if (i(G) !== null) x = !0, _t(R); else {
                    var H = i(J);
                    H !== null && Dt(C, H.startTime - X)
                }
            }

            function R(X, H) {
                x = !1, A && (A = !1, rr()), D = !0;
                var U = M;
                try {
                    return k(X, H)
                } finally {
                    re = null, M = U, D = !1
                }
            }

            function k(X, H) {
                var U = H;
                for ($(U), re = i(G); re !== null && !e && !(re.expirationTime > U && (!X || Be()));) {
                    var q = re.callback;
                    if (typeof q == "function") {
                        re.callback = null, M = re.priorityLevel;
                        var le = re.expirationTime <= U, xe = q(le);
                        U = t.unstable_now(), typeof xe == "function" ? re.callback = xe : re === i(G) && a(G), $(U)
                    } else a(G);
                    re = i(G)
                }
                if (re !== null) return !0;
                var Ae = i(J);
                return Ae !== null && Dt(C, Ae.startTime - U), !1
            }

            function Q(X, H) {
                switch (X) {
                    case f:
                    case d:
                    case p:
                    case g:
                    case b:
                        break;
                    default:
                        X = p
                }
                var U = M;
                M = X;
                try {
                    return H()
                } finally {
                    M = U
                }
            }

            function fe(X) {
                var H;
                switch (M) {
                    case f:
                    case d:
                    case p:
                        H = p;
                        break;
                    default:
                        H = M;
                        break
                }
                var U = M;
                M = H;
                try {
                    return X()
                } finally {
                    M = U
                }
            }

            function ye(X) {
                var H = M;
                return function () {
                    var U = M;
                    M = H;
                    try {
                        return X.apply(this, arguments)
                    } finally {
                        M = U
                    }
                }
            }

            function ue(X, H, U) {
                var q = t.unstable_now(), le;
                if (typeof U == "object" && U !== null) {
                    var xe = U.delay;
                    typeof xe == "number" && xe > 0 ? le = q + xe : le = q
                } else le = q;
                var Ae;
                switch (X) {
                    case f:
                        Ae = F;
                        break;
                    case d:
                        Ae = V;
                        break;
                    case b:
                        Ae = oe;
                        break;
                    case g:
                        Ae = ee;
                        break;
                    case p:
                    default:
                        Ae = Y;
                        break
                }
                var De = le + Ae,
                    Ze = {id: ce++, callback: H, priorityLevel: X, startTime: le, expirationTime: De, sortIndex: -1};
                return le > q ? (Ze.sortIndex = le, n(J, Ze), i(G) === null && Ze === i(J) && (A ? rr() : A = !0, Dt(C, le - q))) : (Ze.sortIndex = De, n(G, Ze), !x && !D && (x = !0, _t(R))), Ze
            }

            function me() {
            }

            function Se() {
                !x && !D && (x = !0, _t(R))
            }

            function Ce() {
                return i(G)
            }

            function Me(X) {
                X.callback = null
            }

            function ve() {
                return M
            }

            var ne = !1, be = null, Ee = -1, Oe = r, ze = -1;

            function Be() {
                var X = t.unstable_now() - ze;
                return !(X < Oe)
            }

            function it() {
            }

            function Ue(X) {
                if (X < 0 || X > 125) {
                    console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                    return
                }
                X > 0 ? Oe = Math.floor(1e3 / X) : Oe = r
            }

            var bt = function () {
                if (be !== null) {
                    var X = t.unstable_now();
                    ze = X;
                    var H = !0, U = !0;
                    try {
                        U = be(H, X)
                    } finally {
                        U ? gt() : (ne = !1, be = null)
                    }
                } else ne = !1
            }, gt;
            if (typeof j == "function") gt = function () {
                j(bt)
            }; else if (typeof MessageChannel < "u") {
                var Ot = new MessageChannel, zt = Ot.port2;
                Ot.port1.onmessage = bt, gt = function () {
                    zt.postMessage(null)
                }
            } else gt = function () {
                B(bt, 0)
            };

            function _t(X) {
                be = X, ne || (ne = !0, gt())
            }

            function Dt(X, H) {
                Ee = B(function () {
                    X(t.unstable_now())
                }, H)
            }

            function rr() {
                z(Ee), Ee = -1
            }

            var pe = it, te = null;
            t.unstable_IdlePriority = b, t.unstable_ImmediatePriority = f, t.unstable_LowPriority = g, t.unstable_NormalPriority = p, t.unstable_Profiling = te, t.unstable_UserBlockingPriority = d, t.unstable_cancelCallback = Me, t.unstable_continueExecution = Se, t.unstable_forceFrameRate = Ue, t.unstable_getCurrentPriorityLevel = ve, t.unstable_getFirstCallbackNode = Ce, t.unstable_next = fe, t.unstable_pauseExecution = me, t.unstable_requestPaint = pe, t.unstable_runWithPriority = Q, t.unstable_scheduleCallback = ue, t.unstable_shouldYield = Be, t.unstable_wrapCallback = ye, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)
        }()
    }(vj)), vj
}

var Poe;

function mge() {
    return Poe || (Poe = 1, Ve.env.NODE_ENV === "production" ? H9.exports = U$e() : H9.exports = j$e()), H9.exports
}

var Noe;

function z$e() {
    if (Noe) return Uu;
    Noe = 1;
    var t = Kv(), e = mge();

    function r(h) {
        for (var m = "https://reactjs.org/docs/error-decoder.html?invariant=" + h, w = 1; w < arguments.length; w++) m += "&args[]=" + encodeURIComponent(arguments[w]);
        return "Minified React error #" + h + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }

    var n = new Set, i = {};

    function a(h, m) {
        o(h, m), o(h + "Capture", m)
    }

    function o(h, m) {
        for (i[h] = m, h = 0; h < m.length; h++) n.add(m[h])
    }

    var s = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
        l = Object.prototype.hasOwnProperty,
        f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
        d = {}, p = {};

    function g(h) {
        return l.call(p, h) ? !0 : l.call(d, h) ? !1 : f.test(h) ? p[h] = !0 : (d[h] = !0, !1)
    }

    function b(h, m, w, O) {
        if (w !== null && w.type === 0) return !1;
        switch (typeof m) {
            case"function":
            case"symbol":
                return !0;
            case"boolean":
                return O ? !1 : w !== null ? !w.acceptsBooleans : (h = h.toLowerCase().slice(0, 5), h !== "data-" && h !== "aria-");
            default:
                return !1
        }
    }

    function S(h, m, w, O) {
        if (m === null || typeof m > "u" || b(h, m, w, O)) return !0;
        if (O) return !1;
        if (w !== null) switch (w.type) {
            case 3:
                return !m;
            case 4:
                return m === !1;
            case 5:
                return isNaN(m);
            case 6:
                return isNaN(m) || 1 > m
        }
        return !1
    }

    function T(h, m, w, O, K, ae, ge) {
        this.acceptsBooleans = m === 2 || m === 3 || m === 4, this.attributeName = O, this.attributeNamespace = K, this.mustUseProperty = w, this.propertyName = h, this.type = m, this.sanitizeURL = ae, this.removeEmptyString = ge
    }

    var I = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (h) {
        I[h] = new T(h, 0, !1, h, null, !1, !1)
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (h) {
        var m = h[0];
        I[m] = new T(m, 1, !1, h[1], null, !1, !1)
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (h) {
        I[h] = new T(h, 2, !1, h.toLowerCase(), null, !1, !1)
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (h) {
        I[h] = new T(h, 2, !1, h, null, !1, !1)
    }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (h) {
        I[h] = new T(h, 3, !1, h.toLowerCase(), null, !1, !1)
    }), ["checked", "multiple", "muted", "selected"].forEach(function (h) {
        I[h] = new T(h, 3, !0, h, null, !1, !1)
    }), ["capture", "download"].forEach(function (h) {
        I[h] = new T(h, 4, !1, h, null, !1, !1)
    }), ["cols", "rows", "size", "span"].forEach(function (h) {
        I[h] = new T(h, 6, !1, h, null, !1, !1)
    }), ["rowSpan", "start"].forEach(function (h) {
        I[h] = new T(h, 5, !1, h.toLowerCase(), null, !1, !1)
    });
    var N = /[\-:]([a-z])/g;

    function P(h) {
        return h[1].toUpperCase()
    }

    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (h) {
        var m = h.replace(N, P);
        I[m] = new T(m, 1, !1, h, null, !1, !1)
    }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (h) {
        var m = h.replace(N, P);
        I[m] = new T(m, 1, !1, h, "http://www.w3.org/1999/xlink", !1, !1)
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function (h) {
        var m = h.replace(N, P);
        I[m] = new T(m, 1, !1, h, "http://www.w3.org/XML/1998/namespace", !1, !1)
    }), ["tabIndex", "crossOrigin"].forEach(function (h) {
        I[h] = new T(h, 1, !1, h.toLowerCase(), null, !1, !1)
    }), I.xlinkHref = new T("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (h) {
        I[h] = new T(h, 1, !1, h.toLowerCase(), null, !0, !0)
    });

    function F(h, m, w, O) {
        var K = I.hasOwnProperty(m) ? I[m] : null;
        (K !== null ? K.type !== 0 : O || !(2 < m.length) || m[0] !== "o" && m[0] !== "O" || m[1] !== "n" && m[1] !== "N") && (S(m, w, K, O) && (w = null), O || K === null ? g(m) && (w === null ? h.removeAttribute(m) : h.setAttribute(m, "" + w)) : K.mustUseProperty ? h[K.propertyName] = w === null ? K.type === 3 ? !1 : "" : w : (m = K.attributeName, O = K.attributeNamespace, w === null ? h.removeAttribute(m) : (K = K.type, w = K === 3 || K === 4 && w === !0 ? "" : "" + w, O ? h.setAttributeNS(O, m, w) : h.setAttribute(m, w))))
    }

    var V = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Y = Symbol.for("react.element"),
        ee = Symbol.for("react.portal"), oe = Symbol.for("react.fragment"), G = Symbol.for("react.strict_mode"),
        J = Symbol.for("react.profiler"), ce = Symbol.for("react.provider"), re = Symbol.for("react.context"),
        M = Symbol.for("react.forward_ref"), D = Symbol.for("react.suspense"), x = Symbol.for("react.suspense_list"),
        A = Symbol.for("react.memo"), B = Symbol.for("react.lazy"), z = Symbol.for("react.offscreen"),
        j = Symbol.iterator;

    function $(h) {
        return h === null || typeof h != "object" ? null : (h = j && h[j] || h["@@iterator"], typeof h == "function" ? h : null)
    }

    var C = Object.assign, R;

    function k(h) {
        if (R === void 0) try {
            throw Error()
        } catch (w) {
            var m = w.stack.trim().match(/\n( *(at )?)/);
            R = m && m[1] || ""
        }
        return `
` + R + h
    }

    var Q = !1;

    function fe(h, m) {
        if (!h || Q) return "";
        Q = !0;
        var w = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (m) if (m = function () {
                throw Error()
            }, Object.defineProperty(m.prototype, "props", {
                set: function () {
                    throw Error()
                }
            }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(m, [])
                } catch (et) {
                    var O = et
                }
                Reflect.construct(h, [], m)
            } else {
                try {
                    m.call()
                } catch (et) {
                    O = et
                }
                h.call(m.prototype)
            } else {
                try {
                    throw Error()
                } catch (et) {
                    O = et
                }
                h()
            }
        } catch (et) {
            if (et && O && typeof et.stack == "string") {
                for (var K = et.stack.split(`
`), ae = O.stack.split(`
`), ge = K.length - 1, Re = ae.length - 1; 1 <= ge && 0 <= Re && K[ge] !== ae[Re];) Re--;
                for (; 1 <= ge && 0 <= Re; ge--, Re--) if (K[ge] !== ae[Re]) {
                    if (ge !== 1 || Re !== 1) do if (ge--, Re--, 0 > Re || K[ge] !== ae[Re]) {
                        var Pe = `
` + K[ge].replace(" at new ", " at ");
                        return h.displayName && Pe.includes("<anonymous>") && (Pe = Pe.replace("<anonymous>", h.displayName)), Pe
                    } while (1 <= ge && 0 <= Re);
                    break
                }
            }
        } finally {
            Q = !1, Error.prepareStackTrace = w
        }
        return (h = h ? h.displayName || h.name : "") ? k(h) : ""
    }

    function ye(h) {
        switch (h.tag) {
            case 5:
                return k(h.type);
            case 16:
                return k("Lazy");
            case 13:
                return k("Suspense");
            case 19:
                return k("SuspenseList");
            case 0:
            case 2:
            case 15:
                return h = fe(h.type, !1), h;
            case 11:
                return h = fe(h.type.render, !1), h;
            case 1:
                return h = fe(h.type, !0), h;
            default:
                return ""
        }
    }

    function ue(h) {
        if (h == null) return null;
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
        switch (h) {
            case oe:
                return "Fragment";
            case ee:
                return "Portal";
            case J:
                return "Profiler";
            case G:
                return "StrictMode";
            case D:
                return "Suspense";
            case x:
                return "SuspenseList"
        }
        if (typeof h == "object") switch (h.$$typeof) {
            case re:
                return (h.displayName || "Context") + ".Consumer";
            case ce:
                return (h._context.displayName || "Context") + ".Provider";
            case M:
                var m = h.render;
                return h = h.displayName, h || (h = m.displayName || m.name || "", h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"), h;
            case A:
                return m = h.displayName || null, m !== null ? m : ue(h.type) || "Memo";
            case B:
                m = h._payload, h = h._init;
                try {
                    return ue(h(m))
                } catch {
                }
        }
        return null
    }

    function me(h) {
        var m = h.type;
        switch (h.tag) {
            case 24:
                return "Cache";
            case 9:
                return (m.displayName || "Context") + ".Consumer";
            case 10:
                return (m._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return h = m.render, h = h.displayName || h.name || "", m.displayName || (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return m;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return ue(m);
            case 8:
                return m === G ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof m == "function") return m.displayName || m.name || null;
                if (typeof m == "string") return m
        }
        return null
    }

    function Se(h) {
        switch (typeof h) {
            case"boolean":
            case"number":
            case"string":
            case"undefined":
                return h;
            case"object":
                return h;
            default:
                return ""
        }
    }

    function Ce(h) {
        var m = h.type;
        return (h = h.nodeName) && h.toLowerCase() === "input" && (m === "checkbox" || m === "radio")
    }

    function Me(h) {
        var m = Ce(h) ? "checked" : "value", w = Object.getOwnPropertyDescriptor(h.constructor.prototype, m),
            O = "" + h[m];
        if (!h.hasOwnProperty(m) && typeof w < "u" && typeof w.get == "function" && typeof w.set == "function") {
            var K = w.get, ae = w.set;
            return Object.defineProperty(h, m, {
                configurable: !0, get: function () {
                    return K.call(this)
                }, set: function (ge) {
                    O = "" + ge, ae.call(this, ge)
                }
            }), Object.defineProperty(h, m, {enumerable: w.enumerable}), {
                getValue: function () {
                    return O
                }, setValue: function (ge) {
                    O = "" + ge
                }, stopTracking: function () {
                    h._valueTracker = null, delete h[m]
                }
            }
        }
    }

    function ve(h) {
        h._valueTracker || (h._valueTracker = Me(h))
    }

    function ne(h) {
        if (!h) return !1;
        var m = h._valueTracker;
        if (!m) return !0;
        var w = m.getValue(), O = "";
        return h && (O = Ce(h) ? h.checked ? "true" : "false" : h.value), h = O, h !== w ? (m.setValue(h), !0) : !1
    }

    function be(h) {
        if (h = h || (typeof document < "u" ? document : void 0), typeof h > "u") return null;
        try {
            return h.activeElement || h.body
        } catch {
            return h.body
        }
    }

    function Ee(h, m) {
        var w = m.checked;
        return C({}, m, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: w ?? h._wrapperState.initialChecked
        })
    }

    function Oe(h, m) {
        var w = m.defaultValue == null ? "" : m.defaultValue, O = m.checked != null ? m.checked : m.defaultChecked;
        w = Se(m.value != null ? m.value : w), h._wrapperState = {
            initialChecked: O,
            initialValue: w,
            controlled: m.type === "checkbox" || m.type === "radio" ? m.checked != null : m.value != null
        }
    }

    function ze(h, m) {
        m = m.checked, m != null && F(h, "checked", m, !1)
    }

    function Be(h, m) {
        ze(h, m);
        var w = Se(m.value), O = m.type;
        if (w != null) O === "number" ? (w === 0 && h.value === "" || h.value != w) && (h.value = "" + w) : h.value !== "" + w && (h.value = "" + w); else if (O === "submit" || O === "reset") {
            h.removeAttribute("value");
            return
        }
        m.hasOwnProperty("value") ? Ue(h, m.type, w) : m.hasOwnProperty("defaultValue") && Ue(h, m.type, Se(m.defaultValue)), m.checked == null && m.defaultChecked != null && (h.defaultChecked = !!m.defaultChecked)
    }

    function it(h, m, w) {
        if (m.hasOwnProperty("value") || m.hasOwnProperty("defaultValue")) {
            var O = m.type;
            if (!(O !== "submit" && O !== "reset" || m.value !== void 0 && m.value !== null)) return;
            m = "" + h._wrapperState.initialValue, w || m === h.value || (h.value = m), h.defaultValue = m
        }
        w = h.name, w !== "" && (h.name = ""), h.defaultChecked = !!h._wrapperState.initialChecked, w !== "" && (h.name = w)
    }

    function Ue(h, m, w) {
        (m !== "number" || be(h.ownerDocument) !== h) && (w == null ? h.defaultValue = "" + h._wrapperState.initialValue : h.defaultValue !== "" + w && (h.defaultValue = "" + w))
    }

    var bt = Array.isArray;

    function gt(h, m, w, O) {
        if (h = h.options, m) {
            m = {};
            for (var K = 0; K < w.length; K++) m["$" + w[K]] = !0;
            for (w = 0; w < h.length; w++) K = m.hasOwnProperty("$" + h[w].value), h[w].selected !== K && (h[w].selected = K), K && O && (h[w].defaultSelected = !0)
        } else {
            for (w = "" + Se(w), m = null, K = 0; K < h.length; K++) {
                if (h[K].value === w) {
                    h[K].selected = !0, O && (h[K].defaultSelected = !0);
                    return
                }
                m !== null || h[K].disabled || (m = h[K])
            }
            m !== null && (m.selected = !0)
        }
    }

    function Ot(h, m) {
        if (m.dangerouslySetInnerHTML != null) throw Error(r(91));
        return C({}, m, {value: void 0, defaultValue: void 0, children: "" + h._wrapperState.initialValue})
    }

    function zt(h, m) {
        var w = m.value;
        if (w == null) {
            if (w = m.children, m = m.defaultValue, w != null) {
                if (m != null) throw Error(r(92));
                if (bt(w)) {
                    if (1 < w.length) throw Error(r(93));
                    w = w[0]
                }
                m = w
            }
            m == null && (m = ""), w = m
        }
        h._wrapperState = {initialValue: Se(w)}
    }

    function _t(h, m) {
        var w = Se(m.value), O = Se(m.defaultValue);
        w != null && (w = "" + w, w !== h.value && (h.value = w), m.defaultValue == null && h.defaultValue !== w && (h.defaultValue = w)), O != null && (h.defaultValue = "" + O)
    }

    function Dt(h) {
        var m = h.textContent;
        m === h._wrapperState.initialValue && m !== "" && m !== null && (h.value = m)
    }

    function rr(h) {
        switch (h) {
            case"svg":
                return "http://www.w3.org/2000/svg";
            case"math":
                return "http://www.w3.org/1998/Math/MathML";
            default:
                return "http://www.w3.org/1999/xhtml"
        }
    }

    function pe(h, m) {
        return h == null || h === "http://www.w3.org/1999/xhtml" ? rr(m) : h === "http://www.w3.org/2000/svg" && m === "foreignObject" ? "http://www.w3.org/1999/xhtml" : h
    }

    var te, X = function (h) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (m, w, O, K) {
            MSApp.execUnsafeLocalFunction(function () {
                return h(m, w, O, K)
            })
        } : h
    }(function (h, m) {
        if (h.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in h) h.innerHTML = m; else {
            for (te = te || document.createElement("div"), te.innerHTML = "<svg>" + m.valueOf().toString() + "</svg>", m = te.firstChild; h.firstChild;) h.removeChild(h.firstChild);
            for (; m.firstChild;) h.appendChild(m.firstChild)
        }
    });

    function H(h, m) {
        if (m) {
            var w = h.firstChild;
            if (w && w === h.lastChild && w.nodeType === 3) {
                w.nodeValue = m;
                return
            }
        }
        h.textContent = m
    }

    var U = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }, q = ["Webkit", "ms", "Moz", "O"];
    Object.keys(U).forEach(function (h) {
        q.forEach(function (m) {
            m = m + h.charAt(0).toUpperCase() + h.substring(1), U[m] = U[h]
        })
    });

    function le(h, m, w) {
        return m == null || typeof m == "boolean" || m === "" ? "" : w || typeof m != "number" || m === 0 || U.hasOwnProperty(h) && U[h] ? ("" + m).trim() : m + "px"
    }

    function xe(h, m) {
        h = h.style;
        for (var w in m) if (m.hasOwnProperty(w)) {
            var O = w.indexOf("--") === 0, K = le(w, m[w], O);
            w === "float" && (w = "cssFloat"), O ? h.setProperty(w, K) : h[w] = K
        }
    }

    var Ae = C({menuitem: !0}, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });

    function De(h, m) {
        if (m) {
            if (Ae[h] && (m.children != null || m.dangerouslySetInnerHTML != null)) throw Error(r(137, h));
            if (m.dangerouslySetInnerHTML != null) {
                if (m.children != null) throw Error(r(60));
                if (typeof m.dangerouslySetInnerHTML != "object" || !("__html" in m.dangerouslySetInnerHTML)) throw Error(r(61))
            }
            if (m.style != null && typeof m.style != "object") throw Error(r(62))
        }
    }

    function Ze(h, m) {
        if (h.indexOf("-") === -1) return typeof m.is == "string";
        switch (h) {
            case"annotation-xml":
            case"color-profile":
            case"font-face":
            case"font-face-src":
            case"font-face-uri":
            case"font-face-format":
            case"font-face-name":
            case"missing-glyph":
                return !1;
            default:
                return !0
        }
    }

    var ft = null;

    function ht(h) {
        return h = h.target || h.srcElement || window, h.correspondingUseElement && (h = h.correspondingUseElement), h.nodeType === 3 ? h.parentNode : h
    }

    var cr = null, Rt = null, Gt = null;

    function sn(h) {
        if (h = ld(h)) {
            if (typeof cr != "function") throw Error(r(280));
            var m = h.stateNode;
            m && (m = Dn(m), cr(h.stateNode, h.type, m))
        }
    }

    function Yr(h) {
        Rt ? Gt ? Gt.push(h) : Gt = [h] : Rt = h
    }

    function br() {
        if (Rt) {
            var h = Rt, m = Gt;
            if (Gt = Rt = null, sn(h), m) for (h = 0; h < m.length; h++) sn(m[h])
        }
    }

    function hn(h, m) {
        return h(m)
    }

    function En() {
    }

    var _r = !1;

    function _n(h, m, w) {
        if (_r) return h(m, w);
        _r = !0;
        try {
            return hn(h, m, w)
        } finally {
            _r = !1, (Rt !== null || Gt !== null) && (En(), br())
        }
    }

    function Nr(h, m) {
        var w = h.stateNode;
        if (w === null) return null;
        var O = Dn(w);
        if (O === null) return null;
        w = O[m];
        e:switch (m) {
            case"onClick":
            case"onClickCapture":
            case"onDoubleClick":
            case"onDoubleClickCapture":
            case"onMouseDown":
            case"onMouseDownCapture":
            case"onMouseMove":
            case"onMouseMoveCapture":
            case"onMouseUp":
            case"onMouseUpCapture":
            case"onMouseEnter":
                (O = !O.disabled) || (h = h.type, O = !(h === "button" || h === "input" || h === "select" || h === "textarea")), h = !O;
                break e;
            default:
                h = !1
        }
        if (h) return null;
        if (w && typeof w != "function") throw Error(r(231, m, typeof w));
        return w
    }

    var mr = !1;
    if (s) try {
        var fn = {};
        Object.defineProperty(fn, "passive", {
            get: function () {
                mr = !0
            }
        }), window.addEventListener("test", fn, fn), window.removeEventListener("test", fn, fn)
    } catch {
        mr = !1
    }

    function Hn(h, m, w, O, K, ae, ge, Re, Pe) {
        var et = Array.prototype.slice.call(arguments, 3);
        try {
            m.apply(w, et)
        } catch (wt) {
            this.onError(wt)
        }
    }

    var Cr = !1, An = null, pn = !1, wr = null, ke = {
        onError: function (h) {
            Cr = !0, An = h
        }
    };

    function st(h, m, w, O, K, ae, ge, Re, Pe) {
        Cr = !1, An = null, Hn.apply(ke, arguments)
    }

    function ot(h, m, w, O, K, ae, ge, Re, Pe) {
        if (st.apply(this, arguments), Cr) {
            if (Cr) {
                var et = An;
                Cr = !1, An = null
            } else throw Error(r(198));
            pn || (pn = !0, wr = et)
        }
    }

    function xt(h) {
        var m = h, w = h;
        if (h.alternate) for (; m.return;) m = m.return; else {
            h = m;
            do m = h, m.flags & 4098 && (w = m.return), h = m.return; while (h)
        }
        return m.tag === 3 ? w : null
    }

    function Yt(h) {
        if (h.tag === 13) {
            var m = h.memoizedState;
            if (m === null && (h = h.alternate, h !== null && (m = h.memoizedState)), m !== null) return m.dehydrated
        }
        return null
    }

    function vr(h) {
        if (xt(h) !== h) throw Error(r(188))
    }

    function Vr(h) {
        var m = h.alternate;
        if (!m) {
            if (m = xt(h), m === null) throw Error(r(188));
            return m !== h ? null : h
        }
        for (var w = h, O = m; ;) {
            var K = w.return;
            if (K === null) break;
            var ae = K.alternate;
            if (ae === null) {
                if (O = K.return, O !== null) {
                    w = O;
                    continue
                }
                break
            }
            if (K.child === ae.child) {
                for (ae = K.child; ae;) {
                    if (ae === w) return vr(K), h;
                    if (ae === O) return vr(K), m;
                    ae = ae.sibling
                }
                throw Error(r(188))
            }
            if (w.return !== O.return) w = K, O = ae; else {
                for (var ge = !1, Re = K.child; Re;) {
                    if (Re === w) {
                        ge = !0, w = K, O = ae;
                        break
                    }
                    if (Re === O) {
                        ge = !0, O = K, w = ae;
                        break
                    }
                    Re = Re.sibling
                }
                if (!ge) {
                    for (Re = ae.child; Re;) {
                        if (Re === w) {
                            ge = !0, w = ae, O = K;
                            break
                        }
                        if (Re === O) {
                            ge = !0, O = ae, w = K;
                            break
                        }
                        Re = Re.sibling
                    }
                    if (!ge) throw Error(r(189))
                }
            }
            if (w.alternate !== O) throw Error(r(190))
        }
        if (w.tag !== 3) throw Error(r(188));
        return w.stateNode.current === w ? h : m
    }

    function Ur(h) {
        return h = Vr(h), h !== null ? fi(h) : null
    }

    function fi(h) {
        if (h.tag === 5 || h.tag === 6) return h;
        for (h = h.child; h !== null;) {
            var m = fi(h);
            if (m !== null) return m;
            h = h.sibling
        }
        return null
    }

    var In = e.unstable_scheduleCallback, kn = e.unstable_cancelCallback, Ai = e.unstable_shouldYield,
        Fi = e.unstable_requestPaint, Pt = e.unstable_now, Wn = e.unstable_getCurrentPriorityLevel,
        Da = e.unstable_ImmediatePriority, Ma = e.unstable_UserBlockingPriority, Oa = e.unstable_NormalPriority,
        Za = e.unstable_LowPriority, Po = e.unstable_IdlePriority, Ja = null, qi = null;

    function Ko(h) {
        if (qi && typeof qi.onCommitFiberRoot == "function") try {
            qi.onCommitFiberRoot(Ja, h, void 0, (h.current.flags & 128) === 128)
        } catch {
        }
    }

    var Pa = Math.clz32 ? Math.clz32 : hf, Dl = Math.log, df = Math.LN2;

    function hf(h) {
        return h >>>= 0, h === 0 ? 32 : 31 - (Dl(h) / df | 0) | 0
    }

    var Yo = 64, Ml = 4194304;

    function us(h) {
        switch (h & -h) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return h & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return h & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return h
        }
    }

    function Ol(h, m) {
        var w = h.pendingLanes;
        if (w === 0) return 0;
        var O = 0, K = h.suspendedLanes, ae = h.pingedLanes, ge = w & 268435455;
        if (ge !== 0) {
            var Re = ge & ~K;
            Re !== 0 ? O = us(Re) : (ae &= ge, ae !== 0 && (O = us(ae)))
        } else ge = w & ~K, ge !== 0 ? O = us(ge) : ae !== 0 && (O = us(ae));
        if (O === 0) return 0;
        if (m !== 0 && m !== O && !(m & K) && (K = O & -O, ae = m & -m, K >= ae || K === 16 && (ae & 4194240) !== 0)) return m;
        if (O & 4 && (O |= w & 16), m = h.entangledLanes, m !== 0) for (h = h.entanglements, m &= O; 0 < m;) w = 31 - Pa(m), K = 1 << w, O |= h[w], m &= ~K;
        return O
    }

    function Pl(h, m) {
        switch (h) {
            case 1:
            case 2:
            case 4:
                return m + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return m + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }

    function Nl(h, m) {
        for (var w = h.suspendedLanes, O = h.pingedLanes, K = h.expirationTimes, ae = h.pendingLanes; 0 < ae;) {
            var ge = 31 - Pa(ae), Re = 1 << ge, Pe = K[ge];
            Pe === -1 ? (!(Re & w) || Re & O) && (K[ge] = Pl(Re, m)) : Pe <= m && (h.expiredLanes |= Re), ae &= ~Re
        }
    }

    function fs(h) {
        return h = h.pendingLanes & -1073741825, h !== 0 ? h : h & 1073741824 ? 1073741824 : 0
    }

    function lh() {
        var h = Yo;
        return Yo <<= 1, !(Yo & 4194240) && (Yo = 64), h
    }

    function Ll(h) {
        for (var m = [], w = 0; 31 > w; w++) m.push(h);
        return m
    }

    function Bl(h, m, w) {
        h.pendingLanes |= m, m !== 536870912 && (h.suspendedLanes = 0, h.pingedLanes = 0), h = h.eventTimes, m = 31 - Pa(m), h[m] = w
    }

    function uh(h, m) {
        var w = h.pendingLanes & ~m;
        h.pendingLanes = m, h.suspendedLanes = 0, h.pingedLanes = 0, h.expiredLanes &= m, h.mutableReadLanes &= m, h.entangledLanes &= m, m = h.entanglements;
        var O = h.eventTimes;
        for (h = h.expirationTimes; 0 < w;) {
            var K = 31 - Pa(w), ae = 1 << K;
            m[K] = 0, O[K] = -1, h[K] = -1, w &= ~ae
        }
    }

    function $l(h, m) {
        var w = h.entangledLanes |= m;
        for (h = h.entanglements; w;) {
            var O = 31 - Pa(w), K = 1 << O;
            K & m | h[O] & m && (h[O] |= m), w &= ~K
        }
    }

    var Bn = 0;

    function $n(h) {
        return h &= -h, 1 < h ? 4 < h ? h & 268435455 ? 16 : 536870912 : 4 : 1
    }

    var Eu, pf, Lr, Yc, Va, Xc = !1, fc = [], No = null, Ii = null, Fn = null, Tu = new Map, Lo = new Map, ba = [],
        dc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

    function kp(h, m) {
        switch (h) {
            case"focusin":
            case"focusout":
                No = null;
                break;
            case"dragenter":
            case"dragleave":
                Ii = null;
                break;
            case"mouseover":
            case"mouseout":
                Fn = null;
                break;
            case"pointerover":
            case"pointerout":
                Tu.delete(m.pointerId);
                break;
            case"gotpointercapture":
            case"lostpointercapture":
                Lo.delete(m.pointerId)
        }
    }

    function ds(h, m, w, O, K, ae) {
        return h === null || h.nativeEvent !== ae ? (h = {
            blockedOn: m,
            domEventName: w,
            eventSystemFlags: O,
            nativeEvent: ae,
            targetContainers: [K]
        }, m !== null && (m = ld(m), m !== null && pf(m)), h) : (h.eventSystemFlags |= O, m = h.targetContainers, K !== null && m.indexOf(K) === -1 && m.push(K), h)
    }

    function ad(h, m, w, O, K) {
        switch (m) {
            case"focusin":
                return No = ds(No, h, m, w, O, K), !0;
            case"dragenter":
                return Ii = ds(Ii, h, m, w, O, K), !0;
            case"mouseover":
                return Fn = ds(Fn, h, m, w, O, K), !0;
            case"pointerover":
                var ae = K.pointerId;
                return Tu.set(ae, ds(Tu.get(ae) || null, h, m, w, O, K)), !0;
            case"gotpointercapture":
                return ae = K.pointerId, Lo.set(ae, ds(Lo.get(ae) || null, h, m, w, O, K)), !0
        }
        return !1
    }

    function cm(h) {
        var m = Ar(h.target);
        if (m !== null) {
            var w = xt(m);
            if (w !== null) {
                if (m = w.tag, m === 13) {
                    if (m = Yt(w), m !== null) {
                        h.blockedOn = m, Va(h.priority, function () {
                            Lr(w)
                        });
                        return
                    }
                } else if (m === 3 && w.stateNode.current.memoizedState.isDehydrated) {
                    h.blockedOn = w.tag === 3 ? w.stateNode.containerInfo : null;
                    return
                }
            }
        }
        h.blockedOn = null
    }

    function od(h) {
        if (h.blockedOn !== null) return !1;
        for (var m = h.targetContainers; 0 < m.length;) {
            var w = bn(h.domEventName, h.eventSystemFlags, m[0], h.nativeEvent);
            if (w === null) {
                w = h.nativeEvent;
                var O = new w.constructor(w.type, w);
                ft = O, w.target.dispatchEvent(O), ft = null
            } else return m = ld(w), m !== null && pf(m), h.blockedOn = w, !1;
            m.shift()
        }
        return !0
    }

    function fh(h, m, w) {
        od(h) && w.delete(m)
    }

    function ug() {
        Xc = !1, No !== null && od(No) && (No = null), Ii !== null && od(Ii) && (Ii = null), Fn !== null && od(Fn) && (Fn = null), Tu.forEach(fh), Lo.forEach(fh)
    }

    function hs(h, m) {
        h.blockedOn === m && (h.blockedOn = null, Xc || (Xc = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, ug)))
    }

    function mf(h) {
        function m(K) {
            return hs(K, h)
        }

        if (0 < fc.length) {
            hs(fc[0], h);
            for (var w = 1; w < fc.length; w++) {
                var O = fc[w];
                O.blockedOn === h && (O.blockedOn = null)
            }
        }
        for (No !== null && hs(No, h), Ii !== null && hs(Ii, h), Fn !== null && hs(Fn, h), Tu.forEach(m), Lo.forEach(m), w = 0; w < ba.length; w++) O = ba[w], O.blockedOn === h && (O.blockedOn = null);
        for (; 0 < ba.length && (w = ba[0], w.blockedOn === null);) cm(w), w.blockedOn === null && ba.shift()
    }

    var hc = V.ReactCurrentBatchConfig, Cu = !0;

    function Te(h, m, w, O) {
        var K = Bn, ae = hc.transition;
        hc.transition = null;
        try {
            Bn = 1, Xe(h, m, w, O)
        } finally {
            Bn = K, hc.transition = ae
        }
    }

    function Ne(h, m, w, O) {
        var K = Bn, ae = hc.transition;
        hc.transition = null;
        try {
            Bn = 4, Xe(h, m, w, O)
        } finally {
            Bn = K, hc.transition = ae
        }
    }

    function Xe(h, m, w, O) {
        if (Cu) {
            var K = bn(h, m, w, O);
            if (K === null) m2(h, m, O, Vt, w), kp(h, O); else if (ad(K, h, m, w, O)) O.stopPropagation(); else if (kp(h, O), m & 4 && -1 < dc.indexOf(h)) {
                for (; K !== null;) {
                    var ae = ld(K);
                    if (ae !== null && Eu(ae), ae = bn(h, m, w, O), ae === null && m2(h, m, O, Vt, w), ae === K) break;
                    K = ae
                }
                K !== null && O.stopPropagation()
            } else m2(h, m, O, null, w)
        }
    }

    var Vt = null;

    function bn(h, m, w, O) {
        if (Vt = null, h = ht(O), h = Ar(h), h !== null) if (m = xt(h), m === null) h = null; else if (w = m.tag, w === 13) {
            if (h = Yt(m), h !== null) return h;
            h = null
        } else if (w === 3) {
            if (m.stateNode.current.memoizedState.isDehydrated) return m.tag === 3 ? m.stateNode.containerInfo : null;
            h = null
        } else m !== h && (h = null);
        return Vt = h, null
    }

    function di(h) {
        switch (h) {
            case"cancel":
            case"click":
            case"close":
            case"contextmenu":
            case"copy":
            case"cut":
            case"auxclick":
            case"dblclick":
            case"dragend":
            case"dragstart":
            case"drop":
            case"focusin":
            case"focusout":
            case"input":
            case"invalid":
            case"keydown":
            case"keypress":
            case"keyup":
            case"mousedown":
            case"mouseup":
            case"paste":
            case"pause":
            case"play":
            case"pointercancel":
            case"pointerdown":
            case"pointerup":
            case"ratechange":
            case"reset":
            case"resize":
            case"seeked":
            case"submit":
            case"touchcancel":
            case"touchend":
            case"touchstart":
            case"volumechange":
            case"change":
            case"selectionchange":
            case"textInput":
            case"compositionstart":
            case"compositionend":
            case"compositionupdate":
            case"beforeblur":
            case"afterblur":
            case"beforeinput":
            case"blur":
            case"fullscreenchange":
            case"focus":
            case"hashchange":
            case"popstate":
            case"select":
            case"selectstart":
                return 1;
            case"drag":
            case"dragenter":
            case"dragexit":
            case"dragleave":
            case"dragover":
            case"mousemove":
            case"mouseout":
            case"mouseover":
            case"pointermove":
            case"pointerout":
            case"pointerover":
            case"scroll":
            case"toggle":
            case"touchmove":
            case"wheel":
            case"mouseenter":
            case"mouseleave":
            case"pointerenter":
            case"pointerleave":
                return 4;
            case"message":
                switch (Wn()) {
                    case Da:
                        return 1;
                    case Ma:
                        return 4;
                    case Oa:
                    case Za:
                        return 16;
                    case Po:
                        return 536870912;
                    default:
                        return 16
                }
            default:
                return 16
        }
    }

    var Qn = null, de = null, Ie = null;

    function Ye() {
        if (Ie) return Ie;
        var h, m = de, w = m.length, O, K = "value" in Qn ? Qn.value : Qn.textContent, ae = K.length;
        for (h = 0; h < w && m[h] === K[h]; h++) ;
        var ge = w - h;
        for (O = 1; O <= ge && m[w - O] === K[ae - O]; O++) ;
        return Ie = K.slice(h, 1 < O ? 1 - O : void 0)
    }

    function rt(h) {
        var m = h.keyCode;
        return "charCode" in h ? (h = h.charCode, h === 0 && m === 13 && (h = 13)) : h = m, h === 10 && (h = 13), 32 <= h || h === 13 ? h : 0
    }

    function Et() {
        return !0
    }

    function Dr() {
        return !1
    }

    function Nt(h) {
        function m(w, O, K, ae, ge) {
            this._reactName = w, this._targetInst = K, this.type = O, this.nativeEvent = ae, this.target = ge, this.currentTarget = null;
            for (var Re in h) h.hasOwnProperty(Re) && (w = h[Re], this[Re] = w ? w(ae) : ae[Re]);
            return this.isDefaultPrevented = (ae.defaultPrevented != null ? ae.defaultPrevented : ae.returnValue === !1) ? Et : Dr, this.isPropagationStopped = Dr, this
        }

        return C(m.prototype, {
            preventDefault: function () {
                this.defaultPrevented = !0;
                var w = this.nativeEvent;
                w && (w.preventDefault ? w.preventDefault() : typeof w.returnValue != "unknown" && (w.returnValue = !1), this.isDefaultPrevented = Et)
            }, stopPropagation: function () {
                var w = this.nativeEvent;
                w && (w.stopPropagation ? w.stopPropagation() : typeof w.cancelBubble != "unknown" && (w.cancelBubble = !0), this.isPropagationStopped = Et)
            }, persist: function () {
            }, isPersistent: Et
        }), m
    }

    var Br = {
            eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (h) {
                return h.timeStamp || Date.now()
            }, defaultPrevented: 0, isTrusted: 0
        }, Rn = Nt(Br), hi = C({}, Br, {view: 0, detail: 0}), sa = Nt(hi), wn, Ui, Ji, Na = C({}, hi, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: $1,
            button: 0,
            buttons: 0,
            relatedTarget: function (h) {
                return h.relatedTarget === void 0 ? h.fromElement === h.srcElement ? h.toElement : h.fromElement : h.relatedTarget
            },
            movementX: function (h) {
                return "movementX" in h ? h.movementX : (h !== Ji && (Ji && h.type === "mousemove" ? (wn = h.screenX - Ji.screenX, Ui = h.screenY - Ji.screenY) : Ui = wn = 0, Ji = h), wn)
            },
            movementY: function (h) {
                return "movementY" in h ? h.movementY : Ui
            }
        }), lm = Nt(Na), sd = C({}, Na, {dataTransfer: 0}), fg = Nt(sd), i2 = C({}, hi, {relatedTarget: 0}), dg = Nt(i2),
        D3 = C({}, Br, {animationName: 0, elapsedTime: 0, pseudoElement: 0}), a2 = Nt(D3), o2 = C({}, Br, {
            clipboardData: function (h) {
                return "clipboardData" in h ? h.clipboardData : window.clipboardData
            }
        }), M3 = Nt(o2), tk = C({}, Br, {data: 0}), O3 = Nt(tk), rk = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, AB = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, dh = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};

    function IB(h) {
        var m = this.nativeEvent;
        return m.getModifierState ? m.getModifierState(h) : (h = dh[h]) ? !!m[h] : !1
    }

    function $1() {
        return IB
    }

    var P3 = C({}, hi, {
        key: function (h) {
            if (h.key) {
                var m = rk[h.key] || h.key;
                if (m !== "Unidentified") return m
            }
            return h.type === "keypress" ? (h = rt(h), h === 13 ? "Enter" : String.fromCharCode(h)) : h.type === "keydown" || h.type === "keyup" ? AB[h.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: $1,
        charCode: function (h) {
            return h.type === "keypress" ? rt(h) : 0
        },
        keyCode: function (h) {
            return h.type === "keydown" || h.type === "keyup" ? h.keyCode : 0
        },
        which: function (h) {
            return h.type === "keypress" ? rt(h) : h.type === "keydown" || h.type === "keyup" ? h.keyCode : 0
        }
    }), N3 = Nt(P3), kB = C({}, Na, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }), F1 = Nt(kB), nk = C({}, hi, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: $1
    }), Qc = Nt(nk), hh = C({}, Br, {propertyName: 0, elapsedTime: 0, pseudoElement: 0}), ho = Nt(hh), ph = C({}, Na, {
        deltaX: function (h) {
            return "deltaX" in h ? h.deltaX : "wheelDeltaX" in h ? -h.wheelDeltaX : 0
        }, deltaY: function (h) {
            return "deltaY" in h ? h.deltaY : "wheelDeltaY" in h ? -h.wheelDeltaY : "wheelDelta" in h ? -h.wheelDelta : 0
        }, deltaZ: 0, deltaMode: 0
    }), L3 = Nt(ph), s2 = [9, 13, 27, 32], B3 = s && "CompositionEvent" in window, mh = null;
    s && "documentMode" in document && (mh = document.documentMode);
    var RB = s && "TextEvent" in window && !mh, ik = s && (!B3 || mh && 8 < mh && 11 >= mh), c2 = " ", ak = !1;

    function ok(h, m) {
        switch (h) {
            case"keyup":
                return s2.indexOf(m.keyCode) !== -1;
            case"keydown":
                return m.keyCode !== 229;
            case"keypress":
            case"mousedown":
            case"focusout":
                return !0;
            default:
                return !1
        }
    }

    function sk(h) {
        return h = h.detail, typeof h == "object" && "data" in h ? h.data : null
    }

    var um = !1;

    function DB(h, m) {
        switch (h) {
            case"compositionend":
                return sk(m);
            case"keypress":
                return m.which !== 32 ? null : (ak = !0, c2);
            case"textInput":
                return h = m.data, h === c2 && ak ? null : h;
            default:
                return null
        }
    }

    function MB(h, m) {
        if (um) return h === "compositionend" || !B3 && ok(h, m) ? (h = Ye(), Ie = de = Qn = null, um = !1, h) : null;
        switch (h) {
            case"paste":
                return null;
            case"keypress":
                if (!(m.ctrlKey || m.altKey || m.metaKey) || m.ctrlKey && m.altKey) {
                    if (m.char && 1 < m.char.length) return m.char;
                    if (m.which) return String.fromCharCode(m.which)
                }
                return null;
            case"compositionend":
                return ik && m.locale !== "ko" ? null : m.data;
            default:
                return null
        }
    }

    var OB = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };

    function $3(h) {
        var m = h && h.nodeName && h.nodeName.toLowerCase();
        return m === "input" ? !!OB[h.type] : m === "textarea"
    }

    function fm(h, m, w, O) {
        Yr(O), m = gg(m, "onChange"), 0 < m.length && (w = new Rn("onChange", "change", null, w, O), h.push({
            event: w,
            listeners: m
        }))
    }

    var dm = null, hg = null;

    function ck(h) {
        vm(h, 0)
    }

    function l2(h) {
        var m = pa(h);
        if (ne(m)) return h
    }

    function PB(h, m) {
        if (h === "change") return m
    }

    var lk = !1;
    if (s) {
        var F3;
        if (s) {
            var U3 = "oninput" in document;
            if (!U3) {
                var uk = document.createElement("div");
                uk.setAttribute("oninput", "return;"), U3 = typeof uk.oninput == "function"
            }
            F3 = U3
        } else F3 = !1;
        lk = F3 && (!document.documentMode || 9 < document.documentMode)
    }

    function fk() {
        dm && (dm.detachEvent("onpropertychange", dk), hg = dm = null)
    }

    function dk(h) {
        if (h.propertyName === "value" && l2(hg)) {
            var m = [];
            fm(m, hg, h, ht(h)), _n(ck, m)
        }
    }

    function hk(h, m, w) {
        h === "focusin" ? (fk(), dm = m, hg = w, dm.attachEvent("onpropertychange", dk)) : h === "focusout" && fk()
    }

    function NB(h) {
        if (h === "selectionchange" || h === "keyup" || h === "keydown") return l2(hg)
    }

    function pk(h, m) {
        if (h === "click") return l2(m)
    }

    function LB(h, m) {
        if (h === "input" || h === "change") return l2(m)
    }

    function BB(h, m) {
        return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m
    }

    var vf = typeof Object.is == "function" ? Object.is : BB;

    function U1(h, m) {
        if (vf(h, m)) return !0;
        if (typeof h != "object" || h === null || typeof m != "object" || m === null) return !1;
        var w = Object.keys(h), O = Object.keys(m);
        if (w.length !== O.length) return !1;
        for (O = 0; O < w.length; O++) {
            var K = w[O];
            if (!l.call(m, K) || !vf(h[K], m[K])) return !1
        }
        return !0
    }

    function u2(h) {
        for (; h && h.firstChild;) h = h.firstChild;
        return h
    }

    function Rp(h, m) {
        var w = u2(h);
        h = 0;
        for (var O; w;) {
            if (w.nodeType === 3) {
                if (O = h + w.textContent.length, h <= m && O >= m) return {node: w, offset: m - h};
                h = O
            }
            e:{
                for (; w;) {
                    if (w.nextSibling) {
                        w = w.nextSibling;
                        break e
                    }
                    w = w.parentNode
                }
                w = void 0
            }
            w = u2(w)
        }
    }

    function j1(h, m) {
        return h && m ? h === m ? !0 : h && h.nodeType === 3 ? !1 : m && m.nodeType === 3 ? j1(h, m.parentNode) : "contains" in h ? h.contains(m) : h.compareDocumentPosition ? !!(h.compareDocumentPosition(m) & 16) : !1 : !1
    }

    function j3() {
        for (var h = window, m = be(); m instanceof h.HTMLIFrameElement;) {
            try {
                var w = typeof m.contentWindow.location.href == "string"
            } catch {
                w = !1
            }
            if (w) h = m.contentWindow; else break;
            m = be(h.document)
        }
        return m
    }

    function Dp(h) {
        var m = h && h.nodeName && h.nodeName.toLowerCase();
        return m && (m === "input" && (h.type === "text" || h.type === "search" || h.type === "tel" || h.type === "url" || h.type === "password") || m === "textarea" || h.contentEditable === "true")
    }

    function $B(h) {
        var m = j3(), w = h.focusedElem, O = h.selectionRange;
        if (m !== w && w && w.ownerDocument && j1(w.ownerDocument.documentElement, w)) {
            if (O !== null && Dp(w)) {
                if (m = O.start, h = O.end, h === void 0 && (h = m), "selectionStart" in w) w.selectionStart = m, w.selectionEnd = Math.min(h, w.value.length); else if (h = (m = w.ownerDocument || document) && m.defaultView || window, h.getSelection) {
                    h = h.getSelection();
                    var K = w.textContent.length, ae = Math.min(O.start, K);
                    O = O.end === void 0 ? ae : Math.min(O.end, K), !h.extend && ae > O && (K = O, O = ae, ae = K), K = Rp(w, ae);
                    var ge = Rp(w, O);
                    K && ge && (h.rangeCount !== 1 || h.anchorNode !== K.node || h.anchorOffset !== K.offset || h.focusNode !== ge.node || h.focusOffset !== ge.offset) && (m = m.createRange(), m.setStart(K.node, K.offset), h.removeAllRanges(), ae > O ? (h.addRange(m), h.extend(ge.node, ge.offset)) : (m.setEnd(ge.node, ge.offset), h.addRange(m)))
                }
            }
            for (m = [], h = w; h = h.parentNode;) h.nodeType === 1 && m.push({
                element: h,
                left: h.scrollLeft,
                top: h.scrollTop
            });
            for (typeof w.focus == "function" && w.focus(), w = 0; w < m.length; w++) h = m[w], h.element.scrollLeft = h.left, h.element.scrollTop = h.top
        }
    }

    var FB = s && "documentMode" in document && 11 >= document.documentMode, pg = null, z3 = null, z1 = null, f2 = !1;

    function mk(h, m, w) {
        var O = w.window === w ? w.document : w.nodeType === 9 ? w : w.ownerDocument;
        f2 || pg == null || pg !== be(O) || (O = pg, "selectionStart" in O && Dp(O) ? O = {
            start: O.selectionStart,
            end: O.selectionEnd
        } : (O = (O.ownerDocument && O.ownerDocument.defaultView || window).getSelection(), O = {
            anchorNode: O.anchorNode,
            anchorOffset: O.anchorOffset,
            focusNode: O.focusNode,
            focusOffset: O.focusOffset
        }), z1 && U1(z1, O) || (z1 = O, O = gg(z3, "onSelect"), 0 < O.length && (m = new Rn("onSelect", "select", null, m, w), h.push({
            event: m,
            listeners: O
        }), m.target = pg)))
    }

    function V1(h, m) {
        var w = {};
        return w[h.toLowerCase()] = m.toLowerCase(), w["Webkit" + h] = "webkit" + m, w["Moz" + h] = "moz" + m, w
    }

    var po = {
        animationend: V1("Animation", "AnimationEnd"),
        animationiteration: V1("Animation", "AnimationIteration"),
        animationstart: V1("Animation", "AnimationStart"),
        transitionend: V1("Transition", "TransitionEnd")
    }, d2 = {}, vk = {};
    s && (vk = document.createElement("div").style, "AnimationEvent" in window || (delete po.animationend.animation, delete po.animationiteration.animation, delete po.animationstart.animation), "TransitionEvent" in window || delete po.transitionend.transition);

    function h2(h) {
        if (d2[h]) return d2[h];
        if (!po[h]) return h;
        var m = po[h], w;
        for (w in m) if (m.hasOwnProperty(w) && w in vk) return d2[h] = m[w];
        return h
    }

    var gk = h2("animationend"), yk = h2("animationiteration"), bk = h2("animationstart"), V3 = h2("transitionend"),
        p2 = new Map,
        mg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

    function Mp(h, m) {
        p2.set(h, m), a(m, [h])
    }

    for (var hm = 0; hm < mg.length; hm++) {
        var H3 = mg[hm], UB = H3.toLowerCase(), jB = H3[0].toUpperCase() + H3.slice(1);
        Mp(UB, "on" + jB)
    }
    Mp(gk, "onAnimationEnd"), Mp(yk, "onAnimationIteration"), Mp(bk, "onAnimationStart"), Mp("dblclick", "onDoubleClick"), Mp("focusin", "onFocus"), Mp("focusout", "onBlur"), Mp(V3, "onTransitionEnd"), o("onMouseEnter", ["mouseout", "mouseover"]), o("onMouseLeave", ["mouseout", "mouseover"]), o("onPointerEnter", ["pointerout", "pointerover"]), o("onPointerLeave", ["pointerout", "pointerover"]), a("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), a("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), a("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), a("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var pm = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
        W3 = new Set("cancel close invalid load scroll toggle".split(" ").concat(pm));

    function mm(h, m, w) {
        var O = h.type || "unknown-event";
        h.currentTarget = w, ot(O, m, void 0, h), h.currentTarget = null
    }

    function vm(h, m) {
        m = (m & 4) !== 0;
        for (var w = 0; w < h.length; w++) {
            var O = h[w], K = O.event;
            O = O.listeners;
            e:{
                var ae = void 0;
                if (m) for (var ge = O.length - 1; 0 <= ge; ge--) {
                    var Re = O[ge], Pe = Re.instance, et = Re.currentTarget;
                    if (Re = Re.listener, Pe !== ae && K.isPropagationStopped()) break e;
                    mm(K, Re, et), ae = Pe
                } else for (ge = 0; ge < O.length; ge++) {
                    if (Re = O[ge], Pe = Re.instance, et = Re.currentTarget, Re = Re.listener, Pe !== ae && K.isPropagationStopped()) break e;
                    mm(K, Re, et), ae = Pe
                }
            }
        }
        if (pn) throw h = wr, pn = !1, wr = null, h
    }

    function ca(h, m) {
        var w = m[Np];
        w === void 0 && (w = m[Np] = new Set);
        var O = h + "__bubble";
        w.has(O) || (G3(m, h, 2, !1), w.add(O))
    }

    function q3(h, m, w) {
        var O = 0;
        m && (O |= 4), G3(w, h, O, m)
    }

    var H1 = "_reactListening" + Math.random().toString(36).slice(2);

    function W1(h) {
        if (!h[H1]) {
            h[H1] = !0, n.forEach(function (w) {
                w !== "selectionchange" && (W3.has(w) || q3(w, !1, h), q3(w, !0, h))
            });
            var m = h.nodeType === 9 ? h : h.ownerDocument;
            m === null || m[H1] || (m[H1] = !0, q3("selectionchange", !1, m))
        }
    }

    function G3(h, m, w, O) {
        switch (di(m)) {
            case 1:
                var K = Te;
                break;
            case 4:
                K = Ne;
                break;
            default:
                K = Xe
        }
        w = K.bind(null, m, w, h), K = void 0, !mr || m !== "touchstart" && m !== "touchmove" && m !== "wheel" || (K = !0), O ? K !== void 0 ? h.addEventListener(m, w, {
            capture: !0,
            passive: K
        }) : h.addEventListener(m, w, !0) : K !== void 0 ? h.addEventListener(m, w, {passive: K}) : h.addEventListener(m, w, !1)
    }

    function m2(h, m, w, O, K) {
        var ae = O;
        if (!(m & 1) && !(m & 2) && O !== null) e:for (; ;) {
            if (O === null) return;
            var ge = O.tag;
            if (ge === 3 || ge === 4) {
                var Re = O.stateNode.containerInfo;
                if (Re === K || Re.nodeType === 8 && Re.parentNode === K) break;
                if (ge === 4) for (ge = O.return; ge !== null;) {
                    var Pe = ge.tag;
                    if ((Pe === 3 || Pe === 4) && (Pe = ge.stateNode.containerInfo, Pe === K || Pe.nodeType === 8 && Pe.parentNode === K)) return;
                    ge = ge.return
                }
                for (; Re !== null;) {
                    if (ge = Ar(Re), ge === null) return;
                    if (Pe = ge.tag, Pe === 5 || Pe === 6) {
                        O = ae = ge;
                        continue e
                    }
                    Re = Re.parentNode
                }
            }
            O = O.return
        }
        _n(function () {
            var et = ae, wt = ht(w), Ct = [];
            e:{
                var vt = p2.get(h);
                if (vt !== void 0) {
                    var Zt = Rn, dr = h;
                    switch (h) {
                        case"keypress":
                            if (rt(w) === 0) break e;
                        case"keydown":
                        case"keyup":
                            Zt = N3;
                            break;
                        case"focusin":
                            dr = "focus", Zt = dg;
                            break;
                        case"focusout":
                            dr = "blur", Zt = dg;
                            break;
                        case"beforeblur":
                        case"afterblur":
                            Zt = dg;
                            break;
                        case"click":
                            if (w.button === 2) break e;
                        case"auxclick":
                        case"dblclick":
                        case"mousedown":
                        case"mousemove":
                        case"mouseup":
                        case"mouseout":
                        case"mouseover":
                        case"contextmenu":
                            Zt = lm;
                            break;
                        case"drag":
                        case"dragend":
                        case"dragenter":
                        case"dragexit":
                        case"dragleave":
                        case"dragover":
                        case"dragstart":
                        case"drop":
                            Zt = fg;
                            break;
                        case"touchcancel":
                        case"touchend":
                        case"touchmove":
                        case"touchstart":
                            Zt = Qc;
                            break;
                        case gk:
                        case yk:
                        case bk:
                            Zt = a2;
                            break;
                        case V3:
                            Zt = ho;
                            break;
                        case"scroll":
                            Zt = sa;
                            break;
                        case"wheel":
                            Zt = L3;
                            break;
                        case"copy":
                        case"cut":
                        case"paste":
                            Zt = M3;
                            break;
                        case"gotpointercapture":
                        case"lostpointercapture":
                        case"pointercancel":
                        case"pointerdown":
                        case"pointermove":
                        case"pointerout":
                        case"pointerover":
                        case"pointerup":
                            Zt = F1
                    }
                    var gr = (m & 4) !== 0, io = !gr && h === "scroll",
                        He = gr ? vt !== null ? vt + "Capture" : null : vt;
                    gr = [];
                    for (var $e = et, Ke; $e !== null;) {
                        Ke = $e;
                        var St = Ke.stateNode;
                        if (Ke.tag === 5 && St !== null && (Ke = St, He !== null && (St = Nr($e, He), St != null && gr.push(vg($e, St, Ke)))), io) break;
                        $e = $e.return
                    }
                    0 < gr.length && (vt = new Zt(vt, dr, null, w, wt), Ct.push({event: vt, listeners: gr}))
                }
            }
            if (!(m & 7)) {
                e:{
                    if (vt = h === "mouseover" || h === "pointerover", Zt = h === "mouseout" || h === "pointerout", vt && w !== ft && (dr = w.relatedTarget || w.fromElement) && (Ar(dr) || dr[gf])) break e;
                    if ((Zt || vt) && (vt = wt.window === wt ? wt : (vt = wt.ownerDocument) ? vt.defaultView || vt.parentWindow : window, Zt ? (dr = w.relatedTarget || w.toElement, Zt = et, dr = dr ? Ar(dr) : null, dr !== null && (io = xt(dr), dr !== io || dr.tag !== 5 && dr.tag !== 6) && (dr = null)) : (Zt = null, dr = et), Zt !== dr)) {
                        if (gr = lm, St = "onMouseLeave", He = "onMouseEnter", $e = "mouse", (h === "pointerout" || h === "pointerover") && (gr = F1, St = "onPointerLeave", He = "onPointerEnter", $e = "pointer"), io = Zt == null ? vt : pa(Zt), Ke = dr == null ? vt : pa(dr), vt = new gr(St, $e + "leave", Zt, w, wt), vt.target = io, vt.relatedTarget = Ke, St = null, Ar(wt) === et && (gr = new gr(He, $e + "enter", dr, w, wt), gr.target = Ke, gr.relatedTarget = io, St = gr), io = St, Zt && dr) t:{
                            for (gr = Zt, He = dr, $e = 0, Ke = gr; Ke; Ke = yg(Ke)) $e++;
                            for (Ke = 0, St = He; St; St = yg(St)) Ke++;
                            for (; 0 < $e - Ke;) gr = yg(gr), $e--;
                            for (; 0 < Ke - $e;) He = yg(He), Ke--;
                            for (; $e--;) {
                                if (gr === He || He !== null && gr === He.alternate) break t;
                                gr = yg(gr), He = yg(He)
                            }
                            gr = null
                        } else gr = null;
                        Zt !== null && K3(Ct, vt, Zt, gr, !1), dr !== null && io !== null && K3(Ct, io, dr, gr, !0)
                    }
                }
                e:{
                    if (vt = et ? pa(et) : window, Zt = vt.nodeName && vt.nodeName.toLowerCase(), Zt === "select" || Zt === "input" && vt.type === "file") var hr = PB; else if ($3(vt)) if (lk) hr = LB; else {
                        hr = NB;
                        var zr = hk
                    } else (Zt = vt.nodeName) && Zt.toLowerCase() === "input" && (vt.type === "checkbox" || vt.type === "radio") && (hr = pk);
                    if (hr && (hr = hr(h, et))) {
                        fm(Ct, hr, w, wt);
                        break e
                    }
                    zr && zr(h, vt, et), h === "focusout" && (zr = vt._wrapperState) && zr.controlled && vt.type === "number" && Ue(vt, "number", vt.value)
                }
                switch (zr = et ? pa(et) : window, h) {
                    case"focusin":
                        ($3(zr) || zr.contentEditable === "true") && (pg = zr, z3 = et, z1 = null);
                        break;
                    case"focusout":
                        z1 = z3 = pg = null;
                        break;
                    case"mousedown":
                        f2 = !0;
                        break;
                    case"contextmenu":
                    case"mouseup":
                    case"dragend":
                        f2 = !1, mk(Ct, w, wt);
                        break;
                    case"selectionchange":
                        if (FB) break;
                    case"keydown":
                    case"keyup":
                        mk(Ct, w, wt)
                }
                var Hr;
                if (B3) e:{
                    switch (h) {
                        case"compositionstart":
                            var Jr = "onCompositionStart";
                            break e;
                        case"compositionend":
                            Jr = "onCompositionEnd";
                            break e;
                        case"compositionupdate":
                            Jr = "onCompositionUpdate";
                            break e
                    }
                    Jr = void 0
                } else um ? ok(h, w) && (Jr = "onCompositionEnd") : h === "keydown" && w.keyCode === 229 && (Jr = "onCompositionStart");
                Jr && (ik && w.locale !== "ko" && (um || Jr !== "onCompositionStart" ? Jr === "onCompositionEnd" && um && (Hr = Ye()) : (Qn = wt, de = "value" in Qn ? Qn.value : Qn.textContent, um = !0)), zr = gg(et, Jr), 0 < zr.length && (Jr = new O3(Jr, h, null, w, wt), Ct.push({
                    event: Jr,
                    listeners: zr
                }), Hr ? Jr.data = Hr : (Hr = sk(w), Hr !== null && (Jr.data = Hr)))), (Hr = RB ? DB(h, w) : MB(h, w)) && (et = gg(et, "onBeforeInput"), 0 < et.length && (wt = new O3("onBeforeInput", "beforeinput", null, w, wt), Ct.push({
                    event: wt,
                    listeners: et
                }), wt.data = Hr))
            }
            vm(Ct, m)
        })
    }

    function vg(h, m, w) {
        return {instance: h, listener: m, currentTarget: w}
    }

    function gg(h, m) {
        for (var w = m + "Capture", O = []; h !== null;) {
            var K = h, ae = K.stateNode;
            K.tag === 5 && ae !== null && (K = ae, ae = Nr(h, w), ae != null && O.unshift(vg(h, ae, K)), ae = Nr(h, m), ae != null && O.push(vg(h, ae, K))), h = h.return
        }
        return O
    }

    function yg(h) {
        if (h === null) return null;
        do h = h.return; while (h && h.tag !== 5);
        return h || null
    }

    function K3(h, m, w, O, K) {
        for (var ae = m._reactName, ge = []; w !== null && w !== O;) {
            var Re = w, Pe = Re.alternate, et = Re.stateNode;
            if (Pe !== null && Pe === O) break;
            Re.tag === 5 && et !== null && (Re = et, K ? (Pe = Nr(w, ae), Pe != null && ge.unshift(vg(w, Pe, Re))) : K || (Pe = Nr(w, ae), Pe != null && ge.push(vg(w, Pe, Re)))), w = w.return
        }
        ge.length !== 0 && h.push({event: m, listeners: ge})
    }

    var zB = /\r\n?/g, VB = /\u0000|\uFFFD/g;

    function wk(h) {
        return (typeof h == "string" ? h : "" + h).replace(zB, `
`).replace(VB, "")
    }

    function Op(h, m, w) {
        if (m = wk(m), wk(h) !== m && w) throw Error(r(425))
    }

    function bg() {
    }

    var gm = null, v2 = null;

    function g2(h, m) {
        return h === "textarea" || h === "noscript" || typeof m.children == "string" || typeof m.children == "number" || typeof m.dangerouslySetInnerHTML == "object" && m.dangerouslySetInnerHTML !== null && m.dangerouslySetInnerHTML.__html != null
    }

    var q1 = typeof setTimeout == "function" ? setTimeout : void 0,
        HB = typeof clearTimeout == "function" ? clearTimeout : void 0,
        ym = typeof Promise == "function" ? Promise : void 0,
        y2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof ym < "u" ? function (h) {
            return ym.resolve(null).then(h).catch(b2)
        } : q1;

    function b2(h) {
        setTimeout(function () {
            throw h
        })
    }

    function G1(h, m) {
        var w = m, O = 0;
        do {
            var K = w.nextSibling;
            if (h.removeChild(w), K && K.nodeType === 8) if (w = K.data, w === "/$") {
                if (O === 0) {
                    h.removeChild(K), mf(m);
                    return
                }
                O--
            } else w !== "$" && w !== "$?" && w !== "$!" || O++;
            w = K
        } while (w);
        mf(m)
    }

    function Pp(h) {
        for (; h != null; h = h.nextSibling) {
            var m = h.nodeType;
            if (m === 1 || m === 3) break;
            if (m === 8) {
                if (m = h.data, m === "$" || m === "$!" || m === "$?") break;
                if (m === "/$") return null
            }
        }
        return h
    }

    function w2(h) {
        h = h.previousSibling;
        for (var m = 0; h;) {
            if (h.nodeType === 8) {
                var w = h.data;
                if (w === "$" || w === "$!" || w === "$?") {
                    if (m === 0) return h;
                    m--
                } else w === "/$" && m++
            }
            h = h.previousSibling
        }
        return null
    }

    var wg = Math.random().toString(36).slice(2), cd = "__reactFiber$" + wg, K1 = "__reactProps$" + wg,
        gf = "__reactContainer$" + wg, Np = "__reactEvents$" + wg, WB = "__reactListeners$" + wg,
        qB = "__reactHandles$" + wg;

    function Ar(h) {
        var m = h[cd];
        if (m) return m;
        for (var w = h.parentNode; w;) {
            if (m = w[gf] || w[cd]) {
                if (w = m.alternate, m.child !== null || w !== null && w.child !== null) for (h = w2(h); h !== null;) {
                    if (w = h[cd]) return w;
                    h = w2(h)
                }
                return m
            }
            h = w, w = h.parentNode
        }
        return null
    }

    function ld(h) {
        return h = h[cd] || h[gf], !h || h.tag !== 5 && h.tag !== 6 && h.tag !== 13 && h.tag !== 3 ? null : h
    }

    function pa(h) {
        if (h.tag === 5 || h.tag === 6) return h.stateNode;
        throw Error(r(33))
    }

    function Dn(h) {
        return h[K1] || null
    }

    var vh = [], ud = -1;

    function fd(h) {
        return {current: h}
    }

    function Mr(h) {
        0 > ud || (h.current = vh[ud], vh[ud] = null, ud--)
    }

    function ai(h, m) {
        ud++, vh[ud] = h.current, h.current = m
    }

    var pc = {}, Ha = fd(pc), wa = fd(!1), mc = pc;

    function Au(h, m) {
        var w = h.type.contextTypes;
        if (!w) return pc;
        var O = h.stateNode;
        if (O && O.__reactInternalMemoizedUnmaskedChildContext === m) return O.__reactInternalMemoizedMaskedChildContext;
        var K = {}, ae;
        for (ae in w) K[ae] = m[ae];
        return O && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = m, h.__reactInternalMemoizedMaskedChildContext = K), K
    }

    function ps(h) {
        return h = h.childContextTypes, h != null
    }

    function S2() {
        Mr(wa), Mr(Ha)
    }

    function Sk(h, m, w) {
        if (Ha.current !== pc) throw Error(r(168));
        ai(Ha, m), ai(wa, w)
    }

    function Sg(h, m, w) {
        var O = h.stateNode;
        if (m = m.childContextTypes, typeof O.getChildContext != "function") return w;
        O = O.getChildContext();
        for (var K in O) if (!(K in m)) throw Error(r(108, me(h) || "Unknown", K));
        return C({}, w, O)
    }

    function Xo(h) {
        return h = (h = h.stateNode) && h.__reactInternalMemoizedMergedChildContext || pc, mc = Ha.current, ai(Ha, h), ai(wa, wa.current), !0
    }

    function _2(h, m, w) {
        var O = h.stateNode;
        if (!O) throw Error(r(169));
        w ? (h = Sg(h, m, mc), O.__reactInternalMemoizedMergedChildContext = h, Mr(wa), Mr(Ha), ai(Ha, h)) : Mr(wa), ai(wa, w)
    }

    var dd = null, _g = !1, gh = !1;

    function x2(h) {
        dd === null ? dd = [h] : dd.push(h)
    }

    function yh(h) {
        _g = !0, x2(h)
    }

    function yf() {
        if (!gh && dd !== null) {
            gh = !0;
            var h = 0, m = Bn;
            try {
                var w = dd;
                for (Bn = 1; h < w.length; h++) {
                    var O = w[h];
                    do O = O(!0); while (O !== null)
                }
                dd = null, _g = !1
            } catch (K) {
                throw dd !== null && (dd = dd.slice(h + 1)), In(Da, yf), K
            } finally {
                Bn = m, gh = !1
            }
        }
        return null
    }

    var Lp = [], Bp = 0, $p = null, bh = 0, mo = [], Iu = 0, Fl = null, hd = 1, pd = "";

    function bm(h, m) {
        Lp[Bp++] = bh, Lp[Bp++] = $p, $p = h, bh = m
    }

    function _k(h, m, w) {
        mo[Iu++] = hd, mo[Iu++] = pd, mo[Iu++] = Fl, Fl = h;
        var O = hd;
        h = pd;
        var K = 32 - Pa(O) - 1;
        O &= ~(1 << K), w += 1;
        var ae = 32 - Pa(m) + K;
        if (30 < ae) {
            var ge = K - K % 5;
            ae = (O & (1 << ge) - 1).toString(32), O >>= ge, K -= ge, hd = 1 << 32 - Pa(m) + K | w << K | O, pd = ae + h
        } else hd = 1 << ae | w << K | O, pd = h
    }

    function E2(h) {
        h.return !== null && (bm(h, 1), _k(h, 1, 0))
    }

    function T2(h) {
        for (; h === $p;) $p = Lp[--Bp], Lp[Bp] = null, bh = Lp[--Bp], Lp[Bp] = null;
        for (; h === Fl;) Fl = mo[--Iu], mo[Iu] = null, pd = mo[--Iu], mo[Iu] = null, hd = mo[--Iu], mo[Iu] = null
    }

    var Zc = null, Jc = null, Sa = !1, ku = null;

    function Y3(h, m) {
        var w = Pu(5, null, null, 0);
        w.elementType = "DELETED", w.stateNode = m, w.return = h, m = h.deletions, m === null ? (h.deletions = [w], h.flags |= 16) : m.push(w)
    }

    function xk(h, m) {
        switch (h.tag) {
            case 5:
                var w = h.type;
                return m = m.nodeType !== 1 || w.toLowerCase() !== m.nodeName.toLowerCase() ? null : m, m !== null ? (h.stateNode = m, Zc = h, Jc = Pp(m.firstChild), !0) : !1;
            case 6:
                return m = h.pendingProps === "" || m.nodeType !== 3 ? null : m, m !== null ? (h.stateNode = m, Zc = h, Jc = null, !0) : !1;
            case 13:
                return m = m.nodeType !== 8 ? null : m, m !== null ? (w = Fl !== null ? {
                    id: hd,
                    overflow: pd
                } : null, h.memoizedState = {
                    dehydrated: m,
                    treeContext: w,
                    retryLane: 1073741824
                }, w = Pu(18, null, null, 0), w.stateNode = m, w.return = h, h.child = w, Zc = h, Jc = null, !0) : !1;
            default:
                return !1
        }
    }

    function X3(h) {
        return (h.mode & 1) !== 0 && (h.flags & 128) === 0
    }

    function Q3(h) {
        if (Sa) {
            var m = Jc;
            if (m) {
                var w = m;
                if (!xk(h, m)) {
                    if (X3(h)) throw Error(r(418));
                    m = Pp(w.nextSibling);
                    var O = Zc;
                    m && xk(h, m) ? Y3(O, w) : (h.flags = h.flags & -4097 | 2, Sa = !1, Zc = h)
                }
            } else {
                if (X3(h)) throw Error(r(418));
                h.flags = h.flags & -4097 | 2, Sa = !1, Zc = h
            }
        }
    }

    function Bo(h) {
        for (h = h.return; h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13;) h = h.return;
        Zc = h
    }

    function C2(h) {
        if (h !== Zc) return !1;
        if (!Sa) return Bo(h), Sa = !0, !1;
        var m;
        if ((m = h.tag !== 3) && !(m = h.tag !== 5) && (m = h.type, m = m !== "head" && m !== "body" && !g2(h.type, h.memoizedProps)), m && (m = Jc)) {
            if (X3(h)) throw Y1(), Error(r(418));
            for (; m;) Y3(h, m), m = Pp(m.nextSibling)
        }
        if (Bo(h), h.tag === 13) {
            if (h = h.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(r(317));
            e:{
                for (h = h.nextSibling, m = 0; h;) {
                    if (h.nodeType === 8) {
                        var w = h.data;
                        if (w === "/$") {
                            if (m === 0) {
                                Jc = Pp(h.nextSibling);
                                break e
                            }
                            m--
                        } else w !== "$" && w !== "$!" && w !== "$?" || m++
                    }
                    h = h.nextSibling
                }
                Jc = null
            }
        } else Jc = Zc ? Pp(h.stateNode.nextSibling) : null;
        return !0
    }

    function Y1() {
        for (var h = Jc; h;) h = Pp(h.nextSibling)
    }

    function Fp() {
        Jc = Zc = null, Sa = !1
    }

    function wh(h) {
        ku === null ? ku = [h] : ku.push(h)
    }

    var GB = V.ReactCurrentBatchConfig;

    function wm(h, m, w) {
        if (h = w.ref, h !== null && typeof h != "function" && typeof h != "object") {
            if (w._owner) {
                if (w = w._owner, w) {
                    if (w.tag !== 1) throw Error(r(309));
                    var O = w.stateNode
                }
                if (!O) throw Error(r(147, h));
                var K = O, ae = "" + h;
                return m !== null && m.ref !== null && typeof m.ref == "function" && m.ref._stringRef === ae ? m.ref : (m = function (ge) {
                    var Re = K.refs;
                    ge === null ? delete Re[ae] : Re[ae] = ge
                }, m._stringRef = ae, m)
            }
            if (typeof h != "string") throw Error(r(284));
            if (!w._owner) throw Error(r(290, h))
        }
        return h
    }

    function A2(h, m) {
        throw h = Object.prototype.toString.call(m), Error(r(31, h === "[object Object]" ? "object with keys {" + Object.keys(m).join(", ") + "}" : h))
    }

    function Ek(h) {
        var m = h._init;
        return m(h._payload)
    }

    function Sm(h) {
        function m(He, $e) {
            if (h) {
                var Ke = He.deletions;
                Ke === null ? (He.deletions = [$e], He.flags |= 16) : Ke.push($e)
            }
        }

        function w(He, $e) {
            if (!h) return null;
            for (; $e !== null;) m(He, $e), $e = $e.sibling;
            return null
        }

        function O(He, $e) {
            for (He = new Map; $e !== null;) $e.key !== null ? He.set($e.key, $e) : He.set($e.index, $e), $e = $e.sibling;
            return He
        }

        function K(He, $e) {
            return He = Gp(He, $e), He.index = 0, He.sibling = null, He
        }

        function ae(He, $e, Ke) {
            return He.index = Ke, h ? (Ke = He.alternate, Ke !== null ? (Ke = Ke.index, Ke < $e ? (He.flags |= 2, $e) : Ke) : (He.flags |= 2, $e)) : (He.flags |= 1048576, $e)
        }

        function ge(He) {
            return h && He.alternate === null && (He.flags |= 2), He
        }

        function Re(He, $e, Ke, St) {
            return $e === null || $e.tag !== 6 ? ($e = I6(Ke, He.mode, St), $e.return = He, $e) : ($e = K($e, Ke), $e.return = He, $e)
        }

        function Pe(He, $e, Ke, St) {
            var hr = Ke.type;
            return hr === oe ? wt(He, $e, Ke.props.children, St, Ke.key) : $e !== null && ($e.elementType === hr || typeof hr == "object" && hr !== null && hr.$$typeof === B && Ek(hr) === $e.type) ? (St = K($e, Ke.props), St.ref = wm(He, $e, Ke), St.return = He, St) : (St = Tb(Ke.type, Ke.key, Ke.props, null, He.mode, St), St.ref = wm(He, $e, Ke), St.return = He, St)
        }

        function et(He, $e, Ke, St) {
            return $e === null || $e.tag !== 4 || $e.stateNode.containerInfo !== Ke.containerInfo || $e.stateNode.implementation !== Ke.implementation ? ($e = o_(Ke, He.mode, St), $e.return = He, $e) : ($e = K($e, Ke.children || []), $e.return = He, $e)
        }

        function wt(He, $e, Ke, St, hr) {
            return $e === null || $e.tag !== 7 ? ($e = Ch(Ke, He.mode, St, hr), $e.return = He, $e) : ($e = K($e, Ke), $e.return = He, $e)
        }

        function Ct(He, $e, Ke) {
            if (typeof $e == "string" && $e !== "" || typeof $e == "number") return $e = I6("" + $e, He.mode, Ke), $e.return = He, $e;
            if (typeof $e == "object" && $e !== null) {
                switch ($e.$$typeof) {
                    case Y:
                        return Ke = Tb($e.type, $e.key, $e.props, null, He.mode, Ke), Ke.ref = wm(He, null, $e), Ke.return = He, Ke;
                    case ee:
                        return $e = o_($e, He.mode, Ke), $e.return = He, $e;
                    case B:
                        var St = $e._init;
                        return Ct(He, St($e._payload), Ke)
                }
                if (bt($e) || $($e)) return $e = Ch($e, He.mode, Ke, null), $e.return = He, $e;
                A2(He, $e)
            }
            return null
        }

        function vt(He, $e, Ke, St) {
            var hr = $e !== null ? $e.key : null;
            if (typeof Ke == "string" && Ke !== "" || typeof Ke == "number") return hr !== null ? null : Re(He, $e, "" + Ke, St);
            if (typeof Ke == "object" && Ke !== null) {
                switch (Ke.$$typeof) {
                    case Y:
                        return Ke.key === hr ? Pe(He, $e, Ke, St) : null;
                    case ee:
                        return Ke.key === hr ? et(He, $e, Ke, St) : null;
                    case B:
                        return hr = Ke._init, vt(He, $e, hr(Ke._payload), St)
                }
                if (bt(Ke) || $(Ke)) return hr !== null ? null : wt(He, $e, Ke, St, null);
                A2(He, Ke)
            }
            return null
        }

        function Zt(He, $e, Ke, St, hr) {
            if (typeof St == "string" && St !== "" || typeof St == "number") return He = He.get(Ke) || null, Re($e, He, "" + St, hr);
            if (typeof St == "object" && St !== null) {
                switch (St.$$typeof) {
                    case Y:
                        return He = He.get(St.key === null ? Ke : St.key) || null, Pe($e, He, St, hr);
                    case ee:
                        return He = He.get(St.key === null ? Ke : St.key) || null, et($e, He, St, hr);
                    case B:
                        var zr = St._init;
                        return Zt(He, $e, Ke, zr(St._payload), hr)
                }
                if (bt(St) || $(St)) return He = He.get(Ke) || null, wt($e, He, St, hr, null);
                A2($e, St)
            }
            return null
        }

        function dr(He, $e, Ke, St) {
            for (var hr = null, zr = null, Hr = $e, Jr = $e = 0, Jo = null; Hr !== null && Jr < Ke.length; Jr++) {
                Hr.index > Jr ? (Jo = Hr, Hr = null) : Jo = Hr.sibling;
                var bi = vt(He, Hr, Ke[Jr], St);
                if (bi === null) {
                    Hr === null && (Hr = Jo);
                    break
                }
                h && Hr && bi.alternate === null && m(He, Hr), $e = ae(bi, $e, Jr), zr === null ? hr = bi : zr.sibling = bi, zr = bi, Hr = Jo
            }
            if (Jr === Ke.length) return w(He, Hr), Sa && bm(He, Jr), hr;
            if (Hr === null) {
                for (; Jr < Ke.length; Jr++) Hr = Ct(He, Ke[Jr], St), Hr !== null && ($e = ae(Hr, $e, Jr), zr === null ? hr = Hr : zr.sibling = Hr, zr = Hr);
                return Sa && bm(He, Jr), hr
            }
            for (Hr = O(He, Hr); Jr < Ke.length; Jr++) Jo = Zt(Hr, He, Jr, Ke[Jr], St), Jo !== null && (h && Jo.alternate !== null && Hr.delete(Jo.key === null ? Jr : Jo.key), $e = ae(Jo, $e, Jr), zr === null ? hr = Jo : zr.sibling = Jo, zr = Jo);
            return h && Hr.forEach(function (Xp) {
                return m(He, Xp)
            }), Sa && bm(He, Jr), hr
        }

        function gr(He, $e, Ke, St) {
            var hr = $(Ke);
            if (typeof hr != "function") throw Error(r(150));
            if (Ke = hr.call(Ke), Ke == null) throw Error(r(151));
            for (var zr = hr = null, Hr = $e, Jr = $e = 0, Jo = null, bi = Ke.next(); Hr !== null && !bi.done; Jr++, bi = Ke.next()) {
                Hr.index > Jr ? (Jo = Hr, Hr = null) : Jo = Hr.sibling;
                var Xp = vt(He, Hr, bi.value, St);
                if (Xp === null) {
                    Hr === null && (Hr = Jo);
                    break
                }
                h && Hr && Xp.alternate === null && m(He, Hr), $e = ae(Xp, $e, Jr), zr === null ? hr = Xp : zr.sibling = Xp, zr = Xp, Hr = Jo
            }
            if (bi.done) return w(He, Hr), Sa && bm(He, Jr), hr;
            if (Hr === null) {
                for (; !bi.done; Jr++, bi = Ke.next()) bi = Ct(He, bi.value, St), bi !== null && ($e = ae(bi, $e, Jr), zr === null ? hr = bi : zr.sibling = bi, zr = bi);
                return Sa && bm(He, Jr), hr
            }
            for (Hr = O(He, Hr); !bi.done; Jr++, bi = Ke.next()) bi = Zt(Hr, He, Jr, bi.value, St), bi !== null && (h && bi.alternate !== null && Hr.delete(bi.key === null ? Jr : bi.key), $e = ae(bi, $e, Jr), zr === null ? hr = bi : zr.sibling = bi, zr = bi);
            return h && Hr.forEach(function (oR) {
                return m(He, oR)
            }), Sa && bm(He, Jr), hr
        }

        function io(He, $e, Ke, St) {
            if (typeof Ke == "object" && Ke !== null && Ke.type === oe && Ke.key === null && (Ke = Ke.props.children), typeof Ke == "object" && Ke !== null) {
                switch (Ke.$$typeof) {
                    case Y:
                        e:{
                            for (var hr = Ke.key, zr = $e; zr !== null;) {
                                if (zr.key === hr) {
                                    if (hr = Ke.type, hr === oe) {
                                        if (zr.tag === 7) {
                                            w(He, zr.sibling), $e = K(zr, Ke.props.children), $e.return = He, He = $e;
                                            break e
                                        }
                                    } else if (zr.elementType === hr || typeof hr == "object" && hr !== null && hr.$$typeof === B && Ek(hr) === zr.type) {
                                        w(He, zr.sibling), $e = K(zr, Ke.props), $e.ref = wm(He, zr, Ke), $e.return = He, He = $e;
                                        break e
                                    }
                                    w(He, zr);
                                    break
                                } else m(He, zr);
                                zr = zr.sibling
                            }
                            Ke.type === oe ? ($e = Ch(Ke.props.children, He.mode, St, Ke.key), $e.return = He, He = $e) : (St = Tb(Ke.type, Ke.key, Ke.props, null, He.mode, St), St.ref = wm(He, $e, Ke), St.return = He, He = St)
                        }
                        return ge(He);
                    case ee:
                        e:{
                            for (zr = Ke.key; $e !== null;) {
                                if ($e.key === zr) if ($e.tag === 4 && $e.stateNode.containerInfo === Ke.containerInfo && $e.stateNode.implementation === Ke.implementation) {
                                    w(He, $e.sibling), $e = K($e, Ke.children || []), $e.return = He, He = $e;
                                    break e
                                } else {
                                    w(He, $e);
                                    break
                                } else m(He, $e);
                                $e = $e.sibling
                            }
                            $e = o_(Ke, He.mode, St), $e.return = He, He = $e
                        }
                        return ge(He);
                    case B:
                        return zr = Ke._init, io(He, $e, zr(Ke._payload), St)
                }
                if (bt(Ke)) return dr(He, $e, Ke, St);
                if ($(Ke)) return gr(He, $e, Ke, St);
                A2(He, Ke)
            }
            return typeof Ke == "string" && Ke !== "" || typeof Ke == "number" ? (Ke = "" + Ke, $e !== null && $e.tag === 6 ? (w(He, $e.sibling), $e = K($e, Ke), $e.return = He, He = $e) : (w(He, $e), $e = I6(Ke, He.mode, St), $e.return = He, He = $e), ge(He)) : w(He, $e)
        }

        return io
    }

    var eo = Sm(!0), Wt = Sm(!1), Ul = fd(null), el = null, xg = null, Z3 = null;

    function J3() {
        Z3 = xg = el = null
    }

    function e6(h) {
        var m = Ul.current;
        Mr(Ul), h._currentValue = m
    }

    function t6(h, m, w) {
        for (; h !== null;) {
            var O = h.alternate;
            if ((h.childLanes & m) !== m ? (h.childLanes |= m, O !== null && (O.childLanes |= m)) : O !== null && (O.childLanes & m) !== m && (O.childLanes |= m), h === w) break;
            h = h.return
        }
    }

    function La(h, m) {
        el = h, Z3 = xg = null, h = h.dependencies, h !== null && h.firstContext !== null && (h.lanes & m && (go = !0), h.firstContext = null)
    }

    function Ru(h) {
        var m = h._currentValue;
        if (Z3 !== h) if (h = {context: h, memoizedValue: m, next: null}, xg === null) {
            if (el === null) throw Error(r(308));
            xg = h, el.dependencies = {lanes: 0, firstContext: h}
        } else xg = xg.next = h;
        return m
    }

    var _m = null;

    function r6(h) {
        _m === null ? _m = [h] : _m.push(h)
    }

    function n6(h, m, w, O) {
        var K = m.interleaved;
        return K === null ? (w.next = w, r6(m)) : (w.next = K.next, K.next = w), m.interleaved = w, jl(h, O)
    }

    function jl(h, m) {
        h.lanes |= m;
        var w = h.alternate;
        for (w !== null && (w.lanes |= m), w = h, h = h.return; h !== null;) h.childLanes |= m, w = h.alternate, w !== null && (w.childLanes |= m), w = h, h = h.return;
        return w.tag === 3 ? w.stateNode : null
    }

    var zl = !1;

    function i6(h) {
        h.updateQueue = {
            baseState: h.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {pending: null, interleaved: null, lanes: 0},
            effects: null
        }
    }

    function Tk(h, m) {
        h = h.updateQueue, m.updateQueue === h && (m.updateQueue = {
            baseState: h.baseState,
            firstBaseUpdate: h.firstBaseUpdate,
            lastBaseUpdate: h.lastBaseUpdate,
            shared: h.shared,
            effects: h.effects
        })
    }

    function Sh(h, m) {
        return {eventTime: h, lane: m, tag: 0, payload: null, callback: null, next: null}
    }

    function Up(h, m, w) {
        var O = h.updateQueue;
        if (O === null) return null;
        if (O = O.shared, ei & 2) {
            var K = O.pending;
            return K === null ? m.next = m : (m.next = K.next, K.next = m), O.pending = m, jl(h, w)
        }
        return K = O.interleaved, K === null ? (m.next = m, r6(O)) : (m.next = K.next, K.next = m), O.interleaved = m, jl(h, w)
    }

    function I2(h, m, w) {
        if (m = m.updateQueue, m !== null && (m = m.shared, (w & 4194240) !== 0)) {
            var O = m.lanes;
            O &= h.pendingLanes, w |= O, m.lanes = w, $l(h, w)
        }
    }

    function Ck(h, m) {
        var w = h.updateQueue, O = h.alternate;
        if (O !== null && (O = O.updateQueue, w === O)) {
            var K = null, ae = null;
            if (w = w.firstBaseUpdate, w !== null) {
                do {
                    var ge = {
                        eventTime: w.eventTime,
                        lane: w.lane,
                        tag: w.tag,
                        payload: w.payload,
                        callback: w.callback,
                        next: null
                    };
                    ae === null ? K = ae = ge : ae = ae.next = ge, w = w.next
                } while (w !== null);
                ae === null ? K = ae = m : ae = ae.next = m
            } else K = ae = m;
            w = {
                baseState: O.baseState,
                firstBaseUpdate: K,
                lastBaseUpdate: ae,
                shared: O.shared,
                effects: O.effects
            }, h.updateQueue = w;
            return
        }
        h = w.lastBaseUpdate, h === null ? w.firstBaseUpdate = m : h.next = m, w.lastBaseUpdate = m
    }

    function X1(h, m, w, O) {
        var K = h.updateQueue;
        zl = !1;
        var ae = K.firstBaseUpdate, ge = K.lastBaseUpdate, Re = K.shared.pending;
        if (Re !== null) {
            K.shared.pending = null;
            var Pe = Re, et = Pe.next;
            Pe.next = null, ge === null ? ae = et : ge.next = et, ge = Pe;
            var wt = h.alternate;
            wt !== null && (wt = wt.updateQueue, Re = wt.lastBaseUpdate, Re !== ge && (Re === null ? wt.firstBaseUpdate = et : Re.next = et, wt.lastBaseUpdate = Pe))
        }
        if (ae !== null) {
            var Ct = K.baseState;
            ge = 0, wt = et = Pe = null, Re = ae;
            do {
                var vt = Re.lane, Zt = Re.eventTime;
                if ((O & vt) === vt) {
                    wt !== null && (wt = wt.next = {
                        eventTime: Zt,
                        lane: 0,
                        tag: Re.tag,
                        payload: Re.payload,
                        callback: Re.callback,
                        next: null
                    });
                    e:{
                        var dr = h, gr = Re;
                        switch (vt = m, Zt = w, gr.tag) {
                            case 1:
                                if (dr = gr.payload, typeof dr == "function") {
                                    Ct = dr.call(Zt, Ct, vt);
                                    break e
                                }
                                Ct = dr;
                                break e;
                            case 3:
                                dr.flags = dr.flags & -65537 | 128;
                            case 0:
                                if (dr = gr.payload, vt = typeof dr == "function" ? dr.call(Zt, Ct, vt) : dr, vt == null) break e;
                                Ct = C({}, Ct, vt);
                                break e;
                            case 2:
                                zl = !0
                        }
                    }
                    Re.callback !== null && Re.lane !== 0 && (h.flags |= 64, vt = K.effects, vt === null ? K.effects = [Re] : vt.push(Re))
                } else Zt = {
                    eventTime: Zt,
                    lane: vt,
                    tag: Re.tag,
                    payload: Re.payload,
                    callback: Re.callback,
                    next: null
                }, wt === null ? (et = wt = Zt, Pe = Ct) : wt = wt.next = Zt, ge |= vt;
                if (Re = Re.next, Re === null) {
                    if (Re = K.shared.pending, Re === null) break;
                    vt = Re, Re = vt.next, vt.next = null, K.lastBaseUpdate = vt, K.shared.pending = null
                }
            } while (!0);
            if (wt === null && (Pe = Ct), K.baseState = Pe, K.firstBaseUpdate = et, K.lastBaseUpdate = wt, m = K.shared.interleaved, m !== null) {
                K = m;
                do ge |= K.lane, K = K.next; while (K !== m)
            } else ae === null && (K.shared.lanes = 0);
            bd |= ge, h.lanes = ge, h.memoizedState = Ct
        }
    }

    function a6(h, m, w) {
        if (h = m.effects, m.effects = null, h !== null) for (m = 0; m < h.length; m++) {
            var O = h[m], K = O.callback;
            if (K !== null) {
                if (O.callback = null, O = w, typeof K != "function") throw Error(r(191, K));
                K.call(O)
            }
        }
    }

    var Q1 = {}, md = fd(Q1), Z1 = fd(Q1), J1 = fd(Q1);

    function xm(h) {
        if (h === Q1) throw Error(r(174));
        return h
    }

    function o6(h, m) {
        switch (ai(J1, m), ai(Z1, h), ai(md, Q1), h = m.nodeType, h) {
            case 9:
            case 11:
                m = (m = m.documentElement) ? m.namespaceURI : pe(null, "");
                break;
            default:
                h = h === 8 ? m.parentNode : m, m = h.namespaceURI || null, h = h.tagName, m = pe(m, h)
        }
        Mr(md), ai(md, m)
    }

    function Em() {
        Mr(md), Mr(Z1), Mr(J1)
    }

    function Ak(h) {
        xm(J1.current);
        var m = xm(md.current), w = pe(m, h.type);
        m !== w && (ai(Z1, h), ai(md, w))
    }

    function k2(h) {
        Z1.current === h && (Mr(md), Mr(Z1))
    }

    var Ba = fd(0);

    function R2(h) {
        for (var m = h; m !== null;) {
            if (m.tag === 13) {
                var w = m.memoizedState;
                if (w !== null && (w = w.dehydrated, w === null || w.data === "$?" || w.data === "$!")) return m
            } else if (m.tag === 19 && m.memoizedProps.revealOrder !== void 0) {
                if (m.flags & 128) return m
            } else if (m.child !== null) {
                m.child.return = m, m = m.child;
                continue
            }
            if (m === h) break;
            for (; m.sibling === null;) {
                if (m.return === null || m.return === h) return null;
                m = m.return
            }
            m.sibling.return = m.return, m = m.sibling
        }
        return null
    }

    var eb = [];

    function $r() {
        for (var h = 0; h < eb.length; h++) eb[h]._workInProgressVersionPrimary = null;
        eb.length = 0
    }

    var Mn = V.ReactCurrentDispatcher, gi = V.ReactCurrentBatchConfig, Gi = 0, yi = null, vo = null, Qo = null, D2 = !1,
        tb = !1, Tm = 0, mt = 0;

    function pi() {
        throw Error(r(321))
    }

    function Xr(h, m) {
        if (m === null) return !1;
        for (var w = 0; w < m.length && w < h.length; w++) if (!vf(h[w], m[w])) return !1;
        return !0
    }

    function jp(h, m, w, O, K, ae) {
        if (Gi = ae, yi = m, m.memoizedState = null, m.updateQueue = null, m.lanes = 0, Mn.current = h === null || h.memoizedState === null ? q2 : sb, h = w(O, K), tb) {
            ae = 0;
            do {
                if (tb = !1, Tm = 0, 25 <= ae) throw Error(r(301));
                ae += 1, Qo = vo = null, m.updateQueue = null, Mn.current = G2, h = w(O, K)
            } while (tb)
        }
        if (Mn.current = Rm, m = vo !== null && vo.next !== null, Gi = 0, Qo = vo = yi = null, D2 = !1, m) throw Error(r(300));
        return h
    }

    function bf() {
        var h = Tm !== 0;
        return Tm = 0, h
    }

    function Vs() {
        var h = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
        return Qo === null ? yi.memoizedState = Qo = h : Qo = Qo.next = h, Qo
    }

    function to() {
        if (vo === null) {
            var h = yi.alternate;
            h = h !== null ? h.memoizedState : null
        } else h = vo.next;
        var m = Qo === null ? yi.memoizedState : Qo.next;
        if (m !== null) Qo = m, vo = h; else {
            if (h === null) throw Error(r(310));
            vo = h, h = {
                memoizedState: vo.memoizedState,
                baseState: vo.baseState,
                baseQueue: vo.baseQueue,
                queue: vo.queue,
                next: null
            }, Qo === null ? yi.memoizedState = Qo = h : Qo = Qo.next = h
        }
        return Qo
    }

    function _h(h, m) {
        return typeof m == "function" ? m(h) : m
    }

    function zp(h) {
        var m = to(), w = m.queue;
        if (w === null) throw Error(r(311));
        w.lastRenderedReducer = h;
        var O = vo, K = O.baseQueue, ae = w.pending;
        if (ae !== null) {
            if (K !== null) {
                var ge = K.next;
                K.next = ae.next, ae.next = ge
            }
            O.baseQueue = K = ae, w.pending = null
        }
        if (K !== null) {
            ae = K.next, O = O.baseState;
            var Re = ge = null, Pe = null, et = ae;
            do {
                var wt = et.lane;
                if ((Gi & wt) === wt) Pe !== null && (Pe = Pe.next = {
                    lane: 0,
                    action: et.action,
                    hasEagerState: et.hasEagerState,
                    eagerState: et.eagerState,
                    next: null
                }), O = et.hasEagerState ? et.eagerState : h(O, et.action); else {
                    var Ct = {
                        lane: wt,
                        action: et.action,
                        hasEagerState: et.hasEagerState,
                        eagerState: et.eagerState,
                        next: null
                    };
                    Pe === null ? (Re = Pe = Ct, ge = O) : Pe = Pe.next = Ct, yi.lanes |= wt, bd |= wt
                }
                et = et.next
            } while (et !== null && et !== ae);
            Pe === null ? ge = O : Pe.next = Re, vf(O, m.memoizedState) || (go = !0), m.memoizedState = O, m.baseState = ge, m.baseQueue = Pe, w.lastRenderedState = O
        }
        if (h = w.interleaved, h !== null) {
            K = h;
            do ae = K.lane, yi.lanes |= ae, bd |= ae, K = K.next; while (K !== h)
        } else K === null && (w.lanes = 0);
        return [m.memoizedState, w.dispatch]
    }

    function Cm(h) {
        var m = to(), w = m.queue;
        if (w === null) throw Error(r(311));
        w.lastRenderedReducer = h;
        var O = w.dispatch, K = w.pending, ae = m.memoizedState;
        if (K !== null) {
            w.pending = null;
            var ge = K = K.next;
            do ae = h(ae, ge.action), ge = ge.next; while (ge !== K);
            vf(ae, m.memoizedState) || (go = !0), m.memoizedState = ae, m.baseQueue === null && (m.baseState = ae), w.lastRenderedState = ae
        }
        return [ae, O]
    }

    function M2() {
    }

    function O2(h, m) {
        var w = yi, O = to(), K = m(), ae = !vf(O.memoizedState, K);
        if (ae && (O.memoizedState = K, go = !0), O = O.queue, rb(L2.bind(null, w, O, h), [h]), O.getSnapshot !== m || ae || Qo !== null && Qo.memoizedState.tag & 1) {
            if (w.flags |= 2048, Am(9, N2.bind(null, w, O, K, m), void 0, null), $o === null) throw Error(r(349));
            Gi & 30 || P2(w, m, K)
        }
        return K
    }

    function P2(h, m, w) {
        h.flags |= 16384, h = {getSnapshot: m, value: w}, m = yi.updateQueue, m === null ? (m = {
            lastEffect: null,
            stores: null
        }, yi.updateQueue = m, m.stores = [h]) : (w = m.stores, w === null ? m.stores = [h] : w.push(h))
    }

    function N2(h, m, w, O) {
        m.value = w, m.getSnapshot = O, B2(m) && $2(h)
    }

    function L2(h, m, w) {
        return w(function () {
            B2(m) && $2(h)
        })
    }

    function B2(h) {
        var m = h.getSnapshot;
        h = h.value;
        try {
            var w = m();
            return !vf(h, w)
        } catch {
            return !0
        }
    }

    function $2(h) {
        var m = jl(h, 1);
        m !== null && bc(m, h, 1, -1)
    }

    function F2(h) {
        var m = Vs();
        return typeof h == "function" && (h = h()), m.memoizedState = m.baseState = h, h = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: _h,
            lastRenderedState: h
        }, m.queue = h, h = h.dispatch = km.bind(null, yi, h), [m.memoizedState, h]
    }

    function Am(h, m, w, O) {
        return h = {
            tag: h,
            create: m,
            destroy: w,
            deps: O,
            next: null
        }, m = yi.updateQueue, m === null ? (m = {
            lastEffect: null,
            stores: null
        }, yi.updateQueue = m, m.lastEffect = h.next = h) : (w = m.lastEffect, w === null ? m.lastEffect = h.next = h : (O = w.next, w.next = h, h.next = O, m.lastEffect = h)), h
    }

    function U2() {
        return to().memoizedState
    }

    function Eg(h, m, w, O) {
        var K = Vs();
        yi.flags |= h, K.memoizedState = Am(1 | m, w, void 0, O === void 0 ? null : O)
    }

    function Tg(h, m, w, O) {
        var K = to();
        O = O === void 0 ? null : O;
        var ae = void 0;
        if (vo !== null) {
            var ge = vo.memoizedState;
            if (ae = ge.destroy, O !== null && Xr(O, ge.deps)) {
                K.memoizedState = Am(m, w, ae, O);
                return
            }
        }
        yi.flags |= h, K.memoizedState = Am(1 | m, w, ae, O)
    }

    function j2(h, m) {
        return Eg(8390656, 8, h, m)
    }

    function rb(h, m) {
        return Tg(2048, 8, h, m)
    }

    function z2(h, m) {
        return Tg(4, 2, h, m)
    }

    function nb(h, m) {
        return Tg(4, 4, h, m)
    }

    function Im(h, m) {
        if (typeof m == "function") return h = h(), m(h), function () {
            m(null)
        };
        if (m != null) return h = h(), m.current = h, function () {
            m.current = null
        }
    }

    function V2(h, m, w) {
        return w = w != null ? w.concat([h]) : null, Tg(4, 4, Im.bind(null, m, h), w)
    }

    function ib() {
    }

    function H2(h, m) {
        var w = to();
        m = m === void 0 ? null : m;
        var O = w.memoizedState;
        return O !== null && m !== null && Xr(m, O[1]) ? O[0] : (w.memoizedState = [h, m], h)
    }

    function W2(h, m) {
        var w = to();
        m = m === void 0 ? null : m;
        var O = w.memoizedState;
        return O !== null && m !== null && Xr(m, O[1]) ? O[0] : (h = h(), w.memoizedState = [h, m], h)
    }

    function s6(h, m, w) {
        return Gi & 21 ? (vf(w, m) || (w = lh(), yi.lanes |= w, bd |= w, h.baseState = !0), m) : (h.baseState && (h.baseState = !1, go = !0), h.memoizedState = w)
    }

    function ab(h, m) {
        var w = Bn;
        Bn = w !== 0 && 4 > w ? w : 4, h(!0);
        var O = gi.transition;
        gi.transition = {};
        try {
            h(!1), m()
        } finally {
            Bn = w, gi.transition = O
        }
    }

    function c6() {
        return to().memoizedState
    }

    function ob(h, m, w) {
        var O = wd(h);
        if (w = {
            lane: O,
            action: w,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, tl(h)) Ik(m, w); else if (w = n6(h, m, w, O), w !== null) {
            var K = wo();
            bc(w, h, O, K), ea(w, m, O)
        }
    }

    function km(h, m, w) {
        var O = wd(h), K = {lane: O, action: w, hasEagerState: !1, eagerState: null, next: null};
        if (tl(h)) Ik(m, K); else {
            var ae = h.alternate;
            if (h.lanes === 0 && (ae === null || ae.lanes === 0) && (ae = m.lastRenderedReducer, ae !== null)) try {
                var ge = m.lastRenderedState, Re = ae(ge, w);
                if (K.hasEagerState = !0, K.eagerState = Re, vf(Re, ge)) {
                    var Pe = m.interleaved;
                    Pe === null ? (K.next = K, r6(m)) : (K.next = Pe.next, Pe.next = K), m.interleaved = K;
                    return
                }
            } catch {
            } finally {
            }
            w = n6(h, m, K, O), w !== null && (K = wo(), bc(w, h, O, K), ea(w, m, O))
        }
    }

    function tl(h) {
        var m = h.alternate;
        return h === yi || m !== null && m === yi
    }

    function Ik(h, m) {
        tb = D2 = !0;
        var w = h.pending;
        w === null ? m.next = m : (m.next = w.next, w.next = m), h.pending = m
    }

    function ea(h, m, w) {
        if (w & 4194240) {
            var O = m.lanes;
            O &= h.pendingLanes, w |= O, m.lanes = w, $l(h, w)
        }
    }

    var Rm = {
        readContext: Ru,
        useCallback: pi,
        useContext: pi,
        useEffect: pi,
        useImperativeHandle: pi,
        useInsertionEffect: pi,
        useLayoutEffect: pi,
        useMemo: pi,
        useReducer: pi,
        useRef: pi,
        useState: pi,
        useDebugValue: pi,
        useDeferredValue: pi,
        useTransition: pi,
        useMutableSource: pi,
        useSyncExternalStore: pi,
        useId: pi,
        unstable_isNewReconciler: !1
    }, q2 = {
        readContext: Ru, useCallback: function (h, m) {
            return Vs().memoizedState = [h, m === void 0 ? null : m], h
        }, useContext: Ru, useEffect: j2, useImperativeHandle: function (h, m, w) {
            return w = w != null ? w.concat([h]) : null, Eg(4194308, 4, Im.bind(null, m, h), w)
        }, useLayoutEffect: function (h, m) {
            return Eg(4194308, 4, h, m)
        }, useInsertionEffect: function (h, m) {
            return Eg(4, 2, h, m)
        }, useMemo: function (h, m) {
            var w = Vs();
            return m = m === void 0 ? null : m, h = h(), w.memoizedState = [h, m], h
        }, useReducer: function (h, m, w) {
            var O = Vs();
            return m = w !== void 0 ? w(m) : m, O.memoizedState = O.baseState = m, h = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: h,
                lastRenderedState: m
            }, O.queue = h, h = h.dispatch = ob.bind(null, yi, h), [O.memoizedState, h]
        }, useRef: function (h) {
            var m = Vs();
            return h = {current: h}, m.memoizedState = h
        }, useState: F2, useDebugValue: ib, useDeferredValue: function (h) {
            return Vs().memoizedState = h
        }, useTransition: function () {
            var h = F2(!1), m = h[0];
            return h = ab.bind(null, h[1]), Vs().memoizedState = h, [m, h]
        }, useMutableSource: function () {
        }, useSyncExternalStore: function (h, m, w) {
            var O = yi, K = Vs();
            if (Sa) {
                if (w === void 0) throw Error(r(407));
                w = w()
            } else {
                if (w = m(), $o === null) throw Error(r(349));
                Gi & 30 || P2(O, m, w)
            }
            K.memoizedState = w;
            var ae = {value: w, getSnapshot: m};
            return K.queue = ae, j2(L2.bind(null, O, ae, h), [h]), O.flags |= 2048, Am(9, N2.bind(null, O, ae, w, m), void 0, null), w
        }, useId: function () {
            var h = Vs(), m = $o.identifierPrefix;
            if (Sa) {
                var w = pd, O = hd;
                w = (O & ~(1 << 32 - Pa(O) - 1)).toString(32) + w, m = ":" + m + "R" + w, w = Tm++, 0 < w && (m += "H" + w.toString(32)), m += ":"
            } else w = mt++, m = ":" + m + "r" + w.toString(32) + ":";
            return h.memoizedState = m
        }, unstable_isNewReconciler: !1
    }, sb = {
        readContext: Ru,
        useCallback: H2,
        useContext: Ru,
        useEffect: rb,
        useImperativeHandle: V2,
        useInsertionEffect: z2,
        useLayoutEffect: nb,
        useMemo: W2,
        useReducer: zp,
        useRef: U2,
        useState: function () {
            return zp(_h)
        },
        useDebugValue: ib,
        useDeferredValue: function (h) {
            var m = to();
            return s6(m, vo.memoizedState, h)
        },
        useTransition: function () {
            var h = zp(_h)[0], m = to().memoizedState;
            return [h, m]
        },
        useMutableSource: M2,
        useSyncExternalStore: O2,
        useId: c6,
        unstable_isNewReconciler: !1
    }, G2 = {
        readContext: Ru,
        useCallback: H2,
        useContext: Ru,
        useEffect: rb,
        useImperativeHandle: V2,
        useInsertionEffect: z2,
        useLayoutEffect: nb,
        useMemo: W2,
        useReducer: Cm,
        useRef: U2,
        useState: function () {
            return Cm(_h)
        },
        useDebugValue: ib,
        useDeferredValue: function (h) {
            var m = to();
            return vo === null ? m.memoizedState = h : s6(m, vo.memoizedState, h)
        },
        useTransition: function () {
            var h = Cm(_h)[0], m = to().memoizedState;
            return [h, m]
        },
        useMutableSource: M2,
        useSyncExternalStore: O2,
        useId: c6,
        unstable_isNewReconciler: !1
    };

    function wf(h, m) {
        if (h && h.defaultProps) {
            m = C({}, m), h = h.defaultProps;
            for (var w in h) m[w] === void 0 && (m[w] = h[w]);
            return m
        }
        return m
    }

    function l6(h, m, w, O) {
        m = h.memoizedState, w = w(O, m), w = w == null ? m : C({}, m, w), h.memoizedState = w, h.lanes === 0 && (h.updateQueue.baseState = w)
    }

    var K2 = {
        isMounted: function (h) {
            return (h = h._reactInternals) ? xt(h) === h : !1
        }, enqueueSetState: function (h, m, w) {
            h = h._reactInternals;
            var O = wo(), K = wd(h), ae = Sh(O, K);
            ae.payload = m, w != null && (ae.callback = w), m = Up(h, ae, K), m !== null && (bc(m, h, K, O), I2(m, h, K))
        }, enqueueReplaceState: function (h, m, w) {
            h = h._reactInternals;
            var O = wo(), K = wd(h), ae = Sh(O, K);
            ae.tag = 1, ae.payload = m, w != null && (ae.callback = w), m = Up(h, ae, K), m !== null && (bc(m, h, K, O), I2(m, h, K))
        }, enqueueForceUpdate: function (h, m) {
            h = h._reactInternals;
            var w = wo(), O = wd(h), K = Sh(w, O);
            K.tag = 2, m != null && (K.callback = m), m = Up(h, K, O), m !== null && (bc(m, h, O, w), I2(m, h, O))
        }
    };

    function kk(h, m, w, O, K, ae, ge) {
        return h = h.stateNode, typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(O, ae, ge) : m.prototype && m.prototype.isPureReactComponent ? !U1(w, O) || !U1(K, ae) : !0
    }

    function Y2(h, m, w) {
        var O = !1, K = pc, ae = m.contextType;
        return typeof ae == "object" && ae !== null ? ae = Ru(ae) : (K = ps(m) ? mc : Ha.current, O = m.contextTypes, ae = (O = O != null) ? Au(h, K) : pc), m = new m(w, ae), h.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = K2, h.stateNode = m, m._reactInternals = h, O && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = K, h.__reactInternalMemoizedMaskedChildContext = ae), m
    }

    function Rk(h, m, w, O) {
        h = m.state, typeof m.componentWillReceiveProps == "function" && m.componentWillReceiveProps(w, O), typeof m.UNSAFE_componentWillReceiveProps == "function" && m.UNSAFE_componentWillReceiveProps(w, O), m.state !== h && K2.enqueueReplaceState(m, m.state, null)
    }

    function cb(h, m, w, O) {
        var K = h.stateNode;
        K.props = w, K.state = h.memoizedState, K.refs = {}, i6(h);
        var ae = m.contextType;
        typeof ae == "object" && ae !== null ? K.context = Ru(ae) : (ae = ps(m) ? mc : Ha.current, K.context = Au(h, ae)), K.state = h.memoizedState, ae = m.getDerivedStateFromProps, typeof ae == "function" && (l6(h, m, ae, w), K.state = h.memoizedState), typeof m.getDerivedStateFromProps == "function" || typeof K.getSnapshotBeforeUpdate == "function" || typeof K.UNSAFE_componentWillMount != "function" && typeof K.componentWillMount != "function" || (m = K.state, typeof K.componentWillMount == "function" && K.componentWillMount(), typeof K.UNSAFE_componentWillMount == "function" && K.UNSAFE_componentWillMount(), m !== K.state && K2.enqueueReplaceState(K, K.state, null), X1(h, w, K, O), K.state = h.memoizedState), typeof K.componentDidMount == "function" && (h.flags |= 4194308)
    }

    function Dm(h, m) {
        try {
            var w = "", O = m;
            do w += ye(O), O = O.return; while (O);
            var K = w
        } catch (ae) {
            K = `
Error generating stack: ` + ae.message + `
` + ae.stack
        }
        return {value: h, source: m, stack: K, digest: null}
    }

    function u6(h, m, w) {
        return {value: h, source: null, stack: w ?? null, digest: m ?? null}
    }

    function f6(h, m) {
        try {
            console.error(m.value)
        } catch (w) {
            setTimeout(function () {
                throw w
            })
        }
    }

    var X2 = typeof WeakMap == "function" ? WeakMap : Map;

    function Dk(h, m, w) {
        w = Sh(-1, w), w.tag = 3, w.payload = {element: null};
        var O = m.value;
        return w.callback = function () {
            Dg || (Dg = !0, Pm = O), f6(h, m)
        }, w
    }

    function d6(h, m, w) {
        w = Sh(-1, w), w.tag = 3;
        var O = h.type.getDerivedStateFromError;
        if (typeof O == "function") {
            var K = m.value;
            w.payload = function () {
                return O(K)
            }, w.callback = function () {
                f6(h, m)
            }
        }
        var ae = h.stateNode;
        return ae !== null && typeof ae.componentDidCatch == "function" && (w.callback = function () {
            f6(h, m), typeof O != "function" && (Wp === null ? Wp = new Set([this]) : Wp.add(this));
            var ge = m.stack;
            this.componentDidCatch(m.value, {componentStack: ge !== null ? ge : ""})
        }), w
    }

    function h6(h, m, w) {
        var O = h.pingCache;
        if (O === null) {
            O = h.pingCache = new X2;
            var K = new Set;
            O.set(m, K)
        } else K = O.get(m), K === void 0 && (K = new Set, O.set(m, K));
        K.has(w) || (K.add(w), h = e$.bind(null, h, m, w), m.then(h, h))
    }

    function Mk(h) {
        do {
            var m;
            if ((m = h.tag === 13) && (m = h.memoizedState, m = m !== null ? m.dehydrated !== null : !0), m) return h;
            h = h.return
        } while (h !== null);
        return null
    }

    function Vp(h, m, w, O, K) {
        return h.mode & 1 ? (h.flags |= 65536, h.lanes = K, h) : (h === m ? h.flags |= 65536 : (h.flags |= 128, w.flags |= 131072, w.flags &= -52805, w.tag === 1 && (w.alternate === null ? w.tag = 17 : (m = Sh(-1, 1), m.tag = 2, Up(w, m, 1))), w.lanes |= 1), h)
    }

    var lb = V.ReactCurrentOwner, go = !1;

    function ms(h, m, w, O) {
        m.child = h === null ? Wt(m, null, w, O) : eo(m, h.child, w, O)
    }

    function rl(h, m, w, O, K) {
        w = w.render;
        var ae = m.ref;
        return La(m, K), O = jp(h, m, w, O, ae, K), w = bf(), h !== null && !go ? (m.updateQueue = h.updateQueue, m.flags &= -2053, h.lanes &= ~K, Mu(h, m, K)) : (Sa && w && E2(m), m.flags |= 1, ms(h, m, O, K), m.child)
    }

    function Mm(h, m, w, O, K) {
        if (h === null) {
            var ae = w.type;
            return typeof ae == "function" && !A6(ae) && ae.defaultProps === void 0 && w.compare === null && w.defaultProps === void 0 ? (m.tag = 15, m.type = ae, vn(h, m, ae, O, K)) : (h = Tb(w.type, null, O, m, m.mode, K), h.ref = m.ref, h.return = m, m.child = h)
        }
        if (ae = h.child, !(h.lanes & K)) {
            var ge = ae.memoizedProps;
            if (w = w.compare, w = w !== null ? w : U1, w(ge, O) && h.ref === m.ref) return Mu(h, m, K)
        }
        return m.flags |= 1, h = Gp(ae, O), h.ref = m.ref, h.return = m, m.child = h
    }

    function vn(h, m, w, O, K) {
        if (h !== null) {
            var ae = h.memoizedProps;
            if (U1(ae, O) && h.ref === m.ref) if (go = !1, m.pendingProps = O = ae, (h.lanes & K) !== 0) h.flags & 131072 && (go = !0); else return m.lanes = h.lanes, Mu(h, m, K)
        }
        return Ok(h, m, w, O, K)
    }

    function ub(h, m, w) {
        var O = m.pendingProps, K = O.children, ae = h !== null ? h.memoizedState : null;
        if (O.mode === "hidden") if (!(m.mode & 1)) m.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, ai(Ig, Vl), Vl |= w; else {
            if (!(w & 1073741824)) return h = ae !== null ? ae.baseLanes | w : w, m.lanes = m.childLanes = 1073741824, m.memoizedState = {
                baseLanes: h,
                cachePool: null,
                transitions: null
            }, m.updateQueue = null, ai(Ig, Vl), Vl |= h, null;
            m.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, O = ae !== null ? ae.baseLanes : w, ai(Ig, Vl), Vl |= O
        } else ae !== null ? (O = ae.baseLanes | w, m.memoizedState = null) : O = w, ai(Ig, Vl), Vl |= O;
        return ms(h, m, K, w), m.child
    }

    function p6(h, m) {
        var w = m.ref;
        (h === null && w !== null || h !== null && h.ref !== w) && (m.flags |= 512, m.flags |= 2097152)
    }

    function Ok(h, m, w, O, K) {
        var ae = ps(w) ? mc : Ha.current;
        return ae = Au(m, ae), La(m, K), w = jp(h, m, w, O, ae, K), O = bf(), h !== null && !go ? (m.updateQueue = h.updateQueue, m.flags &= -2053, h.lanes &= ~K, Mu(h, m, K)) : (Sa && O && E2(m), m.flags |= 1, ms(h, m, w, K), m.child)
    }

    function Pk(h, m, w, O, K) {
        if (ps(w)) {
            var ae = !0;
            Xo(m)
        } else ae = !1;
        if (La(m, K), m.stateNode === null) Du(h, m), Y2(m, w, O), cb(m, w, O, K), O = !0; else if (h === null) {
            var ge = m.stateNode, Re = m.memoizedProps;
            ge.props = Re;
            var Pe = ge.context, et = w.contextType;
            typeof et == "object" && et !== null ? et = Ru(et) : (et = ps(w) ? mc : Ha.current, et = Au(m, et));
            var wt = w.getDerivedStateFromProps,
                Ct = typeof wt == "function" || typeof ge.getSnapshotBeforeUpdate == "function";
            Ct || typeof ge.UNSAFE_componentWillReceiveProps != "function" && typeof ge.componentWillReceiveProps != "function" || (Re !== O || Pe !== et) && Rk(m, ge, O, et), zl = !1;
            var vt = m.memoizedState;
            ge.state = vt, X1(m, O, ge, K), Pe = m.memoizedState, Re !== O || vt !== Pe || wa.current || zl ? (typeof wt == "function" && (l6(m, w, wt, O), Pe = m.memoizedState), (Re = zl || kk(m, w, Re, O, vt, Pe, et)) ? (Ct || typeof ge.UNSAFE_componentWillMount != "function" && typeof ge.componentWillMount != "function" || (typeof ge.componentWillMount == "function" && ge.componentWillMount(), typeof ge.UNSAFE_componentWillMount == "function" && ge.UNSAFE_componentWillMount()), typeof ge.componentDidMount == "function" && (m.flags |= 4194308)) : (typeof ge.componentDidMount == "function" && (m.flags |= 4194308), m.memoizedProps = O, m.memoizedState = Pe), ge.props = O, ge.state = Pe, ge.context = et, O = Re) : (typeof ge.componentDidMount == "function" && (m.flags |= 4194308), O = !1)
        } else {
            ge = m.stateNode, Tk(h, m), Re = m.memoizedProps, et = m.type === m.elementType ? Re : wf(m.type, Re), ge.props = et, Ct = m.pendingProps, vt = ge.context, Pe = w.contextType, typeof Pe == "object" && Pe !== null ? Pe = Ru(Pe) : (Pe = ps(w) ? mc : Ha.current, Pe = Au(m, Pe));
            var Zt = w.getDerivedStateFromProps;
            (wt = typeof Zt == "function" || typeof ge.getSnapshotBeforeUpdate == "function") || typeof ge.UNSAFE_componentWillReceiveProps != "function" && typeof ge.componentWillReceiveProps != "function" || (Re !== Ct || vt !== Pe) && Rk(m, ge, O, Pe), zl = !1, vt = m.memoizedState, ge.state = vt, X1(m, O, ge, K);
            var dr = m.memoizedState;
            Re !== Ct || vt !== dr || wa.current || zl ? (typeof Zt == "function" && (l6(m, w, Zt, O), dr = m.memoizedState), (et = zl || kk(m, w, et, O, vt, dr, Pe) || !1) ? (wt || typeof ge.UNSAFE_componentWillUpdate != "function" && typeof ge.componentWillUpdate != "function" || (typeof ge.componentWillUpdate == "function" && ge.componentWillUpdate(O, dr, Pe), typeof ge.UNSAFE_componentWillUpdate == "function" && ge.UNSAFE_componentWillUpdate(O, dr, Pe)), typeof ge.componentDidUpdate == "function" && (m.flags |= 4), typeof ge.getSnapshotBeforeUpdate == "function" && (m.flags |= 1024)) : (typeof ge.componentDidUpdate != "function" || Re === h.memoizedProps && vt === h.memoizedState || (m.flags |= 4), typeof ge.getSnapshotBeforeUpdate != "function" || Re === h.memoizedProps && vt === h.memoizedState || (m.flags |= 1024), m.memoizedProps = O, m.memoizedState = dr), ge.props = O, ge.state = dr, ge.context = Pe, O = et) : (typeof ge.componentDidUpdate != "function" || Re === h.memoizedProps && vt === h.memoizedState || (m.flags |= 4), typeof ge.getSnapshotBeforeUpdate != "function" || Re === h.memoizedProps && vt === h.memoizedState || (m.flags |= 1024), O = !1)
        }
        return fb(h, m, w, O, ae, K)
    }

    function fb(h, m, w, O, K, ae) {
        p6(h, m);
        var ge = (m.flags & 128) !== 0;
        if (!O && !ge) return K && _2(m, w, !1), Mu(h, m, ae);
        O = m.stateNode, lb.current = m;
        var Re = ge && typeof w.getDerivedStateFromError != "function" ? null : O.render();
        return m.flags |= 1, h !== null && ge ? (m.child = eo(m, h.child, null, ae), m.child = eo(m, null, Re, ae)) : ms(h, m, Re, ae), m.memoizedState = O.state, K && _2(m, w, !0), m.child
    }

    function Cg(h) {
        var m = h.stateNode;
        m.pendingContext ? Sk(h, m.pendingContext, m.pendingContext !== m.context) : m.context && Sk(h, m.context, !1), o6(h, m.containerInfo)
    }

    function Nk(h, m, w, O, K) {
        return Fp(), wh(K), m.flags |= 256, ms(h, m, w, O), m.child
    }

    var Q2 = {dehydrated: null, treeContext: null, retryLane: 0};

    function m6(h) {
        return {baseLanes: h, cachePool: null, transitions: null}
    }

    function Z2(h, m, w) {
        var O = m.pendingProps, K = Ba.current, ae = !1, ge = (m.flags & 128) !== 0, Re;
        if ((Re = ge) || (Re = h !== null && h.memoizedState === null ? !1 : (K & 2) !== 0), Re ? (ae = !0, m.flags &= -129) : (h === null || h.memoizedState !== null) && (K |= 1), ai(Ba, K & 1), h === null) return Q3(m), h = m.memoizedState, h !== null && (h = h.dehydrated, h !== null) ? (m.mode & 1 ? h.data === "$!" ? m.lanes = 8 : m.lanes = 1073741824 : m.lanes = 1, null) : (ge = O.children, h = O.fallback, ae ? (O = m.mode, ae = m.child, ge = {
            mode: "hidden",
            children: ge
        }, !(O & 1) && ae !== null ? (ae.childLanes = 0, ae.pendingProps = ge) : ae = Kp(ge, O, 0, null), h = Ch(h, O, w, null), ae.return = m, h.return = m, ae.sibling = h, m.child = ae, m.child.memoizedState = m6(w), m.memoizedState = Q2, h) : v6(m, ge));
        if (K = h.memoizedState, K !== null && (Re = K.dehydrated, Re !== null)) return Lk(h, m, ge, O, Re, K, w);
        if (ae) {
            ae = O.fallback, ge = m.mode, K = h.child, Re = K.sibling;
            var Pe = {mode: "hidden", children: O.children};
            return !(ge & 1) && m.child !== K ? (O = m.child, O.childLanes = 0, O.pendingProps = Pe, m.deletions = null) : (O = Gp(K, Pe), O.subtreeFlags = K.subtreeFlags & 14680064), Re !== null ? ae = Gp(Re, ae) : (ae = Ch(ae, ge, w, null), ae.flags |= 2), ae.return = m, O.return = m, O.sibling = ae, m.child = O, O = ae, ae = m.child, ge = h.child.memoizedState, ge = ge === null ? m6(w) : {
                baseLanes: ge.baseLanes | w,
                cachePool: null,
                transitions: ge.transitions
            }, ae.memoizedState = ge, ae.childLanes = h.childLanes & ~w, m.memoizedState = Q2, O
        }
        return ae = h.child, h = ae.sibling, O = Gp(ae, {
            mode: "visible",
            children: O.children
        }), !(m.mode & 1) && (O.lanes = w), O.return = m, O.sibling = null, h !== null && (w = m.deletions, w === null ? (m.deletions = [h], m.flags |= 16) : w.push(h)), m.child = O, m.memoizedState = null, O
    }

    function v6(h, m) {
        return m = Kp({mode: "visible", children: m}, h.mode, 0, null), m.return = h, h.child = m
    }

    function db(h, m, w, O) {
        return O !== null && wh(O), eo(m, h.child, null, w), h = v6(m, m.pendingProps.children), h.flags |= 2, m.memoizedState = null, h
    }

    function Lk(h, m, w, O, K, ae, ge) {
        if (w) return m.flags & 256 ? (m.flags &= -257, O = u6(Error(r(422))), db(h, m, ge, O)) : m.memoizedState !== null ? (m.child = h.child, m.flags |= 128, null) : (ae = O.fallback, K = m.mode, O = Kp({
            mode: "visible",
            children: O.children
        }, K, 0, null), ae = Ch(ae, K, ge, null), ae.flags |= 2, O.return = m, ae.return = m, O.sibling = ae, m.child = O, m.mode & 1 && eo(m, h.child, null, ge), m.child.memoizedState = m6(ge), m.memoizedState = Q2, ae);
        if (!(m.mode & 1)) return db(h, m, ge, null);
        if (K.data === "$!") {
            if (O = K.nextSibling && K.nextSibling.dataset, O) var Re = O.dgst;
            return O = Re, ae = Error(r(419)), O = u6(ae, O, void 0), db(h, m, ge, O)
        }
        if (Re = (ge & h.childLanes) !== 0, go || Re) {
            if (O = $o, O !== null) {
                switch (ge & -ge) {
                    case 4:
                        K = 2;
                        break;
                    case 16:
                        K = 8;
                        break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        K = 32;
                        break;
                    case 536870912:
                        K = 268435456;
                        break;
                    default:
                        K = 0
                }
                K = K & (O.suspendedLanes | ge) ? 0 : K, K !== 0 && K !== ae.retryLane && (ae.retryLane = K, jl(h, K), bc(O, h, K, -1))
            }
            return C6(), O = u6(Error(r(421))), db(h, m, ge, O)
        }
        return K.data === "$?" ? (m.flags |= 128, m.child = h.child, m = t$.bind(null, h), K._reactRetry = m, null) : (h = ae.treeContext, Jc = Pp(K.nextSibling), Zc = m, Sa = !0, ku = null, h !== null && (mo[Iu++] = hd, mo[Iu++] = pd, mo[Iu++] = Fl, hd = h.id, pd = h.overflow, Fl = m), m = v6(m, O.children), m.flags |= 4096, m)
    }

    function g6(h, m, w) {
        h.lanes |= m;
        var O = h.alternate;
        O !== null && (O.lanes |= m), t6(h.return, m, w)
    }

    function vc(h, m, w, O, K) {
        var ae = h.memoizedState;
        ae === null ? h.memoizedState = {
            isBackwards: m,
            rendering: null,
            renderingStartTime: 0,
            last: O,
            tail: w,
            tailMode: K
        } : (ae.isBackwards = m, ae.rendering = null, ae.renderingStartTime = 0, ae.last = O, ae.tail = w, ae.tailMode = K)
    }

    function vd(h, m, w) {
        var O = m.pendingProps, K = O.revealOrder, ae = O.tail;
        if (ms(h, m, O.children, w), O = Ba.current, O & 2) O = O & 1 | 2, m.flags |= 128; else {
            if (h !== null && h.flags & 128) e:for (h = m.child; h !== null;) {
                if (h.tag === 13) h.memoizedState !== null && g6(h, w, m); else if (h.tag === 19) g6(h, w, m); else if (h.child !== null) {
                    h.child.return = h, h = h.child;
                    continue
                }
                if (h === m) break e;
                for (; h.sibling === null;) {
                    if (h.return === null || h.return === m) break e;
                    h = h.return
                }
                h.sibling.return = h.return, h = h.sibling
            }
            O &= 1
        }
        if (ai(Ba, O), !(m.mode & 1)) m.memoizedState = null; else switch (K) {
            case"forwards":
                for (w = m.child, K = null; w !== null;) h = w.alternate, h !== null && R2(h) === null && (K = w), w = w.sibling;
                w = K, w === null ? (K = m.child, m.child = null) : (K = w.sibling, w.sibling = null), vc(m, !1, K, w, ae);
                break;
            case"backwards":
                for (w = null, K = m.child, m.child = null; K !== null;) {
                    if (h = K.alternate, h !== null && R2(h) === null) {
                        m.child = K;
                        break
                    }
                    h = K.sibling, K.sibling = w, w = K, K = h
                }
                vc(m, !0, w, null, ae);
                break;
            case"together":
                vc(m, !1, null, null, void 0);
                break;
            default:
                m.memoizedState = null
        }
        return m.child
    }

    function Du(h, m) {
        !(m.mode & 1) && h !== null && (h.alternate = null, m.alternate = null, m.flags |= 2)
    }

    function Mu(h, m, w) {
        if (h !== null && (m.dependencies = h.dependencies), bd |= m.lanes, !(w & m.childLanes)) return null;
        if (h !== null && m.child !== h.child) throw Error(r(153));
        if (m.child !== null) {
            for (h = m.child, w = Gp(h, h.pendingProps), m.child = w, w.return = m; h.sibling !== null;) h = h.sibling, w = w.sibling = Gp(h, h.pendingProps), w.return = m;
            w.sibling = null
        }
        return m.child
    }

    function hb(h, m, w) {
        switch (m.tag) {
            case 3:
                Cg(m), Fp();
                break;
            case 5:
                Ak(m);
                break;
            case 1:
                ps(m.type) && Xo(m);
                break;
            case 4:
                o6(m, m.stateNode.containerInfo);
                break;
            case 10:
                var O = m.type._context, K = m.memoizedProps.value;
                ai(Ul, O._currentValue), O._currentValue = K;
                break;
            case 13:
                if (O = m.memoizedState, O !== null) return O.dehydrated !== null ? (ai(Ba, Ba.current & 1), m.flags |= 128, null) : w & m.child.childLanes ? Z2(h, m, w) : (ai(Ba, Ba.current & 1), h = Mu(h, m, w), h !== null ? h.sibling : null);
                ai(Ba, Ba.current & 1);
                break;
            case 19:
                if (O = (w & m.childLanes) !== 0, h.flags & 128) {
                    if (O) return vd(h, m, w);
                    m.flags |= 128
                }
                if (K = m.memoizedState, K !== null && (K.rendering = null, K.tail = null, K.lastEffect = null), ai(Ba, Ba.current), O) break;
                return null;
            case 22:
            case 23:
                return m.lanes = 0, ub(h, m, w)
        }
        return Mu(h, m, w)
    }

    var Ou, yo, Bk, $k;
    Ou = function (h, m) {
        for (var w = m.child; w !== null;) {
            if (w.tag === 5 || w.tag === 6) h.appendChild(w.stateNode); else if (w.tag !== 4 && w.child !== null) {
                w.child.return = w, w = w.child;
                continue
            }
            if (w === m) break;
            for (; w.sibling === null;) {
                if (w.return === null || w.return === m) return;
                w = w.return
            }
            w.sibling.return = w.return, w = w.sibling
        }
    }, yo = function () {
    }, Bk = function (h, m, w, O) {
        var K = h.memoizedProps;
        if (K !== O) {
            h = m.stateNode, xm(md.current);
            var ae = null;
            switch (w) {
                case"input":
                    K = Ee(h, K), O = Ee(h, O), ae = [];
                    break;
                case"select":
                    K = C({}, K, {value: void 0}), O = C({}, O, {value: void 0}), ae = [];
                    break;
                case"textarea":
                    K = Ot(h, K), O = Ot(h, O), ae = [];
                    break;
                default:
                    typeof K.onClick != "function" && typeof O.onClick == "function" && (h.onclick = bg)
            }
            De(w, O);
            var ge;
            w = null;
            for (et in K) if (!O.hasOwnProperty(et) && K.hasOwnProperty(et) && K[et] != null) if (et === "style") {
                var Re = K[et];
                for (ge in Re) Re.hasOwnProperty(ge) && (w || (w = {}), w[ge] = "")
            } else et !== "dangerouslySetInnerHTML" && et !== "children" && et !== "suppressContentEditableWarning" && et !== "suppressHydrationWarning" && et !== "autoFocus" && (i.hasOwnProperty(et) ? ae || (ae = []) : (ae = ae || []).push(et, null));
            for (et in O) {
                var Pe = O[et];
                if (Re = K != null ? K[et] : void 0, O.hasOwnProperty(et) && Pe !== Re && (Pe != null || Re != null)) if (et === "style") if (Re) {
                    for (ge in Re) !Re.hasOwnProperty(ge) || Pe && Pe.hasOwnProperty(ge) || (w || (w = {}), w[ge] = "");
                    for (ge in Pe) Pe.hasOwnProperty(ge) && Re[ge] !== Pe[ge] && (w || (w = {}), w[ge] = Pe[ge])
                } else w || (ae || (ae = []), ae.push(et, w)), w = Pe; else et === "dangerouslySetInnerHTML" ? (Pe = Pe ? Pe.__html : void 0, Re = Re ? Re.__html : void 0, Pe != null && Re !== Pe && (ae = ae || []).push(et, Pe)) : et === "children" ? typeof Pe != "string" && typeof Pe != "number" || (ae = ae || []).push(et, "" + Pe) : et !== "suppressContentEditableWarning" && et !== "suppressHydrationWarning" && (i.hasOwnProperty(et) ? (Pe != null && et === "onScroll" && ca("scroll", h), ae || Re === Pe || (ae = [])) : (ae = ae || []).push(et, Pe))
            }
            w && (ae = ae || []).push("style", w);
            var et = ae;
            (m.updateQueue = et) && (m.flags |= 4)
        }
    }, $k = function (h, m, w, O) {
        w !== O && (m.flags |= 4)
    };

    function pb(h, m) {
        if (!Sa) switch (h.tailMode) {
            case"hidden":
                m = h.tail;
                for (var w = null; m !== null;) m.alternate !== null && (w = m), m = m.sibling;
                w === null ? h.tail = null : w.sibling = null;
                break;
            case"collapsed":
                w = h.tail;
                for (var O = null; w !== null;) w.alternate !== null && (O = w), w = w.sibling;
                O === null ? m || h.tail === null ? h.tail = null : h.tail.sibling = null : O.sibling = null
        }
    }

    function Zo(h) {
        var m = h.alternate !== null && h.alternate.child === h.child, w = 0, O = 0;
        if (m) for (var K = h.child; K !== null;) w |= K.lanes | K.childLanes, O |= K.subtreeFlags & 14680064, O |= K.flags & 14680064, K.return = h, K = K.sibling; else for (K = h.child; K !== null;) w |= K.lanes | K.childLanes, O |= K.subtreeFlags, O |= K.flags, K.return = h, K = K.sibling;
        return h.subtreeFlags |= O, h.childLanes = w, m
    }

    function Fk(h, m, w) {
        var O = m.pendingProps;
        switch (T2(m), m.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return Zo(m), null;
            case 1:
                return ps(m.type) && S2(), Zo(m), null;
            case 3:
                return O = m.stateNode, Em(), Mr(wa), Mr(Ha), $r(), O.pendingContext && (O.context = O.pendingContext, O.pendingContext = null), (h === null || h.child === null) && (C2(m) ? m.flags |= 4 : h === null || h.memoizedState.isDehydrated && !(m.flags & 256) || (m.flags |= 1024, ku !== null && (Nm(ku), ku = null))), yo(h, m), Zo(m), null;
            case 5:
                k2(m);
                var K = xm(J1.current);
                if (w = m.type, h !== null && m.stateNode != null) Bk(h, m, w, O, K), h.ref !== m.ref && (m.flags |= 512, m.flags |= 2097152); else {
                    if (!O) {
                        if (m.stateNode === null) throw Error(r(166));
                        return Zo(m), null
                    }
                    if (h = xm(md.current), C2(m)) {
                        O = m.stateNode, w = m.type;
                        var ae = m.memoizedProps;
                        switch (O[cd] = m, O[K1] = ae, h = (m.mode & 1) !== 0, w) {
                            case"dialog":
                                ca("cancel", O), ca("close", O);
                                break;
                            case"iframe":
                            case"object":
                            case"embed":
                                ca("load", O);
                                break;
                            case"video":
                            case"audio":
                                for (K = 0; K < pm.length; K++) ca(pm[K], O);
                                break;
                            case"source":
                                ca("error", O);
                                break;
                            case"img":
                            case"image":
                            case"link":
                                ca("error", O), ca("load", O);
                                break;
                            case"details":
                                ca("toggle", O);
                                break;
                            case"input":
                                Oe(O, ae), ca("invalid", O);
                                break;
                            case"select":
                                O._wrapperState = {wasMultiple: !!ae.multiple}, ca("invalid", O);
                                break;
                            case"textarea":
                                zt(O, ae), ca("invalid", O)
                        }
                        De(w, ae), K = null;
                        for (var ge in ae) if (ae.hasOwnProperty(ge)) {
                            var Re = ae[ge];
                            ge === "children" ? typeof Re == "string" ? O.textContent !== Re && (ae.suppressHydrationWarning !== !0 && Op(O.textContent, Re, h), K = ["children", Re]) : typeof Re == "number" && O.textContent !== "" + Re && (ae.suppressHydrationWarning !== !0 && Op(O.textContent, Re, h), K = ["children", "" + Re]) : i.hasOwnProperty(ge) && Re != null && ge === "onScroll" && ca("scroll", O)
                        }
                        switch (w) {
                            case"input":
                                ve(O), it(O, ae, !0);
                                break;
                            case"textarea":
                                ve(O), Dt(O);
                                break;
                            case"select":
                            case"option":
                                break;
                            default:
                                typeof ae.onClick == "function" && (O.onclick = bg)
                        }
                        O = K, m.updateQueue = O, O !== null && (m.flags |= 4)
                    } else {
                        ge = K.nodeType === 9 ? K : K.ownerDocument, h === "http://www.w3.org/1999/xhtml" && (h = rr(w)), h === "http://www.w3.org/1999/xhtml" ? w === "script" ? (h = ge.createElement("div"), h.innerHTML = "<script><\/script>", h = h.removeChild(h.firstChild)) : typeof O.is == "string" ? h = ge.createElement(w, {is: O.is}) : (h = ge.createElement(w), w === "select" && (ge = h, O.multiple ? ge.multiple = !0 : O.size && (ge.size = O.size))) : h = ge.createElementNS(h, w), h[cd] = m, h[K1] = O, Ou(h, m, !1, !1), m.stateNode = h;
                        e:{
                            switch (ge = Ze(w, O), w) {
                                case"dialog":
                                    ca("cancel", h), ca("close", h), K = O;
                                    break;
                                case"iframe":
                                case"object":
                                case"embed":
                                    ca("load", h), K = O;
                                    break;
                                case"video":
                                case"audio":
                                    for (K = 0; K < pm.length; K++) ca(pm[K], h);
                                    K = O;
                                    break;
                                case"source":
                                    ca("error", h), K = O;
                                    break;
                                case"img":
                                case"image":
                                case"link":
                                    ca("error", h), ca("load", h), K = O;
                                    break;
                                case"details":
                                    ca("toggle", h), K = O;
                                    break;
                                case"input":
                                    Oe(h, O), K = Ee(h, O), ca("invalid", h);
                                    break;
                                case"option":
                                    K = O;
                                    break;
                                case"select":
                                    h._wrapperState = {wasMultiple: !!O.multiple}, K = C({}, O, {value: void 0}), ca("invalid", h);
                                    break;
                                case"textarea":
                                    zt(h, O), K = Ot(h, O), ca("invalid", h);
                                    break;
                                default:
                                    K = O
                            }
                            De(w, K), Re = K;
                            for (ae in Re) if (Re.hasOwnProperty(ae)) {
                                var Pe = Re[ae];
                                ae === "style" ? xe(h, Pe) : ae === "dangerouslySetInnerHTML" ? (Pe = Pe ? Pe.__html : void 0, Pe != null && X(h, Pe)) : ae === "children" ? typeof Pe == "string" ? (w !== "textarea" || Pe !== "") && H(h, Pe) : typeof Pe == "number" && H(h, "" + Pe) : ae !== "suppressContentEditableWarning" && ae !== "suppressHydrationWarning" && ae !== "autoFocus" && (i.hasOwnProperty(ae) ? Pe != null && ae === "onScroll" && ca("scroll", h) : Pe != null && F(h, ae, Pe, ge))
                            }
                            switch (w) {
                                case"input":
                                    ve(h), it(h, O, !1);
                                    break;
                                case"textarea":
                                    ve(h), Dt(h);
                                    break;
                                case"option":
                                    O.value != null && h.setAttribute("value", "" + Se(O.value));
                                    break;
                                case"select":
                                    h.multiple = !!O.multiple, ae = O.value, ae != null ? gt(h, !!O.multiple, ae, !1) : O.defaultValue != null && gt(h, !!O.multiple, O.defaultValue, !0);
                                    break;
                                default:
                                    typeof K.onClick == "function" && (h.onclick = bg)
                            }
                            switch (w) {
                                case"button":
                                case"input":
                                case"select":
                                case"textarea":
                                    O = !!O.autoFocus;
                                    break e;
                                case"img":
                                    O = !0;
                                    break e;
                                default:
                                    O = !1
                            }
                        }
                        O && (m.flags |= 4)
                    }
                    m.ref !== null && (m.flags |= 512, m.flags |= 2097152)
                }
                return Zo(m), null;
            case 6:
                if (h && m.stateNode != null) $k(h, m, h.memoizedProps, O); else {
                    if (typeof O != "string" && m.stateNode === null) throw Error(r(166));
                    if (w = xm(J1.current), xm(md.current), C2(m)) {
                        if (O = m.stateNode, w = m.memoizedProps, O[cd] = m, (ae = O.nodeValue !== w) && (h = Zc, h !== null)) switch (h.tag) {
                            case 3:
                                Op(O.nodeValue, w, (h.mode & 1) !== 0);
                                break;
                            case 5:
                                h.memoizedProps.suppressHydrationWarning !== !0 && Op(O.nodeValue, w, (h.mode & 1) !== 0)
                        }
                        ae && (m.flags |= 4)
                    } else O = (w.nodeType === 9 ? w : w.ownerDocument).createTextNode(O), O[cd] = m, m.stateNode = O
                }
                return Zo(m), null;
            case 13:
                if (Mr(Ba), O = m.memoizedState, h === null || h.memoizedState !== null && h.memoizedState.dehydrated !== null) {
                    if (Sa && Jc !== null && m.mode & 1 && !(m.flags & 128)) Y1(), Fp(), m.flags |= 98560, ae = !1; else if (ae = C2(m), O !== null && O.dehydrated !== null) {
                        if (h === null) {
                            if (!ae) throw Error(r(318));
                            if (ae = m.memoizedState, ae = ae !== null ? ae.dehydrated : null, !ae) throw Error(r(317));
                            ae[cd] = m
                        } else Fp(), !(m.flags & 128) && (m.memoizedState = null), m.flags |= 4;
                        Zo(m), ae = !1
                    } else ku !== null && (Nm(ku), ku = null), ae = !0;
                    if (!ae) return m.flags & 65536 ? m : null
                }
                return m.flags & 128 ? (m.lanes = w, m) : (O = O !== null, O !== (h !== null && h.memoizedState !== null) && O && (m.child.flags |= 8192, m.mode & 1 && (h === null || Ba.current & 1 ? no === 0 && (no = 3) : C6())), m.updateQueue !== null && (m.flags |= 4), Zo(m), null);
            case 4:
                return Em(), yo(h, m), h === null && W1(m.stateNode.containerInfo), Zo(m), null;
            case 10:
                return e6(m.type._context), Zo(m), null;
            case 17:
                return ps(m.type) && S2(), Zo(m), null;
            case 19:
                if (Mr(Ba), ae = m.memoizedState, ae === null) return Zo(m), null;
                if (O = (m.flags & 128) !== 0, ge = ae.rendering, ge === null) if (O) pb(ae, !1); else {
                    if (no !== 0 || h !== null && h.flags & 128) for (h = m.child; h !== null;) {
                        if (ge = R2(h), ge !== null) {
                            for (m.flags |= 128, pb(ae, !1), O = ge.updateQueue, O !== null && (m.updateQueue = O, m.flags |= 4), m.subtreeFlags = 0, O = w, w = m.child; w !== null;) ae = w, h = O, ae.flags &= 14680066, ge = ae.alternate, ge === null ? (ae.childLanes = 0, ae.lanes = h, ae.child = null, ae.subtreeFlags = 0, ae.memoizedProps = null, ae.memoizedState = null, ae.updateQueue = null, ae.dependencies = null, ae.stateNode = null) : (ae.childLanes = ge.childLanes, ae.lanes = ge.lanes, ae.child = ge.child, ae.subtreeFlags = 0, ae.deletions = null, ae.memoizedProps = ge.memoizedProps, ae.memoizedState = ge.memoizedState, ae.updateQueue = ge.updateQueue, ae.type = ge.type, h = ge.dependencies, ae.dependencies = h === null ? null : {
                                lanes: h.lanes,
                                firstContext: h.firstContext
                            }), w = w.sibling;
                            return ai(Ba, Ba.current & 1 | 2), m.child
                        }
                        h = h.sibling
                    }
                    ae.tail !== null && Pt() > Rg && (m.flags |= 128, O = !0, pb(ae, !1), m.lanes = 4194304)
                } else {
                    if (!O) if (h = R2(ge), h !== null) {
                        if (m.flags |= 128, O = !0, w = h.updateQueue, w !== null && (m.updateQueue = w, m.flags |= 4), pb(ae, !0), ae.tail === null && ae.tailMode === "hidden" && !ge.alternate && !Sa) return Zo(m), null
                    } else 2 * Pt() - ae.renderingStartTime > Rg && w !== 1073741824 && (m.flags |= 128, O = !0, pb(ae, !1), m.lanes = 4194304);
                    ae.isBackwards ? (ge.sibling = m.child, m.child = ge) : (w = ae.last, w !== null ? w.sibling = ge : m.child = ge, ae.last = ge)
                }
                return ae.tail !== null ? (m = ae.tail, ae.rendering = m, ae.tail = m.sibling, ae.renderingStartTime = Pt(), m.sibling = null, w = Ba.current, ai(Ba, O ? w & 1 | 2 : w & 1), m) : (Zo(m), null);
            case 22:
            case 23:
                return T6(), O = m.memoizedState !== null, h !== null && h.memoizedState !== null !== O && (m.flags |= 8192), O && m.mode & 1 ? Vl & 1073741824 && (Zo(m), m.subtreeFlags & 6 && (m.flags |= 8192)) : Zo(m), null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(r(156, m.tag))
    }

    function J2(h, m) {
        switch (T2(m), m.tag) {
            case 1:
                return ps(m.type) && S2(), h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
            case 3:
                return Em(), Mr(wa), Mr(Ha), $r(), h = m.flags, h & 65536 && !(h & 128) ? (m.flags = h & -65537 | 128, m) : null;
            case 5:
                return k2(m), null;
            case 13:
                if (Mr(Ba), h = m.memoizedState, h !== null && h.dehydrated !== null) {
                    if (m.alternate === null) throw Error(r(340));
                    Fp()
                }
                return h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
            case 19:
                return Mr(Ba), null;
            case 4:
                return Em(), null;
            case 10:
                return e6(m.type._context), null;
            case 22:
            case 23:
                return T6(), null;
            case 24:
                return null;
            default:
                return null
        }
    }

    var mb = !1, Hs = !1, KB = typeof WeakSet == "function" ? WeakSet : Set, nr = null;

    function Ag(h, m) {
        var w = h.ref;
        if (w !== null) if (typeof w == "function") try {
            w(null)
        } catch (O) {
            _a(h, m, O)
        } else w.current = null
    }

    function e_(h, m, w) {
        try {
            w()
        } catch (O) {
            _a(h, m, O)
        }
    }

    var Uk = !1;

    function jk(h, m) {
        if (gm = Cu, h = j3(), Dp(h)) {
            if ("selectionStart" in h) var w = {start: h.selectionStart, end: h.selectionEnd}; else {
                w = (w = h.ownerDocument) && w.defaultView || window;
                var O = w.getSelection && w.getSelection();
                if (O && O.rangeCount !== 0) {
                    w = O.anchorNode;
                    var K = O.anchorOffset, ae = O.focusNode;
                    O = O.focusOffset;
                    var ge = 0, Re = -1, Pe = -1, et = 0, wt = 0, Ct = h, vt = null;
                    e:for (; ;) {
                        for (var Zt; Ct !== w || K !== 0 && Ct.nodeType !== 3 || (Re = ge + K), Ct !== ae || O !== 0 && Ct.nodeType !== 3 || (Pe = ge + O), Ct.nodeType === 3 && (ge += Ct.nodeValue.length), (Zt = Ct.firstChild) !== null;) vt = Ct, Ct = Zt;
                        for (; ;) {
                            if (Ct === h) break e;
                            if (vt === w && ++et === K && (Re = ge), vt === ae && ++wt === O && (Pe = ge), (Zt = Ct.nextSibling) !== null) break;
                            Ct = vt, vt = Ct.parentNode
                        }
                        Ct = Zt
                    }
                    w = Re === -1 || Pe === -1 ? null : {start: Re, end: Pe}
                } else w = null
            }
            w = w || {start: 0, end: 0}
        } else w = null;
        for (v2 = {
            focusedElem: h,
            selectionRange: w
        }, Cu = !1, nr = m; nr !== null;) if (m = nr, h = m.child, (m.subtreeFlags & 1028) !== 0 && h !== null) h.return = m, nr = h; else for (; nr !== null;) {
            m = nr;
            try {
                var dr = m.alternate;
                if (m.flags & 1024) switch (m.tag) {
                    case 0:
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if (dr !== null) {
                            var gr = dr.memoizedProps, io = dr.memoizedState, He = m.stateNode,
                                $e = He.getSnapshotBeforeUpdate(m.elementType === m.type ? gr : wf(m.type, gr), io);
                            He.__reactInternalSnapshotBeforeUpdate = $e
                        }
                        break;
                    case 3:
                        var Ke = m.stateNode.containerInfo;
                        Ke.nodeType === 1 ? Ke.textContent = "" : Ke.nodeType === 9 && Ke.documentElement && Ke.removeChild(Ke.documentElement);
                        break;
                    case 5:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        throw Error(r(163))
                }
            } catch (St) {
                _a(m, m.return, St)
            }
            if (h = m.sibling, h !== null) {
                h.return = m.return, nr = h;
                break
            }
            nr = m.return
        }
        return dr = Uk, Uk = !1, dr
    }

    function vb(h, m, w) {
        var O = m.updateQueue;
        if (O = O !== null ? O.lastEffect : null, O !== null) {
            var K = O = O.next;
            do {
                if ((K.tag & h) === h) {
                    var ae = K.destroy;
                    K.destroy = void 0, ae !== void 0 && e_(m, w, ae)
                }
                K = K.next
            } while (K !== O)
        }
    }

    function gb(h, m) {
        if (m = m.updateQueue, m = m !== null ? m.lastEffect : null, m !== null) {
            var w = m = m.next;
            do {
                if ((w.tag & h) === h) {
                    var O = w.create;
                    w.destroy = O()
                }
                w = w.next
            } while (w !== m)
        }
    }

    function y6(h) {
        var m = h.ref;
        if (m !== null) {
            var w = h.stateNode;
            switch (h.tag) {
                case 5:
                    h = w;
                    break;
                default:
                    h = w
            }
            typeof m == "function" ? m(h) : m.current = h
        }
    }

    function t_(h) {
        var m = h.alternate;
        m !== null && (h.alternate = null, t_(m)), h.child = null, h.deletions = null, h.sibling = null, h.tag === 5 && (m = h.stateNode, m !== null && (delete m[cd], delete m[K1], delete m[Np], delete m[WB], delete m[qB])), h.stateNode = null, h.return = null, h.dependencies = null, h.memoizedProps = null, h.memoizedState = null, h.pendingProps = null, h.stateNode = null, h.updateQueue = null
    }

    function yb(h) {
        return h.tag === 5 || h.tag === 3 || h.tag === 4
    }

    function xh(h) {
        e:for (; ;) {
            for (; h.sibling === null;) {
                if (h.return === null || yb(h.return)) return null;
                h = h.return
            }
            for (h.sibling.return = h.return, h = h.sibling; h.tag !== 5 && h.tag !== 6 && h.tag !== 18;) {
                if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
                h.child.return = h, h = h.child
            }
            if (!(h.flags & 2)) return h.stateNode
        }
    }

    function gd(h, m, w) {
        var O = h.tag;
        if (O === 5 || O === 6) h = h.stateNode, m ? w.nodeType === 8 ? w.parentNode.insertBefore(h, m) : w.insertBefore(h, m) : (w.nodeType === 8 ? (m = w.parentNode, m.insertBefore(h, w)) : (m = w, m.appendChild(h)), w = w._reactRootContainer, w != null || m.onclick !== null || (m.onclick = bg)); else if (O !== 4 && (h = h.child, h !== null)) for (gd(h, m, w), h = h.sibling; h !== null;) gd(h, m, w), h = h.sibling
    }

    function yd(h, m, w) {
        var O = h.tag;
        if (O === 5 || O === 6) h = h.stateNode, m ? w.insertBefore(h, m) : w.appendChild(h); else if (O !== 4 && (h = h.child, h !== null)) for (yd(h, m, w), h = h.sibling; h !== null;) yd(h, m, w), h = h.sibling
    }

    var ro = null, gc = !1;

    function yc(h, m, w) {
        for (w = w.child; w !== null;) zk(h, m, w), w = w.sibling
    }

    function zk(h, m, w) {
        if (qi && typeof qi.onCommitFiberUnmount == "function") try {
            qi.onCommitFiberUnmount(Ja, w)
        } catch {
        }
        switch (w.tag) {
            case 5:
                Hs || Ag(w, m);
            case 6:
                var O = ro, K = gc;
                ro = null, yc(h, m, w), ro = O, gc = K, ro !== null && (gc ? (h = ro, w = w.stateNode, h.nodeType === 8 ? h.parentNode.removeChild(w) : h.removeChild(w)) : ro.removeChild(w.stateNode));
                break;
            case 18:
                ro !== null && (gc ? (h = ro, w = w.stateNode, h.nodeType === 8 ? G1(h.parentNode, w) : h.nodeType === 1 && G1(h, w), mf(h)) : G1(ro, w.stateNode));
                break;
            case 4:
                O = ro, K = gc, ro = w.stateNode.containerInfo, gc = !0, yc(h, m, w), ro = O, gc = K;
                break;
            case 0:
            case 11:
            case 14:
            case 15:
                if (!Hs && (O = w.updateQueue, O !== null && (O = O.lastEffect, O !== null))) {
                    K = O = O.next;
                    do {
                        var ae = K, ge = ae.destroy;
                        ae = ae.tag, ge !== void 0 && (ae & 2 || ae & 4) && e_(w, m, ge), K = K.next
                    } while (K !== O)
                }
                yc(h, m, w);
                break;
            case 1:
                if (!Hs && (Ag(w, m), O = w.stateNode, typeof O.componentWillUnmount == "function")) try {
                    O.props = w.memoizedProps, O.state = w.memoizedState, O.componentWillUnmount()
                } catch (Re) {
                    _a(w, m, Re)
                }
                yc(h, m, w);
                break;
            case 21:
                yc(h, m, w);
                break;
            case 22:
                w.mode & 1 ? (Hs = (O = Hs) || w.memoizedState !== null, yc(h, m, w), Hs = O) : yc(h, m, w);
                break;
            default:
                yc(h, m, w)
        }
    }

    function Vk(h) {
        var m = h.updateQueue;
        if (m !== null) {
            h.updateQueue = null;
            var w = h.stateNode;
            w === null && (w = h.stateNode = new KB), m.forEach(function (O) {
                var K = Zk.bind(null, h, O);
                w.has(O) || (w.add(O), O.then(K, K))
            })
        }
    }

    function Sf(h, m) {
        var w = m.deletions;
        if (w !== null) for (var O = 0; O < w.length; O++) {
            var K = w[O];
            try {
                var ae = h, ge = m, Re = ge;
                e:for (; Re !== null;) {
                    switch (Re.tag) {
                        case 5:
                            ro = Re.stateNode, gc = !1;
                            break e;
                        case 3:
                            ro = Re.stateNode.containerInfo, gc = !0;
                            break e;
                        case 4:
                            ro = Re.stateNode.containerInfo, gc = !0;
                            break e
                    }
                    Re = Re.return
                }
                if (ro === null) throw Error(r(160));
                zk(ae, ge, K), ro = null, gc = !1;
                var Pe = K.alternate;
                Pe !== null && (Pe.return = null), K.return = null
            } catch (et) {
                _a(K, m, et)
            }
        }
        if (m.subtreeFlags & 12854) for (m = m.child; m !== null;) b6(m, h), m = m.sibling
    }

    function b6(h, m) {
        var w = h.alternate, O = h.flags;
        switch (h.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (Sf(m, h), nl(h), O & 4) {
                    try {
                        vb(3, h, h.return), gb(3, h)
                    } catch (gr) {
                        _a(h, h.return, gr)
                    }
                    try {
                        vb(5, h, h.return)
                    } catch (gr) {
                        _a(h, h.return, gr)
                    }
                }
                break;
            case 1:
                Sf(m, h), nl(h), O & 512 && w !== null && Ag(w, w.return);
                break;
            case 5:
                if (Sf(m, h), nl(h), O & 512 && w !== null && Ag(w, w.return), h.flags & 32) {
                    var K = h.stateNode;
                    try {
                        H(K, "")
                    } catch (gr) {
                        _a(h, h.return, gr)
                    }
                }
                if (O & 4 && (K = h.stateNode, K != null)) {
                    var ae = h.memoizedProps, ge = w !== null ? w.memoizedProps : ae, Re = h.type, Pe = h.updateQueue;
                    if (h.updateQueue = null, Pe !== null) try {
                        Re === "input" && ae.type === "radio" && ae.name != null && ze(K, ae), Ze(Re, ge);
                        var et = Ze(Re, ae);
                        for (ge = 0; ge < Pe.length; ge += 2) {
                            var wt = Pe[ge], Ct = Pe[ge + 1];
                            wt === "style" ? xe(K, Ct) : wt === "dangerouslySetInnerHTML" ? X(K, Ct) : wt === "children" ? H(K, Ct) : F(K, wt, Ct, et)
                        }
                        switch (Re) {
                            case"input":
                                Be(K, ae);
                                break;
                            case"textarea":
                                _t(K, ae);
                                break;
                            case"select":
                                var vt = K._wrapperState.wasMultiple;
                                K._wrapperState.wasMultiple = !!ae.multiple;
                                var Zt = ae.value;
                                Zt != null ? gt(K, !!ae.multiple, Zt, !1) : vt !== !!ae.multiple && (ae.defaultValue != null ? gt(K, !!ae.multiple, ae.defaultValue, !0) : gt(K, !!ae.multiple, ae.multiple ? [] : "", !1))
                        }
                        K[K1] = ae
                    } catch (gr) {
                        _a(h, h.return, gr)
                    }
                }
                break;
            case 6:
                if (Sf(m, h), nl(h), O & 4) {
                    if (h.stateNode === null) throw Error(r(162));
                    K = h.stateNode, ae = h.memoizedProps;
                    try {
                        K.nodeValue = ae
                    } catch (gr) {
                        _a(h, h.return, gr)
                    }
                }
                break;
            case 3:
                if (Sf(m, h), nl(h), O & 4 && w !== null && w.memoizedState.isDehydrated) try {
                    mf(m.containerInfo)
                } catch (gr) {
                    _a(h, h.return, gr)
                }
                break;
            case 4:
                Sf(m, h), nl(h);
                break;
            case 13:
                Sf(m, h), nl(h), K = h.child, K.flags & 8192 && (ae = K.memoizedState !== null, K.stateNode.isHidden = ae, !ae || K.alternate !== null && K.alternate.memoizedState !== null || (_6 = Pt())), O & 4 && Vk(h);
                break;
            case 22:
                if (wt = w !== null && w.memoizedState !== null, h.mode & 1 ? (Hs = (et = Hs) || wt, Sf(m, h), Hs = et) : Sf(m, h), nl(h), O & 8192) {
                    if (et = h.memoizedState !== null, (h.stateNode.isHidden = et) && !wt && h.mode & 1) for (nr = h, wt = h.child; wt !== null;) {
                        for (Ct = nr = wt; nr !== null;) {
                            switch (vt = nr, Zt = vt.child, vt.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    vb(4, vt, vt.return);
                                    break;
                                case 1:
                                    Ag(vt, vt.return);
                                    var dr = vt.stateNode;
                                    if (typeof dr.componentWillUnmount == "function") {
                                        O = vt, w = vt.return;
                                        try {
                                            m = O, dr.props = m.memoizedProps, dr.state = m.memoizedState, dr.componentWillUnmount()
                                        } catch (gr) {
                                            _a(O, w, gr)
                                        }
                                    }
                                    break;
                                case 5:
                                    Ag(vt, vt.return);
                                    break;
                                case 22:
                                    if (vt.memoizedState !== null) {
                                        bb(Ct);
                                        continue
                                    }
                            }
                            Zt !== null ? (Zt.return = vt, nr = Zt) : bb(Ct)
                        }
                        wt = wt.sibling
                    }
                    e:for (wt = null, Ct = h; ;) {
                        if (Ct.tag === 5) {
                            if (wt === null) {
                                wt = Ct;
                                try {
                                    K = Ct.stateNode, et ? (ae = K.style, typeof ae.setProperty == "function" ? ae.setProperty("display", "none", "important") : ae.display = "none") : (Re = Ct.stateNode, Pe = Ct.memoizedProps.style, ge = Pe != null && Pe.hasOwnProperty("display") ? Pe.display : null, Re.style.display = le("display", ge))
                                } catch (gr) {
                                    _a(h, h.return, gr)
                                }
                            }
                        } else if (Ct.tag === 6) {
                            if (wt === null) try {
                                Ct.stateNode.nodeValue = et ? "" : Ct.memoizedProps
                            } catch (gr) {
                                _a(h, h.return, gr)
                            }
                        } else if ((Ct.tag !== 22 && Ct.tag !== 23 || Ct.memoizedState === null || Ct === h) && Ct.child !== null) {
                            Ct.child.return = Ct, Ct = Ct.child;
                            continue
                        }
                        if (Ct === h) break e;
                        for (; Ct.sibling === null;) {
                            if (Ct.return === null || Ct.return === h) break e;
                            wt === Ct && (wt = null), Ct = Ct.return
                        }
                        wt === Ct && (wt = null), Ct.sibling.return = Ct.return, Ct = Ct.sibling
                    }
                }
                break;
            case 19:
                Sf(m, h), nl(h), O & 4 && Vk(h);
                break;
            case 21:
                break;
            default:
                Sf(m, h), nl(h)
        }
    }

    function nl(h) {
        var m = h.flags;
        if (m & 2) {
            try {
                e:{
                    for (var w = h.return; w !== null;) {
                        if (yb(w)) {
                            var O = w;
                            break e
                        }
                        w = w.return
                    }
                    throw Error(r(160))
                }
                switch (O.tag) {
                    case 5:
                        var K = O.stateNode;
                        O.flags & 32 && (H(K, ""), O.flags &= -33);
                        var ae = xh(h);
                        yd(h, ae, K);
                        break;
                    case 3:
                    case 4:
                        var ge = O.stateNode.containerInfo, Re = xh(h);
                        gd(h, Re, ge);
                        break;
                    default:
                        throw Error(r(161))
                }
            } catch (Pe) {
                _a(h, h.return, Pe)
            }
            h.flags &= -3
        }
        m & 4096 && (h.flags &= -4097)
    }

    function YB(h, m, w) {
        nr = h, w6(h)
    }

    function w6(h, m, w) {
        for (var O = (h.mode & 1) !== 0; nr !== null;) {
            var K = nr, ae = K.child;
            if (K.tag === 22 && O) {
                var ge = K.memoizedState !== null || mb;
                if (!ge) {
                    var Re = K.alternate, Pe = Re !== null && Re.memoizedState !== null || Hs;
                    Re = mb;
                    var et = Hs;
                    if (mb = ge, (Hs = Pe) && !et) for (nr = K; nr !== null;) ge = nr, Pe = ge.child, ge.tag === 22 && ge.memoizedState !== null ? S6(K) : Pe !== null ? (Pe.return = ge, nr = Pe) : S6(K);
                    for (; ae !== null;) nr = ae, w6(ae), ae = ae.sibling;
                    nr = K, mb = Re, Hs = et
                }
                Hk(h)
            } else K.subtreeFlags & 8772 && ae !== null ? (ae.return = K, nr = ae) : Hk(h)
        }
    }

    function Hk(h) {
        for (; nr !== null;) {
            var m = nr;
            if (m.flags & 8772) {
                var w = m.alternate;
                try {
                    if (m.flags & 8772) switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Hs || gb(5, m);
                            break;
                        case 1:
                            var O = m.stateNode;
                            if (m.flags & 4 && !Hs) if (w === null) O.componentDidMount(); else {
                                var K = m.elementType === m.type ? w.memoizedProps : wf(m.type, w.memoizedProps);
                                O.componentDidUpdate(K, w.memoizedState, O.__reactInternalSnapshotBeforeUpdate)
                            }
                            var ae = m.updateQueue;
                            ae !== null && a6(m, ae, O);
                            break;
                        case 3:
                            var ge = m.updateQueue;
                            if (ge !== null) {
                                if (w = null, m.child !== null) switch (m.child.tag) {
                                    case 5:
                                        w = m.child.stateNode;
                                        break;
                                    case 1:
                                        w = m.child.stateNode
                                }
                                a6(m, ge, w)
                            }
                            break;
                        case 5:
                            var Re = m.stateNode;
                            if (w === null && m.flags & 4) {
                                w = Re;
                                var Pe = m.memoizedProps;
                                switch (m.type) {
                                    case"button":
                                    case"input":
                                    case"select":
                                    case"textarea":
                                        Pe.autoFocus && w.focus();
                                        break;
                                    case"img":
                                        Pe.src && (w.src = Pe.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (m.memoizedState === null) {
                                var et = m.alternate;
                                if (et !== null) {
                                    var wt = et.memoizedState;
                                    if (wt !== null) {
                                        var Ct = wt.dehydrated;
                                        Ct !== null && mf(Ct)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(r(163))
                    }
                    Hs || m.flags & 512 && y6(m)
                } catch (vt) {
                    _a(m, m.return, vt)
                }
            }
            if (m === h) {
                nr = null;
                break
            }
            if (w = m.sibling, w !== null) {
                w.return = m.return, nr = w;
                break
            }
            nr = m.return
        }
    }

    function bb(h) {
        for (; nr !== null;) {
            var m = nr;
            if (m === h) {
                nr = null;
                break
            }
            var w = m.sibling;
            if (w !== null) {
                w.return = m.return, nr = w;
                break
            }
            nr = m.return
        }
    }

    function S6(h) {
        for (; nr !== null;) {
            var m = nr;
            try {
                switch (m.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var w = m.return;
                        try {
                            gb(4, m)
                        } catch (Pe) {
                            _a(m, w, Pe)
                        }
                        break;
                    case 1:
                        var O = m.stateNode;
                        if (typeof O.componentDidMount == "function") {
                            var K = m.return;
                            try {
                                O.componentDidMount()
                            } catch (Pe) {
                                _a(m, K, Pe)
                            }
                        }
                        var ae = m.return;
                        try {
                            y6(m)
                        } catch (Pe) {
                            _a(m, ae, Pe)
                        }
                        break;
                    case 5:
                        var ge = m.return;
                        try {
                            y6(m)
                        } catch (Pe) {
                            _a(m, ge, Pe)
                        }
                }
            } catch (Pe) {
                _a(m, m.return, Pe)
            }
            if (m === h) {
                nr = null;
                break
            }
            var Re = m.sibling;
            if (Re !== null) {
                Re.return = m.return, nr = Re;
                break
            }
            nr = m.return
        }
    }

    var XB = Math.ceil, Hp = V.ReactCurrentDispatcher, Om = V.ReactCurrentOwner, vs = V.ReactCurrentBatchConfig, ei = 0,
        $o = null, bo = null, gs = 0, Vl = 0, Ig = fd(0), no = 0, wb = null, bd = 0, kg = 0, r_ = 0, Sb = null,
        il = null, _6 = 0, Rg = 1 / 0, Hl = null, Dg = !1, Pm = null, Wp = null, n_ = !1, Eh = null, _b = 0, qp = 0,
        Mg = null, xb = -1, Ws = 0;

    function wo() {
        return ei & 6 ? Pt() : xb !== -1 ? xb : xb = Pt()
    }

    function wd(h) {
        return h.mode & 1 ? ei & 2 && gs !== 0 ? gs & -gs : GB.transition !== null ? (Ws === 0 && (Ws = lh()), Ws) : (h = Bn, h !== 0 || (h = window.event, h = h === void 0 ? 16 : di(h.type)), h) : 1
    }

    function bc(h, m, w, O) {
        if (50 < qp) throw qp = 0, Mg = null, Error(r(185));
        Bl(h, w, O), (!(ei & 2) || h !== $o) && (h === $o && (!(ei & 2) && (kg |= w), no === 4 && _f(h, gs)), al(h, O), w === 1 && ei === 0 && !(m.mode & 1) && (Rg = Pt() + 500, _g && yf()))
    }

    function al(h, m) {
        var w = h.callbackNode;
        Nl(h, m);
        var O = Ol(h, h === $o ? gs : 0);
        if (O === 0) w !== null && kn(w), h.callbackNode = null, h.callbackPriority = 0; else if (m = O & -O, h.callbackPriority !== m) {
            if (w != null && kn(w), m === 1) h.tag === 0 ? yh(x6.bind(null, h)) : x2(x6.bind(null, h)), y2(function () {
                !(ei & 6) && yf()
            }), w = null; else {
                switch ($n(O)) {
                    case 1:
                        w = Da;
                        break;
                    case 4:
                        w = Ma;
                        break;
                    case 16:
                        w = Oa;
                        break;
                    case 536870912:
                        w = Po;
                        break;
                    default:
                        w = Oa
                }
                w = eR(w, i_.bind(null, h))
            }
            h.callbackPriority = m, h.callbackNode = w
        }
    }

    function i_(h, m) {
        if (xb = -1, Ws = 0, ei & 6) throw Error(r(327));
        var w = h.callbackNode;
        if (Og() && h.callbackNode !== w) return null;
        var O = Ol(h, h === $o ? gs : 0);
        if (O === 0) return null;
        if (O & 30 || O & h.expiredLanes || m) m = a_(h, O); else {
            m = O;
            var K = ei;
            ei |= 2;
            var ae = qk();
            ($o !== h || gs !== m) && (Hl = null, Rg = Pt() + 500, Th(h, m));
            do try {
                Gk();
                break
            } catch (Re) {
                Wk(h, Re)
            } while (!0);
            J3(), Hp.current = ae, ei = K, bo !== null ? m = 0 : ($o = null, gs = 0, m = no)
        }
        if (m !== 0) {
            if (m === 2 && (K = fs(h), K !== 0 && (O = K, m = Eb(h, K))), m === 1) throw w = wb, Th(h, 0), _f(h, O), al(h, Pt()), w;
            if (m === 6) _f(h, O); else {
                if (K = h.current.alternate, !(O & 30) && !QB(K) && (m = a_(h, O), m === 2 && (ae = fs(h), ae !== 0 && (O = ae, m = Eb(h, ae))), m === 1)) throw w = wb, Th(h, 0), _f(h, O), al(h, Pt()), w;
                switch (h.finishedWork = K, h.finishedLanes = O, m) {
                    case 0:
                    case 1:
                        throw Error(r(345));
                    case 2:
                        Bm(h, il, Hl);
                        break;
                    case 3:
                        if (_f(h, O), (O & 130023424) === O && (m = _6 + 500 - Pt(), 10 < m)) {
                            if (Ol(h, 0) !== 0) break;
                            if (K = h.suspendedLanes, (K & O) !== O) {
                                wo(), h.pingedLanes |= h.suspendedLanes & K;
                                break
                            }
                            h.timeoutHandle = q1(Bm.bind(null, h, il, Hl), m);
                            break
                        }
                        Bm(h, il, Hl);
                        break;
                    case 4:
                        if (_f(h, O), (O & 4194240) === O) break;
                        for (m = h.eventTimes, K = -1; 0 < O;) {
                            var ge = 31 - Pa(O);
                            ae = 1 << ge, ge = m[ge], ge > K && (K = ge), O &= ~ae
                        }
                        if (O = K, O = Pt() - O, O = (120 > O ? 120 : 480 > O ? 480 : 1080 > O ? 1080 : 1920 > O ? 1920 : 3e3 > O ? 3e3 : 4320 > O ? 4320 : 1960 * XB(O / 1960)) - O, 10 < O) {
                            h.timeoutHandle = q1(Bm.bind(null, h, il, Hl), O);
                            break
                        }
                        Bm(h, il, Hl);
                        break;
                    case 5:
                        Bm(h, il, Hl);
                        break;
                    default:
                        throw Error(r(329))
                }
            }
        }
        return al(h, Pt()), h.callbackNode === w ? i_.bind(null, h) : null
    }

    function Eb(h, m) {
        var w = Sb;
        return h.current.memoizedState.isDehydrated && (Th(h, m).flags |= 256), h = a_(h, m), h !== 2 && (m = il, il = w, m !== null && Nm(m)), h
    }

    function Nm(h) {
        il === null ? il = h : il.push.apply(il, h)
    }

    function QB(h) {
        for (var m = h; ;) {
            if (m.flags & 16384) {
                var w = m.updateQueue;
                if (w !== null && (w = w.stores, w !== null)) for (var O = 0; O < w.length; O++) {
                    var K = w[O], ae = K.getSnapshot;
                    K = K.value;
                    try {
                        if (!vf(ae(), K)) return !1
                    } catch {
                        return !1
                    }
                }
            }
            if (w = m.child, m.subtreeFlags & 16384 && w !== null) w.return = m, m = w; else {
                if (m === h) break;
                for (; m.sibling === null;) {
                    if (m.return === null || m.return === h) return !0;
                    m = m.return
                }
                m.sibling.return = m.return, m = m.sibling
            }
        }
        return !0
    }

    function _f(h, m) {
        for (m &= ~r_, m &= ~kg, h.suspendedLanes |= m, h.pingedLanes &= ~m, h = h.expirationTimes; 0 < m;) {
            var w = 31 - Pa(m), O = 1 << w;
            h[w] = -1, m &= ~O
        }
    }

    function x6(h) {
        if (ei & 6) throw Error(r(327));
        Og();
        var m = Ol(h, 0);
        if (!(m & 1)) return al(h, Pt()), null;
        var w = a_(h, m);
        if (h.tag !== 0 && w === 2) {
            var O = fs(h);
            O !== 0 && (m = O, w = Eb(h, O))
        }
        if (w === 1) throw w = wb, Th(h, 0), _f(h, m), al(h, Pt()), w;
        if (w === 6) throw Error(r(345));
        return h.finishedWork = h.current.alternate, h.finishedLanes = m, Bm(h, il, Hl), al(h, Pt()), null
    }

    function E6(h, m) {
        var w = ei;
        ei |= 1;
        try {
            return h(m)
        } finally {
            ei = w, ei === 0 && (Rg = Pt() + 500, _g && yf())
        }
    }

    function Lm(h) {
        Eh !== null && Eh.tag === 0 && !(ei & 6) && Og();
        var m = ei;
        ei |= 1;
        var w = vs.transition, O = Bn;
        try {
            if (vs.transition = null, Bn = 1, h) return h()
        } finally {
            Bn = O, vs.transition = w, ei = m, !(ei & 6) && yf()
        }
    }

    function T6() {
        Vl = Ig.current, Mr(Ig)
    }

    function Th(h, m) {
        h.finishedWork = null, h.finishedLanes = 0;
        var w = h.timeoutHandle;
        if (w !== -1 && (h.timeoutHandle = -1, HB(w)), bo !== null) for (w = bo.return; w !== null;) {
            var O = w;
            switch (T2(O), O.tag) {
                case 1:
                    O = O.type.childContextTypes, O != null && S2();
                    break;
                case 3:
                    Em(), Mr(wa), Mr(Ha), $r();
                    break;
                case 5:
                    k2(O);
                    break;
                case 4:
                    Em();
                    break;
                case 13:
                    Mr(Ba);
                    break;
                case 19:
                    Mr(Ba);
                    break;
                case 10:
                    e6(O.type._context);
                    break;
                case 22:
                case 23:
                    T6()
            }
            w = w.return
        }
        if ($o = h, bo = h = Gp(h.current, null), gs = Vl = m, no = 0, wb = null, r_ = kg = bd = 0, il = Sb = null, _m !== null) {
            for (m = 0; m < _m.length; m++) if (w = _m[m], O = w.interleaved, O !== null) {
                w.interleaved = null;
                var K = O.next, ae = w.pending;
                if (ae !== null) {
                    var ge = ae.next;
                    ae.next = K, O.next = ge
                }
                w.pending = O
            }
            _m = null
        }
        return h
    }

    function Wk(h, m) {
        do {
            var w = bo;
            try {
                if (J3(), Mn.current = Rm, D2) {
                    for (var O = yi.memoizedState; O !== null;) {
                        var K = O.queue;
                        K !== null && (K.pending = null), O = O.next
                    }
                    D2 = !1
                }
                if (Gi = 0, Qo = vo = yi = null, tb = !1, Tm = 0, Om.current = null, w === null || w.return === null) {
                    no = 1, wb = m, bo = null;
                    break
                }
                e:{
                    var ae = h, ge = w.return, Re = w, Pe = m;
                    if (m = gs, Re.flags |= 32768, Pe !== null && typeof Pe == "object" && typeof Pe.then == "function") {
                        var et = Pe, wt = Re, Ct = wt.tag;
                        if (!(wt.mode & 1) && (Ct === 0 || Ct === 11 || Ct === 15)) {
                            var vt = wt.alternate;
                            vt ? (wt.updateQueue = vt.updateQueue, wt.memoizedState = vt.memoizedState, wt.lanes = vt.lanes) : (wt.updateQueue = null, wt.memoizedState = null)
                        }
                        var Zt = Mk(ge);
                        if (Zt !== null) {
                            Zt.flags &= -257, Vp(Zt, ge, Re, ae, m), Zt.mode & 1 && h6(ae, et, m), m = Zt, Pe = et;
                            var dr = m.updateQueue;
                            if (dr === null) {
                                var gr = new Set;
                                gr.add(Pe), m.updateQueue = gr
                            } else dr.add(Pe);
                            break e
                        } else {
                            if (!(m & 1)) {
                                h6(ae, et, m), C6();
                                break e
                            }
                            Pe = Error(r(426))
                        }
                    } else if (Sa && Re.mode & 1) {
                        var io = Mk(ge);
                        if (io !== null) {
                            !(io.flags & 65536) && (io.flags |= 256), Vp(io, ge, Re, ae, m), wh(Dm(Pe, Re));
                            break e
                        }
                    }
                    ae = Pe = Dm(Pe, Re), no !== 4 && (no = 2), Sb === null ? Sb = [ae] : Sb.push(ae), ae = ge;
                    do {
                        switch (ae.tag) {
                            case 3:
                                ae.flags |= 65536, m &= -m, ae.lanes |= m;
                                var He = Dk(ae, Pe, m);
                                Ck(ae, He);
                                break e;
                            case 1:
                                Re = Pe;
                                var $e = ae.type, Ke = ae.stateNode;
                                if (!(ae.flags & 128) && (typeof $e.getDerivedStateFromError == "function" || Ke !== null && typeof Ke.componentDidCatch == "function" && (Wp === null || !Wp.has(Ke)))) {
                                    ae.flags |= 65536, m &= -m, ae.lanes |= m;
                                    var St = d6(ae, Re, m);
                                    Ck(ae, St);
                                    break e
                                }
                        }
                        ae = ae.return
                    } while (ae !== null)
                }
                Yk(w)
            } catch (hr) {
                m = hr, bo === w && w !== null && (bo = w = w.return);
                continue
            }
            break
        } while (!0)
    }

    function qk() {
        var h = Hp.current;
        return Hp.current = Rm, h === null ? Rm : h
    }

    function C6() {
        (no === 0 || no === 3 || no === 2) && (no = 4), $o === null || !(bd & 268435455) && !(kg & 268435455) || _f($o, gs)
    }

    function a_(h, m) {
        var w = ei;
        ei |= 2;
        var O = qk();
        ($o !== h || gs !== m) && (Hl = null, Th(h, m));
        do try {
            ZB();
            break
        } catch (K) {
            Wk(h, K)
        } while (!0);
        if (J3(), ei = w, Hp.current = O, bo !== null) throw Error(r(261));
        return $o = null, gs = 0, no
    }

    function ZB() {
        for (; bo !== null;) Kk(bo)
    }

    function Gk() {
        for (; bo !== null && !Ai();) Kk(bo)
    }

    function Kk(h) {
        var m = Jk(h.alternate, h, Vl);
        h.memoizedProps = h.pendingProps, m === null ? Yk(h) : bo = m, Om.current = null
    }

    function Yk(h) {
        var m = h;
        do {
            var w = m.alternate;
            if (h = m.return, m.flags & 32768) {
                if (w = J2(w, m), w !== null) {
                    w.flags &= 32767, bo = w;
                    return
                }
                if (h !== null) h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null; else {
                    no = 6, bo = null;
                    return
                }
            } else if (w = Fk(w, m, Vl), w !== null) {
                bo = w;
                return
            }
            if (m = m.sibling, m !== null) {
                bo = m;
                return
            }
            bo = m = h
        } while (m !== null);
        no === 0 && (no = 5)
    }

    function Bm(h, m, w) {
        var O = Bn, K = vs.transition;
        try {
            vs.transition = null, Bn = 1, JB(h, m, w, O)
        } finally {
            vs.transition = K, Bn = O
        }
        return null
    }

    function JB(h, m, w, O) {
        do Og(); while (Eh !== null);
        if (ei & 6) throw Error(r(327));
        w = h.finishedWork;
        var K = h.finishedLanes;
        if (w === null) return null;
        if (h.finishedWork = null, h.finishedLanes = 0, w === h.current) throw Error(r(177));
        h.callbackNode = null, h.callbackPriority = 0;
        var ae = w.lanes | w.childLanes;
        if (uh(h, ae), h === $o && (bo = $o = null, gs = 0), !(w.subtreeFlags & 2064) && !(w.flags & 2064) || n_ || (n_ = !0, eR(Oa, function () {
            return Og(), null
        })), ae = (w.flags & 15990) !== 0, w.subtreeFlags & 15990 || ae) {
            ae = vs.transition, vs.transition = null;
            var ge = Bn;
            Bn = 1;
            var Re = ei;
            ei |= 4, Om.current = null, jk(h, w), b6(w, h), $B(v2), Cu = !!gm, v2 = gm = null, h.current = w, YB(w), Fi(), ei = Re, Bn = ge, vs.transition = ae
        } else h.current = w;
        if (n_ && (n_ = !1, Eh = h, _b = K), ae = h.pendingLanes, ae === 0 && (Wp = null), Ko(w.stateNode), al(h, Pt()), m !== null) for (O = h.onRecoverableError, w = 0; w < m.length; w++) K = m[w], O(K.value, {
            componentStack: K.stack,
            digest: K.digest
        });
        if (Dg) throw Dg = !1, h = Pm, Pm = null, h;
        return _b & 1 && h.tag !== 0 && Og(), ae = h.pendingLanes, ae & 1 ? h === Mg ? qp++ : (qp = 0, Mg = h) : qp = 0, yf(), null
    }

    function Og() {
        if (Eh !== null) {
            var h = $n(_b), m = vs.transition, w = Bn;
            try {
                if (vs.transition = null, Bn = 16 > h ? 16 : h, Eh === null) var O = !1; else {
                    if (h = Eh, Eh = null, _b = 0, ei & 6) throw Error(r(331));
                    var K = ei;
                    for (ei |= 4, nr = h.current; nr !== null;) {
                        var ae = nr, ge = ae.child;
                        if (nr.flags & 16) {
                            var Re = ae.deletions;
                            if (Re !== null) {
                                for (var Pe = 0; Pe < Re.length; Pe++) {
                                    var et = Re[Pe];
                                    for (nr = et; nr !== null;) {
                                        var wt = nr;
                                        switch (wt.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                vb(8, wt, ae)
                                        }
                                        var Ct = wt.child;
                                        if (Ct !== null) Ct.return = wt, nr = Ct; else for (; nr !== null;) {
                                            wt = nr;
                                            var vt = wt.sibling, Zt = wt.return;
                                            if (t_(wt), wt === et) {
                                                nr = null;
                                                break
                                            }
                                            if (vt !== null) {
                                                vt.return = Zt, nr = vt;
                                                break
                                            }
                                            nr = Zt
                                        }
                                    }
                                }
                                var dr = ae.alternate;
                                if (dr !== null) {
                                    var gr = dr.child;
                                    if (gr !== null) {
                                        dr.child = null;
                                        do {
                                            var io = gr.sibling;
                                            gr.sibling = null, gr = io
                                        } while (gr !== null)
                                    }
                                }
                                nr = ae
                            }
                        }
                        if (ae.subtreeFlags & 2064 && ge !== null) ge.return = ae, nr = ge; else e:for (; nr !== null;) {
                            if (ae = nr, ae.flags & 2048) switch (ae.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    vb(9, ae, ae.return)
                            }
                            var He = ae.sibling;
                            if (He !== null) {
                                He.return = ae.return, nr = He;
                                break e
                            }
                            nr = ae.return
                        }
                    }
                    var $e = h.current;
                    for (nr = $e; nr !== null;) {
                        ge = nr;
                        var Ke = ge.child;
                        if (ge.subtreeFlags & 2064 && Ke !== null) Ke.return = ge, nr = Ke; else e:for (ge = $e; nr !== null;) {
                            if (Re = nr, Re.flags & 2048) try {
                                switch (Re.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        gb(9, Re)
                                }
                            } catch (hr) {
                                _a(Re, Re.return, hr)
                            }
                            if (Re === ge) {
                                nr = null;
                                break e
                            }
                            var St = Re.sibling;
                            if (St !== null) {
                                St.return = Re.return, nr = St;
                                break e
                            }
                            nr = Re.return
                        }
                    }
                    if (ei = K, yf(), qi && typeof qi.onPostCommitFiberRoot == "function") try {
                        qi.onPostCommitFiberRoot(Ja, h)
                    } catch {
                    }
                    O = !0
                }
                return O
            } finally {
                Bn = w, vs.transition = m
            }
        }
        return !1
    }

    function Xk(h, m, w) {
        m = Dm(w, m), m = Dk(h, m, 1), h = Up(h, m, 1), m = wo(), h !== null && (Bl(h, 1, m), al(h, m))
    }

    function _a(h, m, w) {
        if (h.tag === 3) Xk(h, h, w); else for (; m !== null;) {
            if (m.tag === 3) {
                Xk(m, h, w);
                break
            } else if (m.tag === 1) {
                var O = m.stateNode;
                if (typeof m.type.getDerivedStateFromError == "function" || typeof O.componentDidCatch == "function" && (Wp === null || !Wp.has(O))) {
                    h = Dm(w, h), h = d6(m, h, 1), m = Up(m, h, 1), h = wo(), m !== null && (Bl(m, 1, h), al(m, h));
                    break
                }
            }
            m = m.return
        }
    }

    function e$(h, m, w) {
        var O = h.pingCache;
        O !== null && O.delete(m), m = wo(), h.pingedLanes |= h.suspendedLanes & w, $o === h && (gs & w) === w && (no === 4 || no === 3 && (gs & 130023424) === gs && 500 > Pt() - _6 ? Th(h, 0) : r_ |= w), al(h, m)
    }

    function Qk(h, m) {
        m === 0 && (h.mode & 1 ? (m = Ml, Ml <<= 1, !(Ml & 130023424) && (Ml = 4194304)) : m = 1);
        var w = wo();
        h = jl(h, m), h !== null && (Bl(h, m, w), al(h, w))
    }

    function t$(h) {
        var m = h.memoizedState, w = 0;
        m !== null && (w = m.retryLane), Qk(h, w)
    }

    function Zk(h, m) {
        var w = 0;
        switch (h.tag) {
            case 13:
                var O = h.stateNode, K = h.memoizedState;
                K !== null && (w = K.retryLane);
                break;
            case 19:
                O = h.stateNode;
                break;
            default:
                throw Error(r(314))
        }
        O !== null && O.delete(m), Qk(h, w)
    }

    var Jk;
    Jk = function (h, m, w) {
        if (h !== null) if (h.memoizedProps !== m.pendingProps || wa.current) go = !0; else {
            if (!(h.lanes & w) && !(m.flags & 128)) return go = !1, hb(h, m, w);
            go = !!(h.flags & 131072)
        } else go = !1, Sa && m.flags & 1048576 && _k(m, bh, m.index);
        switch (m.lanes = 0, m.tag) {
            case 2:
                var O = m.type;
                Du(h, m), h = m.pendingProps;
                var K = Au(m, Ha.current);
                La(m, w), K = jp(null, m, O, h, K, w);
                var ae = bf();
                return m.flags |= 1, typeof K == "object" && K !== null && typeof K.render == "function" && K.$$typeof === void 0 ? (m.tag = 1, m.memoizedState = null, m.updateQueue = null, ps(O) ? (ae = !0, Xo(m)) : ae = !1, m.memoizedState = K.state !== null && K.state !== void 0 ? K.state : null, i6(m), K.updater = K2, m.stateNode = K, K._reactInternals = m, cb(m, O, h, w), m = fb(null, m, O, !0, ae, w)) : (m.tag = 0, Sa && ae && E2(m), ms(null, m, K, w), m = m.child), m;
            case 16:
                O = m.elementType;
                e:{
                    switch (Du(h, m), h = m.pendingProps, K = O._init, O = K(O._payload), m.type = O, K = m.tag = n$(O), h = wf(O, h), K) {
                        case 0:
                            m = Ok(null, m, O, h, w);
                            break e;
                        case 1:
                            m = Pk(null, m, O, h, w);
                            break e;
                        case 11:
                            m = rl(null, m, O, h, w);
                            break e;
                        case 14:
                            m = Mm(null, m, O, wf(O.type, h), w);
                            break e
                    }
                    throw Error(r(306, O, ""))
                }
                return m;
            case 0:
                return O = m.type, K = m.pendingProps, K = m.elementType === O ? K : wf(O, K), Ok(h, m, O, K, w);
            case 1:
                return O = m.type, K = m.pendingProps, K = m.elementType === O ? K : wf(O, K), Pk(h, m, O, K, w);
            case 3:
                e:{
                    if (Cg(m), h === null) throw Error(r(387));
                    O = m.pendingProps, ae = m.memoizedState, K = ae.element, Tk(h, m), X1(m, O, null, w);
                    var ge = m.memoizedState;
                    if (O = ge.element, ae.isDehydrated) if (ae = {
                        element: O,
                        isDehydrated: !1,
                        cache: ge.cache,
                        pendingSuspenseBoundaries: ge.pendingSuspenseBoundaries,
                        transitions: ge.transitions
                    }, m.updateQueue.baseState = ae, m.memoizedState = ae, m.flags & 256) {
                        K = Dm(Error(r(423)), m), m = Nk(h, m, O, w, K);
                        break e
                    } else if (O !== K) {
                        K = Dm(Error(r(424)), m), m = Nk(h, m, O, w, K);
                        break e
                    } else for (Jc = Pp(m.stateNode.containerInfo.firstChild), Zc = m, Sa = !0, ku = null, w = Wt(m, null, O, w), m.child = w; w;) w.flags = w.flags & -3 | 4096, w = w.sibling; else {
                        if (Fp(), O === K) {
                            m = Mu(h, m, w);
                            break e
                        }
                        ms(h, m, O, w)
                    }
                    m = m.child
                }
                return m;
            case 5:
                return Ak(m), h === null && Q3(m), O = m.type, K = m.pendingProps, ae = h !== null ? h.memoizedProps : null, ge = K.children, g2(O, K) ? ge = null : ae !== null && g2(O, ae) && (m.flags |= 32), p6(h, m), ms(h, m, ge, w), m.child;
            case 6:
                return h === null && Q3(m), null;
            case 13:
                return Z2(h, m, w);
            case 4:
                return o6(m, m.stateNode.containerInfo), O = m.pendingProps, h === null ? m.child = eo(m, null, O, w) : ms(h, m, O, w), m.child;
            case 11:
                return O = m.type, K = m.pendingProps, K = m.elementType === O ? K : wf(O, K), rl(h, m, O, K, w);
            case 7:
                return ms(h, m, m.pendingProps, w), m.child;
            case 8:
                return ms(h, m, m.pendingProps.children, w), m.child;
            case 12:
                return ms(h, m, m.pendingProps.children, w), m.child;
            case 10:
                e:{
                    if (O = m.type._context, K = m.pendingProps, ae = m.memoizedProps, ge = K.value, ai(Ul, O._currentValue), O._currentValue = ge, ae !== null) if (vf(ae.value, ge)) {
                        if (ae.children === K.children && !wa.current) {
                            m = Mu(h, m, w);
                            break e
                        }
                    } else for (ae = m.child, ae !== null && (ae.return = m); ae !== null;) {
                        var Re = ae.dependencies;
                        if (Re !== null) {
                            ge = ae.child;
                            for (var Pe = Re.firstContext; Pe !== null;) {
                                if (Pe.context === O) {
                                    if (ae.tag === 1) {
                                        Pe = Sh(-1, w & -w), Pe.tag = 2;
                                        var et = ae.updateQueue;
                                        if (et !== null) {
                                            et = et.shared;
                                            var wt = et.pending;
                                            wt === null ? Pe.next = Pe : (Pe.next = wt.next, wt.next = Pe), et.pending = Pe
                                        }
                                    }
                                    ae.lanes |= w, Pe = ae.alternate, Pe !== null && (Pe.lanes |= w), t6(ae.return, w, m), Re.lanes |= w;
                                    break
                                }
                                Pe = Pe.next
                            }
                        } else if (ae.tag === 10) ge = ae.type === m.type ? null : ae.child; else if (ae.tag === 18) {
                            if (ge = ae.return, ge === null) throw Error(r(341));
                            ge.lanes |= w, Re = ge.alternate, Re !== null && (Re.lanes |= w), t6(ge, w, m), ge = ae.sibling
                        } else ge = ae.child;
                        if (ge !== null) ge.return = ae; else for (ge = ae; ge !== null;) {
                            if (ge === m) {
                                ge = null;
                                break
                            }
                            if (ae = ge.sibling, ae !== null) {
                                ae.return = ge.return, ge = ae;
                                break
                            }
                            ge = ge.return
                        }
                        ae = ge
                    }
                    ms(h, m, K.children, w), m = m.child
                }
                return m;
            case 9:
                return K = m.type, O = m.pendingProps.children, La(m, w), K = Ru(K), O = O(K), m.flags |= 1, ms(h, m, O, w), m.child;
            case 14:
                return O = m.type, K = wf(O, m.pendingProps), K = wf(O.type, K), Mm(h, m, O, K, w);
            case 15:
                return vn(h, m, m.type, m.pendingProps, w);
            case 17:
                return O = m.type, K = m.pendingProps, K = m.elementType === O ? K : wf(O, K), Du(h, m), m.tag = 1, ps(O) ? (h = !0, Xo(m)) : h = !1, La(m, w), Y2(m, O, K), cb(m, O, K, w), fb(null, m, O, !0, h, w);
            case 19:
                return vd(h, m, w);
            case 22:
                return ub(h, m, w)
        }
        throw Error(r(156, m.tag))
    };

    function eR(h, m) {
        return In(h, m)
    }

    function r$(h, m, w, O) {
        this.tag = h, this.key = w, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = m, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = O, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
    }

    function Pu(h, m, w, O) {
        return new r$(h, m, w, O)
    }

    function A6(h) {
        return h = h.prototype, !(!h || !h.isReactComponent)
    }

    function n$(h) {
        if (typeof h == "function") return A6(h) ? 1 : 0;
        if (h != null) {
            if (h = h.$$typeof, h === M) return 11;
            if (h === A) return 14
        }
        return 2
    }

    function Gp(h, m) {
        var w = h.alternate;
        return w === null ? (w = Pu(h.tag, m, h.key, h.mode), w.elementType = h.elementType, w.type = h.type, w.stateNode = h.stateNode, w.alternate = h, h.alternate = w) : (w.pendingProps = m, w.type = h.type, w.flags = 0, w.subtreeFlags = 0, w.deletions = null), w.flags = h.flags & 14680064, w.childLanes = h.childLanes, w.lanes = h.lanes, w.child = h.child, w.memoizedProps = h.memoizedProps, w.memoizedState = h.memoizedState, w.updateQueue = h.updateQueue, m = h.dependencies, w.dependencies = m === null ? null : {
            lanes: m.lanes,
            firstContext: m.firstContext
        }, w.sibling = h.sibling, w.index = h.index, w.ref = h.ref, w
    }

    function Tb(h, m, w, O, K, ae) {
        var ge = 2;
        if (O = h, typeof h == "function") A6(h) && (ge = 1); else if (typeof h == "string") ge = 5; else e:switch (h) {
            case oe:
                return Ch(w.children, K, ae, m);
            case G:
                ge = 8, K |= 8;
                break;
            case J:
                return h = Pu(12, w, m, K | 2), h.elementType = J, h.lanes = ae, h;
            case D:
                return h = Pu(13, w, m, K), h.elementType = D, h.lanes = ae, h;
            case x:
                return h = Pu(19, w, m, K), h.elementType = x, h.lanes = ae, h;
            case z:
                return Kp(w, K, ae, m);
            default:
                if (typeof h == "object" && h !== null) switch (h.$$typeof) {
                    case ce:
                        ge = 10;
                        break e;
                    case re:
                        ge = 9;
                        break e;
                    case M:
                        ge = 11;
                        break e;
                    case A:
                        ge = 14;
                        break e;
                    case B:
                        ge = 16, O = null;
                        break e
                }
                throw Error(r(130, h == null ? h : typeof h, ""))
        }
        return m = Pu(ge, w, m, K), m.elementType = h, m.type = O, m.lanes = ae, m
    }

    function Ch(h, m, w, O) {
        return h = Pu(7, h, O, m), h.lanes = w, h
    }

    function Kp(h, m, w, O) {
        return h = Pu(22, h, O, m), h.elementType = z, h.lanes = w, h.stateNode = {isHidden: !1}, h
    }

    function I6(h, m, w) {
        return h = Pu(6, h, null, m), h.lanes = w, h
    }

    function o_(h, m, w) {
        return m = Pu(4, h.children !== null ? h.children : [], h.key, m), m.lanes = w, m.stateNode = {
            containerInfo: h.containerInfo,
            pendingChildren: null,
            implementation: h.implementation
        }, m
    }

    function tR(h, m, w, O, K) {
        this.tag = m, this.containerInfo = h, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ll(0), this.expirationTimes = Ll(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ll(0), this.identifierPrefix = O, this.onRecoverableError = K, this.mutableSourceEagerHydrationData = null
    }

    function s_(h, m, w, O, K, ae, ge, Re, Pe) {
        return h = new tR(h, m, w, Re, Pe), m === 1 ? (m = 1, ae === !0 && (m |= 8)) : m = 0, ae = Pu(3, null, null, m), h.current = ae, ae.stateNode = h, ae.memoizedState = {
            element: O,
            isDehydrated: w,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        }, i6(ae), h
    }

    function i$(h, m, w) {
        var O = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {$$typeof: ee, key: O == null ? null : "" + O, children: h, containerInfo: m, implementation: w}
    }

    function k6(h) {
        if (!h) return pc;
        h = h._reactInternals;
        e:{
            if (xt(h) !== h || h.tag !== 1) throw Error(r(170));
            var m = h;
            do {
                switch (m.tag) {
                    case 3:
                        m = m.stateNode.context;
                        break e;
                    case 1:
                        if (ps(m.type)) {
                            m = m.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                m = m.return
            } while (m !== null);
            throw Error(r(171))
        }
        if (h.tag === 1) {
            var w = h.type;
            if (ps(w)) return Sg(h, w, m)
        }
        return m
    }

    function rR(h, m, w, O, K, ae, ge, Re, Pe) {
        return h = s_(w, O, !0, h, K, ae, ge, Re, Pe), h.context = k6(null), w = h.current, O = wo(), K = wd(w), ae = Sh(O, K), ae.callback = m ?? null, Up(w, ae, K), h.current.lanes = K, Bl(h, K, O), al(h, O), h
    }

    function c_(h, m, w, O) {
        var K = m.current, ae = wo(), ge = wd(K);
        return w = k6(w), m.context === null ? m.context = w : m.pendingContext = w, m = Sh(ae, ge), m.payload = {element: h}, O = O === void 0 ? null : O, O !== null && (m.callback = O), h = Up(K, m, ge), h !== null && (bc(h, K, ge, ae), I2(h, K, ge)), ge
    }

    function l_(h) {
        if (h = h.current, !h.child) return null;
        switch (h.child.tag) {
            case 5:
                return h.child.stateNode;
            default:
                return h.child.stateNode
        }
    }

    function R6(h, m) {
        if (h = h.memoizedState, h !== null && h.dehydrated !== null) {
            var w = h.retryLane;
            h.retryLane = w !== 0 && w < m ? w : m
        }
    }

    function u_(h, m) {
        R6(h, m), (h = h.alternate) && R6(h, m)
    }

    function nR() {
        return null
    }

    var $m = typeof reportError == "function" ? reportError : function (h) {
        console.error(h)
    };

    function D6(h) {
        this._internalRoot = h
    }

    f_.prototype.render = D6.prototype.render = function (h) {
        var m = this._internalRoot;
        if (m === null) throw Error(r(409));
        c_(h, m, null, null)
    }, f_.prototype.unmount = D6.prototype.unmount = function () {
        var h = this._internalRoot;
        if (h !== null) {
            this._internalRoot = null;
            var m = h.containerInfo;
            Lm(function () {
                c_(null, h, null, null)
            }), m[gf] = null
        }
    };

    function f_(h) {
        this._internalRoot = h
    }

    f_.prototype.unstable_scheduleHydration = function (h) {
        if (h) {
            var m = Yc();
            h = {blockedOn: null, target: h, priority: m};
            for (var w = 0; w < ba.length && m !== 0 && m < ba[w].priority; w++) ;
            ba.splice(w, 0, h), w === 0 && cm(h)
        }
    };

    function M6(h) {
        return !(!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
    }

    function d_(h) {
        return !(!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11 && (h.nodeType !== 8 || h.nodeValue !== " react-mount-point-unstable "))
    }

    function iR() {
    }

    function a$(h, m, w, O, K) {
        if (K) {
            if (typeof O == "function") {
                var ae = O;
                O = function () {
                    var et = l_(ge);
                    ae.call(et)
                }
            }
            var ge = rR(m, O, h, 0, null, !1, !1, "", iR);
            return h._reactRootContainer = ge, h[gf] = ge.current, W1(h.nodeType === 8 ? h.parentNode : h), Lm(), ge
        }
        for (; K = h.lastChild;) h.removeChild(K);
        if (typeof O == "function") {
            var Re = O;
            O = function () {
                var et = l_(Pe);
                Re.call(et)
            }
        }
        var Pe = s_(h, 0, !1, null, null, !1, !1, "", iR);
        return h._reactRootContainer = Pe, h[gf] = Pe.current, W1(h.nodeType === 8 ? h.parentNode : h), Lm(function () {
            c_(m, Pe, w, O)
        }), Pe
    }

    function Cb(h, m, w, O, K) {
        var ae = w._reactRootContainer;
        if (ae) {
            var ge = ae;
            if (typeof K == "function") {
                var Re = K;
                K = function () {
                    var Pe = l_(ge);
                    Re.call(Pe)
                }
            }
            c_(m, ge, h, K)
        } else ge = a$(w, m, h, K, O);
        return l_(ge)
    }

    Eu = function (h) {
        switch (h.tag) {
            case 3:
                var m = h.stateNode;
                if (m.current.memoizedState.isDehydrated) {
                    var w = us(m.pendingLanes);
                    w !== 0 && ($l(m, w | 1), al(m, Pt()), !(ei & 6) && (Rg = Pt() + 500, yf()))
                }
                break;
            case 13:
                Lm(function () {
                    var O = jl(h, 1);
                    if (O !== null) {
                        var K = wo();
                        bc(O, h, 1, K)
                    }
                }), u_(h, 1)
        }
    }, pf = function (h) {
        if (h.tag === 13) {
            var m = jl(h, 134217728);
            if (m !== null) {
                var w = wo();
                bc(m, h, 134217728, w)
            }
            u_(h, 134217728)
        }
    }, Lr = function (h) {
        if (h.tag === 13) {
            var m = wd(h), w = jl(h, m);
            if (w !== null) {
                var O = wo();
                bc(w, h, m, O)
            }
            u_(h, m)
        }
    }, Yc = function () {
        return Bn
    }, Va = function (h, m) {
        var w = Bn;
        try {
            return Bn = h, m()
        } finally {
            Bn = w
        }
    }, cr = function (h, m, w) {
        switch (m) {
            case"input":
                if (Be(h, w), m = w.name, w.type === "radio" && m != null) {
                    for (w = h; w.parentNode;) w = w.parentNode;
                    for (w = w.querySelectorAll("input[name=" + JSON.stringify("" + m) + '][type="radio"]'), m = 0; m < w.length; m++) {
                        var O = w[m];
                        if (O !== h && O.form === h.form) {
                            var K = Dn(O);
                            if (!K) throw Error(r(90));
                            ne(O), Be(O, K)
                        }
                    }
                }
                break;
            case"textarea":
                _t(h, w);
                break;
            case"select":
                m = w.value, m != null && gt(h, !!w.multiple, m, !1)
        }
    }, hn = E6, En = Lm;
    var o$ = {usingClientEntryPoint: !1, Events: [ld, pa, Dn, Yr, br, E6]},
        Ab = {findFiberByHostInstance: Ar, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom"}, aR = {
            bundleType: Ab.bundleType,
            version: Ab.version,
            rendererPackageName: Ab.rendererPackageName,
            rendererConfig: Ab.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: V.ReactCurrentDispatcher,
            findHostInstanceByFiber: function (h) {
                return h = Ur(h), h === null ? null : h.stateNode
            },
            findFiberByHostInstance: Ab.findFiberByHostInstance || nR,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
        };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Yp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Yp.isDisabled && Yp.supportsFiber) try {
            Ja = Yp.inject(aR), qi = Yp
        } catch {
        }
    }
    return Uu.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = o$, Uu.createPortal = function (h, m) {
        var w = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!M6(m)) throw Error(r(200));
        return i$(h, m, null, w)
    }, Uu.createRoot = function (h, m) {
        if (!M6(h)) throw Error(r(299));
        var w = !1, O = "", K = $m;
        return m != null && (m.unstable_strictMode === !0 && (w = !0), m.identifierPrefix !== void 0 && (O = m.identifierPrefix), m.onRecoverableError !== void 0 && (K = m.onRecoverableError)), m = s_(h, 1, !1, null, null, w, !1, O, K), h[gf] = m.current, W1(h.nodeType === 8 ? h.parentNode : h), new D6(m)
    }, Uu.findDOMNode = function (h) {
        if (h == null) return null;
        if (h.nodeType === 1) return h;
        var m = h._reactInternals;
        if (m === void 0) throw typeof h.render == "function" ? Error(r(188)) : (h = Object.keys(h).join(","), Error(r(268, h)));
        return h = Ur(m), h = h === null ? null : h.stateNode, h
    }, Uu.flushSync = function (h) {
        return Lm(h)
    }, Uu.hydrate = function (h, m, w) {
        if (!d_(m)) throw Error(r(200));
        return Cb(null, h, m, !0, w)
    }, Uu.hydrateRoot = function (h, m, w) {
        if (!M6(h)) throw Error(r(405));
        var O = w != null && w.hydratedSources || null, K = !1, ae = "", ge = $m;
        if (w != null && (w.unstable_strictMode === !0 && (K = !0), w.identifierPrefix !== void 0 && (ae = w.identifierPrefix), w.onRecoverableError !== void 0 && (ge = w.onRecoverableError)), m = rR(m, null, h, 1, w ?? null, K, !1, ae, ge), h[gf] = m.current, W1(h), O) for (h = 0; h < O.length; h++) w = O[h], K = w._getVersion, K = K(w._source), m.mutableSourceEagerHydrationData == null ? m.mutableSourceEagerHydrationData = [w, K] : m.mutableSourceEagerHydrationData.push(w, K);
        return new f_(m)
    }, Uu.render = function (h, m, w) {
        if (!d_(m)) throw Error(r(200));
        return Cb(null, h, m, !1, w)
    }, Uu.unmountComponentAtNode = function (h) {
        if (!d_(h)) throw Error(r(40));
        return h._reactRootContainer ? (Lm(function () {
            Cb(null, null, h, !1, function () {
                h._reactRootContainer = null, h[gf] = null
            })
        }), !0) : !1
    }, Uu.unstable_batchedUpdates = E6, Uu.unstable_renderSubtreeIntoContainer = function (h, m, w, O) {
        if (!d_(w)) throw Error(r(200));
        if (h == null || h._reactInternals === void 0) throw Error(r(38));
        return Cb(h, m, w, !1, O)
    }, Uu.version = "18.3.1-next-f1338f8080-20240426", Uu
}

var ju = {}, Loe;

function V$e() {
    return Loe || (Loe = 1, Ve.env.NODE_ENV !== "production" && function () {
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
        var t = Kv(), e = mge(), r = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, n = !1;

        function i(c) {
            n = c
        }

        function a(c) {
            if (!n) {
                for (var u = arguments.length, v = new Array(u > 1 ? u - 1 : 0), y = 1; y < u; y++) v[y - 1] = arguments[y];
                s("warn", c, v)
            }
        }

        function o(c) {
            if (!n) {
                for (var u = arguments.length, v = new Array(u > 1 ? u - 1 : 0), y = 1; y < u; y++) v[y - 1] = arguments[y];
                s("error", c, v)
            }
        }

        function s(c, u, v) {
            {
                var y = r.ReactDebugCurrentFrame, E = y.getStackAddendum();
                E !== "" && (u += "%s", v = v.concat([E]));
                var L = v.map(function (Z) {
                    return String(Z)
                });
                L.unshift("Warning: " + u), Function.prototype.apply.call(console[c], console, L)
            }
        }

        var l = 0, f = 1, d = 2, p = 3, g = 4, b = 5, S = 6, T = 7, I = 8, N = 9, P = 10, F = 11, V = 12, Y = 13,
            ee = 14, oe = 15, G = 16, J = 17, ce = 18, re = 19, M = 21, D = 22, x = 23, A = 24, B = 25, z = !0, j = !1,
            $ = !1, C = !1, R = !1, k = !0, Q = !1, fe = !0, ye = new Set, ue = {}, me = {};

        function Se(c, u) {
            Ce(c, u), Ce(c + "Capture", u)
        }

        function Ce(c, u) {
            ue[c] && o("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", c), ue[c] = u;
            {
                var v = c.toLowerCase();
                me[v] = c, c === "onDoubleClick" && (me.ondblclick = c)
            }
            for (var y = 0; y < u.length; y++) ye.add(u[y])
        }

        var Me = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
            ve = Object.prototype.hasOwnProperty;

        function ne(c) {
            {
                var u = typeof Symbol == "function" && Symbol.toStringTag,
                    v = u && c[Symbol.toStringTag] || c.constructor.name || "Object";
                return v
            }
        }

        function be(c) {
            try {
                return !1
            } catch {
                return !0
            }
        }

        function Ee(c) {
            return "" + c
        }

        function Oe(c, u) {
            if (be()) return o("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", u, ne(c)), Ee(c)
        }

        function ze(c) {
            if (be()) return o("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ne(c)), Ee(c)
        }

        function Be(c, u) {
            if (be()) return o("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", u, ne(c)), Ee(c)
        }

        function it(c, u) {
            if (be()) return o("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", u, ne(c)), Ee(c)
        }

        function Ue(c) {
            if (be()) return o("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", ne(c)), Ee(c)
        }

        function bt(c) {
            if (be()) return o("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", ne(c)), Ee(c)
        }

        var gt = 0, Ot = 1, zt = 2, _t = 3, Dt = 4, rr = 5, pe = 6,
            te = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",
            X = te + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", H = new RegExp("^[" + te + "][" + X + "]*$"),
            U = {}, q = {};

        function le(c) {
            return ve.call(q, c) ? !0 : ve.call(U, c) ? !1 : H.test(c) ? (q[c] = !0, !0) : (U[c] = !0, o("Invalid attribute name: `%s`", c), !1)
        }

        function xe(c, u, v) {
            return u !== null ? u.type === gt : v ? !1 : c.length > 2 && (c[0] === "o" || c[0] === "O") && (c[1] === "n" || c[1] === "N")
        }

        function Ae(c, u, v, y) {
            if (v !== null && v.type === gt) return !1;
            switch (typeof u) {
                case"function":
                case"symbol":
                    return !0;
                case"boolean": {
                    if (y) return !1;
                    if (v !== null) return !v.acceptsBooleans;
                    var E = c.toLowerCase().slice(0, 5);
                    return E !== "data-" && E !== "aria-"
                }
                default:
                    return !1
            }
        }

        function De(c, u, v, y) {
            if (u === null || typeof u > "u" || Ae(c, u, v, y)) return !0;
            if (y) return !1;
            if (v !== null) switch (v.type) {
                case _t:
                    return !u;
                case Dt:
                    return u === !1;
                case rr:
                    return isNaN(u);
                case pe:
                    return isNaN(u) || u < 1
            }
            return !1
        }

        function Ze(c) {
            return ht.hasOwnProperty(c) ? ht[c] : null
        }

        function ft(c, u, v, y, E, L, Z) {
            this.acceptsBooleans = u === zt || u === _t || u === Dt, this.attributeName = y, this.attributeNamespace = E, this.mustUseProperty = v, this.propertyName = c, this.type = u, this.sanitizeURL = L, this.removeEmptyString = Z
        }

        var ht = {},
            cr = ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"];
        cr.forEach(function (c) {
            ht[c] = new ft(c, gt, !1, c, null, !1, !1)
        }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (c) {
            var u = c[0], v = c[1];
            ht[u] = new ft(u, Ot, !1, v, null, !1, !1)
        }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (c) {
            ht[c] = new ft(c, zt, !1, c.toLowerCase(), null, !1, !1)
        }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (c) {
            ht[c] = new ft(c, zt, !1, c, null, !1, !1)
        }), ["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(function (c) {
            ht[c] = new ft(c, _t, !1, c.toLowerCase(), null, !1, !1)
        }), ["checked", "multiple", "muted", "selected"].forEach(function (c) {
            ht[c] = new ft(c, _t, !0, c, null, !1, !1)
        }), ["capture", "download"].forEach(function (c) {
            ht[c] = new ft(c, Dt, !1, c, null, !1, !1)
        }), ["cols", "rows", "size", "span"].forEach(function (c) {
            ht[c] = new ft(c, pe, !1, c, null, !1, !1)
        }), ["rowSpan", "start"].forEach(function (c) {
            ht[c] = new ft(c, rr, !1, c.toLowerCase(), null, !1, !1)
        });
        var Rt = /[\-\:]([a-z])/g, Gt = function (c) {
            return c[1].toUpperCase()
        };
        ["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(function (c) {
            var u = c.replace(Rt, Gt);
            ht[u] = new ft(u, Ot, !1, c, null, !1, !1)
        }), ["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(function (c) {
            var u = c.replace(Rt, Gt);
            ht[u] = new ft(u, Ot, !1, c, "http://www.w3.org/1999/xlink", !1, !1)
        }), ["xml:base", "xml:lang", "xml:space"].forEach(function (c) {
            var u = c.replace(Rt, Gt);
            ht[u] = new ft(u, Ot, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1)
        }), ["tabIndex", "crossOrigin"].forEach(function (c) {
            ht[c] = new ft(c, Ot, !1, c.toLowerCase(), null, !1, !1)
        });
        var sn = "xlinkHref";
        ht[sn] = new ft("xlinkHref", Ot, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (c) {
            ht[c] = new ft(c, Ot, !1, c.toLowerCase(), null, !0, !0)
        });
        var Yr = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i,
            br = !1;

        function hn(c) {
            !br && Yr.test(c) && (br = !0, o("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(c)))
        }

        function En(c, u, v, y) {
            if (y.mustUseProperty) {
                var E = y.propertyName;
                return c[E]
            } else {
                Oe(v, u), y.sanitizeURL && hn("" + v);
                var L = y.attributeName, Z = null;
                if (y.type === Dt) {
                    if (c.hasAttribute(L)) {
                        var se = c.getAttribute(L);
                        return se === "" ? !0 : De(u, v, y, !1) ? se : se === "" + v ? v : se
                    }
                } else if (c.hasAttribute(L)) {
                    if (De(u, v, y, !1)) return c.getAttribute(L);
                    if (y.type === _t) return v;
                    Z = c.getAttribute(L)
                }
                return De(u, v, y, !1) ? Z === null ? v : Z : Z === "" + v ? v : Z
            }
        }

        function _r(c, u, v, y) {
            {
                if (!le(u)) return;
                if (!c.hasAttribute(u)) return v === void 0 ? void 0 : null;
                var E = c.getAttribute(u);
                return Oe(v, u), E === "" + v ? v : E
            }
        }

        function _n(c, u, v, y) {
            var E = Ze(u);
            if (!xe(u, E, y)) {
                if (De(u, v, E, y) && (v = null), y || E === null) {
                    if (le(u)) {
                        var L = u;
                        v === null ? c.removeAttribute(L) : (Oe(v, u), c.setAttribute(L, "" + v))
                    }
                    return
                }
                var Z = E.mustUseProperty;
                if (Z) {
                    var se = E.propertyName;
                    if (v === null) {
                        var he = E.type;
                        c[se] = he === _t ? !1 : ""
                    } else c[se] = v;
                    return
                }
                var we = E.attributeName, _e = E.attributeNamespace;
                if (v === null) c.removeAttribute(we); else {
                    var Fe = E.type, Le;
                    Fe === _t || Fe === Dt && v === !0 ? Le = "" : (Oe(v, we), Le = "" + v, E.sanitizeURL && hn(Le.toString())), _e ? c.setAttributeNS(_e, we, Le) : c.setAttribute(we, Le)
                }
            }
        }

        var Nr = Symbol.for("react.element"), mr = Symbol.for("react.portal"), fn = Symbol.for("react.fragment"),
            Hn = Symbol.for("react.strict_mode"), Cr = Symbol.for("react.profiler"), An = Symbol.for("react.provider"),
            pn = Symbol.for("react.context"), wr = Symbol.for("react.forward_ref"), ke = Symbol.for("react.suspense"),
            st = Symbol.for("react.suspense_list"), ot = Symbol.for("react.memo"), xt = Symbol.for("react.lazy"),
            Yt = Symbol.for("react.scope"), vr = Symbol.for("react.debug_trace_mode"),
            Vr = Symbol.for("react.offscreen"), Ur = Symbol.for("react.legacy_hidden"), fi = Symbol.for("react.cache"),
            In = Symbol.for("react.tracing_marker"), kn = Symbol.iterator, Ai = "@@iterator";

        function Fi(c) {
            if (c === null || typeof c != "object") return null;
            var u = kn && c[kn] || c[Ai];
            return typeof u == "function" ? u : null
        }

        var Pt = Object.assign, Wn = 0, Da, Ma, Oa, Za, Po, Ja, qi;

        function Ko() {
        }

        Ko.__reactDisabledLog = !0;

        function Pa() {
            {
                if (Wn === 0) {
                    Da = console.log, Ma = console.info, Oa = console.warn, Za = console.error, Po = console.group, Ja = console.groupCollapsed, qi = console.groupEnd;
                    var c = {configurable: !0, enumerable: !0, value: Ko, writable: !0};
                    Object.defineProperties(console, {
                        info: c,
                        log: c,
                        warn: c,
                        error: c,
                        group: c,
                        groupCollapsed: c,
                        groupEnd: c
                    })
                }
                Wn++
            }
        }

        function Dl() {
            {
                if (Wn--, Wn === 0) {
                    var c = {configurable: !0, enumerable: !0, writable: !0};
                    Object.defineProperties(console, {
                        log: Pt({}, c, {value: Da}),
                        info: Pt({}, c, {value: Ma}),
                        warn: Pt({}, c, {value: Oa}),
                        error: Pt({}, c, {value: Za}),
                        group: Pt({}, c, {value: Po}),
                        groupCollapsed: Pt({}, c, {value: Ja}),
                        groupEnd: Pt({}, c, {value: qi})
                    })
                }
                Wn < 0 && o("disabledDepth fell below zero. This is a bug in React. Please file an issue.")
            }
        }

        var df = r.ReactCurrentDispatcher, hf;

        function Yo(c, u, v) {
            {
                if (hf === void 0) try {
                    throw Error()
                } catch (E) {
                    var y = E.stack.trim().match(/\n( *(at )?)/);
                    hf = y && y[1] || ""
                }
                return `
` + hf + c
            }
        }

        var Ml = !1, us;
        {
            var Ol = typeof WeakMap == "function" ? WeakMap : Map;
            us = new Ol
        }

        function Pl(c, u) {
            if (!c || Ml) return "";
            {
                var v = us.get(c);
                if (v !== void 0) return v
            }
            var y;
            Ml = !0;
            var E = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var L;
            L = df.current, df.current = null, Pa();
            try {
                if (u) {
                    var Z = function () {
                        throw Error()
                    };
                    if (Object.defineProperty(Z.prototype, "props", {
                        set: function () {
                            throw Error()
                        }
                    }), typeof Reflect == "object" && Reflect.construct) {
                        try {
                            Reflect.construct(Z, [])
                        } catch (nt) {
                            y = nt
                        }
                        Reflect.construct(c, [], Z)
                    } else {
                        try {
                            Z.call()
                        } catch (nt) {
                            y = nt
                        }
                        c.call(Z.prototype)
                    }
                } else {
                    try {
                        throw Error()
                    } catch (nt) {
                        y = nt
                    }
                    c()
                }
            } catch (nt) {
                if (nt && y && typeof nt.stack == "string") {
                    for (var se = nt.stack.split(`
`), he = y.stack.split(`
`), we = se.length - 1, _e = he.length - 1; we >= 1 && _e >= 0 && se[we] !== he[_e];) _e--;
                    for (; we >= 1 && _e >= 0; we--, _e--) if (se[we] !== he[_e]) {
                        if (we !== 1 || _e !== 1) do if (we--, _e--, _e < 0 || se[we] !== he[_e]) {
                            var Fe = `
` + se[we].replace(" at new ", " at ");
                            return c.displayName && Fe.includes("<anonymous>") && (Fe = Fe.replace("<anonymous>", c.displayName)), typeof c == "function" && us.set(c, Fe), Fe
                        } while (we >= 1 && _e >= 0);
                        break
                    }
                }
            } finally {
                Ml = !1, df.current = L, Dl(), Error.prepareStackTrace = E
            }
            var Le = c ? c.displayName || c.name : "", Qe = Le ? Yo(Le) : "";
            return typeof c == "function" && us.set(c, Qe), Qe
        }

        function Nl(c, u, v) {
            return Pl(c, !0)
        }

        function fs(c, u, v) {
            return Pl(c, !1)
        }

        function lh(c) {
            var u = c.prototype;
            return !!(u && u.isReactComponent)
        }

        function Ll(c, u, v) {
            if (c == null) return "";
            if (typeof c == "function") return Pl(c, lh(c));
            if (typeof c == "string") return Yo(c);
            switch (c) {
                case ke:
                    return Yo("Suspense");
                case st:
                    return Yo("SuspenseList")
            }
            if (typeof c == "object") switch (c.$$typeof) {
                case wr:
                    return fs(c.render);
                case ot:
                    return Ll(c.type);
                case xt: {
                    var y = c, E = y._payload, L = y._init;
                    try {
                        return Ll(L(E))
                    } catch {
                    }
                }
            }
            return ""
        }

        function Bl(c) {
            switch (c.tag) {
                case b:
                    return Yo(c.type);
                case G:
                    return Yo("Lazy");
                case Y:
                    return Yo("Suspense");
                case re:
                    return Yo("SuspenseList");
                case l:
                case d:
                case oe:
                    return fs(c.type);
                case F:
                    return fs(c.type.render);
                case f:
                    return Nl(c.type);
                default:
                    return ""
            }
        }

        function uh(c) {
            try {
                var u = "", v = c;
                do u += Bl(v), v = v.return; while (v);
                return u
            } catch (y) {
                return `
Error generating stack: ` + y.message + `
` + y.stack
            }
        }

        function $l(c, u, v) {
            var y = c.displayName;
            if (y) return y;
            var E = u.displayName || u.name || "";
            return E !== "" ? v + "(" + E + ")" : v
        }

        function Bn(c) {
            return c.displayName || "Context"
        }

        function $n(c) {
            if (c == null) return null;
            if (typeof c.tag == "number" && o("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function") return c.displayName || c.name || null;
            if (typeof c == "string") return c;
            switch (c) {
                case fn:
                    return "Fragment";
                case mr:
                    return "Portal";
                case Cr:
                    return "Profiler";
                case Hn:
                    return "StrictMode";
                case ke:
                    return "Suspense";
                case st:
                    return "SuspenseList"
            }
            if (typeof c == "object") switch (c.$$typeof) {
                case pn:
                    var u = c;
                    return Bn(u) + ".Consumer";
                case An:
                    var v = c;
                    return Bn(v._context) + ".Provider";
                case wr:
                    return $l(c, c.render, "ForwardRef");
                case ot:
                    var y = c.displayName || null;
                    return y !== null ? y : $n(c.type) || "Memo";
                case xt: {
                    var E = c, L = E._payload, Z = E._init;
                    try {
                        return $n(Z(L))
                    } catch {
                        return null
                    }
                }
            }
            return null
        }

        function Eu(c, u, v) {
            var y = u.displayName || u.name || "";
            return c.displayName || (y !== "" ? v + "(" + y + ")" : v)
        }

        function pf(c) {
            return c.displayName || "Context"
        }

        function Lr(c) {
            var u = c.tag, v = c.type;
            switch (u) {
                case A:
                    return "Cache";
                case N:
                    var y = v;
                    return pf(y) + ".Consumer";
                case P:
                    var E = v;
                    return pf(E._context) + ".Provider";
                case ce:
                    return "DehydratedFragment";
                case F:
                    return Eu(v, v.render, "ForwardRef");
                case T:
                    return "Fragment";
                case b:
                    return v;
                case g:
                    return "Portal";
                case p:
                    return "Root";
                case S:
                    return "Text";
                case G:
                    return $n(v);
                case I:
                    return v === Hn ? "StrictMode" : "Mode";
                case D:
                    return "Offscreen";
                case V:
                    return "Profiler";
                case M:
                    return "Scope";
                case Y:
                    return "Suspense";
                case re:
                    return "SuspenseList";
                case B:
                    return "TracingMarker";
                case f:
                case l:
                case J:
                case d:
                case ee:
                case oe:
                    if (typeof v == "function") return v.displayName || v.name || null;
                    if (typeof v == "string") return v;
                    break
            }
            return null
        }

        var Yc = r.ReactDebugCurrentFrame, Va = null, Xc = !1;

        function fc() {
            {
                if (Va === null) return null;
                var c = Va._debugOwner;
                if (c !== null && typeof c < "u") return Lr(c)
            }
            return null
        }

        function No() {
            return Va === null ? "" : uh(Va)
        }

        function Ii() {
            Yc.getCurrentStack = null, Va = null, Xc = !1
        }

        function Fn(c) {
            Yc.getCurrentStack = c === null ? null : No, Va = c, Xc = !1
        }

        function Tu() {
            return Va
        }

        function Lo(c) {
            Xc = c
        }

        function ba(c) {
            return "" + c
        }

        function dc(c) {
            switch (typeof c) {
                case"boolean":
                case"number":
                case"string":
                case"undefined":
                    return c;
                case"object":
                    return bt(c), c;
                default:
                    return ""
            }
        }

        var kp = {button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0};

        function ds(c, u) {
            kp[u.type] || u.onChange || u.onInput || u.readOnly || u.disabled || u.value == null || o("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), u.onChange || u.readOnly || u.disabled || u.checked == null || o("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.")
        }

        function ad(c) {
            var u = c.type, v = c.nodeName;
            return v && v.toLowerCase() === "input" && (u === "checkbox" || u === "radio")
        }

        function cm(c) {
            return c._valueTracker
        }

        function od(c) {
            c._valueTracker = null
        }

        function fh(c) {
            var u = "";
            return c && (ad(c) ? u = c.checked ? "true" : "false" : u = c.value), u
        }

        function ug(c) {
            var u = ad(c) ? "checked" : "value", v = Object.getOwnPropertyDescriptor(c.constructor.prototype, u);
            bt(c[u]);
            var y = "" + c[u];
            if (!(c.hasOwnProperty(u) || typeof v > "u" || typeof v.get != "function" || typeof v.set != "function")) {
                var E = v.get, L = v.set;
                Object.defineProperty(c, u, {
                    configurable: !0, get: function () {
                        return E.call(this)
                    }, set: function (se) {
                        bt(se), y = "" + se, L.call(this, se)
                    }
                }), Object.defineProperty(c, u, {enumerable: v.enumerable});
                var Z = {
                    getValue: function () {
                        return y
                    }, setValue: function (se) {
                        bt(se), y = "" + se
                    }, stopTracking: function () {
                        od(c), delete c[u]
                    }
                };
                return Z
            }
        }

        function hs(c) {
            cm(c) || (c._valueTracker = ug(c))
        }

        function mf(c) {
            if (!c) return !1;
            var u = cm(c);
            if (!u) return !0;
            var v = u.getValue(), y = fh(c);
            return y !== v ? (u.setValue(y), !0) : !1
        }

        function hc(c) {
            if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u") return null;
            try {
                return c.activeElement || c.body
            } catch {
                return c.body
            }
        }

        var Cu = !1, Te = !1, Ne = !1, Xe = !1;

        function Vt(c) {
            var u = c.type === "checkbox" || c.type === "radio";
            return u ? c.checked != null : c.value != null
        }

        function bn(c, u) {
            var v = c, y = u.checked, E = Pt({}, u, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: void 0,
                checked: y ?? v._wrapperState.initialChecked
            });
            return E
        }

        function di(c, u) {
            ds("input", u), u.checked !== void 0 && u.defaultChecked !== void 0 && !Te && (o("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", fc() || "A component", u.type), Te = !0), u.value !== void 0 && u.defaultValue !== void 0 && !Cu && (o("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", fc() || "A component", u.type), Cu = !0);
            var v = c, y = u.defaultValue == null ? "" : u.defaultValue;
            v._wrapperState = {
                initialChecked: u.checked != null ? u.checked : u.defaultChecked,
                initialValue: dc(u.value != null ? u.value : y),
                controlled: Vt(u)
            }
        }

        function Qn(c, u) {
            var v = c, y = u.checked;
            y != null && _n(v, "checked", y, !1)
        }

        function de(c, u) {
            var v = c;
            {
                var y = Vt(u);
                !v._wrapperState.controlled && y && !Xe && (o("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Xe = !0), v._wrapperState.controlled && !y && !Ne && (o("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Ne = !0)
            }
            Qn(c, u);
            var E = dc(u.value), L = u.type;
            if (E != null) L === "number" ? (E === 0 && v.value === "" || v.value != E) && (v.value = ba(E)) : v.value !== ba(E) && (v.value = ba(E)); else if (L === "submit" || L === "reset") {
                v.removeAttribute("value");
                return
            }
            u.hasOwnProperty("value") ? Et(v, u.type, E) : u.hasOwnProperty("defaultValue") && Et(v, u.type, dc(u.defaultValue)), u.checked == null && u.defaultChecked != null && (v.defaultChecked = !!u.defaultChecked)
        }

        function Ie(c, u, v) {
            var y = c;
            if (u.hasOwnProperty("value") || u.hasOwnProperty("defaultValue")) {
                var E = u.type, L = E === "submit" || E === "reset";
                if (L && (u.value === void 0 || u.value === null)) return;
                var Z = ba(y._wrapperState.initialValue);
                v || Z !== y.value && (y.value = Z), y.defaultValue = Z
            }
            var se = y.name;
            se !== "" && (y.name = ""), y.defaultChecked = !y.defaultChecked, y.defaultChecked = !!y._wrapperState.initialChecked, se !== "" && (y.name = se)
        }

        function Ye(c, u) {
            var v = c;
            de(v, u), rt(v, u)
        }

        function rt(c, u) {
            var v = u.name;
            if (u.type === "radio" && v != null) {
                for (var y = c; y.parentNode;) y = y.parentNode;
                Oe(v, "name");
                for (var E = y.querySelectorAll("input[name=" + JSON.stringify("" + v) + '][type="radio"]'), L = 0; L < E.length; L++) {
                    var Z = E[L];
                    if (!(Z === c || Z.form !== c.form)) {
                        var se = xR(Z);
                        if (!se) throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                        mf(Z), de(Z, se)
                    }
                }
            }
        }

        function Et(c, u, v) {
            (u !== "number" || hc(c.ownerDocument) !== c) && (v == null ? c.defaultValue = ba(c._wrapperState.initialValue) : c.defaultValue !== ba(v) && (c.defaultValue = ba(v)))
        }

        var Dr = !1, Nt = !1, Br = !1;

        function Rn(c, u) {
            u.value == null && (typeof u.children == "object" && u.children !== null ? t.Children.forEach(u.children, function (v) {
                v != null && (typeof v == "string" || typeof v == "number" || Nt || (Nt = !0, o("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")))
            }) : u.dangerouslySetInnerHTML != null && (Br || (Br = !0, o("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), u.selected != null && !Dr && (o("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Dr = !0)
        }

        function hi(c, u) {
            u.value != null && c.setAttribute("value", ba(dc(u.value)))
        }

        var sa = Array.isArray;

        function wn(c) {
            return sa(c)
        }

        var Ui;
        Ui = !1;

        function Ji() {
            var c = fc();
            return c ? `

Check the render method of \`` + c + "`." : ""
        }

        var Na = ["value", "defaultValue"];

        function lm(c) {
            {
                ds("select", c);
                for (var u = 0; u < Na.length; u++) {
                    var v = Na[u];
                    if (c[v] != null) {
                        var y = wn(c[v]);
                        c.multiple && !y ? o("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", v, Ji()) : !c.multiple && y && o("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", v, Ji())
                    }
                }
            }
        }

        function sd(c, u, v, y) {
            var E = c.options;
            if (u) {
                for (var L = v, Z = {}, se = 0; se < L.length; se++) Z["$" + L[se]] = !0;
                for (var he = 0; he < E.length; he++) {
                    var we = Z.hasOwnProperty("$" + E[he].value);
                    E[he].selected !== we && (E[he].selected = we), we && y && (E[he].defaultSelected = !0)
                }
            } else {
                for (var _e = ba(dc(v)), Fe = null, Le = 0; Le < E.length; Le++) {
                    if (E[Le].value === _e) {
                        E[Le].selected = !0, y && (E[Le].defaultSelected = !0);
                        return
                    }
                    Fe === null && !E[Le].disabled && (Fe = E[Le])
                }
                Fe !== null && (Fe.selected = !0)
            }
        }

        function fg(c, u) {
            return Pt({}, u, {value: void 0})
        }

        function i2(c, u) {
            var v = c;
            lm(u), v._wrapperState = {wasMultiple: !!u.multiple}, u.value !== void 0 && u.defaultValue !== void 0 && !Ui && (o("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ui = !0)
        }

        function dg(c, u) {
            var v = c;
            v.multiple = !!u.multiple;
            var y = u.value;
            y != null ? sd(v, !!u.multiple, y, !1) : u.defaultValue != null && sd(v, !!u.multiple, u.defaultValue, !0)
        }

        function D3(c, u) {
            var v = c, y = v._wrapperState.wasMultiple;
            v._wrapperState.wasMultiple = !!u.multiple;
            var E = u.value;
            E != null ? sd(v, !!u.multiple, E, !1) : y !== !!u.multiple && (u.defaultValue != null ? sd(v, !!u.multiple, u.defaultValue, !0) : sd(v, !!u.multiple, u.multiple ? [] : "", !1))
        }

        function a2(c, u) {
            var v = c, y = u.value;
            y != null && sd(v, !!u.multiple, y, !1)
        }

        var o2 = !1;

        function M3(c, u) {
            var v = c;
            if (u.dangerouslySetInnerHTML != null) throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            var y = Pt({}, u, {value: void 0, defaultValue: void 0, children: ba(v._wrapperState.initialValue)});
            return y
        }

        function tk(c, u) {
            var v = c;
            ds("textarea", u), u.value !== void 0 && u.defaultValue !== void 0 && !o2 && (o("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", fc() || "A component"), o2 = !0);
            var y = u.value;
            if (y == null) {
                var E = u.children, L = u.defaultValue;
                if (E != null) {
                    o("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                    {
                        if (L != null) throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                        if (wn(E)) {
                            if (E.length > 1) throw new Error("<textarea> can only have at most one child.");
                            E = E[0]
                        }
                        L = E
                    }
                }
                L == null && (L = ""), y = L
            }
            v._wrapperState = {initialValue: dc(y)}
        }

        function O3(c, u) {
            var v = c, y = dc(u.value), E = dc(u.defaultValue);
            if (y != null) {
                var L = ba(y);
                L !== v.value && (v.value = L), u.defaultValue == null && v.defaultValue !== L && (v.defaultValue = L)
            }
            E != null && (v.defaultValue = ba(E))
        }

        function rk(c, u) {
            var v = c, y = v.textContent;
            y === v._wrapperState.initialValue && y !== "" && y !== null && (v.value = y)
        }

        function AB(c, u) {
            O3(c, u)
        }

        var dh = "http://www.w3.org/1999/xhtml", IB = "http://www.w3.org/1998/Math/MathML",
            $1 = "http://www.w3.org/2000/svg";

        function P3(c) {
            switch (c) {
                case"svg":
                    return $1;
                case"math":
                    return IB;
                default:
                    return dh
            }
        }

        function N3(c, u) {
            return c == null || c === dh ? P3(u) : c === $1 && u === "foreignObject" ? dh : c
        }

        var kB = function (c) {
            return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (u, v, y, E) {
                MSApp.execUnsafeLocalFunction(function () {
                    return c(u, v, y, E)
                })
            } : c
        }, F1, nk = kB(function (c, u) {
            if (c.namespaceURI === $1 && !("innerHTML" in c)) {
                F1 = F1 || document.createElement("div"), F1.innerHTML = "<svg>" + u.valueOf().toString() + "</svg>";
                for (var v = F1.firstChild; c.firstChild;) c.removeChild(c.firstChild);
                for (; v.firstChild;) c.appendChild(v.firstChild);
                return
            }
            c.innerHTML = u
        }), Qc = 1, hh = 3, ho = 8, ph = 9, L3 = 11, s2 = function (c, u) {
            if (u) {
                var v = c.firstChild;
                if (v && v === c.lastChild && v.nodeType === hh) {
                    v.nodeValue = u;
                    return
                }
            }
            c.textContent = u
        }, B3 = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
        }, mh = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0
        };

        function RB(c, u) {
            return c + u.charAt(0).toUpperCase() + u.substring(1)
        }

        var ik = ["Webkit", "ms", "Moz", "O"];
        Object.keys(mh).forEach(function (c) {
            ik.forEach(function (u) {
                mh[RB(u, c)] = mh[c]
            })
        });

        function c2(c, u, v) {
            var y = u == null || typeof u == "boolean" || u === "";
            return y ? "" : !v && typeof u == "number" && u !== 0 && !(mh.hasOwnProperty(c) && mh[c]) ? u + "px" : (it(u, c), ("" + u).trim())
        }

        var ak = /([A-Z])/g, ok = /^ms-/;

        function sk(c) {
            return c.replace(ak, "-$1").toLowerCase().replace(ok, "-ms-")
        }

        var um = function () {
        };
        {
            var DB = /^(?:webkit|moz|o)[A-Z]/, MB = /^-ms-/, OB = /-(.)/g, $3 = /;\s*$/, fm = {}, dm = {}, hg = !1,
                ck = !1, l2 = function (c) {
                    return c.replace(OB, function (u, v) {
                        return v.toUpperCase()
                    })
                }, PB = function (c) {
                    fm.hasOwnProperty(c) && fm[c] || (fm[c] = !0, o("Unsupported style property %s. Did you mean %s?", c, l2(c.replace(MB, "ms-"))))
                }, lk = function (c) {
                    fm.hasOwnProperty(c) && fm[c] || (fm[c] = !0, o("Unsupported vendor-prefixed style property %s. Did you mean %s?", c, c.charAt(0).toUpperCase() + c.slice(1)))
                }, F3 = function (c, u) {
                    dm.hasOwnProperty(u) && dm[u] || (dm[u] = !0, o(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, c, u.replace($3, "")))
                }, U3 = function (c, u) {
                    hg || (hg = !0, o("`NaN` is an invalid value for the `%s` css style property.", c))
                }, uk = function (c, u) {
                    ck || (ck = !0, o("`Infinity` is an invalid value for the `%s` css style property.", c))
                };
            um = function (c, u) {
                c.indexOf("-") > -1 ? PB(c) : DB.test(c) ? lk(c) : $3.test(u) && F3(c, u), typeof u == "number" && (isNaN(u) ? U3(c, u) : isFinite(u) || uk(c, u))
            }
        }
        var fk = um;

        function dk(c) {
            {
                var u = "", v = "";
                for (var y in c) if (c.hasOwnProperty(y)) {
                    var E = c[y];
                    if (E != null) {
                        var L = y.indexOf("--") === 0;
                        u += v + (L ? y : sk(y)) + ":", u += c2(y, E, L), v = ";"
                    }
                }
                return u || null
            }
        }

        function hk(c, u) {
            var v = c.style;
            for (var y in u) if (u.hasOwnProperty(y)) {
                var E = y.indexOf("--") === 0;
                E || fk(y, u[y]);
                var L = c2(y, u[y], E);
                y === "float" && (y = "cssFloat"), E ? v.setProperty(y, L) : v[y] = L
            }
        }

        function NB(c) {
            return c == null || typeof c == "boolean" || c === ""
        }

        function pk(c) {
            var u = {};
            for (var v in c) for (var y = B3[v] || [v], E = 0; E < y.length; E++) u[y[E]] = v;
            return u
        }

        function LB(c, u) {
            {
                if (!u) return;
                var v = pk(c), y = pk(u), E = {};
                for (var L in v) {
                    var Z = v[L], se = y[L];
                    if (se && Z !== se) {
                        var he = Z + "," + se;
                        if (E[he]) continue;
                        E[he] = !0, o("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", NB(c[Z]) ? "Removing" : "Updating", Z, se)
                    }
                }
            }
        }

        var BB = {
            area: !0,
            base: !0,
            br: !0,
            col: !0,
            embed: !0,
            hr: !0,
            img: !0,
            input: !0,
            keygen: !0,
            link: !0,
            meta: !0,
            param: !0,
            source: !0,
            track: !0,
            wbr: !0
        }, vf = Pt({menuitem: !0}, BB), U1 = "__html";

        function u2(c, u) {
            if (u) {
                if (vf[c] && (u.children != null || u.dangerouslySetInnerHTML != null)) throw new Error(c + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                if (u.dangerouslySetInnerHTML != null) {
                    if (u.children != null) throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                    if (typeof u.dangerouslySetInnerHTML != "object" || !(U1 in u.dangerouslySetInnerHTML)) throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.")
                }
                if (!u.suppressContentEditableWarning && u.contentEditable && u.children != null && o("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), u.style != null && typeof u.style != "object") throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.")
            }
        }

        function Rp(c, u) {
            if (c.indexOf("-") === -1) return typeof u.is == "string";
            switch (c) {
                case"annotation-xml":
                case"color-profile":
                case"font-face":
                case"font-face-src":
                case"font-face-uri":
                case"font-face-format":
                case"font-face-name":
                case"missing-glyph":
                    return !1;
                default:
                    return !0
            }
        }

        var j1 = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
        }, j3 = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
        }, Dp = {}, $B = new RegExp("^(aria)-[" + X + "]*$"), FB = new RegExp("^(aria)[A-Z][" + X + "]*$");

        function pg(c, u) {
            {
                if (ve.call(Dp, u) && Dp[u]) return !0;
                if (FB.test(u)) {
                    var v = "aria-" + u.slice(4).toLowerCase(), y = j3.hasOwnProperty(v) ? v : null;
                    if (y == null) return o("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", u), Dp[u] = !0, !0;
                    if (u !== y) return o("Invalid ARIA attribute `%s`. Did you mean `%s`?", u, y), Dp[u] = !0, !0
                }
                if ($B.test(u)) {
                    var E = u.toLowerCase(), L = j3.hasOwnProperty(E) ? E : null;
                    if (L == null) return Dp[u] = !0, !1;
                    if (u !== L) return o("Unknown ARIA attribute `%s`. Did you mean `%s`?", u, L), Dp[u] = !0, !0
                }
            }
            return !0
        }

        function z3(c, u) {
            {
                var v = [];
                for (var y in u) {
                    var E = pg(c, y);
                    E || v.push(y)
                }
                var L = v.map(function (Z) {
                    return "`" + Z + "`"
                }).join(", ");
                v.length === 1 ? o("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", L, c) : v.length > 1 && o("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", L, c)
            }
        }

        function z1(c, u) {
            Rp(c, u) || z3(c, u)
        }

        var f2 = !1;

        function mk(c, u) {
            {
                if (c !== "input" && c !== "textarea" && c !== "select") return;
                u != null && u.value === null && !f2 && (f2 = !0, c === "select" && u.multiple ? o("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", c) : o("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", c))
            }
        }

        var V1 = function () {
        };
        {
            var po = {}, d2 = /^on./, vk = /^on[^A-Z]/, h2 = new RegExp("^(aria)-[" + X + "]*$"),
                gk = new RegExp("^(aria)[A-Z][" + X + "]*$");
            V1 = function (c, u, v, y) {
                if (ve.call(po, u) && po[u]) return !0;
                var E = u.toLowerCase();
                if (E === "onfocusin" || E === "onfocusout") return o("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), po[u] = !0, !0;
                if (y != null) {
                    var L = y.registrationNameDependencies, Z = y.possibleRegistrationNames;
                    if (L.hasOwnProperty(u)) return !0;
                    var se = Z.hasOwnProperty(E) ? Z[E] : null;
                    if (se != null) return o("Invalid event handler property `%s`. Did you mean `%s`?", u, se), po[u] = !0, !0;
                    if (d2.test(u)) return o("Unknown event handler property `%s`. It will be ignored.", u), po[u] = !0, !0
                } else if (d2.test(u)) return vk.test(u) && o("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", u), po[u] = !0, !0;
                if (h2.test(u) || gk.test(u)) return !0;
                if (E === "innerhtml") return o("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), po[u] = !0, !0;
                if (E === "aria") return o("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), po[u] = !0, !0;
                if (E === "is" && v !== null && v !== void 0 && typeof v != "string") return o("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof v), po[u] = !0, !0;
                if (typeof v == "number" && isNaN(v)) return o("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", u), po[u] = !0, !0;
                var he = Ze(u), we = he !== null && he.type === gt;
                if (j1.hasOwnProperty(E)) {
                    var _e = j1[E];
                    if (_e !== u) return o("Invalid DOM property `%s`. Did you mean `%s`?", u, _e), po[u] = !0, !0
                } else if (!we && u !== E) return o("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", u, E), po[u] = !0, !0;
                return typeof v == "boolean" && Ae(u, v, he, !1) ? (v ? o('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', v, u, u, v, u) : o('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', v, u, u, v, u, u, u), po[u] = !0, !0) : we ? !0 : Ae(u, v, he, !1) ? (po[u] = !0, !1) : ((v === "false" || v === "true") && he !== null && he.type === _t && (o("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", v, u, v === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', u, v), po[u] = !0), !0)
            }
        }
        var yk = function (c, u, v) {
            {
                var y = [];
                for (var E in u) {
                    var L = V1(c, E, u[E], v);
                    L || y.push(E)
                }
                var Z = y.map(function (se) {
                    return "`" + se + "`"
                }).join(", ");
                y.length === 1 ? o("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Z, c) : y.length > 1 && o("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Z, c)
            }
        };

        function bk(c, u, v) {
            Rp(c, u) || yk(c, u, v)
        }

        var V3 = 1, p2 = 2, mg = 4, Mp = V3 | p2 | mg, hm = null;

        function H3(c) {
            hm !== null && o("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), hm = c
        }

        function UB() {
            hm === null && o("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), hm = null
        }

        function jB(c) {
            return c === hm
        }

        function pm(c) {
            var u = c.target || c.srcElement || window;
            return u.correspondingUseElement && (u = u.correspondingUseElement), u.nodeType === hh ? u.parentNode : u
        }

        var W3 = null, mm = null, vm = null;

        function ca(c) {
            var u = Lg(c);
            if (u) {
                if (typeof W3 != "function") throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
                var v = u.stateNode;
                if (v) {
                    var y = xR(v);
                    W3(u.stateNode, u.type, y)
                }
            }
        }

        function q3(c) {
            W3 = c
        }

        function H1(c) {
            mm ? vm ? vm.push(c) : vm = [c] : mm = c
        }

        function W1() {
            return mm !== null || vm !== null
        }

        function G3() {
            if (mm) {
                var c = mm, u = vm;
                if (mm = null, vm = null, ca(c), u) for (var v = 0; v < u.length; v++) ca(u[v])
            }
        }

        var m2 = function (c, u) {
            return c(u)
        }, vg = function () {
        }, gg = !1;

        function yg() {
            var c = W1();
            c && (vg(), G3())
        }

        function K3(c, u, v) {
            if (gg) return c(u, v);
            gg = !0;
            try {
                return m2(c, u, v)
            } finally {
                gg = !1, yg()
            }
        }

        function zB(c, u, v) {
            m2 = c, vg = v
        }

        function VB(c) {
            return c === "button" || c === "input" || c === "select" || c === "textarea"
        }

        function wk(c, u, v) {
            switch (c) {
                case"onClick":
                case"onClickCapture":
                case"onDoubleClick":
                case"onDoubleClickCapture":
                case"onMouseDown":
                case"onMouseDownCapture":
                case"onMouseMove":
                case"onMouseMoveCapture":
                case"onMouseUp":
                case"onMouseUpCapture":
                case"onMouseEnter":
                    return !!(v.disabled && VB(u));
                default:
                    return !1
            }
        }

        function Op(c, u) {
            var v = c.stateNode;
            if (v === null) return null;
            var y = xR(v);
            if (y === null) return null;
            var E = y[u];
            if (wk(u, c.type, y)) return null;
            if (E && typeof E != "function") throw new Error("Expected `" + u + "` listener to be a function, instead got a value of `" + typeof E + "` type.");
            return E
        }

        var bg = !1;
        if (Me) try {
            var gm = {};
            Object.defineProperty(gm, "passive", {
                get: function () {
                    bg = !0
                }
            }), window.addEventListener("test", gm, gm), window.removeEventListener("test", gm, gm)
        } catch {
            bg = !1
        }

        function v2(c, u, v, y, E, L, Z, se, he) {
            var we = Array.prototype.slice.call(arguments, 3);
            try {
                u.apply(v, we)
            } catch (_e) {
                this.onError(_e)
            }
        }

        var g2 = v2;
        if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
            var q1 = document.createElement("react");
            g2 = function (u, v, y, E, L, Z, se, he, we) {
                if (typeof document > "u" || document === null) throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                var _e = document.createEvent("Event"), Fe = !1, Le = !0, Qe = window.event,
                    nt = Object.getOwnPropertyDescriptor(window, "event");

                function lt() {
                    q1.removeEventListener(ut, jr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Qe)
                }

                var qt = Array.prototype.slice.call(arguments, 3);

                function jr() {
                    Fe = !0, lt(), v.apply(y, qt), Le = !1
                }

                var xr, ri = !1, qn = !1;

                function We(qe) {
                    if (xr = qe.error, ri = !0, xr === null && qe.colno === 0 && qe.lineno === 0 && (qn = !0), qe.defaultPrevented && xr != null && typeof xr == "object") try {
                        xr._suppressLogging = !0
                    } catch {
                    }
                }

                var ut = "react-" + (u || "invokeguardedcallback");
                if (window.addEventListener("error", We), q1.addEventListener(ut, jr, !1), _e.initEvent(ut, !1, !1), q1.dispatchEvent(_e), nt && Object.defineProperty(window, "event", nt), Fe && Le && (ri ? qn && (xr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : xr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(xr)), window.removeEventListener("error", We), !Fe) return lt(), v2.apply(this, arguments)
            }
        }
        var HB = g2, ym = !1, y2 = null, b2 = !1, G1 = null, Pp = {
            onError: function (c) {
                ym = !0, y2 = c
            }
        };

        function w2(c, u, v, y, E, L, Z, se, he) {
            ym = !1, y2 = null, HB.apply(Pp, arguments)
        }

        function wg(c, u, v, y, E, L, Z, se, he) {
            if (w2.apply(this, arguments), ym) {
                var we = gf();
                b2 || (b2 = !0, G1 = we)
            }
        }

        function cd() {
            if (b2) {
                var c = G1;
                throw b2 = !1, G1 = null, c
            }
        }

        function K1() {
            return ym
        }

        function gf() {
            if (ym) {
                var c = y2;
                return ym = !1, y2 = null, c
            } else throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.")
        }

        function Np(c) {
            return c._reactInternals
        }

        function WB(c) {
            return c._reactInternals !== void 0
        }

        function qB(c, u) {
            c._reactInternals = u
        }

        var Ar = 0, ld = 1, pa = 2, Dn = 4, vh = 16, ud = 32, fd = 64, Mr = 128, ai = 256, pc = 512, Ha = 1024,
            wa = 2048, mc = 4096, Au = 8192, ps = 16384, S2 = wa | Dn | fd | pc | Ha | ps, Sk = 32767, Sg = 32768,
            Xo = 65536, _2 = 131072, dd = 1048576, _g = 2097152, gh = 4194304, x2 = 8388608, yh = 16777216,
            yf = 33554432, Lp = Dn | Ha | 0, Bp = pa | Dn | vh | ud | pc | mc | Au, $p = Dn | fd | pc | Au,
            bh = wa | vh, mo = gh | x2 | _g, Iu = r.ReactCurrentOwner;

        function Fl(c) {
            var u = c, v = c;
            if (c.alternate) for (; u.return;) u = u.return; else {
                var y = u;
                do u = y, (u.flags & (pa | mc)) !== Ar && (v = u.return), y = u.return; while (y)
            }
            return u.tag === p ? v : null
        }

        function hd(c) {
            if (c.tag === Y) {
                var u = c.memoizedState;
                if (u === null) {
                    var v = c.alternate;
                    v !== null && (u = v.memoizedState)
                }
                if (u !== null) return u.dehydrated
            }
            return null
        }

        function pd(c) {
            return c.tag === p ? c.stateNode.containerInfo : null
        }

        function bm(c) {
            return Fl(c) === c
        }

        function _k(c) {
            {
                var u = Iu.current;
                if (u !== null && u.tag === f) {
                    var v = u, y = v.stateNode;
                    y._warnedAboutRefsInRender || o("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Lr(v) || "A component"), y._warnedAboutRefsInRender = !0
                }
            }
            var E = Np(c);
            return E ? Fl(E) === E : !1
        }

        function E2(c) {
            if (Fl(c) !== c) throw new Error("Unable to find node on an unmounted component.")
        }

        function T2(c) {
            var u = c.alternate;
            if (!u) {
                var v = Fl(c);
                if (v === null) throw new Error("Unable to find node on an unmounted component.");
                return v !== c ? null : c
            }
            for (var y = c, E = u; ;) {
                var L = y.return;
                if (L === null) break;
                var Z = L.alternate;
                if (Z === null) {
                    var se = L.return;
                    if (se !== null) {
                        y = E = se;
                        continue
                    }
                    break
                }
                if (L.child === Z.child) {
                    for (var he = L.child; he;) {
                        if (he === y) return E2(L), c;
                        if (he === E) return E2(L), u;
                        he = he.sibling
                    }
                    throw new Error("Unable to find node on an unmounted component.")
                }
                if (y.return !== E.return) y = L, E = Z; else {
                    for (var we = !1, _e = L.child; _e;) {
                        if (_e === y) {
                            we = !0, y = L, E = Z;
                            break
                        }
                        if (_e === E) {
                            we = !0, E = L, y = Z;
                            break
                        }
                        _e = _e.sibling
                    }
                    if (!we) {
                        for (_e = Z.child; _e;) {
                            if (_e === y) {
                                we = !0, y = Z, E = L;
                                break
                            }
                            if (_e === E) {
                                we = !0, E = Z, y = L;
                                break
                            }
                            _e = _e.sibling
                        }
                        if (!we) throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.")
                    }
                }
                if (y.alternate !== E) throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.")
            }
            if (y.tag !== p) throw new Error("Unable to find node on an unmounted component.");
            return y.stateNode.current === y ? c : u
        }

        function Zc(c) {
            var u = T2(c);
            return u !== null ? Jc(u) : null
        }

        function Jc(c) {
            if (c.tag === b || c.tag === S) return c;
            for (var u = c.child; u !== null;) {
                var v = Jc(u);
                if (v !== null) return v;
                u = u.sibling
            }
            return null
        }

        function Sa(c) {
            var u = T2(c);
            return u !== null ? ku(u) : null
        }

        function ku(c) {
            if (c.tag === b || c.tag === S) return c;
            for (var u = c.child; u !== null;) {
                if (u.tag !== g) {
                    var v = ku(u);
                    if (v !== null) return v
                }
                u = u.sibling
            }
            return null
        }

        var Y3 = e.unstable_scheduleCallback, xk = e.unstable_cancelCallback, X3 = e.unstable_shouldYield,
            Q3 = e.unstable_requestPaint, Bo = e.unstable_now, C2 = e.unstable_getCurrentPriorityLevel,
            Y1 = e.unstable_ImmediatePriority, Fp = e.unstable_UserBlockingPriority, wh = e.unstable_NormalPriority,
            GB = e.unstable_LowPriority, wm = e.unstable_IdlePriority, A2 = e.unstable_yieldValue,
            Ek = e.unstable_setDisableYieldValue, Sm = null, eo = null, Wt = null, Ul = !1,
            el = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";

        function xg(c) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
            var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (u.isDisabled) return !0;
            if (!u.supportsFiber) return o("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
            try {
                c = Pt({}, c, {getLaneLabelMap: _m, injectProfilingHooks: Ru}), Sm = u.inject(c), eo = u
            } catch (v) {
                o("React instrumentation encountered an error: %s.", v)
            }
            return !!u.checkDCE
        }

        function Z3(c, u) {
            if (eo && typeof eo.onScheduleFiberRoot == "function") try {
                eo.onScheduleFiberRoot(Sm, c, u)
            } catch (v) {
                Ul || (Ul = !0, o("React instrumentation encountered an error: %s", v))
            }
        }

        function J3(c, u) {
            if (eo && typeof eo.onCommitFiberRoot == "function") try {
                var v = (c.current.flags & Mr) === Mr;
                {
                    var y;
                    switch (u) {
                        case vc:
                            y = Y1;
                            break;
                        case vd:
                            y = Fp;
                            break;
                        case Du:
                            y = wh;
                            break;
                        case Mu:
                            y = wm;
                            break;
                        default:
                            y = wh;
                            break
                    }
                    eo.onCommitFiberRoot(Sm, c, y, v)
                }
            } catch (E) {
                Ul || (Ul = !0, o("React instrumentation encountered an error: %s", E))
            }
        }

        function e6(c) {
            if (eo && typeof eo.onPostCommitFiberRoot == "function") try {
                eo.onPostCommitFiberRoot(Sm, c)
            } catch (u) {
                Ul || (Ul = !0, o("React instrumentation encountered an error: %s", u))
            }
        }

        function t6(c) {
            if (eo && typeof eo.onCommitFiberUnmount == "function") try {
                eo.onCommitFiberUnmount(Sm, c)
            } catch (u) {
                Ul || (Ul = !0, o("React instrumentation encountered an error: %s", u))
            }
        }

        function La(c) {
            if (typeof A2 == "function" && (Ek(c), i(c)), eo && typeof eo.setStrictMode == "function") try {
                eo.setStrictMode(Sm, c)
            } catch (u) {
                Ul || (Ul = !0, o("React instrumentation encountered an error: %s", u))
            }
        }

        function Ru(c) {
            Wt = c
        }

        function _m() {
            {
                for (var c = new Map, u = 1, v = 0; v < Tm; v++) {
                    var y = Ik(u);
                    c.set(u, y), u *= 2
                }
                return c
            }
        }

        function r6(c) {
            Wt !== null && typeof Wt.markCommitStarted == "function" && Wt.markCommitStarted(c)
        }

        function n6() {
            Wt !== null && typeof Wt.markCommitStopped == "function" && Wt.markCommitStopped()
        }

        function jl(c) {
            Wt !== null && typeof Wt.markComponentRenderStarted == "function" && Wt.markComponentRenderStarted(c)
        }

        function zl() {
            Wt !== null && typeof Wt.markComponentRenderStopped == "function" && Wt.markComponentRenderStopped()
        }

        function i6(c) {
            Wt !== null && typeof Wt.markComponentPassiveEffectMountStarted == "function" && Wt.markComponentPassiveEffectMountStarted(c)
        }

        function Tk() {
            Wt !== null && typeof Wt.markComponentPassiveEffectMountStopped == "function" && Wt.markComponentPassiveEffectMountStopped()
        }

        function Sh(c) {
            Wt !== null && typeof Wt.markComponentPassiveEffectUnmountStarted == "function" && Wt.markComponentPassiveEffectUnmountStarted(c)
        }

        function Up() {
            Wt !== null && typeof Wt.markComponentPassiveEffectUnmountStopped == "function" && Wt.markComponentPassiveEffectUnmountStopped()
        }

        function I2(c) {
            Wt !== null && typeof Wt.markComponentLayoutEffectMountStarted == "function" && Wt.markComponentLayoutEffectMountStarted(c)
        }

        function Ck() {
            Wt !== null && typeof Wt.markComponentLayoutEffectMountStopped == "function" && Wt.markComponentLayoutEffectMountStopped()
        }

        function X1(c) {
            Wt !== null && typeof Wt.markComponentLayoutEffectUnmountStarted == "function" && Wt.markComponentLayoutEffectUnmountStarted(c)
        }

        function a6() {
            Wt !== null && typeof Wt.markComponentLayoutEffectUnmountStopped == "function" && Wt.markComponentLayoutEffectUnmountStopped()
        }

        function Q1(c, u, v) {
            Wt !== null && typeof Wt.markComponentErrored == "function" && Wt.markComponentErrored(c, u, v)
        }

        function md(c, u, v) {
            Wt !== null && typeof Wt.markComponentSuspended == "function" && Wt.markComponentSuspended(c, u, v)
        }

        function Z1(c) {
            Wt !== null && typeof Wt.markLayoutEffectsStarted == "function" && Wt.markLayoutEffectsStarted(c)
        }

        function J1() {
            Wt !== null && typeof Wt.markLayoutEffectsStopped == "function" && Wt.markLayoutEffectsStopped()
        }

        function xm(c) {
            Wt !== null && typeof Wt.markPassiveEffectsStarted == "function" && Wt.markPassiveEffectsStarted(c)
        }

        function o6() {
            Wt !== null && typeof Wt.markPassiveEffectsStopped == "function" && Wt.markPassiveEffectsStopped()
        }

        function Em(c) {
            Wt !== null && typeof Wt.markRenderStarted == "function" && Wt.markRenderStarted(c)
        }

        function Ak() {
            Wt !== null && typeof Wt.markRenderYielded == "function" && Wt.markRenderYielded()
        }

        function k2() {
            Wt !== null && typeof Wt.markRenderStopped == "function" && Wt.markRenderStopped()
        }

        function Ba(c) {
            Wt !== null && typeof Wt.markRenderScheduled == "function" && Wt.markRenderScheduled(c)
        }

        function R2(c, u) {
            Wt !== null && typeof Wt.markForceUpdateScheduled == "function" && Wt.markForceUpdateScheduled(c, u)
        }

        function eb(c, u) {
            Wt !== null && typeof Wt.markStateUpdateScheduled == "function" && Wt.markStateUpdateScheduled(c, u)
        }

        var $r = 0, Mn = 1, gi = 2, Gi = 8, yi = 16, vo = Math.clz32 ? Math.clz32 : tb, Qo = Math.log, D2 = Math.LN2;

        function tb(c) {
            var u = c >>> 0;
            return u === 0 ? 32 : 31 - (Qo(u) / D2 | 0) | 0
        }

        var Tm = 31, mt = 0, pi = 0, Xr = 1, jp = 2, bf = 4, Vs = 8, to = 16, _h = 32, zp = 4194240, Cm = 64, M2 = 128,
            O2 = 256, P2 = 512, N2 = 1024, L2 = 2048, B2 = 4096, $2 = 8192, F2 = 16384, Am = 32768, U2 = 65536,
            Eg = 131072, Tg = 262144, j2 = 524288, rb = 1048576, z2 = 2097152, nb = 130023424, Im = 4194304,
            V2 = 8388608, ib = 16777216, H2 = 33554432, W2 = 67108864, s6 = Im, ab = 134217728, c6 = 268435455,
            ob = 268435456, km = 536870912, tl = 1073741824;

        function Ik(c) {
            {
                if (c & Xr) return "Sync";
                if (c & jp) return "InputContinuousHydration";
                if (c & bf) return "InputContinuous";
                if (c & Vs) return "DefaultHydration";
                if (c & to) return "Default";
                if (c & _h) return "TransitionHydration";
                if (c & zp) return "Transition";
                if (c & nb) return "Retry";
                if (c & ab) return "SelectiveHydration";
                if (c & ob) return "IdleHydration";
                if (c & km) return "Idle";
                if (c & tl) return "Offscreen"
            }
        }

        var ea = -1, Rm = Cm, q2 = Im;

        function sb(c) {
            switch (Vp(c)) {
                case Xr:
                    return Xr;
                case jp:
                    return jp;
                case bf:
                    return bf;
                case Vs:
                    return Vs;
                case to:
                    return to;
                case _h:
                    return _h;
                case Cm:
                case M2:
                case O2:
                case P2:
                case N2:
                case L2:
                case B2:
                case $2:
                case F2:
                case Am:
                case U2:
                case Eg:
                case Tg:
                case j2:
                case rb:
                case z2:
                    return c & zp;
                case Im:
                case V2:
                case ib:
                case H2:
                case W2:
                    return c & nb;
                case ab:
                    return ab;
                case ob:
                    return ob;
                case km:
                    return km;
                case tl:
                    return tl;
                default:
                    return o("Should have found matching lanes. This is a bug in React."), c
            }
        }

        function G2(c, u) {
            var v = c.pendingLanes;
            if (v === mt) return mt;
            var y = mt, E = c.suspendedLanes, L = c.pingedLanes, Z = v & c6;
            if (Z !== mt) {
                var se = Z & ~E;
                if (se !== mt) y = sb(se); else {
                    var he = Z & L;
                    he !== mt && (y = sb(he))
                }
            } else {
                var we = v & ~E;
                we !== mt ? y = sb(we) : L !== mt && (y = sb(L))
            }
            if (y === mt) return mt;
            if (u !== mt && u !== y && (u & E) === mt) {
                var _e = Vp(y), Fe = Vp(u);
                if (_e >= Fe || _e === to && (Fe & zp) !== mt) return u
            }
            (y & bf) !== mt && (y |= v & to);
            var Le = c.entangledLanes;
            if (Le !== mt) for (var Qe = c.entanglements, nt = y & Le; nt > 0;) {
                var lt = go(nt), qt = 1 << lt;
                y |= Qe[lt], nt &= ~qt
            }
            return y
        }

        function wf(c, u) {
            for (var v = c.eventTimes, y = ea; u > 0;) {
                var E = go(u), L = 1 << E, Z = v[E];
                Z > y && (y = Z), u &= ~L
            }
            return y
        }

        function l6(c, u) {
            switch (c) {
                case Xr:
                case jp:
                case bf:
                    return u + 250;
                case Vs:
                case to:
                case _h:
                case Cm:
                case M2:
                case O2:
                case P2:
                case N2:
                case L2:
                case B2:
                case $2:
                case F2:
                case Am:
                case U2:
                case Eg:
                case Tg:
                case j2:
                case rb:
                case z2:
                    return u + 5e3;
                case Im:
                case V2:
                case ib:
                case H2:
                case W2:
                    return ea;
                case ab:
                case ob:
                case km:
                case tl:
                    return ea;
                default:
                    return o("Should have found matching lanes. This is a bug in React."), ea
            }
        }

        function K2(c, u) {
            for (var v = c.pendingLanes, y = c.suspendedLanes, E = c.pingedLanes, L = c.expirationTimes, Z = v; Z > 0;) {
                var se = go(Z), he = 1 << se, we = L[se];
                we === ea ? ((he & y) === mt || (he & E) !== mt) && (L[se] = l6(he, u)) : we <= u && (c.expiredLanes |= he), Z &= ~he
            }
        }

        function kk(c) {
            return sb(c.pendingLanes)
        }

        function Y2(c) {
            var u = c.pendingLanes & ~tl;
            return u !== mt ? u : u & tl ? tl : mt
        }

        function Rk(c) {
            return (c & Xr) !== mt
        }

        function cb(c) {
            return (c & c6) !== mt
        }

        function Dm(c) {
            return (c & nb) === c
        }

        function u6(c) {
            var u = Xr | bf | to;
            return (c & u) === mt
        }

        function f6(c) {
            return (c & zp) === c
        }

        function X2(c, u) {
            var v = jp | bf | Vs | to;
            return (u & v) !== mt
        }

        function Dk(c, u) {
            return (u & c.expiredLanes) !== mt
        }

        function d6(c) {
            return (c & zp) !== mt
        }

        function h6() {
            var c = Rm;
            return Rm <<= 1, (Rm & zp) === mt && (Rm = Cm), c
        }

        function Mk() {
            var c = q2;
            return q2 <<= 1, (q2 & nb) === mt && (q2 = Im), c
        }

        function Vp(c) {
            return c & -c
        }

        function lb(c) {
            return Vp(c)
        }

        function go(c) {
            return 31 - vo(c)
        }

        function ms(c) {
            return go(c)
        }

        function rl(c, u) {
            return (c & u) !== mt
        }

        function Mm(c, u) {
            return (c & u) === u
        }

        function vn(c, u) {
            return c | u
        }

        function ub(c, u) {
            return c & ~u
        }

        function p6(c, u) {
            return c & u
        }

        function Ok(c) {
            return c
        }

        function Pk(c, u) {
            return c !== pi && c < u ? c : u
        }

        function fb(c) {
            for (var u = [], v = 0; v < Tm; v++) u.push(c);
            return u
        }

        function Cg(c, u, v) {
            c.pendingLanes |= u, u !== km && (c.suspendedLanes = mt, c.pingedLanes = mt);
            var y = c.eventTimes, E = ms(u);
            y[E] = v
        }

        function Nk(c, u) {
            c.suspendedLanes |= u, c.pingedLanes &= ~u;
            for (var v = c.expirationTimes, y = u; y > 0;) {
                var E = go(y), L = 1 << E;
                v[E] = ea, y &= ~L
            }
        }

        function Q2(c, u, v) {
            c.pingedLanes |= c.suspendedLanes & u
        }

        function m6(c, u) {
            var v = c.pendingLanes & ~u;
            c.pendingLanes = u, c.suspendedLanes = mt, c.pingedLanes = mt, c.expiredLanes &= u, c.mutableReadLanes &= u, c.entangledLanes &= u;
            for (var y = c.entanglements, E = c.eventTimes, L = c.expirationTimes, Z = v; Z > 0;) {
                var se = go(Z), he = 1 << se;
                y[se] = mt, E[se] = ea, L[se] = ea, Z &= ~he
            }
        }

        function Z2(c, u) {
            for (var v = c.entangledLanes |= u, y = c.entanglements, E = v; E;) {
                var L = go(E), Z = 1 << L;
                Z & u | y[L] & u && (y[L] |= u), E &= ~Z
            }
        }

        function v6(c, u) {
            var v = Vp(u), y;
            switch (v) {
                case bf:
                    y = jp;
                    break;
                case to:
                    y = Vs;
                    break;
                case Cm:
                case M2:
                case O2:
                case P2:
                case N2:
                case L2:
                case B2:
                case $2:
                case F2:
                case Am:
                case U2:
                case Eg:
                case Tg:
                case j2:
                case rb:
                case z2:
                case Im:
                case V2:
                case ib:
                case H2:
                case W2:
                    y = _h;
                    break;
                case km:
                    y = ob;
                    break;
                default:
                    y = pi;
                    break
            }
            return (y & (c.suspendedLanes | u)) !== pi ? pi : y
        }

        function db(c, u, v) {
            if (el) for (var y = c.pendingUpdatersLaneMap; v > 0;) {
                var E = ms(v), L = 1 << E, Z = y[E];
                Z.add(u), v &= ~L
            }
        }

        function Lk(c, u) {
            if (el) for (var v = c.pendingUpdatersLaneMap, y = c.memoizedUpdaters; u > 0;) {
                var E = ms(u), L = 1 << E, Z = v[E];
                Z.size > 0 && (Z.forEach(function (se) {
                    var he = se.alternate;
                    (he === null || !y.has(he)) && y.add(se)
                }), Z.clear()), u &= ~L
            }
        }

        function g6(c, u) {
            return null
        }

        var vc = Xr, vd = bf, Du = to, Mu = km, hb = pi;

        function Ou() {
            return hb
        }

        function yo(c) {
            hb = c
        }

        function Bk(c, u) {
            var v = hb;
            try {
                return hb = c, u()
            } finally {
                hb = v
            }
        }

        function $k(c, u) {
            return c !== 0 && c < u ? c : u
        }

        function pb(c, u) {
            return c === 0 || c > u ? c : u
        }

        function Zo(c, u) {
            return c !== 0 && c < u
        }

        function Fk(c) {
            var u = Vp(c);
            return Zo(vc, u) ? Zo(vd, u) ? cb(u) ? Du : Mu : vd : vc
        }

        function J2(c) {
            var u = c.current.memoizedState;
            return u.isDehydrated
        }

        var mb;

        function Hs(c) {
            mb = c
        }

        function KB(c) {
            mb(c)
        }

        var nr;

        function Ag(c) {
            nr = c
        }

        var e_;

        function Uk(c) {
            e_ = c
        }

        var jk;

        function vb(c) {
            jk = c
        }

        var gb;

        function y6(c) {
            gb = c
        }

        var t_ = !1, yb = [], xh = null, gd = null, yd = null, ro = new Map, gc = new Map, yc = [],
            zk = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset", "submit"];

        function Vk(c) {
            return zk.indexOf(c) > -1
        }

        function Sf(c, u, v, y, E) {
            return {blockedOn: c, domEventName: u, eventSystemFlags: v, nativeEvent: E, targetContainers: [y]}
        }

        function b6(c, u) {
            switch (c) {
                case"focusin":
                case"focusout":
                    xh = null;
                    break;
                case"dragenter":
                case"dragleave":
                    gd = null;
                    break;
                case"mouseover":
                case"mouseout":
                    yd = null;
                    break;
                case"pointerover":
                case"pointerout": {
                    var v = u.pointerId;
                    ro.delete(v);
                    break
                }
                case"gotpointercapture":
                case"lostpointercapture": {
                    var y = u.pointerId;
                    gc.delete(y);
                    break
                }
            }
        }

        function nl(c, u, v, y, E, L) {
            if (c === null || c.nativeEvent !== L) {
                var Z = Sf(u, v, y, E, L);
                if (u !== null) {
                    var se = Lg(u);
                    se !== null && nr(se)
                }
                return Z
            }
            c.eventSystemFlags |= y;
            var he = c.targetContainers;
            return E !== null && he.indexOf(E) === -1 && he.push(E), c
        }

        function YB(c, u, v, y, E) {
            switch (u) {
                case"focusin": {
                    var L = E;
                    return xh = nl(xh, c, u, v, y, L), !0
                }
                case"dragenter": {
                    var Z = E;
                    return gd = nl(gd, c, u, v, y, Z), !0
                }
                case"mouseover": {
                    var se = E;
                    return yd = nl(yd, c, u, v, y, se), !0
                }
                case"pointerover": {
                    var he = E, we = he.pointerId;
                    return ro.set(we, nl(ro.get(we) || null, c, u, v, y, he)), !0
                }
                case"gotpointercapture": {
                    var _e = E, Fe = _e.pointerId;
                    return gc.set(Fe, nl(gc.get(Fe) || null, c, u, v, y, _e)), !0
                }
            }
            return !1
        }

        function w6(c) {
            var u = Rb(c.target);
            if (u !== null) {
                var v = Fl(u);
                if (v !== null) {
                    var y = v.tag;
                    if (y === Y) {
                        var E = hd(v);
                        if (E !== null) {
                            c.blockedOn = E, gb(c.priority, function () {
                                e_(v)
                            });
                            return
                        }
                    } else if (y === p) {
                        var L = v.stateNode;
                        if (J2(L)) {
                            c.blockedOn = pd(v);
                            return
                        }
                    }
                }
            }
            c.blockedOn = null
        }

        function Hk(c) {
            for (var u = jk(), v = {
                blockedOn: null,
                target: c,
                priority: u
            }, y = 0; y < yc.length && Zo(u, yc[y].priority); y++) ;
            yc.splice(y, 0, v), y === 0 && w6(v)
        }

        function bb(c) {
            if (c.blockedOn !== null) return !1;
            for (var u = c.targetContainers; u.length > 0;) {
                var v = u[0], y = kg(c.domEventName, c.eventSystemFlags, v, c.nativeEvent);
                if (y === null) {
                    var E = c.nativeEvent, L = new E.constructor(E.type, E);
                    H3(L), E.target.dispatchEvent(L), UB()
                } else {
                    var Z = Lg(y);
                    return Z !== null && nr(Z), c.blockedOn = y, !1
                }
                u.shift()
            }
            return !0
        }

        function S6(c, u, v) {
            bb(c) && v.delete(u)
        }

        function XB() {
            t_ = !1, xh !== null && bb(xh) && (xh = null), gd !== null && bb(gd) && (gd = null), yd !== null && bb(yd) && (yd = null), ro.forEach(S6), gc.forEach(S6)
        }

        function Hp(c, u) {
            c.blockedOn === u && (c.blockedOn = null, t_ || (t_ = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, XB)))
        }

        function Om(c) {
            if (yb.length > 0) {
                Hp(yb[0], c);
                for (var u = 1; u < yb.length; u++) {
                    var v = yb[u];
                    v.blockedOn === c && (v.blockedOn = null)
                }
            }
            xh !== null && Hp(xh, c), gd !== null && Hp(gd, c), yd !== null && Hp(yd, c);
            var y = function (se) {
                return Hp(se, c)
            };
            ro.forEach(y), gc.forEach(y);
            for (var E = 0; E < yc.length; E++) {
                var L = yc[E];
                L.blockedOn === c && (L.blockedOn = null)
            }
            for (; yc.length > 0;) {
                var Z = yc[0];
                if (Z.blockedOn !== null) break;
                w6(Z), Z.blockedOn === null && yc.shift()
            }
        }

        var vs = r.ReactCurrentBatchConfig, ei = !0;

        function $o(c) {
            ei = !!c
        }

        function bo() {
            return ei
        }

        function gs(c, u, v) {
            var y = r_(u), E;
            switch (y) {
                case vc:
                    E = Vl;
                    break;
                case vd:
                    E = Ig;
                    break;
                case Du:
                default:
                    E = no;
                    break
            }
            return E.bind(null, u, v, c)
        }

        function Vl(c, u, v, y) {
            var E = Ou(), L = vs.transition;
            vs.transition = null;
            try {
                yo(vc), no(c, u, v, y)
            } finally {
                yo(E), vs.transition = L
            }
        }

        function Ig(c, u, v, y) {
            var E = Ou(), L = vs.transition;
            vs.transition = null;
            try {
                yo(vd), no(c, u, v, y)
            } finally {
                yo(E), vs.transition = L
            }
        }

        function no(c, u, v, y) {
            ei && wb(c, u, v, y)
        }

        function wb(c, u, v, y) {
            var E = kg(c, u, v, y);
            if (E === null) {
                h$(c, u, y, bd, v), b6(c, y);
                return
            }
            if (YB(E, c, u, v, y)) {
                y.stopPropagation();
                return
            }
            if (b6(c, y), u & mg && Vk(c)) {
                for (; E !== null;) {
                    var L = Lg(E);
                    L !== null && KB(L);
                    var Z = kg(c, u, v, y);
                    if (Z === null && h$(c, u, y, bd, v), Z === E) break;
                    E = Z
                }
                E !== null && y.stopPropagation();
                return
            }
            h$(c, u, y, null, v)
        }

        var bd = null;

        function kg(c, u, v, y) {
            bd = null;
            var E = pm(y), L = Rb(E);
            if (L !== null) {
                var Z = Fl(L);
                if (Z === null) L = null; else {
                    var se = Z.tag;
                    if (se === Y) {
                        var he = hd(Z);
                        if (he !== null) return he;
                        L = null
                    } else if (se === p) {
                        var we = Z.stateNode;
                        if (J2(we)) return pd(Z);
                        L = null
                    } else Z !== L && (L = null)
                }
            }
            return bd = L, null
        }

        function r_(c) {
            switch (c) {
                case"cancel":
                case"click":
                case"close":
                case"contextmenu":
                case"copy":
                case"cut":
                case"auxclick":
                case"dblclick":
                case"dragend":
                case"dragstart":
                case"drop":
                case"focusin":
                case"focusout":
                case"input":
                case"invalid":
                case"keydown":
                case"keypress":
                case"keyup":
                case"mousedown":
                case"mouseup":
                case"paste":
                case"pause":
                case"play":
                case"pointercancel":
                case"pointerdown":
                case"pointerup":
                case"ratechange":
                case"reset":
                case"resize":
                case"seeked":
                case"submit":
                case"touchcancel":
                case"touchend":
                case"touchstart":
                case"volumechange":
                case"change":
                case"selectionchange":
                case"textInput":
                case"compositionstart":
                case"compositionend":
                case"compositionupdate":
                case"beforeblur":
                case"afterblur":
                case"beforeinput":
                case"blur":
                case"fullscreenchange":
                case"focus":
                case"hashchange":
                case"popstate":
                case"select":
                case"selectstart":
                    return vc;
                case"drag":
                case"dragenter":
                case"dragexit":
                case"dragleave":
                case"dragover":
                case"mousemove":
                case"mouseout":
                case"mouseover":
                case"pointermove":
                case"pointerout":
                case"pointerover":
                case"scroll":
                case"toggle":
                case"touchmove":
                case"wheel":
                case"mouseenter":
                case"mouseleave":
                case"pointerenter":
                case"pointerleave":
                    return vd;
                case"message": {
                    var u = C2();
                    switch (u) {
                        case Y1:
                            return vc;
                        case Fp:
                            return vd;
                        case wh:
                        case GB:
                            return Du;
                        case wm:
                            return Mu;
                        default:
                            return Du
                    }
                }
                default:
                    return Du
            }
        }

        function Sb(c, u, v) {
            return c.addEventListener(u, v, !1), v
        }

        function il(c, u, v) {
            return c.addEventListener(u, v, !0), v
        }

        function _6(c, u, v, y) {
            return c.addEventListener(u, v, {capture: !0, passive: y}), v
        }

        function Rg(c, u, v, y) {
            return c.addEventListener(u, v, {passive: y}), v
        }

        var Hl = null, Dg = null, Pm = null;

        function Wp(c) {
            return Hl = c, Dg = _b(), !0
        }

        function n_() {
            Hl = null, Dg = null, Pm = null
        }

        function Eh() {
            if (Pm) return Pm;
            var c, u = Dg, v = u.length, y, E = _b(), L = E.length;
            for (c = 0; c < v && u[c] === E[c]; c++) ;
            var Z = v - c;
            for (y = 1; y <= Z && u[v - y] === E[L - y]; y++) ;
            var se = y > 1 ? 1 - y : void 0;
            return Pm = E.slice(c, se), Pm
        }

        function _b() {
            return "value" in Hl ? Hl.value : Hl.textContent
        }

        function qp(c) {
            var u, v = c.keyCode;
            return "charCode" in c ? (u = c.charCode, u === 0 && v === 13 && (u = 13)) : u = v, u === 10 && (u = 13), u >= 32 || u === 13 ? u : 0
        }

        function Mg() {
            return !0
        }

        function xb() {
            return !1
        }

        function Ws(c) {
            function u(v, y, E, L, Z) {
                this._reactName = v, this._targetInst = E, this.type = y, this.nativeEvent = L, this.target = Z, this.currentTarget = null;
                for (var se in c) if (c.hasOwnProperty(se)) {
                    var he = c[se];
                    he ? this[se] = he(L) : this[se] = L[se]
                }
                var we = L.defaultPrevented != null ? L.defaultPrevented : L.returnValue === !1;
                return we ? this.isDefaultPrevented = Mg : this.isDefaultPrevented = xb, this.isPropagationStopped = xb, this
            }

            return Pt(u.prototype, {
                preventDefault: function () {
                    this.defaultPrevented = !0;
                    var v = this.nativeEvent;
                    v && (v.preventDefault ? v.preventDefault() : typeof v.returnValue != "unknown" && (v.returnValue = !1), this.isDefaultPrevented = Mg)
                }, stopPropagation: function () {
                    var v = this.nativeEvent;
                    v && (v.stopPropagation ? v.stopPropagation() : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0), this.isPropagationStopped = Mg)
                }, persist: function () {
                }, isPersistent: Mg
            }), u
        }

        var wo = {
            eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (c) {
                return c.timeStamp || Date.now()
            }, defaultPrevented: 0, isTrusted: 0
        }, wd = Ws(wo), bc = Pt({}, wo, {view: 0, detail: 0}), al = Ws(bc), i_, Eb, Nm;

        function QB(c) {
            c !== Nm && (Nm && c.type === "mousemove" ? (i_ = c.screenX - Nm.screenX, Eb = c.screenY - Nm.screenY) : (i_ = 0, Eb = 0), Nm = c)
        }

        var _f = Pt({}, bc, {
                screenX: 0,
                screenY: 0,
                clientX: 0,
                clientY: 0,
                pageX: 0,
                pageY: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                getModifierState: _a,
                button: 0,
                buttons: 0,
                relatedTarget: function (c) {
                    return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget
                },
                movementX: function (c) {
                    return "movementX" in c ? c.movementX : (QB(c), i_)
                },
                movementY: function (c) {
                    return "movementY" in c ? c.movementY : Eb
                }
            }), x6 = Ws(_f), E6 = Pt({}, _f, {dataTransfer: 0}), Lm = Ws(E6), T6 = Pt({}, bc, {relatedTarget: 0}),
            Th = Ws(T6), Wk = Pt({}, wo, {animationName: 0, elapsedTime: 0, pseudoElement: 0}), qk = Ws(Wk),
            C6 = Pt({}, wo, {
                clipboardData: function (c) {
                    return "clipboardData" in c ? c.clipboardData : window.clipboardData
                }
            }), a_ = Ws(C6), ZB = Pt({}, wo, {data: 0}), Gk = Ws(ZB), Kk = Gk, Yk = {
                Esc: "Escape",
                Spacebar: " ",
                Left: "ArrowLeft",
                Up: "ArrowUp",
                Right: "ArrowRight",
                Down: "ArrowDown",
                Del: "Delete",
                Win: "OS",
                Menu: "ContextMenu",
                Apps: "ContextMenu",
                Scroll: "ScrollLock",
                MozPrintableKey: "Unidentified"
            }, Bm = {
                8: "Backspace",
                9: "Tab",
                12: "Clear",
                13: "Enter",
                16: "Shift",
                17: "Control",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Escape",
                32: " ",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "ArrowLeft",
                38: "ArrowUp",
                39: "ArrowRight",
                40: "ArrowDown",
                45: "Insert",
                46: "Delete",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "NumLock",
                145: "ScrollLock",
                224: "Meta"
            };

        function JB(c) {
            if (c.key) {
                var u = Yk[c.key] || c.key;
                if (u !== "Unidentified") return u
            }
            if (c.type === "keypress") {
                var v = qp(c);
                return v === 13 ? "Enter" : String.fromCharCode(v)
            }
            return c.type === "keydown" || c.type === "keyup" ? Bm[c.keyCode] || "Unidentified" : ""
        }

        var Og = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};

        function Xk(c) {
            var u = this, v = u.nativeEvent;
            if (v.getModifierState) return v.getModifierState(c);
            var y = Og[c];
            return y ? !!v[y] : !1
        }

        function _a(c) {
            return Xk
        }

        var e$ = Pt({}, bc, {
                key: JB,
                code: 0,
                location: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                repeat: 0,
                locale: 0,
                getModifierState: _a,
                charCode: function (c) {
                    return c.type === "keypress" ? qp(c) : 0
                },
                keyCode: function (c) {
                    return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
                },
                which: function (c) {
                    return c.type === "keypress" ? qp(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
                }
            }), Qk = Ws(e$), t$ = Pt({}, _f, {
                pointerId: 0,
                width: 0,
                height: 0,
                pressure: 0,
                tangentialPressure: 0,
                tiltX: 0,
                tiltY: 0,
                twist: 0,
                pointerType: 0,
                isPrimary: 0
            }), Zk = Ws(t$), Jk = Pt({}, bc, {
                touches: 0,
                targetTouches: 0,
                changedTouches: 0,
                altKey: 0,
                metaKey: 0,
                ctrlKey: 0,
                shiftKey: 0,
                getModifierState: _a
            }), eR = Ws(Jk), r$ = Pt({}, wo, {propertyName: 0, elapsedTime: 0, pseudoElement: 0}), Pu = Ws(r$),
            A6 = Pt({}, _f, {
                deltaX: function (c) {
                    return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0
                }, deltaY: function (c) {
                    return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0
                }, deltaZ: 0, deltaMode: 0
            }), n$ = Ws(A6), Gp = [9, 13, 27, 32], Tb = 229, Ch = Me && "CompositionEvent" in window, Kp = null;
        Me && "documentMode" in document && (Kp = document.documentMode);
        var I6 = Me && "TextEvent" in window && !Kp, o_ = Me && (!Ch || Kp && Kp > 8 && Kp <= 11), tR = 32,
            s_ = String.fromCharCode(tR);

        function i$() {
            Se("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Se("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Se("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Se("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"])
        }

        var k6 = !1;

        function rR(c) {
            return (c.ctrlKey || c.altKey || c.metaKey) && !(c.ctrlKey && c.altKey)
        }

        function c_(c) {
            switch (c) {
                case"compositionstart":
                    return "onCompositionStart";
                case"compositionend":
                    return "onCompositionEnd";
                case"compositionupdate":
                    return "onCompositionUpdate"
            }
        }

        function l_(c, u) {
            return c === "keydown" && u.keyCode === Tb
        }

        function R6(c, u) {
            switch (c) {
                case"keyup":
                    return Gp.indexOf(u.keyCode) !== -1;
                case"keydown":
                    return u.keyCode !== Tb;
                case"keypress":
                case"mousedown":
                case"focusout":
                    return !0;
                default:
                    return !1
            }
        }

        function u_(c) {
            var u = c.detail;
            return typeof u == "object" && "data" in u ? u.data : null
        }

        function nR(c) {
            return c.locale === "ko"
        }

        var $m = !1;

        function D6(c, u, v, y, E) {
            var L, Z;
            if (Ch ? L = c_(u) : $m ? R6(u, y) && (L = "onCompositionEnd") : l_(u, y) && (L = "onCompositionStart"), !L) return null;
            o_ && !nR(y) && (!$m && L === "onCompositionStart" ? $m = Wp(E) : L === "onCompositionEnd" && $m && (Z = Eh()));
            var se = uR(v, L);
            if (se.length > 0) {
                var he = new Gk(L, u, null, y, E);
                if (c.push({event: he, listeners: se}), Z) he.data = Z; else {
                    var we = u_(y);
                    we !== null && (he.data = we)
                }
            }
        }

        function f_(c, u) {
            switch (c) {
                case"compositionend":
                    return u_(u);
                case"keypress":
                    var v = u.which;
                    return v !== tR ? null : (k6 = !0, s_);
                case"textInput":
                    var y = u.data;
                    return y === s_ && k6 ? null : y;
                default:
                    return null
            }
        }

        function M6(c, u) {
            if ($m) {
                if (c === "compositionend" || !Ch && R6(c, u)) {
                    var v = Eh();
                    return n_(), $m = !1, v
                }
                return null
            }
            switch (c) {
                case"paste":
                    return null;
                case"keypress":
                    if (!rR(u)) {
                        if (u.char && u.char.length > 1) return u.char;
                        if (u.which) return String.fromCharCode(u.which)
                    }
                    return null;
                case"compositionend":
                    return o_ && !nR(u) ? null : u.data;
                default:
                    return null
            }
        }

        function d_(c, u, v, y, E) {
            var L;
            if (I6 ? L = f_(u, y) : L = M6(u, y), !L) return null;
            var Z = uR(v, "onBeforeInput");
            if (Z.length > 0) {
                var se = new Kk("onBeforeInput", "beforeinput", null, y, E);
                c.push({event: se, listeners: Z}), se.data = L
            }
        }

        function iR(c, u, v, y, E, L, Z) {
            D6(c, u, v, y, E), d_(c, u, v, y, E)
        }

        var a$ = {
            color: !0,
            date: !0,
            datetime: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0
        };

        function Cb(c) {
            var u = c && c.nodeName && c.nodeName.toLowerCase();
            return u === "input" ? !!a$[c.type] : u === "textarea"
        }

        function o$(c) {
            if (!Me) return !1;
            var u = "on" + c, v = u in document;
            if (!v) {
                var y = document.createElement("div");
                y.setAttribute(u, "return;"), v = typeof y[u] == "function"
            }
            return v
        }

        function Ab() {
            Se("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"])
        }

        function aR(c, u, v, y) {
            H1(y);
            var E = uR(u, "onChange");
            if (E.length > 0) {
                var L = new wd("onChange", "change", null, v, y);
                c.push({event: L, listeners: E})
            }
        }

        var Yp = null, h = null;

        function m(c) {
            var u = c.nodeName && c.nodeName.toLowerCase();
            return u === "select" || u === "input" && c.type === "file"
        }

        function w(c) {
            var u = [];
            aR(u, h, c, pm(c)), K3(O, u)
        }

        function O(c) {
            kre(c, 0)
        }

        function K(c) {
            var u = y_(c);
            if (mf(u)) return c
        }

        function ae(c, u) {
            if (c === "change") return u
        }

        var ge = !1;
        Me && (ge = o$("input") && (!document.documentMode || document.documentMode > 9));

        function Re(c, u) {
            Yp = c, h = u, Yp.attachEvent("onpropertychange", et)
        }

        function Pe() {
            Yp && (Yp.detachEvent("onpropertychange", et), Yp = null, h = null)
        }

        function et(c) {
            c.propertyName === "value" && K(h) && w(c)
        }

        function wt(c, u, v) {
            c === "focusin" ? (Pe(), Re(u, v)) : c === "focusout" && Pe()
        }

        function Ct(c, u) {
            if (c === "selectionchange" || c === "keyup" || c === "keydown") return K(h)
        }

        function vt(c) {
            var u = c.nodeName;
            return u && u.toLowerCase() === "input" && (c.type === "checkbox" || c.type === "radio")
        }

        function Zt(c, u) {
            if (c === "click") return K(u)
        }

        function dr(c, u) {
            if (c === "input" || c === "change") return K(u)
        }

        function gr(c) {
            var u = c._wrapperState;
            !u || !u.controlled || c.type !== "number" || Et(c, "number", c.value)
        }

        function io(c, u, v, y, E, L, Z) {
            var se = v ? y_(v) : window, he, we;
            if (m(se) ? he = ae : Cb(se) ? ge ? he = dr : (he = Ct, we = wt) : vt(se) && (he = Zt), he) {
                var _e = he(u, v);
                if (_e) {
                    aR(c, _e, y, E);
                    return
                }
            }
            we && we(u, se, v), u === "focusout" && gr(se)
        }

        function He() {
            Ce("onMouseEnter", ["mouseout", "mouseover"]), Ce("onMouseLeave", ["mouseout", "mouseover"]), Ce("onPointerEnter", ["pointerout", "pointerover"]), Ce("onPointerLeave", ["pointerout", "pointerover"])
        }

        function $e(c, u, v, y, E, L, Z) {
            var se = u === "mouseover" || u === "pointerover", he = u === "mouseout" || u === "pointerout";
            if (se && !jB(y)) {
                var we = y.relatedTarget || y.fromElement;
                if (we && (Rb(we) || q6(we))) return
            }
            if (!(!he && !se)) {
                var _e;
                if (E.window === E) _e = E; else {
                    var Fe = E.ownerDocument;
                    Fe ? _e = Fe.defaultView || Fe.parentWindow : _e = window
                }
                var Le, Qe;
                if (he) {
                    var nt = y.relatedTarget || y.toElement;
                    if (Le = v, Qe = nt ? Rb(nt) : null, Qe !== null) {
                        var lt = Fl(Qe);
                        (Qe !== lt || Qe.tag !== b && Qe.tag !== S) && (Qe = null)
                    }
                } else Le = null, Qe = v;
                if (Le !== Qe) {
                    var qt = x6, jr = "onMouseLeave", xr = "onMouseEnter", ri = "mouse";
                    (u === "pointerout" || u === "pointerover") && (qt = Zk, jr = "onPointerLeave", xr = "onPointerEnter", ri = "pointer");
                    var qn = Le == null ? _e : y_(Le), We = Qe == null ? _e : y_(Qe),
                        ut = new qt(jr, ri + "leave", Le, y, E);
                    ut.target = qn, ut.relatedTarget = We;
                    var qe = null, At = Rb(E);
                    if (At === v) {
                        var tr = new qt(xr, ri + "enter", Qe, y, E);
                        tr.target = We, tr.relatedTarget = qn, qe = tr
                    }
                    yRe(c, ut, qe, Le, Qe)
                }
            }
        }

        function Ke(c, u) {
            return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u
        }

        var St = typeof Object.is == "function" ? Object.is : Ke;

        function hr(c, u) {
            if (St(c, u)) return !0;
            if (typeof c != "object" || c === null || typeof u != "object" || u === null) return !1;
            var v = Object.keys(c), y = Object.keys(u);
            if (v.length !== y.length) return !1;
            for (var E = 0; E < v.length; E++) {
                var L = v[E];
                if (!ve.call(u, L) || !St(c[L], u[L])) return !1
            }
            return !0
        }

        function zr(c) {
            for (; c && c.firstChild;) c = c.firstChild;
            return c
        }

        function Hr(c) {
            for (; c;) {
                if (c.nextSibling) return c.nextSibling;
                c = c.parentNode
            }
        }

        function Jr(c, u) {
            for (var v = zr(c), y = 0, E = 0; v;) {
                if (v.nodeType === hh) {
                    if (E = y + v.textContent.length, y <= u && E >= u) return {node: v, offset: u - y};
                    y = E
                }
                v = zr(Hr(v))
            }
        }

        function Jo(c) {
            var u = c.ownerDocument, v = u && u.defaultView || window, y = v.getSelection && v.getSelection();
            if (!y || y.rangeCount === 0) return null;
            var E = y.anchorNode, L = y.anchorOffset, Z = y.focusNode, se = y.focusOffset;
            return bi(c, E, L, Z, se)
        }

        function bi(c, u, v, y, E) {
            var L = 0, Z = -1, se = -1, he = 0, we = 0, _e = c, Fe = null;
            e:for (; ;) {
                for (var Le = null; _e === u && (v === 0 || _e.nodeType === hh) && (Z = L + v), _e === y && (E === 0 || _e.nodeType === hh) && (se = L + E), _e.nodeType === hh && (L += _e.nodeValue.length), (Le = _e.firstChild) !== null;) Fe = _e, _e = Le;
                for (; ;) {
                    if (_e === c) break e;
                    if (Fe === u && ++he === v && (Z = L), Fe === y && ++we === E && (se = L), (Le = _e.nextSibling) !== null) break;
                    _e = Fe, Fe = _e.parentNode
                }
                _e = Le
            }
            return Z === -1 || se === -1 ? null : {start: Z, end: se}
        }

        function Xp(c, u) {
            var v = c.ownerDocument || document, y = v && v.defaultView || window;
            if (y.getSelection) {
                var E = y.getSelection(), L = c.textContent.length, Z = Math.min(u.start, L),
                    se = u.end === void 0 ? Z : Math.min(u.end, L);
                if (!E.extend && Z > se) {
                    var he = se;
                    se = Z, Z = he
                }
                var we = Jr(c, Z), _e = Jr(c, se);
                if (we && _e) {
                    if (E.rangeCount === 1 && E.anchorNode === we.node && E.anchorOffset === we.offset && E.focusNode === _e.node && E.focusOffset === _e.offset) return;
                    var Fe = v.createRange();
                    Fe.setStart(we.node, we.offset), E.removeAllRanges(), Z > se ? (E.addRange(Fe), E.extend(_e.node, _e.offset)) : (Fe.setEnd(_e.node, _e.offset), E.addRange(Fe))
                }
            }
        }

        function oR(c) {
            return c && c.nodeType === hh
        }

        function yre(c, u) {
            return !c || !u ? !1 : c === u ? !0 : oR(c) ? !1 : oR(u) ? yre(c, u.parentNode) : "contains" in c ? c.contains(u) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(u) & 16) : !1
        }

        function eRe(c) {
            return c && c.ownerDocument && yre(c.ownerDocument.documentElement, c)
        }

        function tRe(c) {
            try {
                return typeof c.contentWindow.location.href == "string"
            } catch {
                return !1
            }
        }

        function bre() {
            for (var c = window, u = hc(); u instanceof c.HTMLIFrameElement;) {
                if (tRe(u)) c = u.contentWindow; else return u;
                u = hc(c.document)
            }
            return u
        }

        function s$(c) {
            var u = c && c.nodeName && c.nodeName.toLowerCase();
            return u && (u === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || u === "textarea" || c.contentEditable === "true")
        }

        function rRe() {
            var c = bre();
            return {focusedElem: c, selectionRange: s$(c) ? iRe(c) : null}
        }

        function nRe(c) {
            var u = bre(), v = c.focusedElem, y = c.selectionRange;
            if (u !== v && eRe(v)) {
                y !== null && s$(v) && aRe(v, y);
                for (var E = [], L = v; L = L.parentNode;) L.nodeType === Qc && E.push({
                    element: L,
                    left: L.scrollLeft,
                    top: L.scrollTop
                });
                typeof v.focus == "function" && v.focus();
                for (var Z = 0; Z < E.length; Z++) {
                    var se = E[Z];
                    se.element.scrollLeft = se.left, se.element.scrollTop = se.top
                }
            }
        }

        function iRe(c) {
            var u;
            return "selectionStart" in c ? u = {
                start: c.selectionStart,
                end: c.selectionEnd
            } : u = Jo(c), u || {start: 0, end: 0}
        }

        function aRe(c, u) {
            var v = u.start, y = u.end;
            y === void 0 && (y = v), "selectionStart" in c ? (c.selectionStart = v, c.selectionEnd = Math.min(y, c.value.length)) : Xp(c, u)
        }

        var oRe = Me && "documentMode" in document && document.documentMode <= 11;

        function sRe() {
            Se("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"])
        }

        var h_ = null, c$ = null, O6 = null, l$ = !1;

        function cRe(c) {
            if ("selectionStart" in c && s$(c)) return {start: c.selectionStart, end: c.selectionEnd};
            var u = c.ownerDocument && c.ownerDocument.defaultView || window, v = u.getSelection();
            return {
                anchorNode: v.anchorNode,
                anchorOffset: v.anchorOffset,
                focusNode: v.focusNode,
                focusOffset: v.focusOffset
            }
        }

        function lRe(c) {
            return c.window === c ? c.document : c.nodeType === ph ? c : c.ownerDocument
        }

        function wre(c, u, v) {
            var y = lRe(v);
            if (!(l$ || h_ == null || h_ !== hc(y))) {
                var E = cRe(h_);
                if (!O6 || !hr(O6, E)) {
                    O6 = E;
                    var L = uR(c$, "onSelect");
                    if (L.length > 0) {
                        var Z = new wd("onSelect", "select", null, u, v);
                        c.push({event: Z, listeners: L}), Z.target = h_
                    }
                }
            }
        }

        function uRe(c, u, v, y, E, L, Z) {
            var se = v ? y_(v) : window;
            switch (u) {
                case"focusin":
                    (Cb(se) || se.contentEditable === "true") && (h_ = se, c$ = v, O6 = null);
                    break;
                case"focusout":
                    h_ = null, c$ = null, O6 = null;
                    break;
                case"mousedown":
                    l$ = !0;
                    break;
                case"contextmenu":
                case"mouseup":
                case"dragend":
                    l$ = !1, wre(c, y, E);
                    break;
                case"selectionchange":
                    if (oRe) break;
                case"keydown":
                case"keyup":
                    wre(c, y, E)
            }
        }

        function sR(c, u) {
            var v = {};
            return v[c.toLowerCase()] = u.toLowerCase(), v["Webkit" + c] = "webkit" + u, v["Moz" + c] = "moz" + u, v
        }

        var p_ = {
            animationend: sR("Animation", "AnimationEnd"),
            animationiteration: sR("Animation", "AnimationIteration"),
            animationstart: sR("Animation", "AnimationStart"),
            transitionend: sR("Transition", "TransitionEnd")
        }, u$ = {}, Sre = {};
        Me && (Sre = document.createElement("div").style, "AnimationEvent" in window || (delete p_.animationend.animation, delete p_.animationiteration.animation, delete p_.animationstart.animation), "TransitionEvent" in window || delete p_.transitionend.transition);

        function cR(c) {
            if (u$[c]) return u$[c];
            if (!p_[c]) return c;
            var u = p_[c];
            for (var v in u) if (u.hasOwnProperty(v) && v in Sre) return u$[c] = u[v];
            return c
        }

        var _re = cR("animationend"), xre = cR("animationiteration"), Ere = cR("animationstart"),
            Tre = cR("transitionend"), Cre = new Map,
            Are = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];

        function Pg(c, u) {
            Cre.set(c, u), Se(u, [c])
        }

        function fRe() {
            for (var c = 0; c < Are.length; c++) {
                var u = Are[c], v = u.toLowerCase(), y = u[0].toUpperCase() + u.slice(1);
                Pg(v, "on" + y)
            }
            Pg(_re, "onAnimationEnd"), Pg(xre, "onAnimationIteration"), Pg(Ere, "onAnimationStart"), Pg("dblclick", "onDoubleClick"), Pg("focusin", "onFocus"), Pg("focusout", "onBlur"), Pg(Tre, "onTransitionEnd")
        }

        function dRe(c, u, v, y, E, L, Z) {
            var se = Cre.get(u);
            if (se !== void 0) {
                var he = wd, we = u;
                switch (u) {
                    case"keypress":
                        if (qp(y) === 0) return;
                    case"keydown":
                    case"keyup":
                        he = Qk;
                        break;
                    case"focusin":
                        we = "focus", he = Th;
                        break;
                    case"focusout":
                        we = "blur", he = Th;
                        break;
                    case"beforeblur":
                    case"afterblur":
                        he = Th;
                        break;
                    case"click":
                        if (y.button === 2) return;
                    case"auxclick":
                    case"dblclick":
                    case"mousedown":
                    case"mousemove":
                    case"mouseup":
                    case"mouseout":
                    case"mouseover":
                    case"contextmenu":
                        he = x6;
                        break;
                    case"drag":
                    case"dragend":
                    case"dragenter":
                    case"dragexit":
                    case"dragleave":
                    case"dragover":
                    case"dragstart":
                    case"drop":
                        he = Lm;
                        break;
                    case"touchcancel":
                    case"touchend":
                    case"touchmove":
                    case"touchstart":
                        he = eR;
                        break;
                    case _re:
                    case xre:
                    case Ere:
                        he = qk;
                        break;
                    case Tre:
                        he = Pu;
                        break;
                    case"scroll":
                        he = al;
                        break;
                    case"wheel":
                        he = n$;
                        break;
                    case"copy":
                    case"cut":
                    case"paste":
                        he = a_;
                        break;
                    case"gotpointercapture":
                    case"lostpointercapture":
                    case"pointercancel":
                    case"pointerdown":
                    case"pointermove":
                    case"pointerout":
                    case"pointerover":
                    case"pointerup":
                        he = Zk;
                        break
                }
                var _e = (L & mg) !== 0;
                {
                    var Fe = !_e && u === "scroll", Le = vRe(v, se, y.type, _e, Fe);
                    if (Le.length > 0) {
                        var Qe = new he(se, we, null, y, E);
                        c.push({event: Qe, listeners: Le})
                    }
                }
            }
        }

        fRe(), He(), Ab(), sRe(), i$();

        function hRe(c, u, v, y, E, L, Z) {
            dRe(c, u, v, y, E, L);
            var se = (L & Mp) === 0;
            se && ($e(c, u, v, y, E), io(c, u, v, y, E), uRe(c, u, v, y, E), iR(c, u, v, y, E))
        }

        var P6 = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"],
            f$ = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(P6));

        function Ire(c, u, v) {
            var y = c.type || "unknown-event";
            c.currentTarget = v, wg(y, u, void 0, c), c.currentTarget = null
        }

        function pRe(c, u, v) {
            var y;
            if (v) for (var E = u.length - 1; E >= 0; E--) {
                var L = u[E], Z = L.instance, se = L.currentTarget, he = L.listener;
                if (Z !== y && c.isPropagationStopped()) return;
                Ire(c, he, se), y = Z
            } else for (var we = 0; we < u.length; we++) {
                var _e = u[we], Fe = _e.instance, Le = _e.currentTarget, Qe = _e.listener;
                if (Fe !== y && c.isPropagationStopped()) return;
                Ire(c, Qe, Le), y = Fe
            }
        }

        function kre(c, u) {
            for (var v = (u & mg) !== 0, y = 0; y < c.length; y++) {
                var E = c[y], L = E.event, Z = E.listeners;
                pRe(L, Z, v)
            }
            cd()
        }

        function mRe(c, u, v, y, E) {
            var L = pm(v), Z = [];
            hRe(Z, c, y, v, L, u), kre(Z, u)
        }

        function $a(c, u) {
            f$.has(c) || o('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', c);
            var v = !1, y = W9e(u), E = bRe(c, v);
            y.has(E) || (Rre(u, c, p2, v), y.add(E))
        }

        function d$(c, u, v) {
            f$.has(c) && !u && o('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', c);
            var y = 0;
            u && (y |= mg), Rre(v, c, y, u)
        }

        var lR = "_reactListening" + Math.random().toString(36).slice(2);

        function N6(c) {
            if (!c[lR]) {
                c[lR] = !0, ye.forEach(function (v) {
                    v !== "selectionchange" && (f$.has(v) || d$(v, !1, c), d$(v, !0, c))
                });
                var u = c.nodeType === ph ? c : c.ownerDocument;
                u !== null && (u[lR] || (u[lR] = !0, d$("selectionchange", !1, u)))
            }
        }

        function Rre(c, u, v, y, E) {
            var L = gs(c, u, v), Z = void 0;
            bg && (u === "touchstart" || u === "touchmove" || u === "wheel") && (Z = !0), c = c, y ? Z !== void 0 ? _6(c, u, L, Z) : il(c, u, L) : Z !== void 0 ? Rg(c, u, L, Z) : Sb(c, u, L)
        }

        function Dre(c, u) {
            return c === u || c.nodeType === ho && c.parentNode === u
        }

        function h$(c, u, v, y, E) {
            var L = y;
            if (!(u & V3) && !(u & p2)) {
                var Z = E;
                if (y !== null) {
                    var se = y;
                    e:for (; ;) {
                        if (se === null) return;
                        var he = se.tag;
                        if (he === p || he === g) {
                            var we = se.stateNode.containerInfo;
                            if (Dre(we, Z)) break;
                            if (he === g) for (var _e = se.return; _e !== null;) {
                                var Fe = _e.tag;
                                if (Fe === p || Fe === g) {
                                    var Le = _e.stateNode.containerInfo;
                                    if (Dre(Le, Z)) return
                                }
                                _e = _e.return
                            }
                            for (; we !== null;) {
                                var Qe = Rb(we);
                                if (Qe === null) return;
                                var nt = Qe.tag;
                                if (nt === b || nt === S) {
                                    se = L = Qe;
                                    continue e
                                }
                                we = we.parentNode
                            }
                        }
                        se = se.return
                    }
                }
            }
            K3(function () {
                return mRe(c, u, v, L)
            })
        }

        function L6(c, u, v) {
            return {instance: c, listener: u, currentTarget: v}
        }

        function vRe(c, u, v, y, E, L) {
            for (var Z = u !== null ? u + "Capture" : null, se = y ? Z : u, he = [], we = c, _e = null; we !== null;) {
                var Fe = we, Le = Fe.stateNode, Qe = Fe.tag;
                if (Qe === b && Le !== null && (_e = Le, se !== null)) {
                    var nt = Op(we, se);
                    nt != null && he.push(L6(we, nt, _e))
                }
                if (E) break;
                we = we.return
            }
            return he
        }

        function uR(c, u) {
            for (var v = u + "Capture", y = [], E = c; E !== null;) {
                var L = E, Z = L.stateNode, se = L.tag;
                if (se === b && Z !== null) {
                    var he = Z, we = Op(E, v);
                    we != null && y.unshift(L6(E, we, he));
                    var _e = Op(E, u);
                    _e != null && y.push(L6(E, _e, he))
                }
                E = E.return
            }
            return y
        }

        function m_(c) {
            if (c === null) return null;
            do c = c.return; while (c && c.tag !== b);
            return c || null
        }

        function gRe(c, u) {
            for (var v = c, y = u, E = 0, L = v; L; L = m_(L)) E++;
            for (var Z = 0, se = y; se; se = m_(se)) Z++;
            for (; E - Z > 0;) v = m_(v), E--;
            for (; Z - E > 0;) y = m_(y), Z--;
            for (var he = E; he--;) {
                if (v === y || y !== null && v === y.alternate) return v;
                v = m_(v), y = m_(y)
            }
            return null
        }

        function Mre(c, u, v, y, E) {
            for (var L = u._reactName, Z = [], se = v; se !== null && se !== y;) {
                var he = se, we = he.alternate, _e = he.stateNode, Fe = he.tag;
                if (we !== null && we === y) break;
                if (Fe === b && _e !== null) {
                    var Le = _e;
                    if (E) {
                        var Qe = Op(se, L);
                        Qe != null && Z.unshift(L6(se, Qe, Le))
                    } else if (!E) {
                        var nt = Op(se, L);
                        nt != null && Z.push(L6(se, nt, Le))
                    }
                }
                se = se.return
            }
            Z.length !== 0 && c.push({event: u, listeners: Z})
        }

        function yRe(c, u, v, y, E) {
            var L = y && E ? gRe(y, E) : null;
            y !== null && Mre(c, u, y, L, !1), E !== null && v !== null && Mre(c, v, E, L, !0)
        }

        function bRe(c, u) {
            return c + "__" + (u ? "capture" : "bubble")
        }

        var Nu = !1, B6 = "dangerouslySetInnerHTML", fR = "suppressContentEditableWarning",
            Ng = "suppressHydrationWarning", Ore = "autoFocus", Ib = "children", kb = "style", dR = "__html", p$, hR,
            $6, Pre, pR, Nre, Lre;
        p$ = {dialog: !0, webview: !0}, hR = function (c, u) {
            z1(c, u), mk(c, u), bk(c, u, {registrationNameDependencies: ue, possibleRegistrationNames: me})
        }, Nre = Me && !document.documentMode, $6 = function (c, u, v) {
            if (!Nu) {
                var y = mR(v), E = mR(u);
                E !== y && (Nu = !0, o("Prop `%s` did not match. Server: %s Client: %s", c, JSON.stringify(E), JSON.stringify(y)))
            }
        }, Pre = function (c) {
            if (!Nu) {
                Nu = !0;
                var u = [];
                c.forEach(function (v) {
                    u.push(v)
                }), o("Extra attributes from the server: %s", u)
            }
        }, pR = function (c, u) {
            u === !1 ? o("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", c, c, c) : o("Expected `%s` listener to be a function, instead got a value of `%s` type.", c, typeof u)
        }, Lre = function (c, u) {
            var v = c.namespaceURI === dh ? c.ownerDocument.createElement(c.tagName) : c.ownerDocument.createElementNS(c.namespaceURI, c.tagName);
            return v.innerHTML = u, v.innerHTML
        };
        var wRe = /\r\n?/g, SRe = /\u0000|\uFFFD/g;

        function mR(c) {
            Ue(c);
            var u = typeof c == "string" ? c : "" + c;
            return u.replace(wRe, `
`).replace(SRe, "")
        }

        function vR(c, u, v, y) {
            var E = mR(u), L = mR(c);
            if (L !== E && (y && (Nu || (Nu = !0, o('Text content did not match. Server: "%s" Client: "%s"', L, E))), v && z)) throw new Error("Text content does not match server-rendered HTML.")
        }

        function Bre(c) {
            return c.nodeType === ph ? c : c.ownerDocument
        }

        function _Re() {
        }

        function gR(c) {
            c.onclick = _Re
        }

        function xRe(c, u, v, y, E) {
            for (var L in y) if (y.hasOwnProperty(L)) {
                var Z = y[L];
                if (L === kb) Z && Object.freeze(Z), hk(u, Z); else if (L === B6) {
                    var se = Z ? Z[dR] : void 0;
                    se != null && nk(u, se)
                } else if (L === Ib) if (typeof Z == "string") {
                    var he = c !== "textarea" || Z !== "";
                    he && s2(u, Z)
                } else typeof Z == "number" && s2(u, "" + Z); else L === fR || L === Ng || L === Ore || (ue.hasOwnProperty(L) ? Z != null && (typeof Z != "function" && pR(L, Z), L === "onScroll" && $a("scroll", u)) : Z != null && _n(u, L, Z, E))
            }
        }

        function ERe(c, u, v, y) {
            for (var E = 0; E < u.length; E += 2) {
                var L = u[E], Z = u[E + 1];
                L === kb ? hk(c, Z) : L === B6 ? nk(c, Z) : L === Ib ? s2(c, Z) : _n(c, L, Z, y)
            }
        }

        function TRe(c, u, v, y) {
            var E, L = Bre(v), Z, se = y;
            if (se === dh && (se = P3(c)), se === dh) {
                if (E = Rp(c, u), !E && c !== c.toLowerCase() && o("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", c), c === "script") {
                    var he = L.createElement("div");
                    he.innerHTML = "<script><\/script>";
                    var we = he.firstChild;
                    Z = he.removeChild(we)
                } else if (typeof u.is == "string") Z = L.createElement(c, {is: u.is}); else if (Z = L.createElement(c), c === "select") {
                    var _e = Z;
                    u.multiple ? _e.multiple = !0 : u.size && (_e.size = u.size)
                }
            } else Z = L.createElementNS(se, c);
            return se === dh && !E && Object.prototype.toString.call(Z) === "[object HTMLUnknownElement]" && !ve.call(p$, c) && (p$[c] = !0, o("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", c)), Z
        }

        function CRe(c, u) {
            return Bre(u).createTextNode(c)
        }

        function ARe(c, u, v, y) {
            var E = Rp(u, v);
            hR(u, v);
            var L;
            switch (u) {
                case"dialog":
                    $a("cancel", c), $a("close", c), L = v;
                    break;
                case"iframe":
                case"object":
                case"embed":
                    $a("load", c), L = v;
                    break;
                case"video":
                case"audio":
                    for (var Z = 0; Z < P6.length; Z++) $a(P6[Z], c);
                    L = v;
                    break;
                case"source":
                    $a("error", c), L = v;
                    break;
                case"img":
                case"image":
                case"link":
                    $a("error", c), $a("load", c), L = v;
                    break;
                case"details":
                    $a("toggle", c), L = v;
                    break;
                case"input":
                    di(c, v), L = bn(c, v), $a("invalid", c);
                    break;
                case"option":
                    Rn(c, v), L = v;
                    break;
                case"select":
                    i2(c, v), L = fg(c, v), $a("invalid", c);
                    break;
                case"textarea":
                    tk(c, v), L = M3(c, v), $a("invalid", c);
                    break;
                default:
                    L = v
            }
            switch (u2(u, L), xRe(u, c, y, L, E), u) {
                case"input":
                    hs(c), Ie(c, v, !1);
                    break;
                case"textarea":
                    hs(c), rk(c);
                    break;
                case"option":
                    hi(c, v);
                    break;
                case"select":
                    dg(c, v);
                    break;
                default:
                    typeof L.onClick == "function" && gR(c);
                    break
            }
        }

        function IRe(c, u, v, y, E) {
            hR(u, y);
            var L = null, Z, se;
            switch (u) {
                case"input":
                    Z = bn(c, v), se = bn(c, y), L = [];
                    break;
                case"select":
                    Z = fg(c, v), se = fg(c, y), L = [];
                    break;
                case"textarea":
                    Z = M3(c, v), se = M3(c, y), L = [];
                    break;
                default:
                    Z = v, se = y, typeof Z.onClick != "function" && typeof se.onClick == "function" && gR(c);
                    break
            }
            u2(u, se);
            var he, we, _e = null;
            for (he in Z) if (!(se.hasOwnProperty(he) || !Z.hasOwnProperty(he) || Z[he] == null)) if (he === kb) {
                var Fe = Z[he];
                for (we in Fe) Fe.hasOwnProperty(we) && (_e || (_e = {}), _e[we] = "")
            } else he === B6 || he === Ib || he === fR || he === Ng || he === Ore || (ue.hasOwnProperty(he) ? L || (L = []) : (L = L || []).push(he, null));
            for (he in se) {
                var Le = se[he], Qe = Z != null ? Z[he] : void 0;
                if (!(!se.hasOwnProperty(he) || Le === Qe || Le == null && Qe == null)) if (he === kb) if (Le && Object.freeze(Le), Qe) {
                    for (we in Qe) Qe.hasOwnProperty(we) && (!Le || !Le.hasOwnProperty(we)) && (_e || (_e = {}), _e[we] = "");
                    for (we in Le) Le.hasOwnProperty(we) && Qe[we] !== Le[we] && (_e || (_e = {}), _e[we] = Le[we])
                } else _e || (L || (L = []), L.push(he, _e)), _e = Le; else if (he === B6) {
                    var nt = Le ? Le[dR] : void 0, lt = Qe ? Qe[dR] : void 0;
                    nt != null && lt !== nt && (L = L || []).push(he, nt)
                } else he === Ib ? (typeof Le == "string" || typeof Le == "number") && (L = L || []).push(he, "" + Le) : he === fR || he === Ng || (ue.hasOwnProperty(he) ? (Le != null && (typeof Le != "function" && pR(he, Le), he === "onScroll" && $a("scroll", c)), !L && Qe !== Le && (L = [])) : (L = L || []).push(he, Le))
            }
            return _e && (LB(_e, se[kb]), (L = L || []).push(kb, _e)), L
        }

        function kRe(c, u, v, y, E) {
            v === "input" && E.type === "radio" && E.name != null && Qn(c, E);
            var L = Rp(v, y), Z = Rp(v, E);
            switch (ERe(c, u, L, Z), v) {
                case"input":
                    de(c, E);
                    break;
                case"textarea":
                    O3(c, E);
                    break;
                case"select":
                    D3(c, E);
                    break
            }
        }

        function RRe(c) {
            {
                var u = c.toLowerCase();
                return j1.hasOwnProperty(u) && j1[u] || null
            }
        }

        function DRe(c, u, v, y, E, L, Z) {
            var se, he;
            switch (se = Rp(u, v), hR(u, v), u) {
                case"dialog":
                    $a("cancel", c), $a("close", c);
                    break;
                case"iframe":
                case"object":
                case"embed":
                    $a("load", c);
                    break;
                case"video":
                case"audio":
                    for (var we = 0; we < P6.length; we++) $a(P6[we], c);
                    break;
                case"source":
                    $a("error", c);
                    break;
                case"img":
                case"image":
                case"link":
                    $a("error", c), $a("load", c);
                    break;
                case"details":
                    $a("toggle", c);
                    break;
                case"input":
                    di(c, v), $a("invalid", c);
                    break;
                case"option":
                    Rn(c, v);
                    break;
                case"select":
                    i2(c, v), $a("invalid", c);
                    break;
                case"textarea":
                    tk(c, v), $a("invalid", c);
                    break
            }
            u2(u, v);
            {
                he = new Set;
                for (var _e = c.attributes, Fe = 0; Fe < _e.length; Fe++) {
                    var Le = _e[Fe].name.toLowerCase();
                    switch (Le) {
                        case"value":
                            break;
                        case"checked":
                            break;
                        case"selected":
                            break;
                        default:
                            he.add(_e[Fe].name)
                    }
                }
            }
            var Qe = null;
            for (var nt in v) if (v.hasOwnProperty(nt)) {
                var lt = v[nt];
                if (nt === Ib) typeof lt == "string" ? c.textContent !== lt && (v[Ng] !== !0 && vR(c.textContent, lt, L, Z), Qe = [Ib, lt]) : typeof lt == "number" && c.textContent !== "" + lt && (v[Ng] !== !0 && vR(c.textContent, lt, L, Z), Qe = [Ib, "" + lt]); else if (ue.hasOwnProperty(nt)) lt != null && (typeof lt != "function" && pR(nt, lt), nt === "onScroll" && $a("scroll", c)); else if (Z && typeof se == "boolean") {
                    var qt = void 0, jr = se && Q ? null : Ze(nt);
                    if (v[Ng] !== !0) {
                        if (!(nt === fR || nt === Ng || nt === "value" || nt === "checked" || nt === "selected")) {
                            if (nt === B6) {
                                var xr = c.innerHTML, ri = lt ? lt[dR] : void 0;
                                if (ri != null) {
                                    var qn = Lre(c, ri);
                                    qn !== xr && $6(nt, xr, qn)
                                }
                            } else if (nt === kb) {
                                if (he.delete(nt), Nre) {
                                    var We = dk(lt);
                                    qt = c.getAttribute("style"), We !== qt && $6(nt, qt, We)
                                }
                            } else if (se && !Q) he.delete(nt.toLowerCase()), qt = _r(c, nt, lt), lt !== qt && $6(nt, qt, lt); else if (!xe(nt, jr, se) && !De(nt, lt, jr, se)) {
                                var ut = !1;
                                if (jr !== null) he.delete(jr.attributeName), qt = En(c, nt, lt, jr); else {
                                    var qe = y;
                                    if (qe === dh && (qe = P3(u)), qe === dh) he.delete(nt.toLowerCase()); else {
                                        var At = RRe(nt);
                                        At !== null && At !== nt && (ut = !0, he.delete(At)), he.delete(nt)
                                    }
                                    qt = _r(c, nt, lt)
                                }
                                var tr = Q;
                                !tr && lt !== qt && !ut && $6(nt, qt, lt)
                            }
                        }
                    }
                }
            }
            switch (Z && he.size > 0 && v[Ng] !== !0 && Pre(he), u) {
                case"input":
                    hs(c), Ie(c, v, !0);
                    break;
                case"textarea":
                    hs(c), rk(c);
                    break;
                case"select":
                case"option":
                    break;
                default:
                    typeof v.onClick == "function" && gR(c);
                    break
            }
            return Qe
        }

        function MRe(c, u, v) {
            var y = c.nodeValue !== u;
            return y
        }

        function m$(c, u) {
            {
                if (Nu) return;
                Nu = !0, o("Did not expect server HTML to contain a <%s> in <%s>.", u.nodeName.toLowerCase(), c.nodeName.toLowerCase())
            }
        }

        function v$(c, u) {
            {
                if (Nu) return;
                Nu = !0, o('Did not expect server HTML to contain the text node "%s" in <%s>.', u.nodeValue, c.nodeName.toLowerCase())
            }
        }

        function g$(c, u, v) {
            {
                if (Nu) return;
                Nu = !0, o("Expected server HTML to contain a matching <%s> in <%s>.", u, c.nodeName.toLowerCase())
            }
        }

        function y$(c, u) {
            {
                if (u === "" || Nu) return;
                Nu = !0, o('Expected server HTML to contain a matching text node for "%s" in <%s>.', u, c.nodeName.toLowerCase())
            }
        }

        function ORe(c, u, v) {
            switch (u) {
                case"input":
                    Ye(c, v);
                    return;
                case"textarea":
                    AB(c, v);
                    return;
                case"select":
                    a2(c, v);
                    return
            }
        }

        var F6 = function () {
        }, U6 = function () {
        };
        {
            var PRe = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"],
                $re = ["applet", "caption", "html", "table", "td", "th", "marquee", "object", "template", "foreignObject", "desc", "title"],
                NRe = $re.concat(["button"]), LRe = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], Fre = {
                    current: null,
                    formTag: null,
                    aTagInScope: null,
                    buttonTagInScope: null,
                    nobrTagInScope: null,
                    pTagInButtonScope: null,
                    listItemTagAutoclosing: null,
                    dlItemTagAutoclosing: null
                };
            U6 = function (c, u) {
                var v = Pt({}, c || Fre), y = {tag: u};
                return $re.indexOf(u) !== -1 && (v.aTagInScope = null, v.buttonTagInScope = null, v.nobrTagInScope = null), NRe.indexOf(u) !== -1 && (v.pTagInButtonScope = null), PRe.indexOf(u) !== -1 && u !== "address" && u !== "div" && u !== "p" && (v.listItemTagAutoclosing = null, v.dlItemTagAutoclosing = null), v.current = y, u === "form" && (v.formTag = y), u === "a" && (v.aTagInScope = y), u === "button" && (v.buttonTagInScope = y), u === "nobr" && (v.nobrTagInScope = y), u === "p" && (v.pTagInButtonScope = y), u === "li" && (v.listItemTagAutoclosing = y), (u === "dd" || u === "dt") && (v.dlItemTagAutoclosing = y), v
            };
            var BRe = function (c, u) {
                switch (u) {
                    case"select":
                        return c === "option" || c === "optgroup" || c === "#text";
                    case"optgroup":
                        return c === "option" || c === "#text";
                    case"option":
                        return c === "#text";
                    case"tr":
                        return c === "th" || c === "td" || c === "style" || c === "script" || c === "template";
                    case"tbody":
                    case"thead":
                    case"tfoot":
                        return c === "tr" || c === "style" || c === "script" || c === "template";
                    case"colgroup":
                        return c === "col" || c === "template";
                    case"table":
                        return c === "caption" || c === "colgroup" || c === "tbody" || c === "tfoot" || c === "thead" || c === "style" || c === "script" || c === "template";
                    case"head":
                        return c === "base" || c === "basefont" || c === "bgsound" || c === "link" || c === "meta" || c === "title" || c === "noscript" || c === "noframes" || c === "style" || c === "script" || c === "template";
                    case"html":
                        return c === "head" || c === "body" || c === "frameset";
                    case"frameset":
                        return c === "frame";
                    case"#document":
                        return c === "html"
                }
                switch (c) {
                    case"h1":
                    case"h2":
                    case"h3":
                    case"h4":
                    case"h5":
                    case"h6":
                        return u !== "h1" && u !== "h2" && u !== "h3" && u !== "h4" && u !== "h5" && u !== "h6";
                    case"rp":
                    case"rt":
                        return LRe.indexOf(u) === -1;
                    case"body":
                    case"caption":
                    case"col":
                    case"colgroup":
                    case"frameset":
                    case"frame":
                    case"head":
                    case"html":
                    case"tbody":
                    case"td":
                    case"tfoot":
                    case"th":
                    case"thead":
                    case"tr":
                        return u == null
                }
                return !0
            }, $Re = function (c, u) {
                switch (c) {
                    case"address":
                    case"article":
                    case"aside":
                    case"blockquote":
                    case"center":
                    case"details":
                    case"dialog":
                    case"dir":
                    case"div":
                    case"dl":
                    case"fieldset":
                    case"figcaption":
                    case"figure":
                    case"footer":
                    case"header":
                    case"hgroup":
                    case"main":
                    case"menu":
                    case"nav":
                    case"ol":
                    case"p":
                    case"section":
                    case"summary":
                    case"ul":
                    case"pre":
                    case"listing":
                    case"table":
                    case"hr":
                    case"xmp":
                    case"h1":
                    case"h2":
                    case"h3":
                    case"h4":
                    case"h5":
                    case"h6":
                        return u.pTagInButtonScope;
                    case"form":
                        return u.formTag || u.pTagInButtonScope;
                    case"li":
                        return u.listItemTagAutoclosing;
                    case"dd":
                    case"dt":
                        return u.dlItemTagAutoclosing;
                    case"button":
                        return u.buttonTagInScope;
                    case"a":
                        return u.aTagInScope;
                    case"nobr":
                        return u.nobrTagInScope
                }
                return null
            }, Ure = {};
            F6 = function (c, u, v) {
                v = v || Fre;
                var y = v.current, E = y && y.tag;
                u != null && (c != null && o("validateDOMNesting: when childText is passed, childTag should be null"), c = "#text");
                var L = BRe(c, E) ? null : y, Z = L ? null : $Re(c, v), se = L || Z;
                if (se) {
                    var he = se.tag, we = !!L + "|" + c + "|" + he;
                    if (!Ure[we]) {
                        Ure[we] = !0;
                        var _e = c, Fe = "";
                        if (c === "#text" ? /\S/.test(u) ? _e = "Text nodes" : (_e = "Whitespace text nodes", Fe = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : _e = "<" + c + ">", L) {
                            var Le = "";
                            he === "table" && c === "tr" && (Le += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), o("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", _e, he, Fe, Le)
                        } else o("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", _e, he)
                    }
                }
            }
        }
        var yR = "suppressHydrationWarning", bR = "$", wR = "/$", j6 = "$?", z6 = "$!", FRe = "style", b$ = null,
            w$ = null;

        function URe(c) {
            var u, v, y = c.nodeType;
            switch (y) {
                case ph:
                case L3: {
                    u = y === ph ? "#document" : "#fragment";
                    var E = c.documentElement;
                    v = E ? E.namespaceURI : N3(null, "");
                    break
                }
                default: {
                    var L = y === ho ? c.parentNode : c, Z = L.namespaceURI || null;
                    u = L.tagName, v = N3(Z, u);
                    break
                }
            }
            {
                var se = u.toLowerCase(), he = U6(null, se);
                return {namespace: v, ancestorInfo: he}
            }
        }

        function jRe(c, u, v) {
            {
                var y = c, E = N3(y.namespace, u), L = U6(y.ancestorInfo, u);
                return {namespace: E, ancestorInfo: L}
            }
        }

        function FZt(c) {
            return c
        }

        function zRe(c) {
            b$ = bo(), w$ = rRe();
            var u = null;
            return $o(!1), u
        }

        function VRe(c) {
            nRe(w$), $o(b$), b$ = null, w$ = null
        }

        function HRe(c, u, v, y, E) {
            var L;
            {
                var Z = y;
                if (F6(c, null, Z.ancestorInfo), typeof u.children == "string" || typeof u.children == "number") {
                    var se = "" + u.children, he = U6(Z.ancestorInfo, c);
                    F6(null, se, he)
                }
                L = Z.namespace
            }
            var we = TRe(c, u, v, L);
            return W6(E, we), I$(we, u), we
        }

        function WRe(c, u) {
            c.appendChild(u)
        }

        function qRe(c, u, v, y, E) {
            switch (ARe(c, u, v, y), u) {
                case"button":
                case"input":
                case"select":
                case"textarea":
                    return !!v.autoFocus;
                case"img":
                    return !0;
                default:
                    return !1
            }
        }

        function GRe(c, u, v, y, E, L) {
            {
                var Z = L;
                if (typeof y.children != typeof v.children && (typeof y.children == "string" || typeof y.children == "number")) {
                    var se = "" + y.children, he = U6(Z.ancestorInfo, u);
                    F6(null, se, he)
                }
            }
            return IRe(c, u, v, y)
        }

        function S$(c, u) {
            return c === "textarea" || c === "noscript" || typeof u.children == "string" || typeof u.children == "number" || typeof u.dangerouslySetInnerHTML == "object" && u.dangerouslySetInnerHTML !== null && u.dangerouslySetInnerHTML.__html != null
        }

        function KRe(c, u, v, y) {
            {
                var E = v;
                F6(null, c, E.ancestorInfo)
            }
            var L = CRe(c, u);
            return W6(y, L), L
        }

        function YRe() {
            var c = window.event;
            return c === void 0 ? Du : r_(c.type)
        }

        var _$ = typeof setTimeout == "function" ? setTimeout : void 0,
            XRe = typeof clearTimeout == "function" ? clearTimeout : void 0, x$ = -1,
            jre = typeof Promise == "function" ? Promise : void 0,
            QRe = typeof queueMicrotask == "function" ? queueMicrotask : typeof jre < "u" ? function (c) {
                return jre.resolve(null).then(c).catch(ZRe)
            } : _$;

        function ZRe(c) {
            setTimeout(function () {
                throw c
            })
        }

        function JRe(c, u, v, y) {
            switch (u) {
                case"button":
                case"input":
                case"select":
                case"textarea":
                    v.autoFocus && c.focus();
                    return;
                case"img": {
                    v.src && (c.src = v.src);
                    return
                }
            }
        }

        function e9e(c, u, v, y, E, L) {
            kRe(c, u, v, y, E), I$(c, E)
        }

        function zre(c) {
            s2(c, "")
        }

        function t9e(c, u, v) {
            c.nodeValue = v
        }

        function r9e(c, u) {
            c.appendChild(u)
        }

        function n9e(c, u) {
            var v;
            c.nodeType === ho ? (v = c.parentNode, v.insertBefore(u, c)) : (v = c, v.appendChild(u));
            var y = c._reactRootContainer;
            y == null && v.onclick === null && gR(v)
        }

        function i9e(c, u, v) {
            c.insertBefore(u, v)
        }

        function a9e(c, u, v) {
            c.nodeType === ho ? c.parentNode.insertBefore(u, v) : c.insertBefore(u, v)
        }

        function o9e(c, u) {
            c.removeChild(u)
        }

        function s9e(c, u) {
            c.nodeType === ho ? c.parentNode.removeChild(u) : c.removeChild(u)
        }

        function E$(c, u) {
            var v = u, y = 0;
            do {
                var E = v.nextSibling;
                if (c.removeChild(v), E && E.nodeType === ho) {
                    var L = E.data;
                    if (L === wR) if (y === 0) {
                        c.removeChild(E), Om(u);
                        return
                    } else y--; else (L === bR || L === j6 || L === z6) && y++
                }
                v = E
            } while (v);
            Om(u)
        }

        function c9e(c, u) {
            c.nodeType === ho ? E$(c.parentNode, u) : c.nodeType === Qc && E$(c, u), Om(c)
        }

        function l9e(c) {
            c = c;
            var u = c.style;
            typeof u.setProperty == "function" ? u.setProperty("display", "none", "important") : u.display = "none"
        }

        function u9e(c) {
            c.nodeValue = ""
        }

        function f9e(c, u) {
            c = c;
            var v = u[FRe], y = v != null && v.hasOwnProperty("display") ? v.display : null;
            c.style.display = c2("display", y)
        }

        function d9e(c, u) {
            c.nodeValue = u
        }

        function h9e(c) {
            c.nodeType === Qc ? c.textContent = "" : c.nodeType === ph && c.documentElement && c.removeChild(c.documentElement)
        }

        function p9e(c, u, v) {
            return c.nodeType !== Qc || u.toLowerCase() !== c.nodeName.toLowerCase() ? null : c
        }

        function m9e(c, u) {
            return u === "" || c.nodeType !== hh ? null : c
        }

        function v9e(c) {
            return c.nodeType !== ho ? null : c
        }

        function Vre(c) {
            return c.data === j6
        }

        function T$(c) {
            return c.data === z6
        }

        function g9e(c) {
            var u = c.nextSibling && c.nextSibling.dataset, v, y, E;
            return u && (v = u.dgst, y = u.msg, E = u.stck), {message: y, digest: v, stack: E}
        }

        function y9e(c, u) {
            c._reactRetry = u
        }

        function SR(c) {
            for (; c != null; c = c.nextSibling) {
                var u = c.nodeType;
                if (u === Qc || u === hh) break;
                if (u === ho) {
                    var v = c.data;
                    if (v === bR || v === z6 || v === j6) break;
                    if (v === wR) return null
                }
            }
            return c
        }

        function V6(c) {
            return SR(c.nextSibling)
        }

        function b9e(c) {
            return SR(c.firstChild)
        }

        function w9e(c) {
            return SR(c.firstChild)
        }

        function S9e(c) {
            return SR(c.nextSibling)
        }

        function _9e(c, u, v, y, E, L, Z) {
            W6(L, c), I$(c, v);
            var se;
            {
                var he = E;
                se = he.namespace
            }
            var we = (L.mode & Mn) !== $r;
            return DRe(c, u, v, se, y, we, Z)
        }

        function x9e(c, u, v, y) {
            return W6(v, c), MRe(c, u)
        }

        function E9e(c, u) {
            W6(u, c)
        }

        function T9e(c) {
            for (var u = c.nextSibling, v = 0; u;) {
                if (u.nodeType === ho) {
                    var y = u.data;
                    if (y === wR) {
                        if (v === 0) return V6(u);
                        v--
                    } else (y === bR || y === z6 || y === j6) && v++
                }
                u = u.nextSibling
            }
            return null
        }

        function Hre(c) {
            for (var u = c.previousSibling, v = 0; u;) {
                if (u.nodeType === ho) {
                    var y = u.data;
                    if (y === bR || y === z6 || y === j6) {
                        if (v === 0) return u;
                        v--
                    } else y === wR && v++
                }
                u = u.previousSibling
            }
            return null
        }

        function C9e(c) {
            Om(c)
        }

        function A9e(c) {
            Om(c)
        }

        function I9e(c) {
            return c !== "head" && c !== "body"
        }

        function k9e(c, u, v, y) {
            var E = !0;
            vR(u.nodeValue, v, y, E)
        }

        function R9e(c, u, v, y, E, L) {
            if (u[yR] !== !0) {
                var Z = !0;
                vR(y.nodeValue, E, L, Z)
            }
        }

        function D9e(c, u) {
            u.nodeType === Qc ? m$(c, u) : u.nodeType === ho || v$(c, u)
        }

        function M9e(c, u) {
            {
                var v = c.parentNode;
                v !== null && (u.nodeType === Qc ? m$(v, u) : u.nodeType === ho || v$(v, u))
            }
        }

        function O9e(c, u, v, y, E) {
            (E || u[yR] !== !0) && (y.nodeType === Qc ? m$(v, y) : y.nodeType === ho || v$(v, y))
        }

        function P9e(c, u, v) {
            g$(c, u)
        }

        function N9e(c, u) {
            y$(c, u)
        }

        function L9e(c, u, v) {
            {
                var y = c.parentNode;
                y !== null && g$(y, u)
            }
        }

        function B9e(c, u) {
            {
                var v = c.parentNode;
                v !== null && y$(v, u)
            }
        }

        function $9e(c, u, v, y, E, L) {
            (L || u[yR] !== !0) && g$(v, y)
        }

        function F9e(c, u, v, y, E) {
            (E || u[yR] !== !0) && y$(v, y)
        }

        function U9e(c) {
            o("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", c.nodeName.toLowerCase())
        }

        function j9e(c) {
            N6(c)
        }

        var v_ = Math.random().toString(36).slice(2), g_ = "__reactFiber$" + v_, C$ = "__reactProps$" + v_,
            H6 = "__reactContainer$" + v_, A$ = "__reactEvents$" + v_, z9e = "__reactListeners$" + v_,
            V9e = "__reactHandles$" + v_;

        function H9e(c) {
            delete c[g_], delete c[C$], delete c[A$], delete c[z9e], delete c[V9e]
        }

        function W6(c, u) {
            u[g_] = c
        }

        function _R(c, u) {
            u[H6] = c
        }

        function Wre(c) {
            c[H6] = null
        }

        function q6(c) {
            return !!c[H6]
        }

        function Rb(c) {
            var u = c[g_];
            if (u) return u;
            for (var v = c.parentNode; v;) {
                if (u = v[H6] || v[g_], u) {
                    var y = u.alternate;
                    if (u.child !== null || y !== null && y.child !== null) for (var E = Hre(c); E !== null;) {
                        var L = E[g_];
                        if (L) return L;
                        E = Hre(E)
                    }
                    return u
                }
                c = v, v = c.parentNode
            }
            return null
        }

        function Lg(c) {
            var u = c[g_] || c[H6];
            return u && (u.tag === b || u.tag === S || u.tag === Y || u.tag === p) ? u : null
        }

        function y_(c) {
            if (c.tag === b || c.tag === S) return c.stateNode;
            throw new Error("getNodeFromInstance: Invalid argument.")
        }

        function xR(c) {
            return c[C$] || null
        }

        function I$(c, u) {
            c[C$] = u
        }

        function W9e(c) {
            var u = c[A$];
            return u === void 0 && (u = c[A$] = new Set), u
        }

        var qre = {}, Gre = r.ReactDebugCurrentFrame;

        function ER(c) {
            if (c) {
                var u = Ll(c.type);
                Gre.setExtraStackFrame(u)
            } else Gre.setExtraStackFrame(null)
        }

        function Ah(c, u, v, y, E) {
            {
                var L = Function.call.bind(ve);
                for (var Z in c) if (L(c, Z)) {
                    var se = void 0;
                    try {
                        if (typeof c[Z] != "function") {
                            var he = Error((y || "React class") + ": " + v + " type `" + Z + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[Z] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                            throw he.name = "Invariant Violation", he
                        }
                        se = c[Z](u, Z, y, v, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")
                    } catch (we) {
                        se = we
                    }
                    se && !(se instanceof Error) && (ER(E), o("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", y || "React class", v, Z, typeof se), ER(null)), se instanceof Error && !(se.message in qre) && (qre[se.message] = !0, ER(E), o("Failed %s type: %s", v, se.message), ER(null))
                }
            }
        }

        var k$ = [], TR;
        TR = [];
        var Fm = -1;

        function Bg(c) {
            return {current: c}
        }

        function ol(c, u) {
            if (Fm < 0) {
                o("Unexpected pop.");
                return
            }
            u !== TR[Fm] && o("Unexpected Fiber popped."), c.current = k$[Fm], k$[Fm] = null, TR[Fm] = null, Fm--
        }

        function sl(c, u, v) {
            Fm++, k$[Fm] = c.current, TR[Fm] = v, c.current = u
        }

        var R$;
        R$ = {};
        var xf = {};
        Object.freeze(xf);
        var Um = Bg(xf), Qp = Bg(!1), D$ = xf;

        function b_(c, u, v) {
            return v && Zp(u) ? D$ : Um.current
        }

        function Kre(c, u, v) {
            {
                var y = c.stateNode;
                y.__reactInternalMemoizedUnmaskedChildContext = u, y.__reactInternalMemoizedMaskedChildContext = v
            }
        }

        function w_(c, u) {
            {
                var v = c.type, y = v.contextTypes;
                if (!y) return xf;
                var E = c.stateNode;
                if (E && E.__reactInternalMemoizedUnmaskedChildContext === u) return E.__reactInternalMemoizedMaskedChildContext;
                var L = {};
                for (var Z in y) L[Z] = u[Z];
                {
                    var se = Lr(c) || "Unknown";
                    Ah(y, L, "context", se)
                }
                return E && Kre(c, u, L), L
            }
        }

        function CR() {
            return Qp.current
        }

        function Zp(c) {
            {
                var u = c.childContextTypes;
                return u != null
            }
        }

        function AR(c) {
            ol(Qp, c), ol(Um, c)
        }

        function M$(c) {
            ol(Qp, c), ol(Um, c)
        }

        function Yre(c, u, v) {
            {
                if (Um.current !== xf) throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
                sl(Um, u, c), sl(Qp, v, c)
            }
        }

        function Xre(c, u, v) {
            {
                var y = c.stateNode, E = u.childContextTypes;
                if (typeof y.getChildContext != "function") {
                    {
                        var L = Lr(c) || "Unknown";
                        R$[L] || (R$[L] = !0, o("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", L, L))
                    }
                    return v
                }
                var Z = y.getChildContext();
                for (var se in Z) if (!(se in E)) throw new Error((Lr(c) || "Unknown") + '.getChildContext(): key "' + se + '" is not defined in childContextTypes.');
                {
                    var he = Lr(c) || "Unknown";
                    Ah(E, Z, "child context", he)
                }
                return Pt({}, v, Z)
            }
        }

        function IR(c) {
            {
                var u = c.stateNode, v = u && u.__reactInternalMemoizedMergedChildContext || xf;
                return D$ = Um.current, sl(Um, v, c), sl(Qp, Qp.current, c), !0
            }
        }

        function Qre(c, u, v) {
            {
                var y = c.stateNode;
                if (!y) throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
                if (v) {
                    var E = Xre(c, u, D$);
                    y.__reactInternalMemoizedMergedChildContext = E, ol(Qp, c), ol(Um, c), sl(Um, E, c), sl(Qp, v, c)
                } else ol(Qp, c), sl(Qp, v, c)
            }
        }

        function q9e(c) {
            {
                if (!bm(c) || c.tag !== f) throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
                var u = c;
                do {
                    switch (u.tag) {
                        case p:
                            return u.stateNode.context;
                        case f: {
                            var v = u.type;
                            if (Zp(v)) return u.stateNode.__reactInternalMemoizedMergedChildContext;
                            break
                        }
                    }
                    u = u.return
                } while (u !== null);
                throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.")
            }
        }

        var $g = 0, kR = 1, jm = null, O$ = !1, P$ = !1;

        function Zre(c) {
            jm === null ? jm = [c] : jm.push(c)
        }

        function G9e(c) {
            O$ = !0, Zre(c)
        }

        function Jre() {
            O$ && Fg()
        }

        function Fg() {
            if (!P$ && jm !== null) {
                P$ = !0;
                var c = 0, u = Ou();
                try {
                    var v = !0, y = jm;
                    for (yo(vc); c < y.length; c++) {
                        var E = y[c];
                        do E = E(v); while (E !== null)
                    }
                    jm = null, O$ = !1
                } catch (L) {
                    throw jm !== null && (jm = jm.slice(c + 1)), Y3(Y1, Fg), L
                } finally {
                    yo(u), P$ = !1
                }
            }
            return null
        }

        var S_ = [], __ = 0, RR = null, DR = 0, Sd = [], _d = 0, Db = null, zm = 1, Vm = "";

        function K9e(c) {
            return Ob(), (c.flags & dd) !== Ar
        }

        function Y9e(c) {
            return Ob(), DR
        }

        function X9e() {
            var c = Vm, u = zm, v = u & ~Q9e(u);
            return v.toString(32) + c
        }

        function Mb(c, u) {
            Ob(), S_[__++] = DR, S_[__++] = RR, RR = c, DR = u
        }

        function ene(c, u, v) {
            Ob(), Sd[_d++] = zm, Sd[_d++] = Vm, Sd[_d++] = Db, Db = c;
            var y = zm, E = Vm, L = MR(y) - 1, Z = y & ~(1 << L), se = v + 1, he = MR(u) + L;
            if (he > 30) {
                var we = L - L % 5, _e = (1 << we) - 1, Fe = (Z & _e).toString(32), Le = Z >> we, Qe = L - we,
                    nt = MR(u) + Qe, lt = se << Qe, qt = lt | Le, jr = Fe + E;
                zm = 1 << nt | qt, Vm = jr
            } else {
                var xr = se << L, ri = xr | Z, qn = E;
                zm = 1 << he | ri, Vm = qn
            }
        }

        function N$(c) {
            Ob();
            var u = c.return;
            if (u !== null) {
                var v = 1, y = 0;
                Mb(c, v), ene(c, v, y)
            }
        }

        function MR(c) {
            return 32 - vo(c)
        }

        function Q9e(c) {
            return 1 << MR(c) - 1
        }

        function L$(c) {
            for (; c === RR;) RR = S_[--__], S_[__] = null, DR = S_[--__], S_[__] = null;
            for (; c === Db;) Db = Sd[--_d], Sd[_d] = null, Vm = Sd[--_d], Sd[_d] = null, zm = Sd[--_d], Sd[_d] = null
        }

        function Z9e() {
            return Ob(), Db !== null ? {id: zm, overflow: Vm} : null
        }

        function J9e(c, u) {
            Ob(), Sd[_d++] = zm, Sd[_d++] = Vm, Sd[_d++] = Db, zm = u.id, Vm = u.overflow, Db = c
        }

        function Ob() {
            Sc() || o("Expected to be hydrating. This is a bug in React. Please file an issue.")
        }

        var wc = null, xd = null, Ih = !1, Pb = !1, Ug = null;

        function e7e() {
            Ih && o("We should not be hydrating here. This is a bug in React. Please file a bug.")
        }

        function tne() {
            Pb = !0
        }

        function t7e() {
            return Pb
        }

        function r7e(c) {
            var u = c.stateNode.containerInfo;
            return xd = w9e(u), wc = c, Ih = !0, Ug = null, Pb = !1, !0
        }

        function n7e(c, u, v) {
            return xd = S9e(u), wc = c, Ih = !0, Ug = null, Pb = !1, v !== null && J9e(c, v), !0
        }

        function rne(c, u) {
            switch (c.tag) {
                case p: {
                    D9e(c.stateNode.containerInfo, u);
                    break
                }
                case b: {
                    var v = (c.mode & Mn) !== $r;
                    O9e(c.type, c.memoizedProps, c.stateNode, u, v);
                    break
                }
                case Y: {
                    var y = c.memoizedState;
                    y.dehydrated !== null && M9e(y.dehydrated, u);
                    break
                }
            }
        }

        function nne(c, u) {
            rne(c, u);
            var v = oOe();
            v.stateNode = u, v.return = c;
            var y = c.deletions;
            y === null ? (c.deletions = [v], c.flags |= vh) : y.push(v)
        }

        function B$(c, u) {
            {
                if (Pb) return;
                switch (c.tag) {
                    case p: {
                        var v = c.stateNode.containerInfo;
                        switch (u.tag) {
                            case b:
                                var y = u.type;
                                P9e(v, y);
                                break;
                            case S:
                                var E = u.pendingProps;
                                N9e(v, E);
                                break
                        }
                        break
                    }
                    case b: {
                        var L = c.type, Z = c.memoizedProps, se = c.stateNode;
                        switch (u.tag) {
                            case b: {
                                var he = u.type, we = u.pendingProps, _e = (c.mode & Mn) !== $r;
                                $9e(L, Z, se, he, we, _e);
                                break
                            }
                            case S: {
                                var Fe = u.pendingProps, Le = (c.mode & Mn) !== $r;
                                F9e(L, Z, se, Fe, Le);
                                break
                            }
                        }
                        break
                    }
                    case Y: {
                        var Qe = c.memoizedState, nt = Qe.dehydrated;
                        if (nt !== null) switch (u.tag) {
                            case b:
                                var lt = u.type;
                                L9e(nt, lt);
                                break;
                            case S:
                                var qt = u.pendingProps;
                                B9e(nt, qt);
                                break
                        }
                        break
                    }
                    default:
                        return
                }
            }
        }

        function ine(c, u) {
            u.flags = u.flags & ~mc | pa, B$(c, u)
        }

        function ane(c, u) {
            switch (c.tag) {
                case b: {
                    var v = c.type, y = p9e(u, v);
                    return y !== null ? (c.stateNode = y, wc = c, xd = b9e(y), !0) : !1
                }
                case S: {
                    var E = c.pendingProps, L = m9e(u, E);
                    return L !== null ? (c.stateNode = L, wc = c, xd = null, !0) : !1
                }
                case Y: {
                    var Z = v9e(u);
                    if (Z !== null) {
                        var se = {dehydrated: Z, treeContext: Z9e(), retryLane: tl};
                        c.memoizedState = se;
                        var he = sOe(Z);
                        return he.return = c, c.child = he, wc = c, xd = null, !0
                    }
                    return !1
                }
                default:
                    return !1
            }
        }

        function $$(c) {
            return (c.mode & Mn) !== $r && (c.flags & Mr) === Ar
        }

        function F$(c) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.")
        }

        function U$(c) {
            if (Ih) {
                var u = xd;
                if (!u) {
                    $$(c) && (B$(wc, c), F$()), ine(wc, c), Ih = !1, wc = c;
                    return
                }
                var v = u;
                if (!ane(c, u)) {
                    $$(c) && (B$(wc, c), F$()), u = V6(v);
                    var y = wc;
                    if (!u || !ane(c, u)) {
                        ine(wc, c), Ih = !1, wc = c;
                        return
                    }
                    nne(y, v)
                }
            }
        }

        function i7e(c, u, v) {
            var y = c.stateNode, E = !Pb, L = _9e(y, c.type, c.memoizedProps, u, v, c, E);
            return c.updateQueue = L, L !== null
        }

        function a7e(c) {
            var u = c.stateNode, v = c.memoizedProps, y = x9e(u, v, c);
            if (y) {
                var E = wc;
                if (E !== null) switch (E.tag) {
                    case p: {
                        var L = E.stateNode.containerInfo, Z = (E.mode & Mn) !== $r;
                        k9e(L, u, v, Z);
                        break
                    }
                    case b: {
                        var se = E.type, he = E.memoizedProps, we = E.stateNode, _e = (E.mode & Mn) !== $r;
                        R9e(se, he, we, u, v, _e);
                        break
                    }
                }
            }
            return y
        }

        function o7e(c) {
            var u = c.memoizedState, v = u !== null ? u.dehydrated : null;
            if (!v) throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            E9e(v, c)
        }

        function s7e(c) {
            var u = c.memoizedState, v = u !== null ? u.dehydrated : null;
            if (!v) throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            return T9e(v)
        }

        function one(c) {
            for (var u = c.return; u !== null && u.tag !== b && u.tag !== p && u.tag !== Y;) u = u.return;
            wc = u
        }

        function OR(c) {
            if (c !== wc) return !1;
            if (!Ih) return one(c), Ih = !0, !1;
            if (c.tag !== p && (c.tag !== b || I9e(c.type) && !S$(c.type, c.memoizedProps))) {
                var u = xd;
                if (u) if ($$(c)) sne(c), F$(); else for (; u;) nne(c, u), u = V6(u)
            }
            return one(c), c.tag === Y ? xd = s7e(c) : xd = wc ? V6(c.stateNode) : null, !0
        }

        function c7e() {
            return Ih && xd !== null
        }

        function sne(c) {
            for (var u = xd; u;) rne(c, u), u = V6(u)
        }

        function x_() {
            wc = null, xd = null, Ih = !1, Pb = !1
        }

        function cne() {
            Ug !== null && (tae(Ug), Ug = null)
        }

        function Sc() {
            return Ih
        }

        function j$(c) {
            Ug === null ? Ug = [c] : Ug.push(c)
        }

        var l7e = r.ReactCurrentBatchConfig, u7e = null;

        function f7e() {
            return l7e.transition
        }

        var kh = {
            recordUnsafeLifecycleWarnings: function (c, u) {
            }, flushPendingUnsafeLifecycleWarnings: function () {
            }, recordLegacyContextWarning: function (c, u) {
            }, flushLegacyContextWarning: function () {
            }, discardPendingWarnings: function () {
            }
        };
        {
            var d7e = function (c) {
                for (var u = null, v = c; v !== null;) v.mode & Gi && (u = v), v = v.return;
                return u
            }, Nb = function (c) {
                var u = [];
                return c.forEach(function (v) {
                    u.push(v)
                }), u.sort().join(", ")
            }, G6 = [], K6 = [], Y6 = [], X6 = [], Q6 = [], Z6 = [], Lb = new Set;
            kh.recordUnsafeLifecycleWarnings = function (c, u) {
                Lb.has(c.type) || (typeof u.componentWillMount == "function" && u.componentWillMount.__suppressDeprecationWarning !== !0 && G6.push(c), c.mode & Gi && typeof u.UNSAFE_componentWillMount == "function" && K6.push(c), typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Y6.push(c), c.mode & Gi && typeof u.UNSAFE_componentWillReceiveProps == "function" && X6.push(c), typeof u.componentWillUpdate == "function" && u.componentWillUpdate.__suppressDeprecationWarning !== !0 && Q6.push(c), c.mode & Gi && typeof u.UNSAFE_componentWillUpdate == "function" && Z6.push(c))
            }, kh.flushPendingUnsafeLifecycleWarnings = function () {
                var c = new Set;
                G6.length > 0 && (G6.forEach(function (Le) {
                    c.add(Lr(Le) || "Component"), Lb.add(Le.type)
                }), G6 = []);
                var u = new Set;
                K6.length > 0 && (K6.forEach(function (Le) {
                    u.add(Lr(Le) || "Component"), Lb.add(Le.type)
                }), K6 = []);
                var v = new Set;
                Y6.length > 0 && (Y6.forEach(function (Le) {
                    v.add(Lr(Le) || "Component"), Lb.add(Le.type)
                }), Y6 = []);
                var y = new Set;
                X6.length > 0 && (X6.forEach(function (Le) {
                    y.add(Lr(Le) || "Component"), Lb.add(Le.type)
                }), X6 = []);
                var E = new Set;
                Q6.length > 0 && (Q6.forEach(function (Le) {
                    E.add(Lr(Le) || "Component"), Lb.add(Le.type)
                }), Q6 = []);
                var L = new Set;
                if (Z6.length > 0 && (Z6.forEach(function (Le) {
                    L.add(Lr(Le) || "Component"), Lb.add(Le.type)
                }), Z6 = []), u.size > 0) {
                    var Z = Nb(u);
                    o(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Z)
                }
                if (y.size > 0) {
                    var se = Nb(y);
                    o(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, se)
                }
                if (L.size > 0) {
                    var he = Nb(L);
                    o(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, he)
                }
                if (c.size > 0) {
                    var we = Nb(c);
                    a(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, we)
                }
                if (v.size > 0) {
                    var _e = Nb(v);
                    a(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _e)
                }
                if (E.size > 0) {
                    var Fe = Nb(E);
                    a(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Fe)
                }
            };
            var PR = new Map, lne = new Set;
            kh.recordLegacyContextWarning = function (c, u) {
                var v = d7e(c);
                if (v === null) {
                    o("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                    return
                }
                if (!lne.has(c.type)) {
                    var y = PR.get(v);
                    (c.type.contextTypes != null || c.type.childContextTypes != null || u !== null && typeof u.getChildContext == "function") && (y === void 0 && (y = [], PR.set(v, y)), y.push(c))
                }
            }, kh.flushLegacyContextWarning = function () {
                PR.forEach(function (c, u) {
                    if (c.length !== 0) {
                        var v = c[0], y = new Set;
                        c.forEach(function (L) {
                            y.add(Lr(L) || "Component"), lne.add(L.type)
                        });
                        var E = Nb(y);
                        try {
                            Fn(v), o(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, E)
                        } finally {
                            Ii()
                        }
                    }
                })
            }, kh.discardPendingWarnings = function () {
                G6 = [], K6 = [], Y6 = [], X6 = [], Q6 = [], Z6 = [], PR = new Map
            }
        }
        var z$, V$, H$, W$, q$, une = function (c, u) {
        };
        z$ = !1, V$ = !1, H$ = {}, W$ = {}, q$ = {}, une = function (c, u) {
            if (!(c === null || typeof c != "object") && !(!c._store || c._store.validated || c.key != null)) {
                if (typeof c._store != "object") throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
                c._store.validated = !0;
                var v = Lr(u) || "Component";
                W$[v] || (W$[v] = !0, o('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'))
            }
        };

        function h7e(c) {
            return c.prototype && c.prototype.isReactComponent
        }

        function J6(c, u, v) {
            var y = v.ref;
            if (y !== null && typeof y != "function" && typeof y != "object") {
                if ((c.mode & Gi || fe) && !(v._owner && v._self && v._owner.stateNode !== v._self) && !(v._owner && v._owner.tag !== f) && !(typeof v.type == "function" && !h7e(v.type)) && v._owner) {
                    var E = Lr(c) || "Component";
                    H$[E] || (o('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', E, y), H$[E] = !0)
                }
                if (v._owner) {
                    var L = v._owner, Z;
                    if (L) {
                        var se = L;
                        if (se.tag !== f) throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                        Z = se.stateNode
                    }
                    if (!Z) throw new Error("Missing owner for string ref " + y + ". This error is likely caused by a bug in React. Please file an issue.");
                    var he = Z;
                    Be(y, "ref");
                    var we = "" + y;
                    if (u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === we) return u.ref;
                    var _e = function (Fe) {
                        var Le = he.refs;
                        Fe === null ? delete Le[we] : Le[we] = Fe
                    };
                    return _e._stringRef = we, _e
                } else {
                    if (typeof y != "string") throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                    if (!v._owner) throw new Error("Element ref was specified as a string (" + y + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`)
                }
            }
            return y
        }

        function NR(c, u) {
            var v = Object.prototype.toString.call(u);
            throw new Error("Objects are not valid as a React child (found: " + (v === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : v) + "). If you meant to render a collection of children, use an array instead.")
        }

        function LR(c) {
            {
                var u = Lr(c) || "Component";
                if (q$[u]) return;
                q$[u] = !0, o("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.")
            }
        }

        function fne(c) {
            var u = c._payload, v = c._init;
            return v(u)
        }

        function dne(c) {
            function u(We, ut) {
                if (c) {
                    var qe = We.deletions;
                    qe === null ? (We.deletions = [ut], We.flags |= vh) : qe.push(ut)
                }
            }

            function v(We, ut) {
                if (!c) return null;
                for (var qe = ut; qe !== null;) u(We, qe), qe = qe.sibling;
                return null
            }

            function y(We, ut) {
                for (var qe = new Map, At = ut; At !== null;) At.key !== null ? qe.set(At.key, At) : qe.set(At.index, At), At = At.sibling;
                return qe
            }

            function E(We, ut) {
                var qe = Wb(We, ut);
                return qe.index = 0, qe.sibling = null, qe
            }

            function L(We, ut, qe) {
                if (We.index = qe, !c) return We.flags |= dd, ut;
                var At = We.alternate;
                if (At !== null) {
                    var tr = At.index;
                    return tr < ut ? (We.flags |= pa, ut) : tr
                } else return We.flags |= pa, ut
            }

            function Z(We) {
                return c && We.alternate === null && (We.flags |= pa), We
            }

            function se(We, ut, qe, At) {
                if (ut === null || ut.tag !== S) {
                    var tr = UU(qe, We.mode, At);
                    return tr.return = We, tr
                } else {
                    var Kt = E(ut, qe);
                    return Kt.return = We, Kt
                }
            }

            function he(We, ut, qe, At) {
                var tr = qe.type;
                if (tr === fn) return _e(We, ut, qe.props.children, At, qe.key);
                if (ut !== null && (ut.elementType === tr || gae(ut, qe) || typeof tr == "object" && tr !== null && tr.$$typeof === xt && fne(tr) === ut.type)) {
                    var Kt = E(ut, qe.props);
                    return Kt.ref = J6(We, ut, qe), Kt.return = We, Kt._debugSource = qe._source, Kt._debugOwner = qe._owner, Kt
                }
                var rn = FU(qe, We.mode, At);
                return rn.ref = J6(We, ut, qe), rn.return = We, rn
            }

            function we(We, ut, qe, At) {
                if (ut === null || ut.tag !== g || ut.stateNode.containerInfo !== qe.containerInfo || ut.stateNode.implementation !== qe.implementation) {
                    var tr = jU(qe, We.mode, At);
                    return tr.return = We, tr
                } else {
                    var Kt = E(ut, qe.children || []);
                    return Kt.return = We, Kt
                }
            }

            function _e(We, ut, qe, At, tr) {
                if (ut === null || ut.tag !== T) {
                    var Kt = Qg(qe, We.mode, At, tr);
                    return Kt.return = We, Kt
                } else {
                    var rn = E(ut, qe);
                    return rn.return = We, rn
                }
            }

            function Fe(We, ut, qe) {
                if (typeof ut == "string" && ut !== "" || typeof ut == "number") {
                    var At = UU("" + ut, We.mode, qe);
                    return At.return = We, At
                }
                if (typeof ut == "object" && ut !== null) {
                    switch (ut.$$typeof) {
                        case Nr: {
                            var tr = FU(ut, We.mode, qe);
                            return tr.ref = J6(We, null, ut), tr.return = We, tr
                        }
                        case mr: {
                            var Kt = jU(ut, We.mode, qe);
                            return Kt.return = We, Kt
                        }
                        case xt: {
                            var rn = ut._payload, dn = ut._init;
                            return Fe(We, dn(rn), qe)
                        }
                    }
                    if (wn(ut) || Fi(ut)) {
                        var Yi = Qg(ut, We.mode, qe, null);
                        return Yi.return = We, Yi
                    }
                    NR(We, ut)
                }
                return typeof ut == "function" && LR(We), null
            }

            function Le(We, ut, qe, At) {
                var tr = ut !== null ? ut.key : null;
                if (typeof qe == "string" && qe !== "" || typeof qe == "number") return tr !== null ? null : se(We, ut, "" + qe, At);
                if (typeof qe == "object" && qe !== null) {
                    switch (qe.$$typeof) {
                        case Nr:
                            return qe.key === tr ? he(We, ut, qe, At) : null;
                        case mr:
                            return qe.key === tr ? we(We, ut, qe, At) : null;
                        case xt: {
                            var Kt = qe._payload, rn = qe._init;
                            return Le(We, ut, rn(Kt), At)
                        }
                    }
                    if (wn(qe) || Fi(qe)) return tr !== null ? null : _e(We, ut, qe, At, null);
                    NR(We, qe)
                }
                return typeof qe == "function" && LR(We), null
            }

            function Qe(We, ut, qe, At, tr) {
                if (typeof At == "string" && At !== "" || typeof At == "number") {
                    var Kt = We.get(qe) || null;
                    return se(ut, Kt, "" + At, tr)
                }
                if (typeof At == "object" && At !== null) {
                    switch (At.$$typeof) {
                        case Nr: {
                            var rn = We.get(At.key === null ? qe : At.key) || null;
                            return he(ut, rn, At, tr)
                        }
                        case mr: {
                            var dn = We.get(At.key === null ? qe : At.key) || null;
                            return we(ut, dn, At, tr)
                        }
                        case xt:
                            var Yi = At._payload, wi = At._init;
                            return Qe(We, ut, qe, wi(Yi), tr)
                    }
                    if (wn(At) || Fi(At)) {
                        var Fo = We.get(qe) || null;
                        return _e(ut, Fo, At, tr, null)
                    }
                    NR(ut, At)
                }
                return typeof At == "function" && LR(ut), null
            }

            function nt(We, ut, qe) {
                {
                    if (typeof We != "object" || We === null) return ut;
                    switch (We.$$typeof) {
                        case Nr:
                        case mr:
                            une(We, qe);
                            var At = We.key;
                            if (typeof At != "string") break;
                            if (ut === null) {
                                ut = new Set, ut.add(At);
                                break
                            }
                            if (!ut.has(At)) {
                                ut.add(At);
                                break
                            }
                            o("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", At);
                            break;
                        case xt:
                            var tr = We._payload, Kt = We._init;
                            nt(Kt(tr), ut, qe);
                            break
                    }
                }
                return ut
            }

            function lt(We, ut, qe, At) {
                for (var tr = null, Kt = 0; Kt < qe.length; Kt++) {
                    var rn = qe[Kt];
                    tr = nt(rn, tr, We)
                }
                for (var dn = null, Yi = null, wi = ut, Fo = 0, Si = 0, So = null; wi !== null && Si < qe.length; Si++) {
                    wi.index > Si ? (So = wi, wi = null) : So = wi.sibling;
                    var ll = Le(We, wi, qe[Si], At);
                    if (ll === null) {
                        wi === null && (wi = So);
                        break
                    }
                    c && wi && ll.alternate === null && u(We, wi), Fo = L(ll, Fo, Si), Yi === null ? dn = ll : Yi.sibling = ll, Yi = ll, wi = So
                }
                if (Si === qe.length) {
                    if (v(We, wi), Sc()) {
                        var Ic = Si;
                        Mb(We, Ic)
                    }
                    return dn
                }
                if (wi === null) {
                    for (; Si < qe.length; Si++) {
                        var Tf = Fe(We, qe[Si], At);
                        Tf !== null && (Fo = L(Tf, Fo, Si), Yi === null ? dn = Tf : Yi.sibling = Tf, Yi = Tf)
                    }
                    if (Sc()) {
                        var Kl = Si;
                        Mb(We, Kl)
                    }
                    return dn
                }
                for (var Yl = y(We, wi); Si < qe.length; Si++) {
                    var ul = Qe(Yl, We, Si, qe[Si], At);
                    ul !== null && (c && ul.alternate !== null && Yl.delete(ul.key === null ? Si : ul.key), Fo = L(ul, Fo, Si), Yi === null ? dn = ul : Yi.sibling = ul, Yi = ul)
                }
                if (c && Yl.forEach(function (z_) {
                    return u(We, z_)
                }), Sc()) {
                    var Xm = Si;
                    Mb(We, Xm)
                }
                return dn
            }

            function qt(We, ut, qe, At) {
                var tr = Fi(qe);
                if (typeof tr != "function") throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                {
                    typeof Symbol == "function" && qe[Symbol.toStringTag] === "Generator" && (V$ || o("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), V$ = !0), qe.entries === tr && (z$ || o("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), z$ = !0);
                    var Kt = tr.call(qe);
                    if (Kt) for (var rn = null, dn = Kt.next(); !dn.done; dn = Kt.next()) {
                        var Yi = dn.value;
                        rn = nt(Yi, rn, We)
                    }
                }
                var wi = tr.call(qe);
                if (wi == null) throw new Error("An iterable object provided no iterator.");
                for (var Fo = null, Si = null, So = ut, ll = 0, Ic = 0, Tf = null, Kl = wi.next(); So !== null && !Kl.done; Ic++, Kl = wi.next()) {
                    So.index > Ic ? (Tf = So, So = null) : Tf = So.sibling;
                    var Yl = Le(We, So, Kl.value, At);
                    if (Yl === null) {
                        So === null && (So = Tf);
                        break
                    }
                    c && So && Yl.alternate === null && u(We, So), ll = L(Yl, ll, Ic), Si === null ? Fo = Yl : Si.sibling = Yl, Si = Yl, So = Tf
                }
                if (Kl.done) {
                    if (v(We, So), Sc()) {
                        var ul = Ic;
                        Mb(We, ul)
                    }
                    return Fo
                }
                if (So === null) {
                    for (; !Kl.done; Ic++, Kl = wi.next()) {
                        var Xm = Fe(We, Kl.value, At);
                        Xm !== null && (ll = L(Xm, ll, Ic), Si === null ? Fo = Xm : Si.sibling = Xm, Si = Xm)
                    }
                    if (Sc()) {
                        var z_ = Ic;
                        Mb(We, z_)
                    }
                    return Fo
                }
                for (var D5 = y(We, So); !Kl.done; Ic++, Kl = wi.next()) {
                    var o0 = Qe(D5, We, Ic, Kl.value, At);
                    o0 !== null && (c && o0.alternate !== null && D5.delete(o0.key === null ? Ic : o0.key), ll = L(o0, ll, Ic), Si === null ? Fo = o0 : Si.sibling = o0, Si = o0)
                }
                if (c && D5.forEach(function ($Oe) {
                    return u(We, $Oe)
                }), Sc()) {
                    var BOe = Ic;
                    Mb(We, BOe)
                }
                return Fo
            }

            function jr(We, ut, qe, At) {
                if (ut !== null && ut.tag === S) {
                    v(We, ut.sibling);
                    var tr = E(ut, qe);
                    return tr.return = We, tr
                }
                v(We, ut);
                var Kt = UU(qe, We.mode, At);
                return Kt.return = We, Kt
            }

            function xr(We, ut, qe, At) {
                for (var tr = qe.key, Kt = ut; Kt !== null;) {
                    if (Kt.key === tr) {
                        var rn = qe.type;
                        if (rn === fn) {
                            if (Kt.tag === T) {
                                v(We, Kt.sibling);
                                var dn = E(Kt, qe.props.children);
                                return dn.return = We, dn._debugSource = qe._source, dn._debugOwner = qe._owner, dn
                            }
                        } else if (Kt.elementType === rn || gae(Kt, qe) || typeof rn == "object" && rn !== null && rn.$$typeof === xt && fne(rn) === Kt.type) {
                            v(We, Kt.sibling);
                            var Yi = E(Kt, qe.props);
                            return Yi.ref = J6(We, Kt, qe), Yi.return = We, Yi._debugSource = qe._source, Yi._debugOwner = qe._owner, Yi
                        }
                        v(We, Kt);
                        break
                    } else u(We, Kt);
                    Kt = Kt.sibling
                }
                if (qe.type === fn) {
                    var wi = Qg(qe.props.children, We.mode, At, qe.key);
                    return wi.return = We, wi
                } else {
                    var Fo = FU(qe, We.mode, At);
                    return Fo.ref = J6(We, ut, qe), Fo.return = We, Fo
                }
            }

            function ri(We, ut, qe, At) {
                for (var tr = qe.key, Kt = ut; Kt !== null;) {
                    if (Kt.key === tr) if (Kt.tag === g && Kt.stateNode.containerInfo === qe.containerInfo && Kt.stateNode.implementation === qe.implementation) {
                        v(We, Kt.sibling);
                        var rn = E(Kt, qe.children || []);
                        return rn.return = We, rn
                    } else {
                        v(We, Kt);
                        break
                    } else u(We, Kt);
                    Kt = Kt.sibling
                }
                var dn = jU(qe, We.mode, At);
                return dn.return = We, dn
            }

            function qn(We, ut, qe, At) {
                var tr = typeof qe == "object" && qe !== null && qe.type === fn && qe.key === null;
                if (tr && (qe = qe.props.children), typeof qe == "object" && qe !== null) {
                    switch (qe.$$typeof) {
                        case Nr:
                            return Z(xr(We, ut, qe, At));
                        case mr:
                            return Z(ri(We, ut, qe, At));
                        case xt:
                            var Kt = qe._payload, rn = qe._init;
                            return qn(We, ut, rn(Kt), At)
                    }
                    if (wn(qe)) return lt(We, ut, qe, At);
                    if (Fi(qe)) return qt(We, ut, qe, At);
                    NR(We, qe)
                }
                return typeof qe == "string" && qe !== "" || typeof qe == "number" ? Z(jr(We, ut, "" + qe, At)) : (typeof qe == "function" && LR(We), v(We, ut))
            }

            return qn
        }

        var E_ = dne(!0), hne = dne(!1);

        function p7e(c, u) {
            if (c !== null && u.child !== c.child) throw new Error("Resuming work not yet implemented.");
            if (u.child !== null) {
                var v = u.child, y = Wb(v, v.pendingProps);
                for (u.child = y, y.return = u; v.sibling !== null;) v = v.sibling, y = y.sibling = Wb(v, v.pendingProps), y.return = u;
                y.sibling = null
            }
        }

        function m7e(c, u) {
            for (var v = c.child; v !== null;) tOe(v, u), v = v.sibling
        }

        var G$ = Bg(null), K$;
        K$ = {};
        var BR = null, T_ = null, Y$ = null, $R = !1;

        function FR() {
            BR = null, T_ = null, Y$ = null, $R = !1
        }

        function pne() {
            $R = !0
        }

        function mne() {
            $R = !1
        }

        function vne(c, u, v) {
            sl(G$, u._currentValue, c), u._currentValue = v, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== K$ && o("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = K$
        }

        function X$(c, u) {
            var v = G$.current;
            ol(G$, u), c._currentValue = v
        }

        function Q$(c, u, v) {
            for (var y = c; y !== null;) {
                var E = y.alternate;
                if (Mm(y.childLanes, u) ? E !== null && !Mm(E.childLanes, u) && (E.childLanes = vn(E.childLanes, u)) : (y.childLanes = vn(y.childLanes, u), E !== null && (E.childLanes = vn(E.childLanes, u))), y === v) break;
                y = y.return
            }
            y !== v && o("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.")
        }

        function v7e(c, u, v) {
            g7e(c, u, v)
        }

        function g7e(c, u, v) {
            var y = c.child;
            for (y !== null && (y.return = c); y !== null;) {
                var E = void 0, L = y.dependencies;
                if (L !== null) {
                    E = y.child;
                    for (var Z = L.firstContext; Z !== null;) {
                        if (Z.context === u) {
                            if (y.tag === f) {
                                var se = lb(v), he = Hm(ea, se);
                                he.tag = jR;
                                var we = y.updateQueue;
                                if (we !== null) {
                                    var _e = we.shared, Fe = _e.pending;
                                    Fe === null ? he.next = he : (he.next = Fe.next, Fe.next = he), _e.pending = he
                                }
                            }
                            y.lanes = vn(y.lanes, v);
                            var Le = y.alternate;
                            Le !== null && (Le.lanes = vn(Le.lanes, v)), Q$(y.return, v, c), L.lanes = vn(L.lanes, v);
                            break
                        }
                        Z = Z.next
                    }
                } else if (y.tag === P) E = y.type === c.type ? null : y.child; else if (y.tag === ce) {
                    var Qe = y.return;
                    if (Qe === null) throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                    Qe.lanes = vn(Qe.lanes, v);
                    var nt = Qe.alternate;
                    nt !== null && (nt.lanes = vn(nt.lanes, v)), Q$(Qe, v, c), E = y.sibling
                } else E = y.child;
                if (E !== null) E.return = y; else for (E = y; E !== null;) {
                    if (E === c) {
                        E = null;
                        break
                    }
                    var lt = E.sibling;
                    if (lt !== null) {
                        lt.return = E.return, E = lt;
                        break
                    }
                    E = E.return
                }
                y = E
            }
        }

        function C_(c, u) {
            BR = c, T_ = null, Y$ = null;
            var v = c.dependencies;
            if (v !== null) {
                var y = v.firstContext;
                y !== null && (rl(v.lanes, u) && p5(), v.firstContext = null)
            }
        }

        function es(c) {
            $R && o("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            var u = c._currentValue;
            if (Y$ !== c) {
                var v = {context: c, memoizedValue: u, next: null};
                if (T_ === null) {
                    if (BR === null) throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                    T_ = v, BR.dependencies = {lanes: mt, firstContext: v}
                } else T_ = T_.next = v
            }
            return u
        }

        var Bb = null;

        function Z$(c) {
            Bb === null ? Bb = [c] : Bb.push(c)
        }

        function y7e() {
            if (Bb !== null) {
                for (var c = 0; c < Bb.length; c++) {
                    var u = Bb[c], v = u.interleaved;
                    if (v !== null) {
                        u.interleaved = null;
                        var y = v.next, E = u.pending;
                        if (E !== null) {
                            var L = E.next;
                            E.next = y, v.next = L
                        }
                        u.pending = v
                    }
                }
                Bb = null
            }
        }

        function gne(c, u, v, y) {
            var E = u.interleaved;
            return E === null ? (v.next = v, Z$(u)) : (v.next = E.next, E.next = v), u.interleaved = v, UR(c, y)
        }

        function b7e(c, u, v, y) {
            var E = u.interleaved;
            E === null ? (v.next = v, Z$(u)) : (v.next = E.next, E.next = v), u.interleaved = v
        }

        function w7e(c, u, v, y) {
            var E = u.interleaved;
            return E === null ? (v.next = v, Z$(u)) : (v.next = E.next, E.next = v), u.interleaved = v, UR(c, y)
        }

        function Lu(c, u) {
            return UR(c, u)
        }

        var S7e = UR;

        function UR(c, u) {
            c.lanes = vn(c.lanes, u);
            var v = c.alternate;
            v !== null && (v.lanes = vn(v.lanes, u)), v === null && (c.flags & (pa | mc)) !== Ar && hae(c);
            for (var y = c, E = c.return; E !== null;) E.childLanes = vn(E.childLanes, u), v = E.alternate, v !== null ? v.childLanes = vn(v.childLanes, u) : (E.flags & (pa | mc)) !== Ar && hae(c), y = E, E = E.return;
            if (y.tag === p) {
                var L = y.stateNode;
                return L
            } else return null
        }

        var yne = 0, bne = 1, jR = 2, J$ = 3, zR = !1, eF, VR;
        eF = !1, VR = null;

        function tF(c) {
            var u = {
                baseState: c.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {pending: null, interleaved: null, lanes: mt},
                effects: null
            };
            c.updateQueue = u
        }

        function wne(c, u) {
            var v = u.updateQueue, y = c.updateQueue;
            if (v === y) {
                var E = {
                    baseState: y.baseState,
                    firstBaseUpdate: y.firstBaseUpdate,
                    lastBaseUpdate: y.lastBaseUpdate,
                    shared: y.shared,
                    effects: y.effects
                };
                u.updateQueue = E
            }
        }

        function Hm(c, u) {
            var v = {eventTime: c, lane: u, tag: yne, payload: null, callback: null, next: null};
            return v
        }

        function jg(c, u, v) {
            var y = c.updateQueue;
            if (y === null) return null;
            var E = y.shared;
            if (VR === E && !eF && (o("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), eF = !0), yMe()) {
                var L = E.pending;
                return L === null ? u.next = u : (u.next = L.next, L.next = u), E.pending = u, S7e(c, v)
            } else return w7e(c, E, u, v)
        }

        function HR(c, u, v) {
            var y = u.updateQueue;
            if (y !== null) {
                var E = y.shared;
                if (d6(v)) {
                    var L = E.lanes;
                    L = p6(L, c.pendingLanes);
                    var Z = vn(L, v);
                    E.lanes = Z, Z2(c, Z)
                }
            }
        }

        function rF(c, u) {
            var v = c.updateQueue, y = c.alternate;
            if (y !== null) {
                var E = y.updateQueue;
                if (v === E) {
                    var L = null, Z = null, se = v.firstBaseUpdate;
                    if (se !== null) {
                        var he = se;
                        do {
                            var we = {
                                eventTime: he.eventTime,
                                lane: he.lane,
                                tag: he.tag,
                                payload: he.payload,
                                callback: he.callback,
                                next: null
                            };
                            Z === null ? L = Z = we : (Z.next = we, Z = we), he = he.next
                        } while (he !== null);
                        Z === null ? L = Z = u : (Z.next = u, Z = u)
                    } else L = Z = u;
                    v = {
                        baseState: E.baseState,
                        firstBaseUpdate: L,
                        lastBaseUpdate: Z,
                        shared: E.shared,
                        effects: E.effects
                    }, c.updateQueue = v;
                    return
                }
            }
            var _e = v.lastBaseUpdate;
            _e === null ? v.firstBaseUpdate = u : _e.next = u, v.lastBaseUpdate = u
        }

        function _7e(c, u, v, y, E, L) {
            switch (v.tag) {
                case bne: {
                    var Z = v.payload;
                    if (typeof Z == "function") {
                        pne();
                        var se = Z.call(L, y, E);
                        {
                            if (c.mode & Gi) {
                                La(!0);
                                try {
                                    Z.call(L, y, E)
                                } finally {
                                    La(!1)
                                }
                            }
                            mne()
                        }
                        return se
                    }
                    return Z
                }
                case J$:
                    c.flags = c.flags & ~Xo | Mr;
                case yne: {
                    var he = v.payload, we;
                    if (typeof he == "function") {
                        pne(), we = he.call(L, y, E);
                        {
                            if (c.mode & Gi) {
                                La(!0);
                                try {
                                    he.call(L, y, E)
                                } finally {
                                    La(!1)
                                }
                            }
                            mne()
                        }
                    } else we = he;
                    return we == null ? y : Pt({}, y, we)
                }
                case jR:
                    return zR = !0, y
            }
            return y
        }

        function WR(c, u, v, y) {
            var E = c.updateQueue;
            zR = !1, VR = E.shared;
            var L = E.firstBaseUpdate, Z = E.lastBaseUpdate, se = E.shared.pending;
            if (se !== null) {
                E.shared.pending = null;
                var he = se, we = he.next;
                he.next = null, Z === null ? L = we : Z.next = we, Z = he;
                var _e = c.alternate;
                if (_e !== null) {
                    var Fe = _e.updateQueue, Le = Fe.lastBaseUpdate;
                    Le !== Z && (Le === null ? Fe.firstBaseUpdate = we : Le.next = we, Fe.lastBaseUpdate = he)
                }
            }
            if (L !== null) {
                var Qe = E.baseState, nt = mt, lt = null, qt = null, jr = null, xr = L;
                do {
                    var ri = xr.lane, qn = xr.eventTime;
                    if (Mm(y, ri)) {
                        if (jr !== null) {
                            var ut = {
                                eventTime: qn,
                                lane: pi,
                                tag: xr.tag,
                                payload: xr.payload,
                                callback: xr.callback,
                                next: null
                            };
                            jr = jr.next = ut
                        }
                        Qe = _7e(c, E, xr, Qe, u, v);
                        var qe = xr.callback;
                        if (qe !== null && xr.lane !== pi) {
                            c.flags |= fd;
                            var At = E.effects;
                            At === null ? E.effects = [xr] : At.push(xr)
                        }
                    } else {
                        var We = {
                            eventTime: qn,
                            lane: ri,
                            tag: xr.tag,
                            payload: xr.payload,
                            callback: xr.callback,
                            next: null
                        };
                        jr === null ? (qt = jr = We, lt = Qe) : jr = jr.next = We, nt = vn(nt, ri)
                    }
                    if (xr = xr.next, xr === null) {
                        if (se = E.shared.pending, se === null) break;
                        var tr = se, Kt = tr.next;
                        tr.next = null, xr = Kt, E.lastBaseUpdate = tr, E.shared.pending = null
                    }
                } while (!0);
                jr === null && (lt = Qe), E.baseState = lt, E.firstBaseUpdate = qt, E.lastBaseUpdate = jr;
                var rn = E.shared.interleaved;
                if (rn !== null) {
                    var dn = rn;
                    do nt = vn(nt, dn.lane), dn = dn.next; while (dn !== rn)
                } else L === null && (E.shared.lanes = mt);
                C5(nt), c.lanes = nt, c.memoizedState = Qe
            }
            VR = null
        }

        function x7e(c, u) {
            if (typeof c != "function") throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + c));
            c.call(u)
        }

        function Sne() {
            zR = !1
        }

        function qR() {
            return zR
        }

        function _ne(c, u, v) {
            var y = u.effects;
            if (u.effects = null, y !== null) for (var E = 0; E < y.length; E++) {
                var L = y[E], Z = L.callback;
                Z !== null && (L.callback = null, x7e(Z, v))
            }
        }

        var e5 = {}, zg = Bg(e5), t5 = Bg(e5), GR = Bg(e5);

        function KR(c) {
            if (c === e5) throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            return c
        }

        function xne() {
            var c = KR(GR.current);
            return c
        }

        function nF(c, u) {
            sl(GR, u, c), sl(t5, c, c), sl(zg, e5, c);
            var v = URe(u);
            ol(zg, c), sl(zg, v, c)
        }

        function A_(c) {
            ol(zg, c), ol(t5, c), ol(GR, c)
        }

        function iF() {
            var c = KR(zg.current);
            return c
        }

        function Ene(c) {
            KR(GR.current);
            var u = KR(zg.current), v = jRe(u, c.type);
            u !== v && (sl(t5, c, c), sl(zg, v, c))
        }

        function aF(c) {
            t5.current === c && (ol(zg, c), ol(t5, c))
        }

        var E7e = 0, Tne = 1, Cne = 1, r5 = 2, Rh = Bg(E7e);

        function oF(c, u) {
            return (c & u) !== 0
        }

        function I_(c) {
            return c & Tne
        }

        function sF(c, u) {
            return c & Tne | u
        }

        function T7e(c, u) {
            return c | u
        }

        function Vg(c, u) {
            sl(Rh, u, c)
        }

        function k_(c) {
            ol(Rh, c)
        }

        function C7e(c, u) {
            var v = c.memoizedState;
            return v !== null ? v.dehydrated !== null : !0
        }

        function YR(c) {
            for (var u = c; u !== null;) {
                if (u.tag === Y) {
                    var v = u.memoizedState;
                    if (v !== null) {
                        var y = v.dehydrated;
                        if (y === null || Vre(y) || T$(y)) return u
                    }
                } else if (u.tag === re && u.memoizedProps.revealOrder !== void 0) {
                    var E = (u.flags & Mr) !== Ar;
                    if (E) return u
                } else if (u.child !== null) {
                    u.child.return = u, u = u.child;
                    continue
                }
                if (u === c) return null;
                for (; u.sibling === null;) {
                    if (u.return === null || u.return === c) return null;
                    u = u.return
                }
                u.sibling.return = u.return, u = u.sibling
            }
            return null
        }

        var Bu = 0, ys = 1, Jp = 2, bs = 4, _c = 8, cF = [];

        function lF() {
            for (var c = 0; c < cF.length; c++) {
                var u = cF[c];
                u._workInProgressVersionPrimary = null
            }
            cF.length = 0
        }

        function A7e(c, u) {
            var v = u._getVersion, y = v(u._source);
            c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [u, y] : c.mutableSourceEagerHydrationData.push(u, y)
        }

        var Jt = r.ReactCurrentDispatcher, n5 = r.ReactCurrentBatchConfig, uF, R_;
        uF = new Set;
        var $b = mt, Ki = null, ws = null, Ss = null, XR = !1, i5 = !1, a5 = 0, I7e = 0, k7e = 25, dt = null, Ed = null,
            Hg = -1, fF = !1;

        function Di() {
            {
                var c = dt;
                Ed === null ? Ed = [c] : Ed.push(c)
            }
        }

        function $t() {
            {
                var c = dt;
                Ed !== null && (Hg++, Ed[Hg] !== c && R7e(c))
            }
        }

        function D_(c) {
            c != null && !wn(c) && o("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", dt, typeof c)
        }

        function R7e(c) {
            {
                var u = Lr(Ki);
                if (!uF.has(u) && (uF.add(u), Ed !== null)) {
                    for (var v = "", y = 30, E = 0; E <= Hg; E++) {
                        for (var L = Ed[E], Z = E === Hg ? c : L, se = E + 1 + ". " + L; se.length < y;) se += " ";
                        se += Z + `
`, v += se
                    }
                    o(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, u, v)
                }
            }
        }

        function cl() {
            throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`)
        }

        function dF(c, u) {
            if (fF) return !1;
            if (u === null) return o("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", dt), !1;
            c.length !== u.length && o(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, dt, "[" + u.join(", ") + "]", "[" + c.join(", ") + "]");
            for (var v = 0; v < u.length && v < c.length; v++) if (!St(c[v], u[v])) return !1;
            return !0
        }

        function M_(c, u, v, y, E, L) {
            $b = L, Ki = u, Ed = c !== null ? c._debugHookTypes : null, Hg = -1, fF = c !== null && c.type !== u.type, u.memoizedState = null, u.updateQueue = null, u.lanes = mt, c !== null && c.memoizedState !== null ? Jt.current = Kne : Ed !== null ? Jt.current = Gne : Jt.current = qne;
            var Z = v(y, E);
            if (i5) {
                var se = 0;
                do {
                    if (i5 = !1, a5 = 0, se >= k7e) throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                    se += 1, fF = !1, ws = null, Ss = null, u.updateQueue = null, Hg = -1, Jt.current = Yne, Z = v(y, E)
                } while (i5)
            }
            Jt.current = l9, u._debugHookTypes = Ed;
            var he = ws !== null && ws.next !== null;
            if ($b = mt, Ki = null, ws = null, Ss = null, dt = null, Ed = null, Hg = -1, c !== null && (c.flags & mo) !== (u.flags & mo) && (c.mode & Mn) !== $r && o("Internal React error: Expected static flag was missing. Please notify the React team."), XR = !1, he) throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            return Z
        }

        function O_() {
            var c = a5 !== 0;
            return a5 = 0, c
        }

        function Ane(c, u, v) {
            u.updateQueue = c.updateQueue, (u.mode & yi) !== $r ? u.flags &= ~(yf | yh | wa | Dn) : u.flags &= ~(wa | Dn), c.lanes = ub(c.lanes, v)
        }

        function Ine() {
            if (Jt.current = l9, XR) {
                for (var c = Ki.memoizedState; c !== null;) {
                    var u = c.queue;
                    u !== null && (u.pending = null), c = c.next
                }
                XR = !1
            }
            $b = mt, Ki = null, ws = null, Ss = null, Ed = null, Hg = -1, dt = null, jne = !1, i5 = !1, a5 = 0
        }

        function e0() {
            var c = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
            return Ss === null ? Ki.memoizedState = Ss = c : Ss = Ss.next = c, Ss
        }

        function Td() {
            var c;
            if (ws === null) {
                var u = Ki.alternate;
                u !== null ? c = u.memoizedState : c = null
            } else c = ws.next;
            var v;
            if (Ss === null ? v = Ki.memoizedState : v = Ss.next, v !== null) Ss = v, v = Ss.next, ws = c; else {
                if (c === null) throw new Error("Rendered more hooks than during the previous render.");
                ws = c;
                var y = {
                    memoizedState: ws.memoizedState,
                    baseState: ws.baseState,
                    baseQueue: ws.baseQueue,
                    queue: ws.queue,
                    next: null
                };
                Ss === null ? Ki.memoizedState = Ss = y : Ss = Ss.next = y
            }
            return Ss
        }

        function kne() {
            return {lastEffect: null, stores: null}
        }

        function hF(c, u) {
            return typeof u == "function" ? u(c) : u
        }

        function pF(c, u, v) {
            var y = e0(), E;
            v !== void 0 ? E = v(u) : E = u, y.memoizedState = y.baseState = E;
            var L = {
                pending: null,
                interleaved: null,
                lanes: mt,
                dispatch: null,
                lastRenderedReducer: c,
                lastRenderedState: E
            };
            y.queue = L;
            var Z = L.dispatch = P7e.bind(null, Ki, L);
            return [y.memoizedState, Z]
        }

        function mF(c, u, v) {
            var y = Td(), E = y.queue;
            if (E === null) throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            E.lastRenderedReducer = c;
            var L = ws, Z = L.baseQueue, se = E.pending;
            if (se !== null) {
                if (Z !== null) {
                    var he = Z.next, we = se.next;
                    Z.next = we, se.next = he
                }
                L.baseQueue !== Z && o("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), L.baseQueue = Z = se, E.pending = null
            }
            if (Z !== null) {
                var _e = Z.next, Fe = L.baseState, Le = null, Qe = null, nt = null, lt = _e;
                do {
                    var qt = lt.lane;
                    if (Mm($b, qt)) {
                        if (nt !== null) {
                            var xr = {
                                lane: pi,
                                action: lt.action,
                                hasEagerState: lt.hasEagerState,
                                eagerState: lt.eagerState,
                                next: null
                            };
                            nt = nt.next = xr
                        }
                        if (lt.hasEagerState) Fe = lt.eagerState; else {
                            var ri = lt.action;
                            Fe = c(Fe, ri)
                        }
                    } else {
                        var jr = {
                            lane: qt,
                            action: lt.action,
                            hasEagerState: lt.hasEagerState,
                            eagerState: lt.eagerState,
                            next: null
                        };
                        nt === null ? (Qe = nt = jr, Le = Fe) : nt = nt.next = jr, Ki.lanes = vn(Ki.lanes, qt), C5(qt)
                    }
                    lt = lt.next
                } while (lt !== null && lt !== _e);
                nt === null ? Le = Fe : nt.next = Qe, St(Fe, y.memoizedState) || p5(), y.memoizedState = Fe, y.baseState = Le, y.baseQueue = nt, E.lastRenderedState = Fe
            }
            var qn = E.interleaved;
            if (qn !== null) {
                var We = qn;
                do {
                    var ut = We.lane;
                    Ki.lanes = vn(Ki.lanes, ut), C5(ut), We = We.next
                } while (We !== qn)
            } else Z === null && (E.lanes = mt);
            var qe = E.dispatch;
            return [y.memoizedState, qe]
        }

        function vF(c, u, v) {
            var y = Td(), E = y.queue;
            if (E === null) throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            E.lastRenderedReducer = c;
            var L = E.dispatch, Z = E.pending, se = y.memoizedState;
            if (Z !== null) {
                E.pending = null;
                var he = Z.next, we = he;
                do {
                    var _e = we.action;
                    se = c(se, _e), we = we.next
                } while (we !== he);
                St(se, y.memoizedState) || p5(), y.memoizedState = se, y.baseQueue === null && (y.baseState = se), E.lastRenderedState = se
            }
            return [se, L]
        }

        function UZt(c, u, v) {
        }

        function jZt(c, u, v) {
        }

        function gF(c, u, v) {
            var y = Ki, E = e0(), L, Z = Sc();
            if (Z) {
                if (v === void 0) throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
                L = v(), R_ || L !== v() && (o("The result of getServerSnapshot should be cached to avoid an infinite loop"), R_ = !0)
            } else {
                if (L = u(), !R_) {
                    var se = u();
                    St(L, se) || (o("The result of getSnapshot should be cached to avoid an infinite loop"), R_ = !0)
                }
                var he = I9();
                if (he === null) throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
                X2(he, $b) || Rne(y, u, L)
            }
            E.memoizedState = L;
            var we = {value: L, getSnapshot: u};
            return E.queue = we, t9(Mne.bind(null, y, we, c), [c]), y.flags |= wa, o5(ys | _c, Dne.bind(null, y, we, L, u), void 0, null), L
        }

        function QR(c, u, v) {
            var y = Ki, E = Td(), L = u();
            if (!R_) {
                var Z = u();
                St(L, Z) || (o("The result of getSnapshot should be cached to avoid an infinite loop"), R_ = !0)
            }
            var se = E.memoizedState, he = !St(se, L);
            he && (E.memoizedState = L, p5());
            var we = E.queue;
            if (c5(Mne.bind(null, y, we, c), [c]), we.getSnapshot !== u || he || Ss !== null && Ss.memoizedState.tag & ys) {
                y.flags |= wa, o5(ys | _c, Dne.bind(null, y, we, L, u), void 0, null);
                var _e = I9();
                if (_e === null) throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
                X2(_e, $b) || Rne(y, u, L)
            }
            return L
        }

        function Rne(c, u, v) {
            c.flags |= ps;
            var y = {getSnapshot: u, value: v}, E = Ki.updateQueue;
            if (E === null) E = kne(), Ki.updateQueue = E, E.stores = [y]; else {
                var L = E.stores;
                L === null ? E.stores = [y] : L.push(y)
            }
        }

        function Dne(c, u, v, y) {
            u.value = v, u.getSnapshot = y, One(u) && Pne(c)
        }

        function Mne(c, u, v) {
            var y = function () {
                One(u) && Pne(c)
            };
            return v(y)
        }

        function One(c) {
            var u = c.getSnapshot, v = c.value;
            try {
                var y = u();
                return !St(v, y)
            } catch {
                return !0
            }
        }

        function Pne(c) {
            var u = Lu(c, Xr);
            u !== null && Ts(u, c, Xr, ea)
        }

        function ZR(c) {
            var u = e0();
            typeof c == "function" && (c = c()), u.memoizedState = u.baseState = c;
            var v = {
                pending: null,
                interleaved: null,
                lanes: mt,
                dispatch: null,
                lastRenderedReducer: hF,
                lastRenderedState: c
            };
            u.queue = v;
            var y = v.dispatch = N7e.bind(null, Ki, v);
            return [u.memoizedState, y]
        }

        function yF(c) {
            return mF(hF)
        }

        function bF(c) {
            return vF(hF)
        }

        function o5(c, u, v, y) {
            var E = {tag: c, create: u, destroy: v, deps: y, next: null}, L = Ki.updateQueue;
            if (L === null) L = kne(), Ki.updateQueue = L, L.lastEffect = E.next = E; else {
                var Z = L.lastEffect;
                if (Z === null) L.lastEffect = E.next = E; else {
                    var se = Z.next;
                    Z.next = E, E.next = se, L.lastEffect = E
                }
            }
            return E
        }

        function wF(c) {
            var u = e0();
            {
                var v = {current: c};
                return u.memoizedState = v, v
            }
        }

        function JR(c) {
            var u = Td();
            return u.memoizedState
        }

        function s5(c, u, v, y) {
            var E = e0(), L = y === void 0 ? null : y;
            Ki.flags |= c, E.memoizedState = o5(ys | u, v, void 0, L)
        }

        function e9(c, u, v, y) {
            var E = Td(), L = y === void 0 ? null : y, Z = void 0;
            if (ws !== null) {
                var se = ws.memoizedState;
                if (Z = se.destroy, L !== null) {
                    var he = se.deps;
                    if (dF(L, he)) {
                        E.memoizedState = o5(u, v, Z, L);
                        return
                    }
                }
            }
            Ki.flags |= c, E.memoizedState = o5(ys | u, v, Z, L)
        }

        function t9(c, u) {
            return (Ki.mode & yi) !== $r ? s5(yf | wa | x2, _c, c, u) : s5(wa | x2, _c, c, u)
        }

        function c5(c, u) {
            return e9(wa, _c, c, u)
        }

        function SF(c, u) {
            return s5(Dn, Jp, c, u)
        }

        function r9(c, u) {
            return e9(Dn, Jp, c, u)
        }

        function _F(c, u) {
            var v = Dn;
            return v |= gh, (Ki.mode & yi) !== $r && (v |= yh), s5(v, bs, c, u)
        }

        function n9(c, u) {
            return e9(Dn, bs, c, u)
        }

        function Nne(c, u) {
            if (typeof u == "function") {
                var v = u, y = c();
                return v(y), function () {
                    v(null)
                }
            } else if (u != null) {
                var E = u;
                E.hasOwnProperty("current") || o("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(E).join(", ") + "}");
                var L = c();
                return E.current = L, function () {
                    E.current = null
                }
            }
        }

        function xF(c, u, v) {
            typeof u != "function" && o("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", u !== null ? typeof u : "null");
            var y = v != null ? v.concat([c]) : null, E = Dn;
            return E |= gh, (Ki.mode & yi) !== $r && (E |= yh), s5(E, bs, Nne.bind(null, u, c), y)
        }

        function i9(c, u, v) {
            typeof u != "function" && o("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", u !== null ? typeof u : "null");
            var y = v != null ? v.concat([c]) : null;
            return e9(Dn, bs, Nne.bind(null, u, c), y)
        }

        function D7e(c, u) {
        }

        var a9 = D7e;

        function EF(c, u) {
            var v = e0(), y = u === void 0 ? null : u;
            return v.memoizedState = [c, y], c
        }

        function o9(c, u) {
            var v = Td(), y = u === void 0 ? null : u, E = v.memoizedState;
            if (E !== null && y !== null) {
                var L = E[1];
                if (dF(y, L)) return E[0]
            }
            return v.memoizedState = [c, y], c
        }

        function TF(c, u) {
            var v = e0(), y = u === void 0 ? null : u, E = c();
            return v.memoizedState = [E, y], E
        }

        function s9(c, u) {
            var v = Td(), y = u === void 0 ? null : u, E = v.memoizedState;
            if (E !== null && y !== null) {
                var L = E[1];
                if (dF(y, L)) return E[0]
            }
            var Z = c();
            return v.memoizedState = [Z, y], Z
        }

        function CF(c) {
            var u = e0();
            return u.memoizedState = c, c
        }

        function Lne(c) {
            var u = Td(), v = ws, y = v.memoizedState;
            return $ne(u, y, c)
        }

        function Bne(c) {
            var u = Td();
            if (ws === null) return u.memoizedState = c, c;
            var v = ws.memoizedState;
            return $ne(u, v, c)
        }

        function $ne(c, u, v) {
            var y = !u6($b);
            if (y) {
                if (!St(v, u)) {
                    var E = h6();
                    Ki.lanes = vn(Ki.lanes, E), C5(E), c.baseState = !0
                }
                return u
            } else return c.baseState && (c.baseState = !1, p5()), c.memoizedState = v, v
        }

        function M7e(c, u, v) {
            var y = Ou();
            yo($k(y, vd)), c(!0);
            var E = n5.transition;
            n5.transition = {};
            var L = n5.transition;
            n5.transition._updatedFibers = new Set;
            try {
                c(!1), u()
            } finally {
                if (yo(y), n5.transition = E, E === null && L._updatedFibers) {
                    var Z = L._updatedFibers.size;
                    Z > 10 && a("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), L._updatedFibers.clear()
                }
            }
        }

        function AF() {
            var c = ZR(!1), u = c[0], v = c[1], y = M7e.bind(null, v), E = e0();
            return E.memoizedState = y, [u, y]
        }

        function Fne() {
            var c = yF(), u = c[0], v = Td(), y = v.memoizedState;
            return [u, y]
        }

        function Une() {
            var c = bF(), u = c[0], v = Td(), y = v.memoizedState;
            return [u, y]
        }

        var jne = !1;

        function O7e() {
            return jne
        }

        function IF() {
            var c = e0(), u = I9(), v = u.identifierPrefix, y;
            if (Sc()) {
                var E = X9e();
                y = ":" + v + "R" + E;
                var L = a5++;
                L > 0 && (y += "H" + L.toString(32)), y += ":"
            } else {
                var Z = I7e++;
                y = ":" + v + "r" + Z.toString(32) + ":"
            }
            return c.memoizedState = y, y
        }

        function c9() {
            var c = Td(), u = c.memoizedState;
            return u
        }

        function P7e(c, u, v) {
            typeof arguments[3] == "function" && o("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            var y = Yg(c), E = {lane: y, action: v, hasEagerState: !1, eagerState: null, next: null};
            if (zne(c)) Vne(u, E); else {
                var L = gne(c, u, E, y);
                if (L !== null) {
                    var Z = Gl();
                    Ts(L, c, y, Z), Hne(L, u, y)
                }
            }
            Wne(c, y)
        }

        function N7e(c, u, v) {
            typeof arguments[3] == "function" && o("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            var y = Yg(c), E = {lane: y, action: v, hasEagerState: !1, eagerState: null, next: null};
            if (zne(c)) Vne(u, E); else {
                var L = c.alternate;
                if (c.lanes === mt && (L === null || L.lanes === mt)) {
                    var Z = u.lastRenderedReducer;
                    if (Z !== null) {
                        var se;
                        se = Jt.current, Jt.current = Dh;
                        try {
                            var he = u.lastRenderedState, we = Z(he, v);
                            if (E.hasEagerState = !0, E.eagerState = we, St(we, he)) {
                                b7e(c, u, E);
                                return
                            }
                        } catch {
                        } finally {
                            Jt.current = se
                        }
                    }
                }
                var _e = gne(c, u, E, y);
                if (_e !== null) {
                    var Fe = Gl();
                    Ts(_e, c, y, Fe), Hne(_e, u, y)
                }
            }
            Wne(c, y)
        }

        function zne(c) {
            var u = c.alternate;
            return c === Ki || u !== null && u === Ki
        }

        function Vne(c, u) {
            i5 = XR = !0;
            var v = c.pending;
            v === null ? u.next = u : (u.next = v.next, v.next = u), c.pending = u
        }

        function Hne(c, u, v) {
            if (d6(v)) {
                var y = u.lanes;
                y = p6(y, c.pendingLanes);
                var E = vn(y, v);
                u.lanes = E, Z2(c, E)
            }
        }

        function Wne(c, u, v) {
            eb(c, u)
        }

        var l9 = {
            readContext: es,
            useCallback: cl,
            useContext: cl,
            useEffect: cl,
            useImperativeHandle: cl,
            useInsertionEffect: cl,
            useLayoutEffect: cl,
            useMemo: cl,
            useReducer: cl,
            useRef: cl,
            useState: cl,
            useDebugValue: cl,
            useDeferredValue: cl,
            useTransition: cl,
            useMutableSource: cl,
            useSyncExternalStore: cl,
            useId: cl,
            unstable_isNewReconciler: j
        }, qne = null, Gne = null, Kne = null, Yne = null, t0 = null, Dh = null, u9 = null;
        {
            var kF = function () {
                o("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")
            }, cn = function () {
                o("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks")
            };
            qne = {
                readContext: function (c) {
                    return es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", Di(), D_(u), EF(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", Di(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", Di(), D_(u), t9(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", Di(), D_(v), xF(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", Di(), D_(u), SF(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", Di(), D_(u), _F(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", Di(), D_(u);
                    var v = Jt.current;
                    Jt.current = t0;
                    try {
                        return TF(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", Di();
                    var y = Jt.current;
                    Jt.current = t0;
                    try {
                        return pF(c, u, v)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", Di(), wF(c)
                }, useState: function (c) {
                    dt = "useState", Di();
                    var u = Jt.current;
                    Jt.current = t0;
                    try {
                        return ZR(c)
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", Di(), void 0
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", Di(), CF(c)
                }, useTransition: function () {
                    return dt = "useTransition", Di(), AF()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", Di(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", Di(), gF(c, u, v)
                }, useId: function () {
                    return dt = "useId", Di(), IF()
                }, unstable_isNewReconciler: j
            }, Gne = {
                readContext: function (c) {
                    return es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", $t(), EF(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", $t(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", $t(), t9(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", $t(), xF(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", $t(), SF(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", $t(), _F(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", $t();
                    var v = Jt.current;
                    Jt.current = t0;
                    try {
                        return TF(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", $t();
                    var y = Jt.current;
                    Jt.current = t0;
                    try {
                        return pF(c, u, v)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", $t(), wF(c)
                }, useState: function (c) {
                    dt = "useState", $t();
                    var u = Jt.current;
                    Jt.current = t0;
                    try {
                        return ZR(c)
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", $t(), void 0
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", $t(), CF(c)
                }, useTransition: function () {
                    return dt = "useTransition", $t(), AF()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", $t(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", $t(), gF(c, u, v)
                }, useId: function () {
                    return dt = "useId", $t(), IF()
                }, unstable_isNewReconciler: j
            }, Kne = {
                readContext: function (c) {
                    return es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", $t(), o9(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", $t(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", $t(), c5(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", $t(), i9(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", $t(), r9(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", $t(), n9(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", $t();
                    var v = Jt.current;
                    Jt.current = Dh;
                    try {
                        return s9(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", $t();
                    var y = Jt.current;
                    Jt.current = Dh;
                    try {
                        return mF(c)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", $t(), JR()
                }, useState: function (c) {
                    dt = "useState", $t();
                    var u = Jt.current;
                    Jt.current = Dh;
                    try {
                        return yF()
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", $t(), a9()
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", $t(), Lne(c)
                }, useTransition: function () {
                    return dt = "useTransition", $t(), Fne()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", $t(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", $t(), QR(c, u)
                }, useId: function () {
                    return dt = "useId", $t(), c9()
                }, unstable_isNewReconciler: j
            }, Yne = {
                readContext: function (c) {
                    return es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", $t(), o9(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", $t(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", $t(), c5(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", $t(), i9(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", $t(), r9(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", $t(), n9(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", $t();
                    var v = Jt.current;
                    Jt.current = u9;
                    try {
                        return s9(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", $t();
                    var y = Jt.current;
                    Jt.current = u9;
                    try {
                        return vF(c)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", $t(), JR()
                }, useState: function (c) {
                    dt = "useState", $t();
                    var u = Jt.current;
                    Jt.current = u9;
                    try {
                        return bF()
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", $t(), a9()
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", $t(), Bne(c)
                }, useTransition: function () {
                    return dt = "useTransition", $t(), Une()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", $t(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", $t(), QR(c, u)
                }, useId: function () {
                    return dt = "useId", $t(), c9()
                }, unstable_isNewReconciler: j
            }, t0 = {
                readContext: function (c) {
                    return kF(), es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", cn(), Di(), EF(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", cn(), Di(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", cn(), Di(), t9(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", cn(), Di(), xF(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", cn(), Di(), SF(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", cn(), Di(), _F(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", cn(), Di();
                    var v = Jt.current;
                    Jt.current = t0;
                    try {
                        return TF(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", cn(), Di();
                    var y = Jt.current;
                    Jt.current = t0;
                    try {
                        return pF(c, u, v)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", cn(), Di(), wF(c)
                }, useState: function (c) {
                    dt = "useState", cn(), Di();
                    var u = Jt.current;
                    Jt.current = t0;
                    try {
                        return ZR(c)
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", cn(), Di(), void 0
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", cn(), Di(), CF(c)
                }, useTransition: function () {
                    return dt = "useTransition", cn(), Di(), AF()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", cn(), Di(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", cn(), Di(), gF(c, u, v)
                }, useId: function () {
                    return dt = "useId", cn(), Di(), IF()
                }, unstable_isNewReconciler: j
            }, Dh = {
                readContext: function (c) {
                    return kF(), es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", cn(), $t(), o9(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", cn(), $t(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", cn(), $t(), c5(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", cn(), $t(), i9(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", cn(), $t(), r9(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", cn(), $t(), n9(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", cn(), $t();
                    var v = Jt.current;
                    Jt.current = Dh;
                    try {
                        return s9(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", cn(), $t();
                    var y = Jt.current;
                    Jt.current = Dh;
                    try {
                        return mF(c)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", cn(), $t(), JR()
                }, useState: function (c) {
                    dt = "useState", cn(), $t();
                    var u = Jt.current;
                    Jt.current = Dh;
                    try {
                        return yF()
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", cn(), $t(), a9()
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", cn(), $t(), Lne(c)
                }, useTransition: function () {
                    return dt = "useTransition", cn(), $t(), Fne()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", cn(), $t(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", cn(), $t(), QR(c, u)
                }, useId: function () {
                    return dt = "useId", cn(), $t(), c9()
                }, unstable_isNewReconciler: j
            }, u9 = {
                readContext: function (c) {
                    return kF(), es(c)
                }, useCallback: function (c, u) {
                    return dt = "useCallback", cn(), $t(), o9(c, u)
                }, useContext: function (c) {
                    return dt = "useContext", cn(), $t(), es(c)
                }, useEffect: function (c, u) {
                    return dt = "useEffect", cn(), $t(), c5(c, u)
                }, useImperativeHandle: function (c, u, v) {
                    return dt = "useImperativeHandle", cn(), $t(), i9(c, u, v)
                }, useInsertionEffect: function (c, u) {
                    return dt = "useInsertionEffect", cn(), $t(), r9(c, u)
                }, useLayoutEffect: function (c, u) {
                    return dt = "useLayoutEffect", cn(), $t(), n9(c, u)
                }, useMemo: function (c, u) {
                    dt = "useMemo", cn(), $t();
                    var v = Jt.current;
                    Jt.current = Dh;
                    try {
                        return s9(c, u)
                    } finally {
                        Jt.current = v
                    }
                }, useReducer: function (c, u, v) {
                    dt = "useReducer", cn(), $t();
                    var y = Jt.current;
                    Jt.current = Dh;
                    try {
                        return vF(c)
                    } finally {
                        Jt.current = y
                    }
                }, useRef: function (c) {
                    return dt = "useRef", cn(), $t(), JR()
                }, useState: function (c) {
                    dt = "useState", cn(), $t();
                    var u = Jt.current;
                    Jt.current = Dh;
                    try {
                        return bF()
                    } finally {
                        Jt.current = u
                    }
                }, useDebugValue: function (c, u) {
                    return dt = "useDebugValue", cn(), $t(), a9()
                }, useDeferredValue: function (c) {
                    return dt = "useDeferredValue", cn(), $t(), Bne(c)
                }, useTransition: function () {
                    return dt = "useTransition", cn(), $t(), Une()
                }, useMutableSource: function (c, u, v) {
                    return dt = "useMutableSource", cn(), $t(), void 0
                }, useSyncExternalStore: function (c, u, v) {
                    return dt = "useSyncExternalStore", cn(), $t(), QR(c, u)
                }, useId: function () {
                    return dt = "useId", cn(), $t(), c9()
                }, unstable_isNewReconciler: j
            }
        }
        var Wg = e.unstable_now, Xne = 0, f9 = -1, l5 = -1, d9 = -1, RF = !1, h9 = !1;

        function Qne() {
            return RF
        }

        function L7e() {
            h9 = !0
        }

        function B7e() {
            RF = !1, h9 = !1
        }

        function $7e() {
            RF = h9, h9 = !1
        }

        function Zne() {
            return Xne
        }

        function Jne() {
            Xne = Wg()
        }

        function DF(c) {
            l5 = Wg(), c.actualStartTime < 0 && (c.actualStartTime = Wg())
        }

        function eie(c) {
            l5 = -1
        }

        function p9(c, u) {
            if (l5 >= 0) {
                var v = Wg() - l5;
                c.actualDuration += v, u && (c.selfBaseDuration = v), l5 = -1
            }
        }

        function r0(c) {
            if (f9 >= 0) {
                var u = Wg() - f9;
                f9 = -1;
                for (var v = c.return; v !== null;) {
                    switch (v.tag) {
                        case p:
                            var y = v.stateNode;
                            y.effectDuration += u;
                            return;
                        case V:
                            var E = v.stateNode;
                            E.effectDuration += u;
                            return
                    }
                    v = v.return
                }
            }
        }

        function MF(c) {
            if (d9 >= 0) {
                var u = Wg() - d9;
                d9 = -1;
                for (var v = c.return; v !== null;) {
                    switch (v.tag) {
                        case p:
                            var y = v.stateNode;
                            y !== null && (y.passiveEffectDuration += u);
                            return;
                        case V:
                            var E = v.stateNode;
                            E !== null && (E.passiveEffectDuration += u);
                            return
                    }
                    v = v.return
                }
            }
        }

        function n0() {
            f9 = Wg()
        }

        function OF() {
            d9 = Wg()
        }

        function PF(c) {
            for (var u = c.child; u;) c.actualDuration += u.actualDuration, u = u.sibling
        }

        function Mh(c, u) {
            if (c && c.defaultProps) {
                var v = Pt({}, u), y = c.defaultProps;
                for (var E in y) v[E] === void 0 && (v[E] = y[E]);
                return v
            }
            return u
        }

        var NF = {}, LF, BF, $F, FF, UF, tie, m9, jF, zF, VF, u5;
        {
            LF = new Set, BF = new Set, $F = new Set, FF = new Set, jF = new Set, UF = new Set, zF = new Set, VF = new Set, u5 = new Set;
            var rie = new Set;
            m9 = function (c, u) {
                if (!(c === null || typeof c == "function")) {
                    var v = u + "_" + c;
                    rie.has(v) || (rie.add(v), o("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", u, c))
                }
            }, tie = function (c, u) {
                if (u === void 0) {
                    var v = $n(c) || "Component";
                    UF.has(v) || (UF.add(v), o("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", v))
                }
            }, Object.defineProperty(NF, "_processChildContext", {
                enumerable: !1, value: function () {
                    throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).")
                }
            }), Object.freeze(NF)
        }

        function HF(c, u, v, y) {
            var E = c.memoizedState, L = v(y, E);
            {
                if (c.mode & Gi) {
                    La(!0);
                    try {
                        L = v(y, E)
                    } finally {
                        La(!1)
                    }
                }
                tie(u, L)
            }
            var Z = L == null ? E : Pt({}, E, L);
            if (c.memoizedState = Z, c.lanes === mt) {
                var se = c.updateQueue;
                se.baseState = Z
            }
        }

        var WF = {
            isMounted: _k, enqueueSetState: function (c, u, v) {
                var y = Np(c), E = Gl(), L = Yg(y), Z = Hm(E, L);
                Z.payload = u, v != null && (m9(v, "setState"), Z.callback = v);
                var se = jg(y, Z, L);
                se !== null && (Ts(se, y, L, E), HR(se, y, L)), eb(y, L)
            }, enqueueReplaceState: function (c, u, v) {
                var y = Np(c), E = Gl(), L = Yg(y), Z = Hm(E, L);
                Z.tag = bne, Z.payload = u, v != null && (m9(v, "replaceState"), Z.callback = v);
                var se = jg(y, Z, L);
                se !== null && (Ts(se, y, L, E), HR(se, y, L)), eb(y, L)
            }, enqueueForceUpdate: function (c, u) {
                var v = Np(c), y = Gl(), E = Yg(v), L = Hm(y, E);
                L.tag = jR, u != null && (m9(u, "forceUpdate"), L.callback = u);
                var Z = jg(v, L, E);
                Z !== null && (Ts(Z, v, E, y), HR(Z, v, E)), R2(v, E)
            }
        };

        function nie(c, u, v, y, E, L, Z) {
            var se = c.stateNode;
            if (typeof se.shouldComponentUpdate == "function") {
                var he = se.shouldComponentUpdate(y, L, Z);
                {
                    if (c.mode & Gi) {
                        La(!0);
                        try {
                            he = se.shouldComponentUpdate(y, L, Z)
                        } finally {
                            La(!1)
                        }
                    }
                    he === void 0 && o("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", $n(u) || "Component")
                }
                return he
            }
            return u.prototype && u.prototype.isPureReactComponent ? !hr(v, y) || !hr(E, L) : !0
        }

        function F7e(c, u, v) {
            var y = c.stateNode;
            {
                var E = $n(u) || "Component", L = y.render;
                L || (u.prototype && typeof u.prototype.render == "function" ? o("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", E) : o("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", E)), y.getInitialState && !y.getInitialState.isReactClassApproved && !y.state && o("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", E), y.getDefaultProps && !y.getDefaultProps.isReactClassApproved && o("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", E), y.propTypes && o("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", E), y.contextType && o("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", E), u.childContextTypes && !u5.has(u) && (c.mode & Gi) === $r && (u5.add(u), o(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, E)), u.contextTypes && !u5.has(u) && (c.mode & Gi) === $r && (u5.add(u), o(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, E)), y.contextTypes && o("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", E), u.contextType && u.contextTypes && !zF.has(u) && (zF.add(u), o("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", E)), typeof y.componentShouldUpdate == "function" && o("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", E), u.prototype && u.prototype.isPureReactComponent && typeof y.shouldComponentUpdate < "u" && o("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", $n(u) || "A pure component"), typeof y.componentDidUnmount == "function" && o("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", E), typeof y.componentDidReceiveProps == "function" && o("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", E), typeof y.componentWillRecieveProps == "function" && o("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", E), typeof y.UNSAFE_componentWillRecieveProps == "function" && o("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", E);
                var Z = y.props !== v;
                y.props !== void 0 && Z && o("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", E, E), y.defaultProps && o("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", E, E), typeof y.getSnapshotBeforeUpdate == "function" && typeof y.componentDidUpdate != "function" && !$F.has(u) && ($F.add(u), o("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", $n(u))), typeof y.getDerivedStateFromProps == "function" && o("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", E), typeof y.getDerivedStateFromError == "function" && o("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", E), typeof u.getSnapshotBeforeUpdate == "function" && o("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", E);
                var se = y.state;
                se && (typeof se != "object" || wn(se)) && o("%s.state: must be set to an object or null", E), typeof y.getChildContext == "function" && typeof u.childContextTypes != "object" && o("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", E)
            }
        }

        function iie(c, u) {
            u.updater = WF, c.stateNode = u, qB(u, c), u._reactInternalInstance = NF
        }

        function aie(c, u, v) {
            var y = !1, E = xf, L = xf, Z = u.contextType;
            if ("contextType" in u) {
                var se = Z === null || Z !== void 0 && Z.$$typeof === pn && Z._context === void 0;
                if (!se && !VF.has(u)) {
                    VF.add(u);
                    var he = "";
                    Z === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Z != "object" ? he = " However, it is set to a " + typeof Z + "." : Z.$$typeof === An ? he = " Did you accidentally pass the Context.Provider instead?" : Z._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys(Z).join(", ") + "}.", o("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", $n(u) || "Component", he)
                }
            }
            if (typeof Z == "object" && Z !== null) L = es(Z); else {
                E = b_(c, u, !0);
                var we = u.contextTypes;
                y = we != null, L = y ? w_(c, E) : xf
            }
            var _e = new u(v, L);
            if (c.mode & Gi) {
                La(!0);
                try {
                    _e = new u(v, L)
                } finally {
                    La(!1)
                }
            }
            var Fe = c.memoizedState = _e.state !== null && _e.state !== void 0 ? _e.state : null;
            iie(c, _e);
            {
                if (typeof u.getDerivedStateFromProps == "function" && Fe === null) {
                    var Le = $n(u) || "Component";
                    BF.has(Le) || (BF.add(Le), o("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Le, _e.state === null ? "null" : "undefined", Le))
                }
                if (typeof u.getDerivedStateFromProps == "function" || typeof _e.getSnapshotBeforeUpdate == "function") {
                    var Qe = null, nt = null, lt = null;
                    if (typeof _e.componentWillMount == "function" && _e.componentWillMount.__suppressDeprecationWarning !== !0 ? Qe = "componentWillMount" : typeof _e.UNSAFE_componentWillMount == "function" && (Qe = "UNSAFE_componentWillMount"), typeof _e.componentWillReceiveProps == "function" && _e.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? nt = "componentWillReceiveProps" : typeof _e.UNSAFE_componentWillReceiveProps == "function" && (nt = "UNSAFE_componentWillReceiveProps"), typeof _e.componentWillUpdate == "function" && _e.componentWillUpdate.__suppressDeprecationWarning !== !0 ? lt = "componentWillUpdate" : typeof _e.UNSAFE_componentWillUpdate == "function" && (lt = "UNSAFE_componentWillUpdate"), Qe !== null || nt !== null || lt !== null) {
                        var qt = $n(u) || "Component",
                            jr = typeof u.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                        FF.has(qt) || (FF.add(qt), o(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, qt, jr, Qe !== null ? `
  ` + Qe : "", nt !== null ? `
  ` + nt : "", lt !== null ? `
  ` + lt : ""))
                    }
                }
            }
            return y && Kre(c, E, L), _e
        }

        function U7e(c, u) {
            var v = u.state;
            typeof u.componentWillMount == "function" && u.componentWillMount(), typeof u.UNSAFE_componentWillMount == "function" && u.UNSAFE_componentWillMount(), v !== u.state && (o("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Lr(c) || "Component"), WF.enqueueReplaceState(u, u.state, null))
        }

        function oie(c, u, v, y) {
            var E = u.state;
            if (typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(v, y), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(v, y), u.state !== E) {
                {
                    var L = Lr(c) || "Component";
                    LF.has(L) || (LF.add(L), o("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", L))
                }
                WF.enqueueReplaceState(u, u.state, null)
            }
        }

        function qF(c, u, v, y) {
            F7e(c, u, v);
            var E = c.stateNode;
            E.props = v, E.state = c.memoizedState, E.refs = {}, tF(c);
            var L = u.contextType;
            if (typeof L == "object" && L !== null) E.context = es(L); else {
                var Z = b_(c, u, !0);
                E.context = w_(c, Z)
            }
            {
                if (E.state === v) {
                    var se = $n(u) || "Component";
                    jF.has(se) || (jF.add(se), o("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", se))
                }
                c.mode & Gi && kh.recordLegacyContextWarning(c, E), kh.recordUnsafeLifecycleWarnings(c, E)
            }
            E.state = c.memoizedState;
            var he = u.getDerivedStateFromProps;
            if (typeof he == "function" && (HF(c, u, he, v), E.state = c.memoizedState), typeof u.getDerivedStateFromProps != "function" && typeof E.getSnapshotBeforeUpdate != "function" && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function") && (U7e(c, E), WR(c, v, E, y), E.state = c.memoizedState), typeof E.componentDidMount == "function") {
                var we = Dn;
                we |= gh, (c.mode & yi) !== $r && (we |= yh), c.flags |= we
            }
        }

        function j7e(c, u, v, y) {
            var E = c.stateNode, L = c.memoizedProps;
            E.props = L;
            var Z = E.context, se = u.contextType, he = xf;
            if (typeof se == "object" && se !== null) he = es(se); else {
                var we = b_(c, u, !0);
                he = w_(c, we)
            }
            var _e = u.getDerivedStateFromProps,
                Fe = typeof _e == "function" || typeof E.getSnapshotBeforeUpdate == "function";
            !Fe && (typeof E.UNSAFE_componentWillReceiveProps == "function" || typeof E.componentWillReceiveProps == "function") && (L !== v || Z !== he) && oie(c, E, v, he), Sne();
            var Le = c.memoizedState, Qe = E.state = Le;
            if (WR(c, v, E, y), Qe = c.memoizedState, L === v && Le === Qe && !CR() && !qR()) {
                if (typeof E.componentDidMount == "function") {
                    var nt = Dn;
                    nt |= gh, (c.mode & yi) !== $r && (nt |= yh), c.flags |= nt
                }
                return !1
            }
            typeof _e == "function" && (HF(c, u, _e, v), Qe = c.memoizedState);
            var lt = qR() || nie(c, u, L, v, Le, Qe, he);
            if (lt) {
                if (!Fe && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function") && (typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount()), typeof E.componentDidMount == "function") {
                    var qt = Dn;
                    qt |= gh, (c.mode & yi) !== $r && (qt |= yh), c.flags |= qt
                }
            } else {
                if (typeof E.componentDidMount == "function") {
                    var jr = Dn;
                    jr |= gh, (c.mode & yi) !== $r && (jr |= yh), c.flags |= jr
                }
                c.memoizedProps = v, c.memoizedState = Qe
            }
            return E.props = v, E.state = Qe, E.context = he, lt
        }

        function z7e(c, u, v, y, E) {
            var L = u.stateNode;
            wne(c, u);
            var Z = u.memoizedProps, se = u.type === u.elementType ? Z : Mh(u.type, Z);
            L.props = se;
            var he = u.pendingProps, we = L.context, _e = v.contextType, Fe = xf;
            if (typeof _e == "object" && _e !== null) Fe = es(_e); else {
                var Le = b_(u, v, !0);
                Fe = w_(u, Le)
            }
            var Qe = v.getDerivedStateFromProps,
                nt = typeof Qe == "function" || typeof L.getSnapshotBeforeUpdate == "function";
            !nt && (typeof L.UNSAFE_componentWillReceiveProps == "function" || typeof L.componentWillReceiveProps == "function") && (Z !== he || we !== Fe) && oie(u, L, y, Fe), Sne();
            var lt = u.memoizedState, qt = L.state = lt;
            if (WR(u, y, L, E), qt = u.memoizedState, Z === he && lt === qt && !CR() && !qR() && !$) return typeof L.componentDidUpdate == "function" && (Z !== c.memoizedProps || lt !== c.memoizedState) && (u.flags |= Dn), typeof L.getSnapshotBeforeUpdate == "function" && (Z !== c.memoizedProps || lt !== c.memoizedState) && (u.flags |= Ha), !1;
            typeof Qe == "function" && (HF(u, v, Qe, y), qt = u.memoizedState);
            var jr = qR() || nie(u, v, se, y, lt, qt, Fe) || $;
            return jr ? (!nt && (typeof L.UNSAFE_componentWillUpdate == "function" || typeof L.componentWillUpdate == "function") && (typeof L.componentWillUpdate == "function" && L.componentWillUpdate(y, qt, Fe), typeof L.UNSAFE_componentWillUpdate == "function" && L.UNSAFE_componentWillUpdate(y, qt, Fe)), typeof L.componentDidUpdate == "function" && (u.flags |= Dn), typeof L.getSnapshotBeforeUpdate == "function" && (u.flags |= Ha)) : (typeof L.componentDidUpdate == "function" && (Z !== c.memoizedProps || lt !== c.memoizedState) && (u.flags |= Dn), typeof L.getSnapshotBeforeUpdate == "function" && (Z !== c.memoizedProps || lt !== c.memoizedState) && (u.flags |= Ha), u.memoizedProps = y, u.memoizedState = qt), L.props = y, L.state = qt, L.context = Fe, jr
        }

        function Fb(c, u) {
            return {value: c, source: u, stack: uh(u), digest: null}
        }

        function GF(c, u, v) {
            return {value: c, source: null, stack: v ?? null, digest: u ?? null}
        }

        function V7e(c, u) {
            return !0
        }

        function KF(c, u) {
            try {
                var v = V7e();
                if (v === !1) return;
                var y = u.value;
                {
                    var E = u.source, L = u.stack, Z = L !== null ? L : "";
                    if (y != null && y._suppressLogging) {
                        if (c.tag === f) return;
                        console.error(y)
                    }
                    var se = E ? Lr(E) : null,
                        he = se ? "The above error occurred in the <" + se + "> component:" : "The above error occurred in one of your React components:",
                        we;
                    if (c.tag === p) we = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`; else {
                        var _e = Lr(c) || "Anonymous";
                        we = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + _e + ".")
                    }
                    var Fe = he + `
` + Z + `

` + ("" + we);
                    console.error(Fe)
                }
            } catch (Le) {
                setTimeout(function () {
                    throw Le
                })
            }
        }

        var H7e = typeof WeakMap == "function" ? WeakMap : Map;

        function sie(c, u, v) {
            var y = Hm(ea, v);
            y.tag = J$, y.payload = {element: null};
            var E = u.value;
            return y.callback = function () {
                NMe(E), KF(c, u)
            }, y
        }

        function YF(c, u, v) {
            var y = Hm(ea, v);
            y.tag = J$;
            var E = c.type.getDerivedStateFromError;
            if (typeof E == "function") {
                var L = u.value;
                y.payload = function () {
                    return E(L)
                }, y.callback = function () {
                    yae(c), KF(c, u)
                }
            }
            var Z = c.stateNode;
            return Z !== null && typeof Z.componentDidCatch == "function" && (y.callback = function () {
                yae(c), KF(c, u), typeof E != "function" && OMe(this);
                var he = u.value, we = u.stack;
                this.componentDidCatch(he, {componentStack: we !== null ? we : ""}), typeof E != "function" && (rl(c.lanes, Xr) || o("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Lr(c) || "Unknown"))
            }), y
        }

        function cie(c, u, v) {
            var y = c.pingCache, E;
            if (y === null ? (y = c.pingCache = new H7e, E = new Set, y.set(u, E)) : (E = y.get(u), E === void 0 && (E = new Set, y.set(u, E))), !E.has(v)) {
                E.add(v);
                var L = LMe.bind(null, c, u, v);
                el && A5(c, v), u.then(L, L)
            }
        }

        function W7e(c, u, v, y) {
            var E = c.updateQueue;
            if (E === null) {
                var L = new Set;
                L.add(v), c.updateQueue = L
            } else E.add(v)
        }

        function q7e(c, u) {
            var v = c.tag;
            if ((c.mode & Mn) === $r && (v === l || v === F || v === oe)) {
                var y = c.alternate;
                y ? (c.updateQueue = y.updateQueue, c.memoizedState = y.memoizedState, c.lanes = y.lanes) : (c.updateQueue = null, c.memoizedState = null)
            }
        }

        function lie(c) {
            var u = c;
            do {
                if (u.tag === Y && C7e(u)) return u;
                u = u.return
            } while (u !== null);
            return null
        }

        function uie(c, u, v, y, E) {
            if ((c.mode & Mn) === $r) {
                if (c === u) c.flags |= Xo; else {
                    if (c.flags |= Mr, v.flags |= _2, v.flags &= ~(S2 | Sg), v.tag === f) {
                        var L = v.alternate;
                        if (L === null) v.tag = J; else {
                            var Z = Hm(ea, Xr);
                            Z.tag = jR, jg(v, Z, Xr)
                        }
                    }
                    v.lanes = vn(v.lanes, Xr)
                }
                return c
            }
            return c.flags |= Xo, c.lanes = E, c
        }

        function G7e(c, u, v, y, E) {
            if (v.flags |= Sg, el && A5(c, E), y !== null && typeof y == "object" && typeof y.then == "function") {
                var L = y;
                q7e(v), Sc() && v.mode & Mn && tne();
                var Z = lie(u);
                if (Z !== null) {
                    Z.flags &= ~ai, uie(Z, u, v, c, E), Z.mode & Mn && cie(c, L, E), W7e(Z, c, L);
                    return
                } else {
                    if (!Rk(E)) {
                        cie(c, L, E), AU();
                        return
                    }
                    var se = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                    y = se
                }
            } else if (Sc() && v.mode & Mn) {
                tne();
                var he = lie(u);
                if (he !== null) {
                    (he.flags & Xo) === Ar && (he.flags |= ai), uie(he, u, v, c, E), j$(Fb(y, v));
                    return
                }
            }
            y = Fb(y, v), TMe(y);
            var we = u;
            do {
                switch (we.tag) {
                    case p: {
                        var _e = y;
                        we.flags |= Xo;
                        var Fe = lb(E);
                        we.lanes = vn(we.lanes, Fe);
                        var Le = sie(we, _e, Fe);
                        rF(we, Le);
                        return
                    }
                    case f:
                        var Qe = y, nt = we.type, lt = we.stateNode;
                        if ((we.flags & Mr) === Ar && (typeof nt.getDerivedStateFromError == "function" || lt !== null && typeof lt.componentDidCatch == "function" && !lae(lt))) {
                            we.flags |= Xo;
                            var qt = lb(E);
                            we.lanes = vn(we.lanes, qt);
                            var jr = YF(we, Qe, qt);
                            rF(we, jr);
                            return
                        }
                        break
                }
                we = we.return
            } while (we !== null)
        }

        function K7e() {
            return null
        }

        var f5 = r.ReactCurrentOwner, Oh = !1, XF, d5, QF, ZF, JF, Ub, eU, v9, h5;
        XF = {}, d5 = {}, QF = {}, ZF = {}, JF = {}, Ub = !1, eU = {}, v9 = {}, h5 = {};

        function Wl(c, u, v, y) {
            c === null ? u.child = hne(u, null, v, y) : u.child = E_(u, c.child, v, y)
        }

        function Y7e(c, u, v, y) {
            u.child = E_(u, c.child, null, y), u.child = E_(u, null, v, y)
        }

        function fie(c, u, v, y, E) {
            if (u.type !== u.elementType) {
                var L = v.propTypes;
                L && Ah(L, y, "prop", $n(v))
            }
            var Z = v.render, se = u.ref, he, we;
            C_(u, E), jl(u);
            {
                if (f5.current = u, Lo(!0), he = M_(c, u, Z, y, se, E), we = O_(), u.mode & Gi) {
                    La(!0);
                    try {
                        he = M_(c, u, Z, y, se, E), we = O_()
                    } finally {
                        La(!1)
                    }
                }
                Lo(!1)
            }
            return zl(), c !== null && !Oh ? (Ane(c, u, E), Wm(c, u, E)) : (Sc() && we && N$(u), u.flags |= ld, Wl(c, u, he, E), u.child)
        }

        function die(c, u, v, y, E) {
            if (c === null) {
                var L = v.type;
                if (JMe(L) && v.compare === null && v.defaultProps === void 0) {
                    var Z = L;
                    return Z = j_(L), u.tag = oe, u.type = Z, nU(u, L), hie(c, u, Z, y, E)
                }
                {
                    var se = L.propTypes;
                    if (se && Ah(se, y, "prop", $n(L)), v.defaultProps !== void 0) {
                        var he = $n(L) || "Unknown";
                        h5[he] || (o("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", he), h5[he] = !0)
                    }
                }
                var we = $U(v.type, null, y, u, u.mode, E);
                return we.ref = u.ref, we.return = u, u.child = we, we
            }
            {
                var _e = v.type, Fe = _e.propTypes;
                Fe && Ah(Fe, y, "prop", $n(_e))
            }
            var Le = c.child, Qe = lU(c, E);
            if (!Qe) {
                var nt = Le.memoizedProps, lt = v.compare;
                if (lt = lt !== null ? lt : hr, lt(nt, y) && c.ref === u.ref) return Wm(c, u, E)
            }
            u.flags |= ld;
            var qt = Wb(Le, y);
            return qt.ref = u.ref, qt.return = u, u.child = qt, qt
        }

        function hie(c, u, v, y, E) {
            if (u.type !== u.elementType) {
                var L = u.elementType;
                if (L.$$typeof === xt) {
                    var Z = L, se = Z._payload, he = Z._init;
                    try {
                        L = he(se)
                    } catch {
                        L = null
                    }
                    var we = L && L.propTypes;
                    we && Ah(we, y, "prop", $n(L))
                }
            }
            if (c !== null) {
                var _e = c.memoizedProps;
                if (hr(_e, y) && c.ref === u.ref && u.type === c.type) if (Oh = !1, u.pendingProps = y = _e, lU(c, E)) (c.flags & _2) !== Ar && (Oh = !0); else return u.lanes = c.lanes, Wm(c, u, E)
            }
            return tU(c, u, v, y, E)
        }

        function pie(c, u, v) {
            var y = u.pendingProps, E = y.children, L = c !== null ? c.memoizedState : null;
            if (y.mode === "hidden" || C) if ((u.mode & Mn) === $r) {
                var Z = {baseLanes: mt, cachePool: null, transitions: null};
                u.memoizedState = Z, k9(u, v)
            } else if (rl(v, tl)) {
                var Fe = {baseLanes: mt, cachePool: null, transitions: null};
                u.memoizedState = Fe;
                var Le = L !== null ? L.baseLanes : v;
                k9(u, Le)
            } else {
                var se = null, he;
                if (L !== null) {
                    var we = L.baseLanes;
                    he = vn(we, v)
                } else he = v;
                u.lanes = u.childLanes = tl;
                var _e = {baseLanes: he, cachePool: se, transitions: null};
                return u.memoizedState = _e, u.updateQueue = null, k9(u, he), null
            } else {
                var Qe;
                L !== null ? (Qe = vn(L.baseLanes, v), u.memoizedState = null) : Qe = v, k9(u, Qe)
            }
            return Wl(c, u, E, v), u.child
        }

        function X7e(c, u, v) {
            var y = u.pendingProps;
            return Wl(c, u, y, v), u.child
        }

        function Q7e(c, u, v) {
            var y = u.pendingProps.children;
            return Wl(c, u, y, v), u.child
        }

        function Z7e(c, u, v) {
            {
                u.flags |= Dn;
                {
                    var y = u.stateNode;
                    y.effectDuration = 0, y.passiveEffectDuration = 0
                }
            }
            var E = u.pendingProps, L = E.children;
            return Wl(c, u, L, v), u.child
        }

        function mie(c, u) {
            var v = u.ref;
            (c === null && v !== null || c !== null && c.ref !== v) && (u.flags |= pc, u.flags |= _g)
        }

        function tU(c, u, v, y, E) {
            if (u.type !== u.elementType) {
                var L = v.propTypes;
                L && Ah(L, y, "prop", $n(v))
            }
            var Z;
            {
                var se = b_(u, v, !0);
                Z = w_(u, se)
            }
            var he, we;
            C_(u, E), jl(u);
            {
                if (f5.current = u, Lo(!0), he = M_(c, u, v, y, Z, E), we = O_(), u.mode & Gi) {
                    La(!0);
                    try {
                        he = M_(c, u, v, y, Z, E), we = O_()
                    } finally {
                        La(!1)
                    }
                }
                Lo(!1)
            }
            return zl(), c !== null && !Oh ? (Ane(c, u, E), Wm(c, u, E)) : (Sc() && we && N$(u), u.flags |= ld, Wl(c, u, he, E), u.child)
        }

        function vie(c, u, v, y, E) {
            {
                switch (pOe(u)) {
                    case!1: {
                        var L = u.stateNode, Z = u.type, se = new Z(u.memoizedProps, L.context), he = se.state;
                        L.updater.enqueueSetState(L, he, null);
                        break
                    }
                    case!0: {
                        u.flags |= Mr, u.flags |= Xo;
                        var we = new Error("Simulated error coming from DevTools"), _e = lb(E);
                        u.lanes = vn(u.lanes, _e);
                        var Fe = YF(u, Fb(we, u), _e);
                        rF(u, Fe);
                        break
                    }
                }
                if (u.type !== u.elementType) {
                    var Le = v.propTypes;
                    Le && Ah(Le, y, "prop", $n(v))
                }
            }
            var Qe;
            Zp(v) ? (Qe = !0, IR(u)) : Qe = !1, C_(u, E);
            var nt = u.stateNode, lt;
            nt === null ? (y9(c, u), aie(u, v, y), qF(u, v, y, E), lt = !0) : c === null ? lt = j7e(u, v, y, E) : lt = z7e(c, u, v, y, E);
            var qt = rU(c, u, v, lt, Qe, E);
            {
                var jr = u.stateNode;
                lt && jr.props !== y && (Ub || o("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Lr(u) || "a component"), Ub = !0)
            }
            return qt
        }

        function rU(c, u, v, y, E, L) {
            mie(c, u);
            var Z = (u.flags & Mr) !== Ar;
            if (!y && !Z) return E && Qre(u, v, !1), Wm(c, u, L);
            var se = u.stateNode;
            f5.current = u;
            var he;
            if (Z && typeof v.getDerivedStateFromError != "function") he = null, eie(); else {
                jl(u);
                {
                    if (Lo(!0), he = se.render(), u.mode & Gi) {
                        La(!0);
                        try {
                            se.render()
                        } finally {
                            La(!1)
                        }
                    }
                    Lo(!1)
                }
                zl()
            }
            return u.flags |= ld, c !== null && Z ? Y7e(c, u, he, L) : Wl(c, u, he, L), u.memoizedState = se.state, E && Qre(u, v, !0), u.child
        }

        function gie(c) {
            var u = c.stateNode;
            u.pendingContext ? Yre(c, u.pendingContext, u.pendingContext !== u.context) : u.context && Yre(c, u.context, !1), nF(c, u.containerInfo)
        }

        function J7e(c, u, v) {
            if (gie(u), c === null) throw new Error("Should have a current fiber. This is a bug in React.");
            var y = u.pendingProps, E = u.memoizedState, L = E.element;
            wne(c, u), WR(u, y, null, v);
            var Z = u.memoizedState, se = Z.element;
            if (E.isDehydrated) {
                var he = {
                    element: se,
                    isDehydrated: !1,
                    cache: Z.cache,
                    pendingSuspenseBoundaries: Z.pendingSuspenseBoundaries,
                    transitions: Z.transitions
                }, we = u.updateQueue;
                if (we.baseState = he, u.memoizedState = he, u.flags & ai) {
                    var _e = Fb(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), u);
                    return yie(c, u, se, v, _e)
                } else if (se !== L) {
                    var Fe = Fb(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), u);
                    return yie(c, u, se, v, Fe)
                } else {
                    r7e(u);
                    var Le = hne(u, null, se, v);
                    u.child = Le;
                    for (var Qe = Le; Qe;) Qe.flags = Qe.flags & ~pa | mc, Qe = Qe.sibling
                }
            } else {
                if (x_(), se === L) return Wm(c, u, v);
                Wl(c, u, se, v)
            }
            return u.child
        }

        function yie(c, u, v, y, E) {
            return x_(), j$(E), u.flags |= ai, Wl(c, u, v, y), u.child
        }

        function eDe(c, u, v) {
            Ene(u), c === null && U$(u);
            var y = u.type, E = u.pendingProps, L = c !== null ? c.memoizedProps : null, Z = E.children, se = S$(y, E);
            return se ? Z = null : L !== null && S$(y, L) && (u.flags |= ud), mie(c, u), Wl(c, u, Z, v), u.child
        }

        function tDe(c, u) {
            return c === null && U$(u), null
        }

        function rDe(c, u, v, y) {
            y9(c, u);
            var E = u.pendingProps, L = v, Z = L._payload, se = L._init, he = se(Z);
            u.type = he;
            var we = u.tag = eOe(he), _e = Mh(he, E), Fe;
            switch (we) {
                case l:
                    return nU(u, he), u.type = he = j_(he), Fe = tU(null, u, he, _e, y), Fe;
                case f:
                    return u.type = he = MU(he), Fe = vie(null, u, he, _e, y), Fe;
                case F:
                    return u.type = he = OU(he), Fe = fie(null, u, he, _e, y), Fe;
                case ee: {
                    if (u.type !== u.elementType) {
                        var Le = he.propTypes;
                        Le && Ah(Le, _e, "prop", $n(he))
                    }
                    return Fe = die(null, u, he, Mh(he.type, _e), y), Fe
                }
            }
            var Qe = "";
            throw he !== null && typeof he == "object" && he.$$typeof === xt && (Qe = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + he + ". " + ("Lazy element type must resolve to a class or function." + Qe))
        }

        function nDe(c, u, v, y, E) {
            y9(c, u), u.tag = f;
            var L;
            return Zp(v) ? (L = !0, IR(u)) : L = !1, C_(u, E), aie(u, v, y), qF(u, v, y, E), rU(null, u, v, !0, L, E)
        }

        function iDe(c, u, v, y) {
            y9(c, u);
            var E = u.pendingProps, L;
            {
                var Z = b_(u, v, !1);
                L = w_(u, Z)
            }
            C_(u, y);
            var se, he;
            jl(u);
            {
                if (v.prototype && typeof v.prototype.render == "function") {
                    var we = $n(v) || "Unknown";
                    XF[we] || (o("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", we, we), XF[we] = !0)
                }
                u.mode & Gi && kh.recordLegacyContextWarning(u, null), Lo(!0), f5.current = u, se = M_(null, u, v, E, L, y), he = O_(), Lo(!1)
            }
            if (zl(), u.flags |= ld, typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0) {
                var _e = $n(v) || "Unknown";
                d5[_e] || (o("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _e, _e, _e), d5[_e] = !0)
            }
            if (typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0) {
                {
                    var Fe = $n(v) || "Unknown";
                    d5[Fe] || (o("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Fe, Fe, Fe), d5[Fe] = !0)
                }
                u.tag = f, u.memoizedState = null, u.updateQueue = null;
                var Le = !1;
                return Zp(v) ? (Le = !0, IR(u)) : Le = !1, u.memoizedState = se.state !== null && se.state !== void 0 ? se.state : null, tF(u), iie(u, se), qF(u, v, E, y), rU(null, u, v, !0, Le, y)
            } else {
                if (u.tag = l, u.mode & Gi) {
                    La(!0);
                    try {
                        se = M_(null, u, v, E, L, y), he = O_()
                    } finally {
                        La(!1)
                    }
                }
                return Sc() && he && N$(u), Wl(null, u, se, y), nU(u, v), u.child
            }
        }

        function nU(c, u) {
            {
                if (u && u.childContextTypes && o("%s(...): childContextTypes cannot be defined on a function component.", u.displayName || u.name || "Component"), c.ref !== null) {
                    var v = "", y = fc();
                    y && (v += `

Check the render method of \`` + y + "`.");
                    var E = y || "", L = c._debugSource;
                    L && (E = L.fileName + ":" + L.lineNumber), JF[E] || (JF[E] = !0, o("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", v))
                }
                if (u.defaultProps !== void 0) {
                    var Z = $n(u) || "Unknown";
                    h5[Z] || (o("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", Z), h5[Z] = !0)
                }
                if (typeof u.getDerivedStateFromProps == "function") {
                    var se = $n(u) || "Unknown";
                    ZF[se] || (o("%s: Function components do not support getDerivedStateFromProps.", se), ZF[se] = !0)
                }
                if (typeof u.contextType == "object" && u.contextType !== null) {
                    var he = $n(u) || "Unknown";
                    QF[he] || (o("%s: Function components do not support contextType.", he), QF[he] = !0)
                }
            }
        }

        var iU = {dehydrated: null, treeContext: null, retryLane: pi};

        function aU(c) {
            return {baseLanes: c, cachePool: K7e(), transitions: null}
        }

        function aDe(c, u) {
            var v = null;
            return {baseLanes: vn(c.baseLanes, u), cachePool: v, transitions: c.transitions}
        }

        function oDe(c, u, v, y) {
            if (u !== null) {
                var E = u.memoizedState;
                if (E === null) return !1
            }
            return oF(c, r5)
        }

        function sDe(c, u) {
            return ub(c.childLanes, u)
        }

        function bie(c, u, v) {
            var y = u.pendingProps;
            mOe(u) && (u.flags |= Mr);
            var E = Rh.current, L = !1, Z = (u.flags & Mr) !== Ar;
            if (Z || oDe(E, c) ? (L = !0, u.flags &= ~Mr) : (c === null || c.memoizedState !== null) && (E = T7e(E, Cne)), E = I_(E), Vg(u, E), c === null) {
                U$(u);
                var se = u.memoizedState;
                if (se !== null) {
                    var he = se.dehydrated;
                    if (he !== null) return dDe(u, he)
                }
                var we = y.children, _e = y.fallback;
                if (L) {
                    var Fe = cDe(u, we, _e, v), Le = u.child;
                    return Le.memoizedState = aU(v), u.memoizedState = iU, Fe
                } else return oU(u, we)
            } else {
                var Qe = c.memoizedState;
                if (Qe !== null) {
                    var nt = Qe.dehydrated;
                    if (nt !== null) return hDe(c, u, Z, y, nt, Qe, v)
                }
                if (L) {
                    var lt = y.fallback, qt = y.children, jr = uDe(c, u, qt, lt, v), xr = u.child,
                        ri = c.child.memoizedState;
                    return xr.memoizedState = ri === null ? aU(v) : aDe(ri, v), xr.childLanes = sDe(c, v), u.memoizedState = iU, jr
                } else {
                    var qn = y.children, We = lDe(c, u, qn, v);
                    return u.memoizedState = null, We
                }
            }
        }

        function oU(c, u, v) {
            var y = c.mode, E = {mode: "visible", children: u}, L = sU(E, y);
            return L.return = c, c.child = L, L
        }

        function cDe(c, u, v, y) {
            var E = c.mode, L = c.child, Z = {mode: "hidden", children: u}, se, he;
            return (E & Mn) === $r && L !== null ? (se = L, se.childLanes = mt, se.pendingProps = Z, c.mode & gi && (se.actualDuration = 0, se.actualStartTime = -1, se.selfBaseDuration = 0, se.treeBaseDuration = 0), he = Qg(v, E, y, null)) : (se = sU(Z, E), he = Qg(v, E, y, null)), se.return = c, he.return = c, se.sibling = he, c.child = se, he
        }

        function sU(c, u, v) {
            return bae(c, u, mt, null)
        }

        function wie(c, u) {
            return Wb(c, u)
        }

        function lDe(c, u, v, y) {
            var E = c.child, L = E.sibling, Z = wie(E, {mode: "visible", children: v});
            if ((u.mode & Mn) === $r && (Z.lanes = y), Z.return = u, Z.sibling = null, L !== null) {
                var se = u.deletions;
                se === null ? (u.deletions = [L], u.flags |= vh) : se.push(L)
            }
            return u.child = Z, Z
        }

        function uDe(c, u, v, y, E) {
            var L = u.mode, Z = c.child, se = Z.sibling, he = {mode: "hidden", children: v}, we;
            if ((L & Mn) === $r && u.child !== Z) {
                var _e = u.child;
                we = _e, we.childLanes = mt, we.pendingProps = he, u.mode & gi && (we.actualDuration = 0, we.actualStartTime = -1, we.selfBaseDuration = Z.selfBaseDuration, we.treeBaseDuration = Z.treeBaseDuration), u.deletions = null
            } else we = wie(Z, he), we.subtreeFlags = Z.subtreeFlags & mo;
            var Fe;
            return se !== null ? Fe = Wb(se, y) : (Fe = Qg(y, L, E, null), Fe.flags |= pa), Fe.return = u, we.return = u, we.sibling = Fe, u.child = we, Fe
        }

        function g9(c, u, v, y) {
            y !== null && j$(y), E_(u, c.child, null, v);
            var E = u.pendingProps, L = E.children, Z = oU(u, L);
            return Z.flags |= pa, u.memoizedState = null, Z
        }

        function fDe(c, u, v, y, E) {
            var L = u.mode, Z = {mode: "visible", children: v}, se = sU(Z, L), he = Qg(y, L, E, null);
            return he.flags |= pa, se.return = u, he.return = u, se.sibling = he, u.child = se, (u.mode & Mn) !== $r && E_(u, c.child, null, E), he
        }

        function dDe(c, u, v) {
            return (c.mode & Mn) === $r ? (o("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), c.lanes = Xr) : T$(u) ? c.lanes = Vs : c.lanes = tl, null
        }

        function hDe(c, u, v, y, E, L, Z) {
            if (v) if (u.flags & ai) {
                u.flags &= ~ai;
                var We = GF(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return g9(c, u, Z, We)
            } else {
                if (u.memoizedState !== null) return u.child = c.child, u.flags |= Mr, null;
                var ut = y.children, qe = y.fallback, At = fDe(c, u, ut, qe, Z), tr = u.child;
                return tr.memoizedState = aU(Z), u.memoizedState = iU, At
            } else {
                if (e7e(), (u.mode & Mn) === $r) return g9(c, u, Z, null);
                if (T$(E)) {
                    var se, he, we;
                    {
                        var _e = g9e(E);
                        se = _e.digest, he = _e.message, we = _e.stack
                    }
                    var Fe;
                    he ? Fe = new Error(he) : Fe = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                    var Le = GF(Fe, se, we);
                    return g9(c, u, Z, Le)
                }
                var Qe = rl(Z, c.childLanes);
                if (Oh || Qe) {
                    var nt = I9();
                    if (nt !== null) {
                        var lt = v6(nt, Z);
                        if (lt !== pi && lt !== L.retryLane) {
                            L.retryLane = lt;
                            var qt = ea;
                            Lu(c, lt), Ts(nt, c, lt, qt)
                        }
                    }
                    AU();
                    var jr = GF(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                    return g9(c, u, Z, jr)
                } else if (Vre(E)) {
                    u.flags |= Mr, u.child = c.child;
                    var xr = BMe.bind(null, c);
                    return y9e(E, xr), null
                } else {
                    n7e(u, E, L.treeContext);
                    var ri = y.children, qn = oU(u, ri);
                    return qn.flags |= mc, qn
                }
            }
        }

        function Sie(c, u, v) {
            c.lanes = vn(c.lanes, u);
            var y = c.alternate;
            y !== null && (y.lanes = vn(y.lanes, u)), Q$(c.return, u, v)
        }

        function pDe(c, u, v) {
            for (var y = u; y !== null;) {
                if (y.tag === Y) {
                    var E = y.memoizedState;
                    E !== null && Sie(y, v, c)
                } else if (y.tag === re) Sie(y, v, c); else if (y.child !== null) {
                    y.child.return = y, y = y.child;
                    continue
                }
                if (y === c) return;
                for (; y.sibling === null;) {
                    if (y.return === null || y.return === c) return;
                    y = y.return
                }
                y.sibling.return = y.return, y = y.sibling
            }
        }

        function mDe(c) {
            for (var u = c, v = null; u !== null;) {
                var y = u.alternate;
                y !== null && YR(y) === null && (v = u), u = u.sibling
            }
            return v
        }

        function vDe(c) {
            if (c !== void 0 && c !== "forwards" && c !== "backwards" && c !== "together" && !eU[c]) if (eU[c] = !0, typeof c == "string") switch (c.toLowerCase()) {
                case"together":
                case"forwards":
                case"backwards": {
                    o('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', c, c.toLowerCase());
                    break
                }
                case"forward":
                case"backward": {
                    o('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', c, c.toLowerCase());
                    break
                }
                default:
                    o('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
                    break
            } else o('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c)
        }

        function gDe(c, u) {
            c !== void 0 && !v9[c] && (c !== "collapsed" && c !== "hidden" ? (v9[c] = !0, o('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', c)) : u !== "forwards" && u !== "backwards" && (v9[c] = !0, o('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', c)))
        }

        function _ie(c, u) {
            {
                var v = wn(c), y = !v && typeof Fi(c) == "function";
                if (v || y) {
                    var E = v ? "array" : "iterable";
                    return o("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", E, u, E), !1
                }
            }
            return !0
        }

        function yDe(c, u) {
            if ((u === "forwards" || u === "backwards") && c !== void 0 && c !== null && c !== !1) if (wn(c)) {
                for (var v = 0; v < c.length; v++) if (!_ie(c[v], v)) return
            } else {
                var y = Fi(c);
                if (typeof y == "function") {
                    var E = y.call(c);
                    if (E) for (var L = E.next(), Z = 0; !L.done; L = E.next()) {
                        if (!_ie(L.value, Z)) return;
                        Z++
                    }
                } else o('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', u)
            }
        }

        function cU(c, u, v, y, E) {
            var L = c.memoizedState;
            L === null ? c.memoizedState = {
                isBackwards: u,
                rendering: null,
                renderingStartTime: 0,
                last: y,
                tail: v,
                tailMode: E
            } : (L.isBackwards = u, L.rendering = null, L.renderingStartTime = 0, L.last = y, L.tail = v, L.tailMode = E)
        }

        function xie(c, u, v) {
            var y = u.pendingProps, E = y.revealOrder, L = y.tail, Z = y.children;
            vDe(E), gDe(L, E), yDe(Z, E), Wl(c, u, Z, v);
            var se = Rh.current, he = oF(se, r5);
            if (he) se = sF(se, r5), u.flags |= Mr; else {
                var we = c !== null && (c.flags & Mr) !== Ar;
                we && pDe(u, u.child, v), se = I_(se)
            }
            if (Vg(u, se), (u.mode & Mn) === $r) u.memoizedState = null; else switch (E) {
                case"forwards": {
                    var _e = mDe(u.child), Fe;
                    _e === null ? (Fe = u.child, u.child = null) : (Fe = _e.sibling, _e.sibling = null), cU(u, !1, Fe, _e, L);
                    break
                }
                case"backwards": {
                    var Le = null, Qe = u.child;
                    for (u.child = null; Qe !== null;) {
                        var nt = Qe.alternate;
                        if (nt !== null && YR(nt) === null) {
                            u.child = Qe;
                            break
                        }
                        var lt = Qe.sibling;
                        Qe.sibling = Le, Le = Qe, Qe = lt
                    }
                    cU(u, !0, Le, null, L);
                    break
                }
                case"together": {
                    cU(u, !1, null, null, void 0);
                    break
                }
                default:
                    u.memoizedState = null
            }
            return u.child
        }

        function bDe(c, u, v) {
            nF(u, u.stateNode.containerInfo);
            var y = u.pendingProps;
            return c === null ? u.child = E_(u, null, y, v) : Wl(c, u, y, v), u.child
        }

        var Eie = !1;

        function wDe(c, u, v) {
            var y = u.type, E = y._context, L = u.pendingProps, Z = u.memoizedProps, se = L.value;
            {
                "value" in L || Eie || (Eie = !0, o("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
                var he = u.type.propTypes;
                he && Ah(he, L, "prop", "Context.Provider")
            }
            if (vne(u, E, se), Z !== null) {
                var we = Z.value;
                if (St(we, se)) {
                    if (Z.children === L.children && !CR()) return Wm(c, u, v)
                } else v7e(u, E, v)
            }
            var _e = L.children;
            return Wl(c, u, _e, v), u.child
        }

        var Tie = !1;

        function SDe(c, u, v) {
            var y = u.type;
            y._context === void 0 ? y !== y.Consumer && (Tie || (Tie = !0, o("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : y = y._context;
            var E = u.pendingProps, L = E.children;
            typeof L != "function" && o("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), C_(u, v);
            var Z = es(y);
            jl(u);
            var se;
            return f5.current = u, Lo(!0), se = L(Z), Lo(!1), zl(), u.flags |= ld, Wl(c, u, se, v), u.child
        }

        function p5() {
            Oh = !0
        }

        function y9(c, u) {
            (u.mode & Mn) === $r && c !== null && (c.alternate = null, u.alternate = null, u.flags |= pa)
        }

        function Wm(c, u, v) {
            return c !== null && (u.dependencies = c.dependencies), eie(), C5(u.lanes), rl(v, u.childLanes) ? (p7e(c, u), u.child) : null
        }

        function _De(c, u, v) {
            {
                var y = u.return;
                if (y === null) throw new Error("Cannot swap the root fiber.");
                if (c.alternate = null, u.alternate = null, v.index = u.index, v.sibling = u.sibling, v.return = u.return, v.ref = u.ref, u === y.child) y.child = v; else {
                    var E = y.child;
                    if (E === null) throw new Error("Expected parent to have a child.");
                    for (; E.sibling !== u;) if (E = E.sibling, E === null) throw new Error("Expected to find the previous sibling.");
                    E.sibling = v
                }
                var L = y.deletions;
                return L === null ? (y.deletions = [c], y.flags |= vh) : L.push(c), v.flags |= pa, v
            }
        }

        function lU(c, u) {
            var v = c.lanes;
            return !!rl(v, u)
        }

        function xDe(c, u, v) {
            switch (u.tag) {
                case p:
                    gie(u), x_();
                    break;
                case b:
                    Ene(u);
                    break;
                case f: {
                    var y = u.type;
                    Zp(y) && IR(u);
                    break
                }
                case g:
                    nF(u, u.stateNode.containerInfo);
                    break;
                case P: {
                    var E = u.memoizedProps.value, L = u.type._context;
                    vne(u, L, E);
                    break
                }
                case V: {
                    var Z = rl(v, u.childLanes);
                    Z && (u.flags |= Dn);
                    {
                        var se = u.stateNode;
                        se.effectDuration = 0, se.passiveEffectDuration = 0
                    }
                }
                    break;
                case Y: {
                    var he = u.memoizedState;
                    if (he !== null) {
                        if (he.dehydrated !== null) return Vg(u, I_(Rh.current)), u.flags |= Mr, null;
                        var we = u.child, _e = we.childLanes;
                        if (rl(v, _e)) return bie(c, u, v);
                        Vg(u, I_(Rh.current));
                        var Fe = Wm(c, u, v);
                        return Fe !== null ? Fe.sibling : null
                    } else Vg(u, I_(Rh.current));
                    break
                }
                case re: {
                    var Le = (c.flags & Mr) !== Ar, Qe = rl(v, u.childLanes);
                    if (Le) {
                        if (Qe) return xie(c, u, v);
                        u.flags |= Mr
                    }
                    var nt = u.memoizedState;
                    if (nt !== null && (nt.rendering = null, nt.tail = null, nt.lastEffect = null), Vg(u, Rh.current), Qe) break;
                    return null
                }
                case D:
                case x:
                    return u.lanes = mt, pie(c, u, v)
            }
            return Wm(c, u, v)
        }

        function Cie(c, u, v) {
            if (u._debugNeedsRemount && c !== null) return _De(c, u, $U(u.type, u.key, u.pendingProps, u._debugOwner || null, u.mode, u.lanes));
            if (c !== null) {
                var y = c.memoizedProps, E = u.pendingProps;
                if (y !== E || CR() || u.type !== c.type) Oh = !0; else {
                    var L = lU(c, v);
                    if (!L && (u.flags & Mr) === Ar) return Oh = !1, xDe(c, u, v);
                    (c.flags & _2) !== Ar ? Oh = !0 : Oh = !1
                }
            } else if (Oh = !1, Sc() && K9e(u)) {
                var Z = u.index, se = Y9e();
                ene(u, se, Z)
            }
            switch (u.lanes = mt, u.tag) {
                case d:
                    return iDe(c, u, u.type, v);
                case G: {
                    var he = u.elementType;
                    return rDe(c, u, he, v)
                }
                case l: {
                    var we = u.type, _e = u.pendingProps, Fe = u.elementType === we ? _e : Mh(we, _e);
                    return tU(c, u, we, Fe, v)
                }
                case f: {
                    var Le = u.type, Qe = u.pendingProps, nt = u.elementType === Le ? Qe : Mh(Le, Qe);
                    return vie(c, u, Le, nt, v)
                }
                case p:
                    return J7e(c, u, v);
                case b:
                    return eDe(c, u, v);
                case S:
                    return tDe(c, u);
                case Y:
                    return bie(c, u, v);
                case g:
                    return bDe(c, u, v);
                case F: {
                    var lt = u.type, qt = u.pendingProps, jr = u.elementType === lt ? qt : Mh(lt, qt);
                    return fie(c, u, lt, jr, v)
                }
                case T:
                    return X7e(c, u, v);
                case I:
                    return Q7e(c, u, v);
                case V:
                    return Z7e(c, u, v);
                case P:
                    return wDe(c, u, v);
                case N:
                    return SDe(c, u, v);
                case ee: {
                    var xr = u.type, ri = u.pendingProps, qn = Mh(xr, ri);
                    if (u.type !== u.elementType) {
                        var We = xr.propTypes;
                        We && Ah(We, qn, "prop", $n(xr))
                    }
                    return qn = Mh(xr.type, qn), die(c, u, xr, qn, v)
                }
                case oe:
                    return hie(c, u, u.type, u.pendingProps, v);
                case J: {
                    var ut = u.type, qe = u.pendingProps, At = u.elementType === ut ? qe : Mh(ut, qe);
                    return nDe(c, u, ut, At, v)
                }
                case re:
                    return xie(c, u, v);
                case M:
                    break;
                case D:
                    return pie(c, u, v)
            }
            throw new Error("Unknown unit of work tag (" + u.tag + "). This error is likely caused by a bug in React. Please file an issue.")
        }

        function P_(c) {
            c.flags |= Dn
        }

        function Aie(c) {
            c.flags |= pc, c.flags |= _g
        }

        var Iie, uU, kie, Rie;
        Iie = function (c, u, v, y) {
            for (var E = u.child; E !== null;) {
                if (E.tag === b || E.tag === S) WRe(c, E.stateNode); else if (E.tag !== g) {
                    if (E.child !== null) {
                        E.child.return = E, E = E.child;
                        continue
                    }
                }
                if (E === u) return;
                for (; E.sibling === null;) {
                    if (E.return === null || E.return === u) return;
                    E = E.return
                }
                E.sibling.return = E.return, E = E.sibling
            }
        }, uU = function (c, u) {
        }, kie = function (c, u, v, y, E) {
            var L = c.memoizedProps;
            if (L !== y) {
                var Z = u.stateNode, se = iF(), he = GRe(Z, v, L, y, E, se);
                u.updateQueue = he, he && P_(u)
            }
        }, Rie = function (c, u, v, y) {
            v !== y && P_(u)
        };

        function m5(c, u) {
            if (!Sc()) switch (c.tailMode) {
                case"hidden": {
                    for (var v = c.tail, y = null; v !== null;) v.alternate !== null && (y = v), v = v.sibling;
                    y === null ? c.tail = null : y.sibling = null;
                    break
                }
                case"collapsed": {
                    for (var E = c.tail, L = null; E !== null;) E.alternate !== null && (L = E), E = E.sibling;
                    L === null ? !u && c.tail !== null ? c.tail.sibling = null : c.tail = null : L.sibling = null;
                    break
                }
            }
        }

        function xc(c) {
            var u = c.alternate !== null && c.alternate.child === c.child, v = mt, y = Ar;
            if (u) {
                if ((c.mode & gi) !== $r) {
                    for (var he = c.selfBaseDuration, we = c.child; we !== null;) v = vn(v, vn(we.lanes, we.childLanes)), y |= we.subtreeFlags & mo, y |= we.flags & mo, he += we.treeBaseDuration, we = we.sibling;
                    c.treeBaseDuration = he
                } else for (var _e = c.child; _e !== null;) v = vn(v, vn(_e.lanes, _e.childLanes)), y |= _e.subtreeFlags & mo, y |= _e.flags & mo, _e.return = c, _e = _e.sibling;
                c.subtreeFlags |= y
            } else {
                if ((c.mode & gi) !== $r) {
                    for (var E = c.actualDuration, L = c.selfBaseDuration, Z = c.child; Z !== null;) v = vn(v, vn(Z.lanes, Z.childLanes)), y |= Z.subtreeFlags, y |= Z.flags, E += Z.actualDuration, L += Z.treeBaseDuration, Z = Z.sibling;
                    c.actualDuration = E, c.treeBaseDuration = L
                } else for (var se = c.child; se !== null;) v = vn(v, vn(se.lanes, se.childLanes)), y |= se.subtreeFlags, y |= se.flags, se.return = c, se = se.sibling;
                c.subtreeFlags |= y
            }
            return c.childLanes = v, u
        }

        function EDe(c, u, v) {
            if (c7e() && (u.mode & Mn) !== $r && (u.flags & Mr) === Ar) return sne(u), x_(), u.flags |= ai | Sg | Xo, !1;
            var y = OR(u);
            if (v !== null && v.dehydrated !== null) if (c === null) {
                if (!y) throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (o7e(u), xc(u), (u.mode & gi) !== $r) {
                    var E = v !== null;
                    if (E) {
                        var L = u.child;
                        L !== null && (u.treeBaseDuration -= L.treeBaseDuration)
                    }
                }
                return !1
            } else {
                if (x_(), (u.flags & Mr) === Ar && (u.memoizedState = null), u.flags |= Dn, xc(u), (u.mode & gi) !== $r) {
                    var Z = v !== null;
                    if (Z) {
                        var se = u.child;
                        se !== null && (u.treeBaseDuration -= se.treeBaseDuration)
                    }
                }
                return !1
            } else return cne(), !0
        }

        function Die(c, u, v) {
            var y = u.pendingProps;
            switch (L$(u), u.tag) {
                case d:
                case G:
                case oe:
                case l:
                case F:
                case T:
                case I:
                case V:
                case N:
                case ee:
                    return xc(u), null;
                case f: {
                    var E = u.type;
                    return Zp(E) && AR(u), xc(u), null
                }
                case p: {
                    var L = u.stateNode;
                    if (A_(u), M$(u), lF(), L.pendingContext && (L.context = L.pendingContext, L.pendingContext = null), c === null || c.child === null) {
                        var Z = OR(u);
                        if (Z) P_(u); else if (c !== null) {
                            var se = c.memoizedState;
                            (!se.isDehydrated || (u.flags & ai) !== Ar) && (u.flags |= Ha, cne())
                        }
                    }
                    return uU(c, u), xc(u), null
                }
                case b: {
                    aF(u);
                    var he = xne(), we = u.type;
                    if (c !== null && u.stateNode != null) kie(c, u, we, y, he), c.ref !== u.ref && Aie(u); else {
                        if (!y) {
                            if (u.stateNode === null) throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                            return xc(u), null
                        }
                        var _e = iF(), Fe = OR(u);
                        if (Fe) i7e(u, he, _e) && P_(u); else {
                            var Le = HRe(we, y, he, _e, u);
                            Iie(Le, u, !1, !1), u.stateNode = Le, qRe(Le, we, y, he) && P_(u)
                        }
                        u.ref !== null && Aie(u)
                    }
                    return xc(u), null
                }
                case S: {
                    var Qe = y;
                    if (c && u.stateNode != null) {
                        var nt = c.memoizedProps;
                        Rie(c, u, nt, Qe)
                    } else {
                        if (typeof Qe != "string" && u.stateNode === null) throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                        var lt = xne(), qt = iF(), jr = OR(u);
                        jr ? a7e(u) && P_(u) : u.stateNode = KRe(Qe, lt, qt, u)
                    }
                    return xc(u), null
                }
                case Y: {
                    k_(u);
                    var xr = u.memoizedState;
                    if (c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
                        var ri = EDe(c, u, xr);
                        if (!ri) return u.flags & Xo ? u : null
                    }
                    if ((u.flags & Mr) !== Ar) return u.lanes = v, (u.mode & gi) !== $r && PF(u), u;
                    var qn = xr !== null, We = c !== null && c.memoizedState !== null;
                    if (qn !== We && qn) {
                        var ut = u.child;
                        if (ut.flags |= Au, (u.mode & Mn) !== $r) {
                            var qe = c === null && (u.memoizedProps.unstable_avoidThisFallback !== !0 || !R);
                            qe || oF(Rh.current, Cne) ? EMe() : AU()
                        }
                    }
                    var At = u.updateQueue;
                    if (At !== null && (u.flags |= Dn), xc(u), (u.mode & gi) !== $r && qn) {
                        var tr = u.child;
                        tr !== null && (u.treeBaseDuration -= tr.treeBaseDuration)
                    }
                    return null
                }
                case g:
                    return A_(u), uU(c, u), c === null && j9e(u.stateNode.containerInfo), xc(u), null;
                case P:
                    var Kt = u.type._context;
                    return X$(Kt, u), xc(u), null;
                case J: {
                    var rn = u.type;
                    return Zp(rn) && AR(u), xc(u), null
                }
                case re: {
                    k_(u);
                    var dn = u.memoizedState;
                    if (dn === null) return xc(u), null;
                    var Yi = (u.flags & Mr) !== Ar, wi = dn.rendering;
                    if (wi === null) if (Yi) m5(dn, !1); else {
                        var Fo = CMe() && (c === null || (c.flags & Mr) === Ar);
                        if (!Fo) for (var Si = u.child; Si !== null;) {
                            var So = YR(Si);
                            if (So !== null) {
                                Yi = !0, u.flags |= Mr, m5(dn, !1);
                                var ll = So.updateQueue;
                                return ll !== null && (u.updateQueue = ll, u.flags |= Dn), u.subtreeFlags = Ar, m7e(u, v), Vg(u, sF(Rh.current, r5)), u.child
                            }
                            Si = Si.sibling
                        }
                        dn.tail !== null && Bo() > Zie() && (u.flags |= Mr, Yi = !0, m5(dn, !1), u.lanes = s6)
                    } else {
                        if (!Yi) {
                            var Ic = YR(wi);
                            if (Ic !== null) {
                                u.flags |= Mr, Yi = !0;
                                var Tf = Ic.updateQueue;
                                if (Tf !== null && (u.updateQueue = Tf, u.flags |= Dn), m5(dn, !0), dn.tail === null && dn.tailMode === "hidden" && !wi.alternate && !Sc()) return xc(u), null
                            } else Bo() * 2 - dn.renderingStartTime > Zie() && v !== tl && (u.flags |= Mr, Yi = !0, m5(dn, !1), u.lanes = s6)
                        }
                        if (dn.isBackwards) wi.sibling = u.child, u.child = wi; else {
                            var Kl = dn.last;
                            Kl !== null ? Kl.sibling = wi : u.child = wi, dn.last = wi
                        }
                    }
                    if (dn.tail !== null) {
                        var Yl = dn.tail;
                        dn.rendering = Yl, dn.tail = Yl.sibling, dn.renderingStartTime = Bo(), Yl.sibling = null;
                        var ul = Rh.current;
                        return Yi ? ul = sF(ul, r5) : ul = I_(ul), Vg(u, ul), Yl
                    }
                    return xc(u), null
                }
                case M:
                    break;
                case D:
                case x: {
                    CU(u);
                    var Xm = u.memoizedState, z_ = Xm !== null;
                    if (c !== null) {
                        var D5 = c.memoizedState, o0 = D5 !== null;
                        o0 !== z_ && !C && (u.flags |= Au)
                    }
                    return !z_ || (u.mode & Mn) === $r ? xc(u) : rl(a0, tl) && (xc(u), u.subtreeFlags & (pa | Dn) && (u.flags |= Au)), null
                }
                case A:
                    return null;
                case B:
                    return null
            }
            throw new Error("Unknown unit of work tag (" + u.tag + "). This error is likely caused by a bug in React. Please file an issue.")
        }

        function TDe(c, u, v) {
            switch (L$(u), u.tag) {
                case f: {
                    var y = u.type;
                    Zp(y) && AR(u);
                    var E = u.flags;
                    return E & Xo ? (u.flags = E & ~Xo | Mr, (u.mode & gi) !== $r && PF(u), u) : null
                }
                case p: {
                    A_(u), M$(u), lF();
                    var L = u.flags;
                    return (L & Xo) !== Ar && (L & Mr) === Ar ? (u.flags = L & ~Xo | Mr, u) : null
                }
                case b:
                    return aF(u), null;
                case Y: {
                    k_(u);
                    var Z = u.memoizedState;
                    if (Z !== null && Z.dehydrated !== null) {
                        if (u.alternate === null) throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                        x_()
                    }
                    var se = u.flags;
                    return se & Xo ? (u.flags = se & ~Xo | Mr, (u.mode & gi) !== $r && PF(u), u) : null
                }
                case re:
                    return k_(u), null;
                case g:
                    return A_(u), null;
                case P:
                    var he = u.type._context;
                    return X$(he, u), null;
                case D:
                case x:
                    return CU(u), null;
                case A:
                    return null;
                default:
                    return null
            }
        }

        function Mie(c, u, v) {
            switch (L$(u), u.tag) {
                case f: {
                    var y = u.type.childContextTypes;
                    y != null && AR(u);
                    break
                }
                case p: {
                    A_(u), M$(u), lF();
                    break
                }
                case b: {
                    aF(u);
                    break
                }
                case g:
                    A_(u);
                    break;
                case Y:
                    k_(u);
                    break;
                case re:
                    k_(u);
                    break;
                case P:
                    var E = u.type._context;
                    X$(E, u);
                    break;
                case D:
                case x:
                    CU(u);
                    break
            }
        }

        var Oie = null;
        Oie = new Set;
        var b9 = !1, Ec = !1, CDe = typeof WeakSet == "function" ? WeakSet : Set, pr = null, N_ = null, L_ = null;

        function ADe(c) {
            w2(null, function () {
                throw c
            }), gf()
        }

        var IDe = function (c, u) {
            if (u.props = c.memoizedProps, u.state = c.memoizedState, c.mode & gi) try {
                n0(), u.componentWillUnmount()
            } finally {
                r0(c)
            } else u.componentWillUnmount()
        };

        function Pie(c, u) {
            try {
                qg(bs, c)
            } catch (v) {
                xa(c, u, v)
            }
        }

        function fU(c, u, v) {
            try {
                IDe(c, v)
            } catch (y) {
                xa(c, u, y)
            }
        }

        function kDe(c, u, v) {
            try {
                v.componentDidMount()
            } catch (y) {
                xa(c, u, y)
            }
        }

        function Nie(c, u) {
            try {
                Bie(c)
            } catch (v) {
                xa(c, u, v)
            }
        }

        function B_(c, u) {
            var v = c.ref;
            if (v !== null) if (typeof v == "function") {
                var y;
                try {
                    if (c.mode & gi) try {
                        n0(), y = v(null)
                    } finally {
                        r0(c)
                    } else y = v(null)
                } catch (E) {
                    xa(c, u, E)
                }
                typeof y == "function" && o("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Lr(c))
            } else v.current = null
        }

        function w9(c, u, v) {
            try {
                v()
            } catch (y) {
                xa(c, u, y)
            }
        }

        var Lie = !1;

        function RDe(c, u) {
            zRe(), pr = u, DDe();
            var v = Lie;
            return Lie = !1, v
        }

        function DDe() {
            for (; pr !== null;) {
                var c = pr, u = c.child;
                (c.subtreeFlags & Lp) !== Ar && u !== null ? (u.return = c, pr = u) : MDe()
            }
        }

        function MDe() {
            for (; pr !== null;) {
                var c = pr;
                Fn(c);
                try {
                    ODe(c)
                } catch (v) {
                    xa(c, c.return, v)
                }
                Ii();
                var u = c.sibling;
                if (u !== null) {
                    u.return = c.return, pr = u;
                    return
                }
                pr = c.return
            }
        }

        function ODe(c) {
            var u = c.alternate, v = c.flags;
            if ((v & Ha) !== Ar) {
                switch (Fn(c), c.tag) {
                    case l:
                    case F:
                    case oe:
                        break;
                    case f: {
                        if (u !== null) {
                            var y = u.memoizedProps, E = u.memoizedState, L = c.stateNode;
                            c.type === c.elementType && !Ub && (L.props !== c.memoizedProps && o("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Lr(c) || "instance"), L.state !== c.memoizedState && o("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Lr(c) || "instance"));
                            var Z = L.getSnapshotBeforeUpdate(c.elementType === c.type ? y : Mh(c.type, y), E);
                            {
                                var se = Oie;
                                Z === void 0 && !se.has(c.type) && (se.add(c.type), o("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Lr(c)))
                            }
                            L.__reactInternalSnapshotBeforeUpdate = Z
                        }
                        break
                    }
                    case p: {
                        {
                            var he = c.stateNode;
                            h9e(he.containerInfo)
                        }
                        break
                    }
                    case b:
                    case S:
                    case g:
                    case J:
                        break;
                    default:
                        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")
                }
                Ii()
            }
        }

        function Ph(c, u, v) {
            var y = u.updateQueue, E = y !== null ? y.lastEffect : null;
            if (E !== null) {
                var L = E.next, Z = L;
                do {
                    if ((Z.tag & c) === c) {
                        var se = Z.destroy;
                        Z.destroy = void 0, se !== void 0 && ((c & _c) !== Bu ? Sh(u) : (c & bs) !== Bu && X1(u), (c & Jp) !== Bu && I5(!0), w9(u, v, se), (c & Jp) !== Bu && I5(!1), (c & _c) !== Bu ? Up() : (c & bs) !== Bu && a6())
                    }
                    Z = Z.next
                } while (Z !== L)
            }
        }

        function qg(c, u) {
            var v = u.updateQueue, y = v !== null ? v.lastEffect : null;
            if (y !== null) {
                var E = y.next, L = E;
                do {
                    if ((L.tag & c) === c) {
                        (c & _c) !== Bu ? i6(u) : (c & bs) !== Bu && I2(u);
                        var Z = L.create;
                        (c & Jp) !== Bu && I5(!0), L.destroy = Z(), (c & Jp) !== Bu && I5(!1), (c & _c) !== Bu ? Tk() : (c & bs) !== Bu && Ck();
                        {
                            var se = L.destroy;
                            if (se !== void 0 && typeof se != "function") {
                                var he = void 0;
                                (L.tag & bs) !== Ar ? he = "useLayoutEffect" : (L.tag & Jp) !== Ar ? he = "useInsertionEffect" : he = "useEffect";
                                var we = void 0;
                                se === null ? we = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof se.then == "function" ? we = `

It looks like you wrote ` + he + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + he + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : we = " You returned: " + se, o("%s must not return anything besides a function, which is used for clean-up.%s", he, we)
                            }
                        }
                    }
                    L = L.next
                } while (L !== E)
            }
        }

        function PDe(c, u) {
            if ((u.flags & Dn) !== Ar) switch (u.tag) {
                case V: {
                    var v = u.stateNode.passiveEffectDuration, y = u.memoizedProps, E = y.id, L = y.onPostCommit,
                        Z = Zne(), se = u.alternate === null ? "mount" : "update";
                    Qne() && (se = "nested-update"), typeof L == "function" && L(E, se, v, Z);
                    var he = u.return;
                    e:for (; he !== null;) {
                        switch (he.tag) {
                            case p:
                                var we = he.stateNode;
                                we.passiveEffectDuration += v;
                                break e;
                            case V:
                                var _e = he.stateNode;
                                _e.passiveEffectDuration += v;
                                break e
                        }
                        he = he.return
                    }
                    break
                }
            }
        }

        function NDe(c, u, v, y) {
            if ((v.flags & $p) !== Ar) switch (v.tag) {
                case l:
                case F:
                case oe: {
                    if (!Ec) if (v.mode & gi) try {
                        n0(), qg(bs | ys, v)
                    } finally {
                        r0(v)
                    } else qg(bs | ys, v);
                    break
                }
                case f: {
                    var E = v.stateNode;
                    if (v.flags & Dn && !Ec) if (u === null) if (v.type === v.elementType && !Ub && (E.props !== v.memoizedProps && o("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Lr(v) || "instance"), E.state !== v.memoizedState && o("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Lr(v) || "instance")), v.mode & gi) try {
                        n0(), E.componentDidMount()
                    } finally {
                        r0(v)
                    } else E.componentDidMount(); else {
                        var L = v.elementType === v.type ? u.memoizedProps : Mh(v.type, u.memoizedProps),
                            Z = u.memoizedState;
                        if (v.type === v.elementType && !Ub && (E.props !== v.memoizedProps && o("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Lr(v) || "instance"), E.state !== v.memoizedState && o("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Lr(v) || "instance")), v.mode & gi) try {
                            n0(), E.componentDidUpdate(L, Z, E.__reactInternalSnapshotBeforeUpdate)
                        } finally {
                            r0(v)
                        } else E.componentDidUpdate(L, Z, E.__reactInternalSnapshotBeforeUpdate)
                    }
                    var se = v.updateQueue;
                    se !== null && (v.type === v.elementType && !Ub && (E.props !== v.memoizedProps && o("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Lr(v) || "instance"), E.state !== v.memoizedState && o("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Lr(v) || "instance")), _ne(v, se, E));
                    break
                }
                case p: {
                    var he = v.updateQueue;
                    if (he !== null) {
                        var we = null;
                        if (v.child !== null) switch (v.child.tag) {
                            case b:
                                we = v.child.stateNode;
                                break;
                            case f:
                                we = v.child.stateNode;
                                break
                        }
                        _ne(v, he, we)
                    }
                    break
                }
                case b: {
                    var _e = v.stateNode;
                    if (u === null && v.flags & Dn) {
                        var Fe = v.type, Le = v.memoizedProps;
                        JRe(_e, Fe, Le)
                    }
                    break
                }
                case S:
                    break;
                case g:
                    break;
                case V: {
                    {
                        var Qe = v.memoizedProps, nt = Qe.onCommit, lt = Qe.onRender, qt = v.stateNode.effectDuration,
                            jr = Zne(), xr = u === null ? "mount" : "update";
                        Qne() && (xr = "nested-update"), typeof lt == "function" && lt(v.memoizedProps.id, xr, v.actualDuration, v.treeBaseDuration, v.actualStartTime, jr);
                        {
                            typeof nt == "function" && nt(v.memoizedProps.id, xr, qt, jr), DMe(v);
                            var ri = v.return;
                            e:for (; ri !== null;) {
                                switch (ri.tag) {
                                    case p:
                                        var qn = ri.stateNode;
                                        qn.effectDuration += qt;
                                        break e;
                                    case V:
                                        var We = ri.stateNode;
                                        We.effectDuration += qt;
                                        break e
                                }
                                ri = ri.return
                            }
                        }
                    }
                    break
                }
                case Y: {
                    zDe(c, v);
                    break
                }
                case re:
                case J:
                case M:
                case D:
                case x:
                case B:
                    break;
                default:
                    throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")
            }
            Ec || v.flags & pc && Bie(v)
        }

        function LDe(c) {
            switch (c.tag) {
                case l:
                case F:
                case oe: {
                    if (c.mode & gi) try {
                        n0(), Pie(c, c.return)
                    } finally {
                        r0(c)
                    } else Pie(c, c.return);
                    break
                }
                case f: {
                    var u = c.stateNode;
                    typeof u.componentDidMount == "function" && kDe(c, c.return, u), Nie(c, c.return);
                    break
                }
                case b: {
                    Nie(c, c.return);
                    break
                }
            }
        }

        function BDe(c, u) {
            for (var v = null, y = c; ;) {
                if (y.tag === b) {
                    if (v === null) {
                        v = y;
                        try {
                            var E = y.stateNode;
                            u ? l9e(E) : f9e(y.stateNode, y.memoizedProps)
                        } catch (Z) {
                            xa(c, c.return, Z)
                        }
                    }
                } else if (y.tag === S) {
                    if (v === null) try {
                        var L = y.stateNode;
                        u ? u9e(L) : d9e(L, y.memoizedProps)
                    } catch (Z) {
                        xa(c, c.return, Z)
                    }
                } else if (!((y.tag === D || y.tag === x) && y.memoizedState !== null && y !== c)) {
                    if (y.child !== null) {
                        y.child.return = y, y = y.child;
                        continue
                    }
                }
                if (y === c) return;
                for (; y.sibling === null;) {
                    if (y.return === null || y.return === c) return;
                    v === y && (v = null), y = y.return
                }
                v === y && (v = null), y.sibling.return = y.return, y = y.sibling
            }
        }

        function Bie(c) {
            var u = c.ref;
            if (u !== null) {
                var v = c.stateNode, y;
                switch (c.tag) {
                    case b:
                        y = v;
                        break;
                    default:
                        y = v
                }
                if (typeof u == "function") {
                    var E;
                    if (c.mode & gi) try {
                        n0(), E = u(y)
                    } finally {
                        r0(c)
                    } else E = u(y);
                    typeof E == "function" && o("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Lr(c))
                } else u.hasOwnProperty("current") || o("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Lr(c)), u.current = y
            }
        }

        function $De(c) {
            var u = c.alternate;
            u !== null && (u.return = null), c.return = null
        }

        function $ie(c) {
            var u = c.alternate;
            u !== null && (c.alternate = null, $ie(u));
            {
                if (c.child = null, c.deletions = null, c.sibling = null, c.tag === b) {
                    var v = c.stateNode;
                    v !== null && H9e(v)
                }
                c.stateNode = null, c._debugOwner = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null
            }
        }

        function FDe(c) {
            for (var u = c.return; u !== null;) {
                if (Fie(u)) return u;
                u = u.return
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.")
        }

        function Fie(c) {
            return c.tag === b || c.tag === p || c.tag === g
        }

        function Uie(c) {
            var u = c;
            e:for (; ;) {
                for (; u.sibling === null;) {
                    if (u.return === null || Fie(u.return)) return null;
                    u = u.return
                }
                for (u.sibling.return = u.return, u = u.sibling; u.tag !== b && u.tag !== S && u.tag !== ce;) {
                    if (u.flags & pa || u.child === null || u.tag === g) continue e;
                    u.child.return = u, u = u.child
                }
                if (!(u.flags & pa)) return u.stateNode
            }
        }

        function UDe(c) {
            var u = FDe(c);
            switch (u.tag) {
                case b: {
                    var v = u.stateNode;
                    u.flags & ud && (zre(v), u.flags &= ~ud);
                    var y = Uie(c);
                    hU(c, y, v);
                    break
                }
                case p:
                case g: {
                    var E = u.stateNode.containerInfo, L = Uie(c);
                    dU(c, L, E);
                    break
                }
                default:
                    throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.")
            }
        }

        function dU(c, u, v) {
            var y = c.tag, E = y === b || y === S;
            if (E) {
                var L = c.stateNode;
                u ? a9e(v, L, u) : n9e(v, L)
            } else if (y !== g) {
                var Z = c.child;
                if (Z !== null) {
                    dU(Z, u, v);
                    for (var se = Z.sibling; se !== null;) dU(se, u, v), se = se.sibling
                }
            }
        }

        function hU(c, u, v) {
            var y = c.tag, E = y === b || y === S;
            if (E) {
                var L = c.stateNode;
                u ? i9e(v, L, u) : r9e(v, L)
            } else if (y !== g) {
                var Z = c.child;
                if (Z !== null) {
                    hU(Z, u, v);
                    for (var se = Z.sibling; se !== null;) hU(se, u, v), se = se.sibling
                }
            }
        }

        var Tc = null, Nh = !1;

        function jDe(c, u, v) {
            {
                var y = u;
                e:for (; y !== null;) {
                    switch (y.tag) {
                        case b: {
                            Tc = y.stateNode, Nh = !1;
                            break e
                        }
                        case p: {
                            Tc = y.stateNode.containerInfo, Nh = !0;
                            break e
                        }
                        case g: {
                            Tc = y.stateNode.containerInfo, Nh = !0;
                            break e
                        }
                    }
                    y = y.return
                }
                if (Tc === null) throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                jie(c, u, v), Tc = null, Nh = !1
            }
            $De(v)
        }

        function Gg(c, u, v) {
            for (var y = v.child; y !== null;) jie(c, u, y), y = y.sibling
        }

        function jie(c, u, v) {
            switch (t6(v), v.tag) {
                case b:
                    Ec || B_(v, u);
                case S: {
                    {
                        var y = Tc, E = Nh;
                        Tc = null, Gg(c, u, v), Tc = y, Nh = E, Tc !== null && (Nh ? s9e(Tc, v.stateNode) : o9e(Tc, v.stateNode))
                    }
                    return
                }
                case ce: {
                    Tc !== null && (Nh ? c9e(Tc, v.stateNode) : E$(Tc, v.stateNode));
                    return
                }
                case g: {
                    {
                        var L = Tc, Z = Nh;
                        Tc = v.stateNode.containerInfo, Nh = !0, Gg(c, u, v), Tc = L, Nh = Z
                    }
                    return
                }
                case l:
                case F:
                case ee:
                case oe: {
                    if (!Ec) {
                        var se = v.updateQueue;
                        if (se !== null) {
                            var he = se.lastEffect;
                            if (he !== null) {
                                var we = he.next, _e = we;
                                do {
                                    var Fe = _e, Le = Fe.destroy, Qe = Fe.tag;
                                    Le !== void 0 && ((Qe & Jp) !== Bu ? w9(v, u, Le) : (Qe & bs) !== Bu && (X1(v), v.mode & gi ? (n0(), w9(v, u, Le), r0(v)) : w9(v, u, Le), a6())), _e = _e.next
                                } while (_e !== we)
                            }
                        }
                    }
                    Gg(c, u, v);
                    return
                }
                case f: {
                    if (!Ec) {
                        B_(v, u);
                        var nt = v.stateNode;
                        typeof nt.componentWillUnmount == "function" && fU(v, u, nt)
                    }
                    Gg(c, u, v);
                    return
                }
                case M: {
                    Gg(c, u, v);
                    return
                }
                case D: {
                    if (v.mode & Mn) {
                        var lt = Ec;
                        Ec = lt || v.memoizedState !== null, Gg(c, u, v), Ec = lt
                    } else Gg(c, u, v);
                    break
                }
                default: {
                    Gg(c, u, v);
                    return
                }
            }
        }

        function zDe(c, u) {
            var v = u.memoizedState;
            if (v === null) {
                var y = u.alternate;
                if (y !== null) {
                    var E = y.memoizedState;
                    if (E !== null) {
                        var L = E.dehydrated;
                        L !== null && A9e(L)
                    }
                }
            }
        }

        function zie(c) {
            var u = c.updateQueue;
            if (u !== null) {
                c.updateQueue = null;
                var v = c.stateNode;
                v === null && (v = c.stateNode = new CDe), u.forEach(function (y) {
                    var E = $Me.bind(null, c, y);
                    if (!v.has(y)) {
                        if (v.add(y), el) if (N_ !== null && L_ !== null) A5(L_, N_); else throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                        y.then(E, E)
                    }
                })
            }
        }

        function VDe(c, u, v) {
            N_ = v, L_ = c, Fn(u), Vie(u, c), Fn(u), N_ = null, L_ = null
        }

        function Lh(c, u, v) {
            var y = u.deletions;
            if (y !== null) for (var E = 0; E < y.length; E++) {
                var L = y[E];
                try {
                    jDe(c, u, L)
                } catch (he) {
                    xa(L, u, he)
                }
            }
            var Z = Tu();
            if (u.subtreeFlags & Bp) for (var se = u.child; se !== null;) Fn(se), Vie(se, c), se = se.sibling;
            Fn(Z)
        }

        function Vie(c, u, v) {
            var y = c.alternate, E = c.flags;
            switch (c.tag) {
                case l:
                case F:
                case ee:
                case oe: {
                    if (Lh(u, c), i0(c), E & Dn) {
                        try {
                            Ph(Jp | ys, c, c.return), qg(Jp | ys, c)
                        } catch (rn) {
                            xa(c, c.return, rn)
                        }
                        if (c.mode & gi) {
                            try {
                                n0(), Ph(bs | ys, c, c.return)
                            } catch (rn) {
                                xa(c, c.return, rn)
                            }
                            r0(c)
                        } else try {
                            Ph(bs | ys, c, c.return)
                        } catch (rn) {
                            xa(c, c.return, rn)
                        }
                    }
                    return
                }
                case f: {
                    Lh(u, c), i0(c), E & pc && y !== null && B_(y, y.return);
                    return
                }
                case b: {
                    Lh(u, c), i0(c), E & pc && y !== null && B_(y, y.return);
                    {
                        if (c.flags & ud) {
                            var L = c.stateNode;
                            try {
                                zre(L)
                            } catch (rn) {
                                xa(c, c.return, rn)
                            }
                        }
                        if (E & Dn) {
                            var Z = c.stateNode;
                            if (Z != null) {
                                var se = c.memoizedProps, he = y !== null ? y.memoizedProps : se, we = c.type,
                                    _e = c.updateQueue;
                                if (c.updateQueue = null, _e !== null) try {
                                    e9e(Z, _e, we, he, se)
                                } catch (rn) {
                                    xa(c, c.return, rn)
                                }
                            }
                        }
                    }
                    return
                }
                case S: {
                    if (Lh(u, c), i0(c), E & Dn) {
                        if (c.stateNode === null) throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                        var Fe = c.stateNode, Le = c.memoizedProps, Qe = y !== null ? y.memoizedProps : Le;
                        try {
                            t9e(Fe, Qe, Le)
                        } catch (rn) {
                            xa(c, c.return, rn)
                        }
                    }
                    return
                }
                case p: {
                    if (Lh(u, c), i0(c), E & Dn && y !== null) {
                        var nt = y.memoizedState;
                        if (nt.isDehydrated) try {
                            C9e(u.containerInfo)
                        } catch (rn) {
                            xa(c, c.return, rn)
                        }
                    }
                    return
                }
                case g: {
                    Lh(u, c), i0(c);
                    return
                }
                case Y: {
                    Lh(u, c), i0(c);
                    var lt = c.child;
                    if (lt.flags & Au) {
                        var qt = lt.stateNode, jr = lt.memoizedState, xr = jr !== null;
                        if (qt.isHidden = xr, xr) {
                            var ri = lt.alternate !== null && lt.alternate.memoizedState !== null;
                            ri || xMe()
                        }
                    }
                    E & Dn && zie(c);
                    return
                }
                case D: {
                    var qn = y !== null && y.memoizedState !== null;
                    if (c.mode & Mn) {
                        var We = Ec;
                        Ec = We || qn, Lh(u, c), Ec = We
                    } else Lh(u, c);
                    if (i0(c), E & Au) {
                        var ut = c.stateNode, qe = c.memoizedState, At = qe !== null, tr = c;
                        if (ut.isHidden = At, At && !qn && (tr.mode & Mn) !== $r) {
                            pr = tr;
                            for (var Kt = tr.child; Kt !== null;) pr = Kt, WDe(Kt), Kt = Kt.sibling
                        }
                        BDe(tr, At)
                    }
                    return
                }
                case re: {
                    Lh(u, c), i0(c), E & Dn && zie(c);
                    return
                }
                case M:
                    return;
                default: {
                    Lh(u, c), i0(c);
                    return
                }
            }
        }

        function i0(c) {
            var u = c.flags;
            if (u & pa) {
                try {
                    UDe(c)
                } catch (v) {
                    xa(c, c.return, v)
                }
                c.flags &= ~pa
            }
            u & mc && (c.flags &= ~mc)
        }

        function HDe(c, u, v) {
            N_ = v, L_ = u, pr = c, Hie(c, u), N_ = null, L_ = null
        }

        function Hie(c, u, v) {
            for (var y = (c.mode & Mn) !== $r; pr !== null;) {
                var E = pr, L = E.child;
                if (E.tag === D && y) {
                    var Z = E.memoizedState !== null, se = Z || b9;
                    if (se) {
                        pU(c, u);
                        continue
                    } else {
                        var he = E.alternate, we = he !== null && he.memoizedState !== null, _e = we || Ec, Fe = b9,
                            Le = Ec;
                        b9 = se, Ec = _e, Ec && !Le && (pr = E, qDe(E));
                        for (var Qe = L; Qe !== null;) pr = Qe, Hie(Qe, u), Qe = Qe.sibling;
                        pr = E, b9 = Fe, Ec = Le, pU(c, u);
                        continue
                    }
                }
                (E.subtreeFlags & $p) !== Ar && L !== null ? (L.return = E, pr = L) : pU(c, u)
            }
        }

        function pU(c, u, v) {
            for (; pr !== null;) {
                var y = pr;
                if ((y.flags & $p) !== Ar) {
                    var E = y.alternate;
                    Fn(y);
                    try {
                        NDe(u, E, y)
                    } catch (Z) {
                        xa(y, y.return, Z)
                    }
                    Ii()
                }
                if (y === c) {
                    pr = null;
                    return
                }
                var L = y.sibling;
                if (L !== null) {
                    L.return = y.return, pr = L;
                    return
                }
                pr = y.return
            }
        }

        function WDe(c) {
            for (; pr !== null;) {
                var u = pr, v = u.child;
                switch (u.tag) {
                    case l:
                    case F:
                    case ee:
                    case oe: {
                        if (u.mode & gi) try {
                            n0(), Ph(bs, u, u.return)
                        } finally {
                            r0(u)
                        } else Ph(bs, u, u.return);
                        break
                    }
                    case f: {
                        B_(u, u.return);
                        var y = u.stateNode;
                        typeof y.componentWillUnmount == "function" && fU(u, u.return, y);
                        break
                    }
                    case b: {
                        B_(u, u.return);
                        break
                    }
                    case D: {
                        var E = u.memoizedState !== null;
                        if (E) {
                            Wie(c);
                            continue
                        }
                        break
                    }
                }
                v !== null ? (v.return = u, pr = v) : Wie(c)
            }
        }

        function Wie(c) {
            for (; pr !== null;) {
                var u = pr;
                if (u === c) {
                    pr = null;
                    return
                }
                var v = u.sibling;
                if (v !== null) {
                    v.return = u.return, pr = v;
                    return
                }
                pr = u.return
            }
        }

        function qDe(c) {
            for (; pr !== null;) {
                var u = pr, v = u.child;
                if (u.tag === D) {
                    var y = u.memoizedState !== null;
                    if (y) {
                        qie(c);
                        continue
                    }
                }
                v !== null ? (v.return = u, pr = v) : qie(c)
            }
        }

        function qie(c) {
            for (; pr !== null;) {
                var u = pr;
                Fn(u);
                try {
                    LDe(u)
                } catch (y) {
                    xa(u, u.return, y)
                }
                if (Ii(), u === c) {
                    pr = null;
                    return
                }
                var v = u.sibling;
                if (v !== null) {
                    v.return = u.return, pr = v;
                    return
                }
                pr = u.return
            }
        }

        function GDe(c, u, v, y) {
            pr = u, KDe(u, c)
        }

        function KDe(c, u, v, y) {
            for (; pr !== null;) {
                var E = pr, L = E.child;
                (E.subtreeFlags & bh) !== Ar && L !== null ? (L.return = E, pr = L) : YDe(c, u)
            }
        }

        function YDe(c, u, v, y) {
            for (; pr !== null;) {
                var E = pr;
                if ((E.flags & wa) !== Ar) {
                    Fn(E);
                    try {
                        XDe(u, E)
                    } catch (Z) {
                        xa(E, E.return, Z)
                    }
                    Ii()
                }
                if (E === c) {
                    pr = null;
                    return
                }
                var L = E.sibling;
                if (L !== null) {
                    L.return = E.return, pr = L;
                    return
                }
                pr = E.return
            }
        }

        function XDe(c, u, v, y) {
            switch (u.tag) {
                case l:
                case F:
                case oe: {
                    if (u.mode & gi) {
                        OF();
                        try {
                            qg(_c | ys, u)
                        } finally {
                            MF(u)
                        }
                    } else qg(_c | ys, u);
                    break
                }
            }
        }

        function QDe(c) {
            pr = c, ZDe()
        }

        function ZDe() {
            for (; pr !== null;) {
                var c = pr, u = c.child;
                if ((pr.flags & vh) !== Ar) {
                    var v = c.deletions;
                    if (v !== null) {
                        for (var y = 0; y < v.length; y++) {
                            var E = v[y];
                            pr = E, tMe(E, c)
                        }
                        {
                            var L = c.alternate;
                            if (L !== null) {
                                var Z = L.child;
                                if (Z !== null) {
                                    L.child = null;
                                    do {
                                        var se = Z.sibling;
                                        Z.sibling = null, Z = se
                                    } while (Z !== null)
                                }
                            }
                        }
                        pr = c
                    }
                }
                (c.subtreeFlags & bh) !== Ar && u !== null ? (u.return = c, pr = u) : JDe()
            }
        }

        function JDe() {
            for (; pr !== null;) {
                var c = pr;
                (c.flags & wa) !== Ar && (Fn(c), eMe(c), Ii());
                var u = c.sibling;
                if (u !== null) {
                    u.return = c.return, pr = u;
                    return
                }
                pr = c.return
            }
        }

        function eMe(c) {
            switch (c.tag) {
                case l:
                case F:
                case oe: {
                    c.mode & gi ? (OF(), Ph(_c | ys, c, c.return), MF(c)) : Ph(_c | ys, c, c.return);
                    break
                }
            }
        }

        function tMe(c, u) {
            for (; pr !== null;) {
                var v = pr;
                Fn(v), nMe(v, u), Ii();
                var y = v.child;
                y !== null ? (y.return = v, pr = y) : rMe(c)
            }
        }

        function rMe(c) {
            for (; pr !== null;) {
                var u = pr, v = u.sibling, y = u.return;
                if ($ie(u), u === c) {
                    pr = null;
                    return
                }
                if (v !== null) {
                    v.return = y, pr = v;
                    return
                }
                pr = y
            }
        }

        function nMe(c, u) {
            switch (c.tag) {
                case l:
                case F:
                case oe: {
                    c.mode & gi ? (OF(), Ph(_c, c, u), MF(c)) : Ph(_c, c, u);
                    break
                }
            }
        }

        function iMe(c) {
            switch (c.tag) {
                case l:
                case F:
                case oe: {
                    try {
                        qg(bs | ys, c)
                    } catch (v) {
                        xa(c, c.return, v)
                    }
                    break
                }
                case f: {
                    var u = c.stateNode;
                    try {
                        u.componentDidMount()
                    } catch (v) {
                        xa(c, c.return, v)
                    }
                    break
                }
            }
        }

        function aMe(c) {
            switch (c.tag) {
                case l:
                case F:
                case oe: {
                    try {
                        qg(_c | ys, c)
                    } catch (u) {
                        xa(c, c.return, u)
                    }
                    break
                }
            }
        }

        function oMe(c) {
            switch (c.tag) {
                case l:
                case F:
                case oe: {
                    try {
                        Ph(bs | ys, c, c.return)
                    } catch (v) {
                        xa(c, c.return, v)
                    }
                    break
                }
                case f: {
                    var u = c.stateNode;
                    typeof u.componentWillUnmount == "function" && fU(c, c.return, u);
                    break
                }
            }
        }

        function sMe(c) {
            switch (c.tag) {
                case l:
                case F:
                case oe:
                    try {
                        Ph(_c | ys, c, c.return)
                    } catch (u) {
                        xa(c, c.return, u)
                    }
            }
        }

        if (typeof Symbol == "function" && Symbol.for) {
            var v5 = Symbol.for;
            v5("selector.component"), v5("selector.has_pseudo_class"), v5("selector.role"), v5("selector.test_id"), v5("selector.text")
        }
        var cMe = [];

        function lMe() {
            cMe.forEach(function (c) {
                return c()
            })
        }

        var uMe = r.ReactCurrentActQueue;

        function fMe(c) {
            {
                var u = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0,
                    v = typeof jest < "u";
                return v && u !== !1
            }
        }

        function Gie() {
            {
                var c = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
                return !c && uMe.current !== null && o("The current testing environment is not configured to support act(...)"), c
            }
        }

        var dMe = Math.ceil, mU = r.ReactCurrentDispatcher, vU = r.ReactCurrentOwner, Cc = r.ReactCurrentBatchConfig,
            Bh = r.ReactCurrentActQueue, _s = 0, Kie = 1, Ac = 2, Cd = 4, qm = 0, g5 = 1, jb = 2, S9 = 3, y5 = 4,
            Yie = 5, gU = 6, ti = _s, ql = null, ao = null, xs = mt, a0 = mt, yU = Bg(mt), Es = qm, b5 = null, _9 = mt,
            w5 = mt, x9 = mt, S5 = null, $u = null, bU = 0, Xie = 500, Qie = 1 / 0, hMe = 500, Gm = null;

        function _5() {
            Qie = Bo() + hMe
        }

        function Zie() {
            return Qie
        }

        var E9 = !1, wU = null, $_ = null, zb = !1, Kg = null, x5 = mt, SU = [], pMe = 50, E5 = 0, _U = null, xU = !1,
            T9 = !1, mMe = 50, F_ = 0, C9 = null, T5 = ea, A9 = mt, Jie = !1;

        function I9() {
            return ql
        }

        function Gl() {
            return (ti & (Ac | Cd)) !== _s ? Bo() : (T5 !== ea || (T5 = Bo()), T5)
        }

        function Yg(c) {
            var u = c.mode;
            if ((u & Mn) === $r) return Xr;
            if ((ti & Ac) !== _s && xs !== mt) return lb(xs);
            var v = f7e() !== u7e;
            if (v) {
                if (Cc.transition !== null) {
                    var y = Cc.transition;
                    y._updatedFibers || (y._updatedFibers = new Set), y._updatedFibers.add(c)
                }
                return A9 === pi && (A9 = h6()), A9
            }
            var E = Ou();
            if (E !== pi) return E;
            var L = YRe();
            return L
        }

        function vMe(c) {
            var u = c.mode;
            return (u & Mn) === $r ? Xr : Mk()
        }

        function Ts(c, u, v, y) {
            UMe(), Jie && o("useInsertionEffect must not schedule updates."), xU && (T9 = !0), Cg(c, v, y), (ti & Ac) !== mt && c === ql ? VMe(u) : (el && db(c, u, v), HMe(u), c === ql && ((ti & Ac) === _s && (w5 = vn(w5, v)), Es === y5 && Xg(c, xs)), Fu(c, y), v === Xr && ti === _s && (u.mode & Mn) === $r && !Bh.isBatchingLegacy && (_5(), Jre()))
        }

        function gMe(c, u, v) {
            var y = c.current;
            y.lanes = u, Cg(c, u, v), Fu(c, v)
        }

        function yMe(c) {
            return (ti & Ac) !== _s
        }

        function Fu(c, u) {
            var v = c.callbackNode;
            K2(c, u);
            var y = G2(c, c === ql ? xs : mt);
            if (y === mt) {
                v !== null && mae(v), c.callbackNode = null, c.callbackPriority = pi;
                return
            }
            var E = Vp(y), L = c.callbackPriority;
            if (L === E && !(Bh.current !== null && v !== RU)) {
                v == null && L !== Xr && o("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                return
            }
            v != null && mae(v);
            var Z;
            if (E === Xr) c.tag === $g ? (Bh.isBatchingLegacy !== null && (Bh.didScheduleLegacyUpdate = !0), G9e(rae.bind(null, c))) : Zre(rae.bind(null, c)), Bh.current !== null ? Bh.current.push(Fg) : QRe(function () {
                (ti & (Ac | Cd)) === _s && Fg()
            }), Z = null; else {
                var se;
                switch (Fk(y)) {
                    case vc:
                        se = Y1;
                        break;
                    case vd:
                        se = Fp;
                        break;
                    case Du:
                        se = wh;
                        break;
                    case Mu:
                        se = wm;
                        break;
                    default:
                        se = wh;
                        break
                }
                Z = DU(se, eae.bind(null, c))
            }
            c.callbackPriority = E, c.callbackNode = Z
        }

        function eae(c, u) {
            if (B7e(), T5 = ea, A9 = mt, (ti & (Ac | Cd)) !== _s) throw new Error("Should not already be working.");
            var v = c.callbackNode, y = Ym();
            if (y && c.callbackNode !== v) return null;
            var E = G2(c, c === ql ? xs : mt);
            if (E === mt) return null;
            var L = !X2(c, E) && !Dk(c, E) && !u, Z = L ? IMe(c, E) : R9(c, E);
            if (Z !== qm) {
                if (Z === jb) {
                    var se = Y2(c);
                    se !== mt && (E = se, Z = EU(c, se))
                }
                if (Z === g5) {
                    var he = b5;
                    throw Vb(c, mt), Xg(c, E), Fu(c, Bo()), he
                }
                if (Z === gU) Xg(c, E); else {
                    var we = !X2(c, E), _e = c.current.alternate;
                    if (we && !wMe(_e)) {
                        if (Z = R9(c, E), Z === jb) {
                            var Fe = Y2(c);
                            Fe !== mt && (E = Fe, Z = EU(c, Fe))
                        }
                        if (Z === g5) {
                            var Le = b5;
                            throw Vb(c, mt), Xg(c, E), Fu(c, Bo()), Le
                        }
                    }
                    c.finishedWork = _e, c.finishedLanes = E, bMe(c, Z, E)
                }
            }
            return Fu(c, Bo()), c.callbackNode === v ? eae.bind(null, c) : null
        }

        function EU(c, u) {
            var v = S5;
            if (J2(c)) {
                var y = Vb(c, u);
                y.flags |= ai, U9e(c.containerInfo)
            }
            var E = R9(c, u);
            if (E !== jb) {
                var L = $u;
                $u = v, L !== null && tae(L)
            }
            return E
        }

        function tae(c) {
            $u === null ? $u = c : $u.push.apply($u, c)
        }

        function bMe(c, u, v) {
            switch (u) {
                case qm:
                case g5:
                    throw new Error("Root did not complete. This is a bug in React.");
                case jb: {
                    Hb(c, $u, Gm);
                    break
                }
                case S9: {
                    if (Xg(c, v), Dm(v) && !vae()) {
                        var y = bU + Xie - Bo();
                        if (y > 10) {
                            var E = G2(c, mt);
                            if (E !== mt) break;
                            var L = c.suspendedLanes;
                            if (!Mm(L, v)) {
                                Gl(), Q2(c, L);
                                break
                            }
                            c.timeoutHandle = _$(Hb.bind(null, c, $u, Gm), y);
                            break
                        }
                    }
                    Hb(c, $u, Gm);
                    break
                }
                case y5: {
                    if (Xg(c, v), f6(v)) break;
                    if (!vae()) {
                        var Z = wf(c, v), se = Z, he = Bo() - se, we = FMe(he) - he;
                        if (we > 10) {
                            c.timeoutHandle = _$(Hb.bind(null, c, $u, Gm), we);
                            break
                        }
                    }
                    Hb(c, $u, Gm);
                    break
                }
                case Yie: {
                    Hb(c, $u, Gm);
                    break
                }
                default:
                    throw new Error("Unknown root exit status.")
            }
        }

        function wMe(c) {
            for (var u = c; ;) {
                if (u.flags & ps) {
                    var v = u.updateQueue;
                    if (v !== null) {
                        var y = v.stores;
                        if (y !== null) for (var E = 0; E < y.length; E++) {
                            var L = y[E], Z = L.getSnapshot, se = L.value;
                            try {
                                if (!St(Z(), se)) return !1
                            } catch {
                                return !1
                            }
                        }
                    }
                }
                var he = u.child;
                if (u.subtreeFlags & ps && he !== null) {
                    he.return = u, u = he;
                    continue
                }
                if (u === c) return !0;
                for (; u.sibling === null;) {
                    if (u.return === null || u.return === c) return !0;
                    u = u.return
                }
                u.sibling.return = u.return, u = u.sibling
            }
            return !0
        }

        function Xg(c, u) {
            u = ub(u, x9), u = ub(u, w5), Nk(c, u)
        }

        function rae(c) {
            if ($7e(), (ti & (Ac | Cd)) !== _s) throw new Error("Should not already be working.");
            Ym();
            var u = G2(c, mt);
            if (!rl(u, Xr)) return Fu(c, Bo()), null;
            var v = R9(c, u);
            if (c.tag !== $g && v === jb) {
                var y = Y2(c);
                y !== mt && (u = y, v = EU(c, y))
            }
            if (v === g5) {
                var E = b5;
                throw Vb(c, mt), Xg(c, u), Fu(c, Bo()), E
            }
            if (v === gU) throw new Error("Root did not complete. This is a bug in React.");
            var L = c.current.alternate;
            return c.finishedWork = L, c.finishedLanes = u, Hb(c, $u, Gm), Fu(c, Bo()), null
        }

        function SMe(c, u) {
            u !== mt && (Z2(c, vn(u, Xr)), Fu(c, Bo()), (ti & (Ac | Cd)) === _s && (_5(), Fg()))
        }

        function TU(c, u) {
            var v = ti;
            ti |= Kie;
            try {
                return c(u)
            } finally {
                ti = v, ti === _s && !Bh.isBatchingLegacy && (_5(), Jre())
            }
        }

        function _Me(c, u, v, y, E) {
            var L = Ou(), Z = Cc.transition;
            try {
                return Cc.transition = null, yo(vc), c(u, v, y, E)
            } finally {
                yo(L), Cc.transition = Z, ti === _s && _5()
            }
        }

        function Km(c) {
            Kg !== null && Kg.tag === $g && (ti & (Ac | Cd)) === _s && Ym();
            var u = ti;
            ti |= Kie;
            var v = Cc.transition, y = Ou();
            try {
                return Cc.transition = null, yo(vc), c ? c() : void 0
            } finally {
                yo(y), Cc.transition = v, ti = u, (ti & (Ac | Cd)) === _s && Fg()
            }
        }

        function nae() {
            return (ti & (Ac | Cd)) !== _s
        }

        function k9(c, u) {
            sl(yU, a0, c), a0 = vn(a0, u)
        }

        function CU(c) {
            a0 = yU.current, ol(yU, c)
        }

        function Vb(c, u) {
            c.finishedWork = null, c.finishedLanes = mt;
            var v = c.timeoutHandle;
            if (v !== x$ && (c.timeoutHandle = x$, XRe(v)), ao !== null) for (var y = ao.return; y !== null;) {
                var E = y.alternate;
                Mie(E, y), y = y.return
            }
            ql = c;
            var L = Wb(c.current, null);
            return ao = L, xs = a0 = u, Es = qm, b5 = null, _9 = mt, w5 = mt, x9 = mt, S5 = null, $u = null, y7e(), kh.discardPendingWarnings(), L
        }

        function iae(c, u) {
            do {
                var v = ao;
                try {
                    if (FR(), Ine(), Ii(), vU.current = null, v === null || v.return === null) {
                        Es = g5, b5 = u, ao = null;
                        return
                    }
                    if (v.mode & gi && p9(v, !0), zl(), u !== null && typeof u == "object" && typeof u.then == "function") {
                        var y = u;
                        md(v, y, xs)
                    } else Q1(v, u, xs);
                    G7e(c, v.return, v, u, xs), cae(v)
                } catch (E) {
                    u = E, ao === v && v !== null ? (v = v.return, ao = v) : v = ao;
                    continue
                }
                return
            } while (!0)
        }

        function aae() {
            var c = mU.current;
            return mU.current = l9, c === null ? l9 : c
        }

        function oae(c) {
            mU.current = c
        }

        function xMe() {
            bU = Bo()
        }

        function C5(c) {
            _9 = vn(c, _9)
        }

        function EMe() {
            Es === qm && (Es = S9)
        }

        function AU() {
            (Es === qm || Es === S9 || Es === jb) && (Es = y5), ql !== null && (cb(_9) || cb(w5)) && Xg(ql, xs)
        }

        function TMe(c) {
            Es !== y5 && (Es = jb), S5 === null ? S5 = [c] : S5.push(c)
        }

        function CMe() {
            return Es === qm
        }

        function R9(c, u) {
            var v = ti;
            ti |= Ac;
            var y = aae();
            if (ql !== c || xs !== u) {
                if (el) {
                    var E = c.memoizedUpdaters;
                    E.size > 0 && (A5(c, xs), E.clear()), Lk(c, u)
                }
                Gm = g6(), Vb(c, u)
            }
            Em(u);
            do try {
                AMe();
                break
            } catch (L) {
                iae(c, L)
            } while (!0);
            if (FR(), ti = v, oae(y), ao !== null) throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            return k2(), ql = null, xs = mt, Es
        }

        function AMe() {
            for (; ao !== null;) sae(ao)
        }

        function IMe(c, u) {
            var v = ti;
            ti |= Ac;
            var y = aae();
            if (ql !== c || xs !== u) {
                if (el) {
                    var E = c.memoizedUpdaters;
                    E.size > 0 && (A5(c, xs), E.clear()), Lk(c, u)
                }
                Gm = g6(), _5(), Vb(c, u)
            }
            Em(u);
            do try {
                kMe();
                break
            } catch (L) {
                iae(c, L)
            } while (!0);
            return FR(), oae(y), ti = v, ao !== null ? (Ak(), qm) : (k2(), ql = null, xs = mt, Es)
        }

        function kMe() {
            for (; ao !== null && !X3();) sae(ao)
        }

        function sae(c) {
            var u = c.alternate;
            Fn(c);
            var v;
            (c.mode & gi) !== $r ? (DF(c), v = IU(u, c, a0), p9(c, !0)) : v = IU(u, c, a0), Ii(), c.memoizedProps = c.pendingProps, v === null ? cae(c) : ao = v, vU.current = null
        }

        function cae(c) {
            var u = c;
            do {
                var v = u.alternate, y = u.return;
                if ((u.flags & Sg) === Ar) {
                    Fn(u);
                    var E = void 0;
                    if ((u.mode & gi) === $r ? E = Die(v, u, a0) : (DF(u), E = Die(v, u, a0), p9(u, !1)), Ii(), E !== null) {
                        ao = E;
                        return
                    }
                } else {
                    var L = TDe(v, u);
                    if (L !== null) {
                        L.flags &= Sk, ao = L;
                        return
                    }
                    if ((u.mode & gi) !== $r) {
                        p9(u, !1);
                        for (var Z = u.actualDuration, se = u.child; se !== null;) Z += se.actualDuration, se = se.sibling;
                        u.actualDuration = Z
                    }
                    if (y !== null) y.flags |= Sg, y.subtreeFlags = Ar, y.deletions = null; else {
                        Es = gU, ao = null;
                        return
                    }
                }
                var he = u.sibling;
                if (he !== null) {
                    ao = he;
                    return
                }
                u = y, ao = u
            } while (u !== null);
            Es === qm && (Es = Yie)
        }

        function Hb(c, u, v) {
            var y = Ou(), E = Cc.transition;
            try {
                Cc.transition = null, yo(vc), RMe(c, u, v, y)
            } finally {
                Cc.transition = E, yo(y)
            }
            return null
        }

        function RMe(c, u, v, y) {
            do Ym(); while (Kg !== null);
            if (jMe(), (ti & (Ac | Cd)) !== _s) throw new Error("Should not already be working.");
            var E = c.finishedWork, L = c.finishedLanes;
            if (r6(L), E === null) return n6(), null;
            if (L === mt && o("root.finishedLanes should not be empty during a commit. This is a bug in React."), c.finishedWork = null, c.finishedLanes = mt, E === c.current) throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            c.callbackNode = null, c.callbackPriority = pi;
            var Z = vn(E.lanes, E.childLanes);
            m6(c, Z), c === ql && (ql = null, ao = null, xs = mt), ((E.subtreeFlags & bh) !== Ar || (E.flags & bh) !== Ar) && (zb || (zb = !0, DU(wh, function () {
                return Ym(), null
            })));
            var se = (E.subtreeFlags & (Lp | Bp | $p | bh)) !== Ar, he = (E.flags & (Lp | Bp | $p | bh)) !== Ar;
            if (se || he) {
                var we = Cc.transition;
                Cc.transition = null;
                var _e = Ou();
                yo(vc);
                var Fe = ti;
                ti |= Cd, vU.current = null, RDe(c, E), Jne(), VDe(c, E, L), VRe(), c.current = E, Z1(L), HDe(E, c, L), J1(), Q3(), ti = Fe, yo(_e), Cc.transition = we
            } else c.current = E, Jne();
            var Le = zb;
            if (zb ? (zb = !1, Kg = c, x5 = L) : (F_ = 0, C9 = null), Z = c.pendingLanes, Z === mt && ($_ = null), Le || dae(c.current, !1), J3(E.stateNode, y), el && c.memoizedUpdaters.clear(), lMe(), Fu(c, Bo()), u !== null) for (var Qe = c.onRecoverableError, nt = 0; nt < u.length; nt++) {
                var lt = u[nt], qt = lt.stack, jr = lt.digest;
                Qe(lt.value, {componentStack: qt, digest: jr})
            }
            if (E9) {
                E9 = !1;
                var xr = wU;
                throw wU = null, xr
            }
            return rl(x5, Xr) && c.tag !== $g && Ym(), Z = c.pendingLanes, rl(Z, Xr) ? (L7e(), c === _U ? E5++ : (E5 = 0, _U = c)) : E5 = 0, Fg(), n6(), null
        }

        function Ym() {
            if (Kg !== null) {
                var c = Fk(x5), u = pb(Du, c), v = Cc.transition, y = Ou();
                try {
                    return Cc.transition = null, yo(u), MMe()
                } finally {
                    yo(y), Cc.transition = v
                }
            }
            return !1
        }

        function DMe(c) {
            SU.push(c), zb || (zb = !0, DU(wh, function () {
                return Ym(), null
            }))
        }

        function MMe() {
            if (Kg === null) return !1;
            var c = Kg, u = x5;
            if (Kg = null, x5 = mt, (ti & (Ac | Cd)) !== _s) throw new Error("Cannot flush passive effects while already rendering.");
            xU = !0, T9 = !1, xm(u);
            var v = ti;
            ti |= Cd, QDe(c.current), GDe(c, c.current);
            {
                var y = SU;
                SU = [];
                for (var E = 0; E < y.length; E++) {
                    var L = y[E];
                    PDe(c, L)
                }
            }
            o6(), dae(c.current, !0), ti = v, Fg(), T9 ? c === C9 ? F_++ : (F_ = 0, C9 = c) : F_ = 0, xU = !1, T9 = !1, e6(c);
            {
                var Z = c.current.stateNode;
                Z.effectDuration = 0, Z.passiveEffectDuration = 0
            }
            return !0
        }

        function lae(c) {
            return $_ !== null && $_.has(c)
        }

        function OMe(c) {
            $_ === null ? $_ = new Set([c]) : $_.add(c)
        }

        function PMe(c) {
            E9 || (E9 = !0, wU = c)
        }

        var NMe = PMe;

        function uae(c, u, v) {
            var y = Fb(v, u), E = sie(c, y, Xr), L = jg(c, E, Xr), Z = Gl();
            L !== null && (Cg(L, Xr, Z), Fu(L, Z))
        }

        function xa(c, u, v) {
            if (ADe(v), I5(!1), c.tag === p) {
                uae(c, c, v);
                return
            }
            var y = null;
            for (y = u; y !== null;) {
                if (y.tag === p) {
                    uae(y, c, v);
                    return
                } else if (y.tag === f) {
                    var E = y.type, L = y.stateNode;
                    if (typeof E.getDerivedStateFromError == "function" || typeof L.componentDidCatch == "function" && !lae(L)) {
                        var Z = Fb(v, c), se = YF(y, Z, Xr), he = jg(y, se, Xr), we = Gl();
                        he !== null && (Cg(he, Xr, we), Fu(he, we));
                        return
                    }
                }
                y = y.return
            }
            o(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, v)
        }

        function LMe(c, u, v) {
            var y = c.pingCache;
            y !== null && y.delete(u);
            var E = Gl();
            Q2(c, v), WMe(c), ql === c && Mm(xs, v) && (Es === y5 || Es === S9 && Dm(xs) && Bo() - bU < Xie ? Vb(c, mt) : x9 = vn(x9, v)), Fu(c, E)
        }

        function fae(c, u) {
            u === pi && (u = vMe(c));
            var v = Gl(), y = Lu(c, u);
            y !== null && (Cg(y, u, v), Fu(y, v))
        }

        function BMe(c) {
            var u = c.memoizedState, v = pi;
            u !== null && (v = u.retryLane), fae(c, v)
        }

        function $Me(c, u) {
            var v = pi, y;
            switch (c.tag) {
                case Y:
                    y = c.stateNode;
                    var E = c.memoizedState;
                    E !== null && (v = E.retryLane);
                    break;
                case re:
                    y = c.stateNode;
                    break;
                default:
                    throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.")
            }
            y !== null && y.delete(u), fae(c, v)
        }

        function FMe(c) {
            return c < 120 ? 120 : c < 480 ? 480 : c < 1080 ? 1080 : c < 1920 ? 1920 : c < 3e3 ? 3e3 : c < 4320 ? 4320 : dMe(c / 1960) * 1960
        }

        function UMe() {
            if (E5 > pMe) throw E5 = 0, _U = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            F_ > mMe && (F_ = 0, C9 = null, o("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."))
        }

        function jMe() {
            kh.flushLegacyContextWarning(), kh.flushPendingUnsafeLifecycleWarnings()
        }

        function dae(c, u) {
            Fn(c), D9(c, yh, oMe), u && D9(c, yf, sMe), D9(c, yh, iMe), u && D9(c, yf, aMe), Ii()
        }

        function D9(c, u, v) {
            for (var y = c, E = null; y !== null;) {
                var L = y.subtreeFlags & u;
                y !== E && y.child !== null && L !== Ar ? y = y.child : ((y.flags & u) !== Ar && v(y), y.sibling !== null ? y = y.sibling : y = E = y.return)
            }
        }

        var M9 = null;

        function hae(c) {
            {
                if ((ti & Ac) !== _s || !(c.mode & Mn)) return;
                var u = c.tag;
                if (u !== d && u !== p && u !== f && u !== l && u !== F && u !== ee && u !== oe) return;
                var v = Lr(c) || "ReactComponent";
                if (M9 !== null) {
                    if (M9.has(v)) return;
                    M9.add(v)
                } else M9 = new Set([v]);
                var y = Va;
                try {
                    Fn(c), o("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.")
                } finally {
                    y ? Fn(c) : Ii()
                }
            }
        }

        var IU;
        {
            var zMe = null;
            IU = function (c, u, v) {
                var y = wae(zMe, u);
                try {
                    return Cie(c, u, v)
                } catch (L) {
                    if (t7e() || L !== null && typeof L == "object" && typeof L.then == "function") throw L;
                    if (FR(), Ine(), Mie(c, u), wae(u, y), u.mode & gi && DF(u), w2(null, Cie, null, c, u, v), K1()) {
                        var E = gf();
                        typeof E == "object" && E !== null && E._suppressLogging && typeof L == "object" && L !== null && !L._suppressLogging && (L._suppressLogging = !0)
                    }
                    throw L
                }
            }
        }
        var pae = !1, kU;
        kU = new Set;

        function VMe(c) {
            if (Xc && !O7e()) switch (c.tag) {
                case l:
                case F:
                case oe: {
                    var u = ao && Lr(ao) || "Unknown", v = u;
                    if (!kU.has(v)) {
                        kU.add(v);
                        var y = Lr(c) || "Unknown";
                        o("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", y, u, u)
                    }
                    break
                }
                case f: {
                    pae || (o("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), pae = !0);
                    break
                }
            }
        }

        function A5(c, u) {
            if (el) {
                var v = c.memoizedUpdaters;
                v.forEach(function (y) {
                    db(c, y, u)
                })
            }
        }

        var RU = {};

        function DU(c, u) {
            {
                var v = Bh.current;
                return v !== null ? (v.push(u), RU) : Y3(c, u)
            }
        }

        function mae(c) {
            if (c !== RU) return xk(c)
        }

        function vae() {
            return Bh.current !== null
        }

        function HMe(c) {
            {
                if (c.mode & Mn) {
                    if (!Gie()) return
                } else if (!fMe() || ti !== _s || c.tag !== l && c.tag !== F && c.tag !== oe) return;
                if (Bh.current === null) {
                    var u = Va;
                    try {
                        Fn(c), o(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Lr(c))
                    } finally {
                        u ? Fn(c) : Ii()
                    }
                }
            }
        }

        function WMe(c) {
            c.tag !== $g && Gie() && Bh.current === null && o(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`)
        }

        function I5(c) {
            Jie = c
        }

        var Ad = null, U_ = null, qMe = function (c) {
            Ad = c
        };

        function j_(c) {
            {
                if (Ad === null) return c;
                var u = Ad(c);
                return u === void 0 ? c : u.current
            }
        }

        function MU(c) {
            return j_(c)
        }

        function OU(c) {
            {
                if (Ad === null) return c;
                var u = Ad(c);
                if (u === void 0) {
                    if (c != null && typeof c.render == "function") {
                        var v = j_(c.render);
                        if (c.render !== v) {
                            var y = {$$typeof: wr, render: v};
                            return c.displayName !== void 0 && (y.displayName = c.displayName), y
                        }
                    }
                    return c
                }
                return u.current
            }
        }

        function gae(c, u) {
            {
                if (Ad === null) return !1;
                var v = c.elementType, y = u.type, E = !1, L = typeof y == "object" && y !== null ? y.$$typeof : null;
                switch (c.tag) {
                    case f: {
                        typeof y == "function" && (E = !0);
                        break
                    }
                    case l: {
                        (typeof y == "function" || L === xt) && (E = !0);
                        break
                    }
                    case F: {
                        (L === wr || L === xt) && (E = !0);
                        break
                    }
                    case ee:
                    case oe: {
                        (L === ot || L === xt) && (E = !0);
                        break
                    }
                    default:
                        return !1
                }
                if (E) {
                    var Z = Ad(v);
                    if (Z !== void 0 && Z === Ad(y)) return !0
                }
                return !1
            }
        }

        function yae(c) {
            {
                if (Ad === null || typeof WeakSet != "function") return;
                U_ === null && (U_ = new WeakSet), U_.add(c)
            }
        }

        var GMe = function (c, u) {
            {
                if (Ad === null) return;
                var v = u.staleFamilies, y = u.updatedFamilies;
                Ym(), Km(function () {
                    PU(c.current, y, v)
                })
            }
        }, KMe = function (c, u) {
            {
                if (c.context !== xf) return;
                Ym(), Km(function () {
                    k5(u, c, null, null)
                })
            }
        };

        function PU(c, u, v) {
            {
                var y = c.alternate, E = c.child, L = c.sibling, Z = c.tag, se = c.type, he = null;
                switch (Z) {
                    case l:
                    case oe:
                    case f:
                        he = se;
                        break;
                    case F:
                        he = se.render;
                        break
                }
                if (Ad === null) throw new Error("Expected resolveFamily to be set during hot reload.");
                var we = !1, _e = !1;
                if (he !== null) {
                    var Fe = Ad(he);
                    Fe !== void 0 && (v.has(Fe) ? _e = !0 : u.has(Fe) && (Z === f ? _e = !0 : we = !0))
                }
                if (U_ !== null && (U_.has(c) || y !== null && U_.has(y)) && (_e = !0), _e && (c._debugNeedsRemount = !0), _e || we) {
                    var Le = Lu(c, Xr);
                    Le !== null && Ts(Le, c, Xr, ea)
                }
                E !== null && !_e && PU(E, u, v), L !== null && PU(L, u, v)
            }
        }

        var YMe = function (c, u) {
            {
                var v = new Set, y = new Set(u.map(function (E) {
                    return E.current
                }));
                return NU(c.current, y, v), v
            }
        };

        function NU(c, u, v) {
            {
                var y = c.child, E = c.sibling, L = c.tag, Z = c.type, se = null;
                switch (L) {
                    case l:
                    case oe:
                    case f:
                        se = Z;
                        break;
                    case F:
                        se = Z.render;
                        break
                }
                var he = !1;
                se !== null && u.has(se) && (he = !0), he ? XMe(c, v) : y !== null && NU(y, u, v), E !== null && NU(E, u, v)
            }
        }

        function XMe(c, u) {
            {
                var v = QMe(c, u);
                if (v) return;
                for (var y = c; ;) {
                    switch (y.tag) {
                        case b:
                            u.add(y.stateNode);
                            return;
                        case g:
                            u.add(y.stateNode.containerInfo);
                            return;
                        case p:
                            u.add(y.stateNode.containerInfo);
                            return
                    }
                    if (y.return === null) throw new Error("Expected to reach root first.");
                    y = y.return
                }
            }
        }

        function QMe(c, u) {
            for (var v = c, y = !1; ;) {
                if (v.tag === b) y = !0, u.add(v.stateNode); else if (v.child !== null) {
                    v.child.return = v, v = v.child;
                    continue
                }
                if (v === c) return y;
                for (; v.sibling === null;) {
                    if (v.return === null || v.return === c) return y;
                    v = v.return
                }
                v.sibling.return = v.return, v = v.sibling
            }
            return !1
        }

        var LU;
        {
            LU = !1;
            try {
                Object.preventExtensions({})
            } catch {
                LU = !0
            }
        }

        function ZMe(c, u, v, y) {
            this.tag = c, this.key = v, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = u, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = y, this.flags = Ar, this.subtreeFlags = Ar, this.deletions = null, this.lanes = mt, this.childLanes = mt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !LU && typeof Object.preventExtensions == "function" && Object.preventExtensions(this)
        }

        var Ef = function (c, u, v, y) {
            return new ZMe(c, u, v, y)
        };

        function BU(c) {
            var u = c.prototype;
            return !!(u && u.isReactComponent)
        }

        function JMe(c) {
            return typeof c == "function" && !BU(c) && c.defaultProps === void 0
        }

        function eOe(c) {
            if (typeof c == "function") return BU(c) ? f : l;
            if (c != null) {
                var u = c.$$typeof;
                if (u === wr) return F;
                if (u === ot) return ee
            }
            return d
        }

        function Wb(c, u) {
            var v = c.alternate;
            v === null ? (v = Ef(c.tag, u, c.key, c.mode), v.elementType = c.elementType, v.type = c.type, v.stateNode = c.stateNode, v._debugSource = c._debugSource, v._debugOwner = c._debugOwner, v._debugHookTypes = c._debugHookTypes, v.alternate = c, c.alternate = v) : (v.pendingProps = u, v.type = c.type, v.flags = Ar, v.subtreeFlags = Ar, v.deletions = null, v.actualDuration = 0, v.actualStartTime = -1), v.flags = c.flags & mo, v.childLanes = c.childLanes, v.lanes = c.lanes, v.child = c.child, v.memoizedProps = c.memoizedProps, v.memoizedState = c.memoizedState, v.updateQueue = c.updateQueue;
            var y = c.dependencies;
            switch (v.dependencies = y === null ? null : {
                lanes: y.lanes,
                firstContext: y.firstContext
            }, v.sibling = c.sibling, v.index = c.index, v.ref = c.ref, v.selfBaseDuration = c.selfBaseDuration, v.treeBaseDuration = c.treeBaseDuration, v._debugNeedsRemount = c._debugNeedsRemount, v.tag) {
                case d:
                case l:
                case oe:
                    v.type = j_(c.type);
                    break;
                case f:
                    v.type = MU(c.type);
                    break;
                case F:
                    v.type = OU(c.type);
                    break
            }
            return v
        }

        function tOe(c, u) {
            c.flags &= mo | pa;
            var v = c.alternate;
            if (v === null) c.childLanes = mt, c.lanes = u, c.child = null, c.subtreeFlags = Ar, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null, c.selfBaseDuration = 0, c.treeBaseDuration = 0; else {
                c.childLanes = v.childLanes, c.lanes = v.lanes, c.child = v.child, c.subtreeFlags = Ar, c.deletions = null, c.memoizedProps = v.memoizedProps, c.memoizedState = v.memoizedState, c.updateQueue = v.updateQueue, c.type = v.type;
                var y = v.dependencies;
                c.dependencies = y === null ? null : {
                    lanes: y.lanes,
                    firstContext: y.firstContext
                }, c.selfBaseDuration = v.selfBaseDuration, c.treeBaseDuration = v.treeBaseDuration
            }
            return c
        }

        function rOe(c, u, v) {
            var y;
            return c === kR ? (y = Mn, u === !0 && (y |= Gi, y |= yi)) : y = $r, el && (y |= gi), Ef(p, null, null, y)
        }

        function $U(c, u, v, y, E, L) {
            var Z = d, se = c;
            if (typeof c == "function") BU(c) ? (Z = f, se = MU(se)) : se = j_(se); else if (typeof c == "string") Z = b; else e:switch (c) {
                case fn:
                    return Qg(v.children, E, L, u);
                case Hn:
                    Z = I, E |= Gi, (E & Mn) !== $r && (E |= yi);
                    break;
                case Cr:
                    return nOe(v, E, L, u);
                case ke:
                    return iOe(v, E, L, u);
                case st:
                    return aOe(v, E, L, u);
                case Vr:
                    return bae(v, E, L, u);
                case Ur:
                case Yt:
                case fi:
                case In:
                case vr:
                default: {
                    if (typeof c == "object" && c !== null) switch (c.$$typeof) {
                        case An:
                            Z = P;
                            break e;
                        case pn:
                            Z = N;
                            break e;
                        case wr:
                            Z = F, se = OU(se);
                            break e;
                        case ot:
                            Z = ee;
                            break e;
                        case xt:
                            Z = G, se = null;
                            break e
                    }
                    var he = "";
                    {
                        (c === void 0 || typeof c == "object" && c !== null && Object.keys(c).length === 0) && (he += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                        var we = y ? Lr(y) : null;
                        we && (he += `

Check the render method of \`` + we + "`.")
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (c == null ? c : typeof c) + "." + he))
                }
            }
            var _e = Ef(Z, v, u, E);
            return _e.elementType = c, _e.type = se, _e.lanes = L, _e._debugOwner = y, _e
        }

        function FU(c, u, v) {
            var y = null;
            y = c._owner;
            var E = c.type, L = c.key, Z = c.props, se = $U(E, L, Z, y, u, v);
            return se._debugSource = c._source, se._debugOwner = c._owner, se
        }

        function Qg(c, u, v, y) {
            var E = Ef(T, c, y, u);
            return E.lanes = v, E
        }

        function nOe(c, u, v, y) {
            typeof c.id != "string" && o('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof c.id);
            var E = Ef(V, c, y, u | gi);
            return E.elementType = Cr, E.lanes = v, E.stateNode = {effectDuration: 0, passiveEffectDuration: 0}, E
        }

        function iOe(c, u, v, y) {
            var E = Ef(Y, c, y, u);
            return E.elementType = ke, E.lanes = v, E
        }

        function aOe(c, u, v, y) {
            var E = Ef(re, c, y, u);
            return E.elementType = st, E.lanes = v, E
        }

        function bae(c, u, v, y) {
            var E = Ef(D, c, y, u);
            E.elementType = Vr, E.lanes = v;
            var L = {isHidden: !1};
            return E.stateNode = L, E
        }

        function UU(c, u, v) {
            var y = Ef(S, c, null, u);
            return y.lanes = v, y
        }

        function oOe() {
            var c = Ef(b, null, null, $r);
            return c.elementType = "DELETED", c
        }

        function sOe(c) {
            var u = Ef(ce, null, null, $r);
            return u.stateNode = c, u
        }

        function jU(c, u, v) {
            var y = c.children !== null ? c.children : [], E = Ef(g, y, c.key, u);
            return E.lanes = v, E.stateNode = {
                containerInfo: c.containerInfo,
                pendingChildren: null,
                implementation: c.implementation
            }, E
        }

        function wae(c, u) {
            return c === null && (c = Ef(d, null, null, $r)), c.tag = u.tag, c.key = u.key, c.elementType = u.elementType, c.type = u.type, c.stateNode = u.stateNode, c.return = u.return, c.child = u.child, c.sibling = u.sibling, c.index = u.index, c.ref = u.ref, c.pendingProps = u.pendingProps, c.memoizedProps = u.memoizedProps, c.updateQueue = u.updateQueue, c.memoizedState = u.memoizedState, c.dependencies = u.dependencies, c.mode = u.mode, c.flags = u.flags, c.subtreeFlags = u.subtreeFlags, c.deletions = u.deletions, c.lanes = u.lanes, c.childLanes = u.childLanes, c.alternate = u.alternate, c.actualDuration = u.actualDuration, c.actualStartTime = u.actualStartTime, c.selfBaseDuration = u.selfBaseDuration, c.treeBaseDuration = u.treeBaseDuration, c._debugSource = u._debugSource, c._debugOwner = u._debugOwner, c._debugNeedsRemount = u._debugNeedsRemount, c._debugHookTypes = u._debugHookTypes, c
        }

        function cOe(c, u, v, y, E) {
            this.tag = u, this.containerInfo = c, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = x$, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = pi, this.eventTimes = fb(mt), this.expirationTimes = fb(ea), this.pendingLanes = mt, this.suspendedLanes = mt, this.pingedLanes = mt, this.expiredLanes = mt, this.mutableReadLanes = mt, this.finishedLanes = mt, this.entangledLanes = mt, this.entanglements = fb(mt), this.identifierPrefix = y, this.onRecoverableError = E, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
            {
                this.memoizedUpdaters = new Set;
                for (var L = this.pendingUpdatersLaneMap = [], Z = 0; Z < Tm; Z++) L.push(new Set)
            }
            switch (u) {
                case kR:
                    this._debugRootType = v ? "hydrateRoot()" : "createRoot()";
                    break;
                case $g:
                    this._debugRootType = v ? "hydrate()" : "render()";
                    break
            }
        }

        function Sae(c, u, v, y, E, L, Z, se, he, we) {
            var _e = new cOe(c, u, v, se, he), Fe = rOe(u, L);
            _e.current = Fe, Fe.stateNode = _e;
            {
                var Le = {element: y, isDehydrated: v, cache: null, transitions: null, pendingSuspenseBoundaries: null};
                Fe.memoizedState = Le
            }
            return tF(Fe), _e
        }

        var zU = "18.3.1";

        function lOe(c, u, v) {
            var y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            return ze(y), {
                $$typeof: mr,
                key: y == null ? null : "" + y,
                children: c,
                containerInfo: u,
                implementation: v
            }
        }

        var VU, HU;
        VU = !1, HU = {};

        function _ae(c) {
            if (!c) return xf;
            var u = Np(c), v = q9e(u);
            if (u.tag === f) {
                var y = u.type;
                if (Zp(y)) return Xre(u, y, v)
            }
            return v
        }

        function uOe(c, u) {
            {
                var v = Np(c);
                if (v === void 0) {
                    if (typeof c.render == "function") throw new Error("Unable to find node on an unmounted component.");
                    var y = Object.keys(c).join(",");
                    throw new Error("Argument appears to not be a ReactComponent. Keys: " + y)
                }
                var E = Zc(v);
                if (E === null) return null;
                if (E.mode & Gi) {
                    var L = Lr(v) || "Component";
                    if (!HU[L]) {
                        HU[L] = !0;
                        var Z = Va;
                        try {
                            Fn(E), v.mode & Gi ? o("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", u, u, L) : o("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", u, u, L)
                        } finally {
                            Z ? Fn(Z) : Ii()
                        }
                    }
                }
                return E.stateNode
            }
        }

        function xae(c, u, v, y, E, L, Z, se) {
            var he = !1, we = null;
            return Sae(c, u, he, we, v, y, E, L, Z)
        }

        function Eae(c, u, v, y, E, L, Z, se, he, we) {
            var _e = !0, Fe = Sae(v, y, _e, c, E, L, Z, se, he);
            Fe.context = _ae(null);
            var Le = Fe.current, Qe = Gl(), nt = Yg(Le), lt = Hm(Qe, nt);
            return lt.callback = u ?? null, jg(Le, lt, nt), gMe(Fe, nt, Qe), Fe
        }

        function k5(c, u, v, y) {
            Z3(u, c);
            var E = u.current, L = Gl(), Z = Yg(E);
            Ba(Z);
            var se = _ae(v);
            u.context === null ? u.context = se : u.pendingContext = se, Xc && Va !== null && !VU && (VU = !0, o(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Lr(Va) || "Unknown"));
            var he = Hm(L, Z);
            he.payload = {element: c}, y = y === void 0 ? null : y, y !== null && (typeof y != "function" && o("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", y), he.callback = y);
            var we = jg(E, he, Z);
            return we !== null && (Ts(we, E, Z, L), HR(we, E, Z)), Z
        }

        function O9(c) {
            var u = c.current;
            if (!u.child) return null;
            switch (u.child.tag) {
                case b:
                    return u.child.stateNode;
                default:
                    return u.child.stateNode
            }
        }

        function fOe(c) {
            switch (c.tag) {
                case p: {
                    var u = c.stateNode;
                    if (J2(u)) {
                        var v = kk(u);
                        SMe(u, v)
                    }
                    break
                }
                case Y: {
                    Km(function () {
                        var E = Lu(c, Xr);
                        if (E !== null) {
                            var L = Gl();
                            Ts(E, c, Xr, L)
                        }
                    });
                    var y = Xr;
                    WU(c, y);
                    break
                }
            }
        }

        function Tae(c, u) {
            var v = c.memoizedState;
            v !== null && v.dehydrated !== null && (v.retryLane = Pk(v.retryLane, u))
        }

        function WU(c, u) {
            Tae(c, u);
            var v = c.alternate;
            v && Tae(v, u)
        }

        function dOe(c) {
            if (c.tag === Y) {
                var u = ab, v = Lu(c, u);
                if (v !== null) {
                    var y = Gl();
                    Ts(v, c, u, y)
                }
                WU(c, u)
            }
        }

        function hOe(c) {
            if (c.tag === Y) {
                var u = Yg(c), v = Lu(c, u);
                if (v !== null) {
                    var y = Gl();
                    Ts(v, c, u, y)
                }
                WU(c, u)
            }
        }

        function Cae(c) {
            var u = Sa(c);
            return u === null ? null : u.stateNode
        }

        var Aae = function (c) {
            return null
        };

        function pOe(c) {
            return Aae(c)
        }

        var Iae = function (c) {
            return !1
        };

        function mOe(c) {
            return Iae(c)
        }

        var kae = null, Rae = null, Dae = null, Mae = null, Oae = null, Pae = null, Nae = null, Lae = null, Bae = null;
        {
            var $ae = function (c, u, v) {
                var y = u[v], E = wn(c) ? c.slice() : Pt({}, c);
                return v + 1 === u.length ? (wn(E) ? E.splice(y, 1) : delete E[y], E) : (E[y] = $ae(c[y], u, v + 1), E)
            }, Fae = function (c, u) {
                return $ae(c, u, 0)
            }, Uae = function (c, u, v, y) {
                var E = u[y], L = wn(c) ? c.slice() : Pt({}, c);
                if (y + 1 === u.length) {
                    var Z = v[y];
                    L[Z] = L[E], wn(L) ? L.splice(E, 1) : delete L[E]
                } else L[E] = Uae(c[E], u, v, y + 1);
                return L
            }, jae = function (c, u, v) {
                if (u.length !== v.length) {
                    a("copyWithRename() expects paths of the same length");
                    return
                } else for (var y = 0; y < v.length - 1; y++) if (u[y] !== v[y]) {
                    a("copyWithRename() expects paths to be the same except for the deepest key");
                    return
                }
                return Uae(c, u, v, 0)
            }, zae = function (c, u, v, y) {
                if (v >= u.length) return y;
                var E = u[v], L = wn(c) ? c.slice() : Pt({}, c);
                return L[E] = zae(c[E], u, v + 1, y), L
            }, Vae = function (c, u, v) {
                return zae(c, u, 0, v)
            }, qU = function (c, u) {
                for (var v = c.memoizedState; v !== null && u > 0;) v = v.next, u--;
                return v
            };
            kae = function (c, u, v, y) {
                var E = qU(c, u);
                if (E !== null) {
                    var L = Vae(E.memoizedState, v, y);
                    E.memoizedState = L, E.baseState = L, c.memoizedProps = Pt({}, c.memoizedProps);
                    var Z = Lu(c, Xr);
                    Z !== null && Ts(Z, c, Xr, ea)
                }
            }, Rae = function (c, u, v) {
                var y = qU(c, u);
                if (y !== null) {
                    var E = Fae(y.memoizedState, v);
                    y.memoizedState = E, y.baseState = E, c.memoizedProps = Pt({}, c.memoizedProps);
                    var L = Lu(c, Xr);
                    L !== null && Ts(L, c, Xr, ea)
                }
            }, Dae = function (c, u, v, y) {
                var E = qU(c, u);
                if (E !== null) {
                    var L = jae(E.memoizedState, v, y);
                    E.memoizedState = L, E.baseState = L, c.memoizedProps = Pt({}, c.memoizedProps);
                    var Z = Lu(c, Xr);
                    Z !== null && Ts(Z, c, Xr, ea)
                }
            }, Mae = function (c, u, v) {
                c.pendingProps = Vae(c.memoizedProps, u, v), c.alternate && (c.alternate.pendingProps = c.pendingProps);
                var y = Lu(c, Xr);
                y !== null && Ts(y, c, Xr, ea)
            }, Oae = function (c, u) {
                c.pendingProps = Fae(c.memoizedProps, u), c.alternate && (c.alternate.pendingProps = c.pendingProps);
                var v = Lu(c, Xr);
                v !== null && Ts(v, c, Xr, ea)
            }, Pae = function (c, u, v) {
                c.pendingProps = jae(c.memoizedProps, u, v), c.alternate && (c.alternate.pendingProps = c.pendingProps);
                var y = Lu(c, Xr);
                y !== null && Ts(y, c, Xr, ea)
            }, Nae = function (c) {
                var u = Lu(c, Xr);
                u !== null && Ts(u, c, Xr, ea)
            }, Lae = function (c) {
                Aae = c
            }, Bae = function (c) {
                Iae = c
            }
        }

        function vOe(c) {
            var u = Zc(c);
            return u === null ? null : u.stateNode
        }

        function gOe(c) {
            return null
        }

        function yOe() {
            return Va
        }

        function bOe(c) {
            var u = c.findFiberByHostInstance, v = r.ReactCurrentDispatcher;
            return xg({
                bundleType: c.bundleType,
                version: c.version,
                rendererPackageName: c.rendererPackageName,
                rendererConfig: c.rendererConfig,
                overrideHookState: kae,
                overrideHookStateDeletePath: Rae,
                overrideHookStateRenamePath: Dae,
                overrideProps: Mae,
                overridePropsDeletePath: Oae,
                overridePropsRenamePath: Pae,
                setErrorHandler: Lae,
                setSuspenseHandler: Bae,
                scheduleUpdate: Nae,
                currentDispatcherRef: v,
                findHostInstanceByFiber: vOe,
                findFiberByHostInstance: u || gOe,
                findHostInstancesForRefresh: YMe,
                scheduleRefresh: GMe,
                scheduleRoot: KMe,
                setRefreshHandler: qMe,
                getCurrentFiber: yOe,
                reconcilerVersion: zU
            })
        }

        var Hae = typeof reportError == "function" ? reportError : function (c) {
            console.error(c)
        };

        function GU(c) {
            this._internalRoot = c
        }

        P9.prototype.render = GU.prototype.render = function (c) {
            var u = this._internalRoot;
            if (u === null) throw new Error("Cannot update an unmounted root.");
            {
                typeof arguments[1] == "function" ? o("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : N9(arguments[1]) ? o("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && o("You passed a second argument to root.render(...) but it only accepts one argument.");
                var v = u.containerInfo;
                if (v.nodeType !== ho) {
                    var y = Cae(u.current);
                    y && y.parentNode !== v && o("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.")
                }
            }
            k5(c, u, null, null)
        }, P9.prototype.unmount = GU.prototype.unmount = function () {
            typeof arguments[0] == "function" && o("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            var c = this._internalRoot;
            if (c !== null) {
                this._internalRoot = null;
                var u = c.containerInfo;
                nae() && o("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Km(function () {
                    k5(null, c, null, null)
                }), Wre(u)
            }
        };

        function wOe(c, u) {
            if (!N9(c)) throw new Error("createRoot(...): Target container is not a DOM element.");
            Wae(c);
            var v = !1, y = !1, E = "", L = Hae;
            u != null && (u.hydrate ? a("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof u == "object" && u !== null && u.$$typeof === Nr && o(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), u.unstable_strictMode === !0 && (v = !0), u.identifierPrefix !== void 0 && (E = u.identifierPrefix), u.onRecoverableError !== void 0 && (L = u.onRecoverableError));
            var Z = xae(c, kR, null, v, y, E, L);
            _R(Z.current, c);
            var se = c.nodeType === ho ? c.parentNode : c;
            return N6(se), new GU(Z)
        }

        function P9(c) {
            this._internalRoot = c
        }

        function SOe(c) {
            c && Hk(c)
        }

        P9.prototype.unstable_scheduleHydration = SOe;

        function _Oe(c, u, v) {
            if (!N9(c)) throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            Wae(c), u === void 0 && o("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            var y = v ?? null, E = v != null && v.hydratedSources || null, L = !1, Z = !1, se = "", he = Hae;
            v != null && (v.unstable_strictMode === !0 && (L = !0), v.identifierPrefix !== void 0 && (se = v.identifierPrefix), v.onRecoverableError !== void 0 && (he = v.onRecoverableError));
            var we = Eae(u, null, c, kR, y, L, Z, se, he);
            if (_R(we.current, c), N6(c), E) for (var _e = 0; _e < E.length; _e++) {
                var Fe = E[_e];
                A7e(we, Fe)
            }
            return new P9(we)
        }

        function N9(c) {
            return !!(c && (c.nodeType === Qc || c.nodeType === ph || c.nodeType === L3 || !k))
        }

        function R5(c) {
            return !!(c && (c.nodeType === Qc || c.nodeType === ph || c.nodeType === L3 || c.nodeType === ho && c.nodeValue === " react-mount-point-unstable "))
        }

        function Wae(c) {
            c.nodeType === Qc && c.tagName && c.tagName.toUpperCase() === "BODY" && o("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), q6(c) && (c._reactRootContainer ? o("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : o("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."))
        }

        var xOe = r.ReactCurrentOwner, qae;
        qae = function (c) {
            if (c._reactRootContainer && c.nodeType !== ho) {
                var u = Cae(c._reactRootContainer.current);
                u && u.parentNode !== c && o("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.")
            }
            var v = !!c._reactRootContainer, y = KU(c), E = !!(y && Lg(y));
            E && !v && o("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), c.nodeType === Qc && c.tagName && c.tagName.toUpperCase() === "BODY" && o("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.")
        };

        function KU(c) {
            return c ? c.nodeType === ph ? c.documentElement : c.firstChild : null
        }

        function Gae() {
        }

        function EOe(c, u, v, y, E) {
            if (E) {
                if (typeof y == "function") {
                    var L = y;
                    y = function () {
                        var Le = O9(Z);
                        L.call(Le)
                    }
                }
                var Z = Eae(u, y, c, $g, null, !1, !1, "", Gae);
                c._reactRootContainer = Z, _R(Z.current, c);
                var se = c.nodeType === ho ? c.parentNode : c;
                return N6(se), Km(), Z
            } else {
                for (var he; he = c.lastChild;) c.removeChild(he);
                if (typeof y == "function") {
                    var we = y;
                    y = function () {
                        var Le = O9(_e);
                        we.call(Le)
                    }
                }
                var _e = xae(c, $g, null, !1, !1, "", Gae);
                c._reactRootContainer = _e, _R(_e.current, c);
                var Fe = c.nodeType === ho ? c.parentNode : c;
                return N6(Fe), Km(function () {
                    k5(u, _e, v, y)
                }), _e
            }
        }

        function TOe(c, u) {
            c !== null && typeof c != "function" && o("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", u, c)
        }

        function L9(c, u, v, y, E) {
            qae(v), TOe(E === void 0 ? null : E, "render");
            var L = v._reactRootContainer, Z;
            if (!L) Z = EOe(v, u, c, E, y); else {
                if (Z = L, typeof E == "function") {
                    var se = E;
                    E = function () {
                        var he = O9(Z);
                        se.call(he)
                    }
                }
                k5(u, Z, c, E)
            }
            return O9(Z)
        }

        var Kae = !1;

        function COe(c) {
            {
                Kae || (Kae = !0, o("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
                var u = xOe.current;
                if (u !== null && u.stateNode !== null) {
                    var v = u.stateNode._warnedAboutRefsInRender;
                    v || o("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", $n(u.type) || "A component"), u.stateNode._warnedAboutRefsInRender = !0
                }
            }
            return c == null ? null : c.nodeType === Qc ? c : uOe(c, "findDOMNode")
        }

        function AOe(c, u, v) {
            if (o("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !R5(u)) throw new Error("Target container is not a DOM element.");
            {
                var y = q6(u) && u._reactRootContainer === void 0;
                y && o("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?")
            }
            return L9(null, c, u, !0, v)
        }

        function IOe(c, u, v) {
            if (o("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !R5(u)) throw new Error("Target container is not a DOM element.");
            {
                var y = q6(u) && u._reactRootContainer === void 0;
                y && o("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?")
            }
            return L9(null, c, u, !1, v)
        }

        function kOe(c, u, v, y) {
            if (o("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !R5(v)) throw new Error("Target container is not a DOM element.");
            if (c == null || !WB(c)) throw new Error("parentComponent must be a valid React Component");
            return L9(c, u, v, !1, y)
        }

        var Yae = !1;

        function ROe(c) {
            if (Yae || (Yae = !0, o("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !R5(c)) throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            {
                var u = q6(c) && c._reactRootContainer === void 0;
                u && o("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?")
            }
            if (c._reactRootContainer) {
                {
                    var v = KU(c), y = v && !Lg(v);
                    y && o("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.")
                }
                return Km(function () {
                    L9(null, null, c, !1, function () {
                        c._reactRootContainer = null, Wre(c)
                    })
                }), !0
            } else {
                {
                    var E = KU(c), L = !!(E && Lg(E)),
                        Z = c.nodeType === Qc && R5(c.parentNode) && !!c.parentNode._reactRootContainer;
                    L && o("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", Z ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.")
                }
                return !1
            }
        }

        Hs(fOe), Ag(dOe), Uk(hOe), vb(Ou), y6(Bk), (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && o("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), q3(ORe), zB(TU, _Me, Km);

        function DOe(c, u) {
            var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!N9(u)) throw new Error("Target container is not a DOM element.");
            return lOe(c, u, null, v)
        }

        function MOe(c, u, v, y) {
            return kOe(c, u, v, y)
        }

        var YU = {usingClientEntryPoint: !1, Events: [Lg, y_, xR, H1, G3, TU]};

        function OOe(c, u) {
            return YU.usingClientEntryPoint || o('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), wOe(c, u)
        }

        function POe(c, u, v) {
            return YU.usingClientEntryPoint || o('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), _Oe(c, u, v)
        }

        function NOe(c) {
            return nae() && o("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Km(c)
        }

        var LOe = bOe({findFiberByHostInstance: Rb, bundleType: 1, version: zU, rendererPackageName: "react-dom"});
        if (!LOe && Me && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
            var Xae = window.location.protocol;
            /^(https?|file):$/.test(Xae) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (Xae === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold")
        }
        ju.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = YU, ju.createPortal = DOe, ju.createRoot = OOe, ju.findDOMNode = COe, ju.flushSync = NOe, ju.hydrate = AOe, ju.hydrateRoot = POe, ju.render = IOe, ju.unmountComponentAtNode = ROe, ju.unstable_batchedUpdates = TU, ju.unstable_renderSubtreeIntoContainer = MOe, ju.version = zU, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)
    }()), ju
}

function vge() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
        if (Ve.env.NODE_ENV !== "production") throw new Error("^_^");
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(vge)
        } catch (t) {
            console.error(t)
        }
    }
}

Ve.env.NODE_ENV === "production" ? (vge(), DW.exports = z$e()) : DW.exports = V$e();
var Jh = DW.exports;
const WZt = za(Jh);
var MW, gj = Jh;
if (Ve.env.NODE_ENV === "production") MW = gj.hydrateRoot; else {
    var Boe = gj.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    MW = function (t, e, r) {
        Boe.usingClientEntryPoint = !0;
        try {
            return gj.hydrateRoot(t, e, r)
        } finally {
            Boe.usingClientEntryPoint = !1
        }
    }
}
var Ni;
(function (t) {
    t.assertEqual = i => i;

    function e(i) {
    }

    t.assertIs = e;

    function r(i) {
        throw new Error
    }

    t.assertNever = r, t.arrayToEnum = i => {
        const a = {};
        for (const o of i) a[o] = o;
        return a
    }, t.getValidEnumValues = i => {
        const a = t.objectKeys(i).filter(s => typeof i[i[s]] != "number"), o = {};
        for (const s of a) o[s] = i[s];
        return t.objectValues(o)
    }, t.objectValues = i => t.objectKeys(i).map(function (a) {
        return i[a]
    }), t.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => {
        const a = [];
        for (const o in i) Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
        return a
    }, t.find = (i, a) => {
        for (const o of i) if (a(o)) return o
    }, t.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i;

    function n(i, a = " | ") {
        return i.map(o => typeof o == "string" ? `'${o}'` : o).join(a)
    }

    t.joinValues = n, t.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a
})(Ni || (Ni = {}));
var OW;
(function (t) {
    t.mergeShapes = (e, r) => ({...e, ...r})
})(OW || (OW = {}));
const or = Ni.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
    wy = t => {
        switch (typeof t) {
            case"undefined":
                return or.undefined;
            case"string":
                return or.string;
            case"number":
                return isNaN(t) ? or.nan : or.number;
            case"boolean":
                return or.boolean;
            case"function":
                return or.function;
            case"bigint":
                return or.bigint;
            case"symbol":
                return or.symbol;
            case"object":
                return Array.isArray(t) ? or.array : t === null ? or.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? or.promise : typeof Map < "u" && t instanceof Map ? or.map : typeof Set < "u" && t instanceof Set ? or.set : typeof Date < "u" && t instanceof Date ? or.date : or.object;
            default:
                return or.unknown
        }
    },
    Mt = Ni.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]),
    H$e = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");

class ip extends Error {
    constructor(e) {
        super(), this.issues = [], this.addIssue = n => {
            this.issues = [...this.issues, n]
        }, this.addIssues = (n = []) => {
            this.issues = [...this.issues, ...n]
        };
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e
    }

    get errors() {
        return this.issues
    }

    format(e) {
        const r = e || function (a) {
            return a.message
        }, n = {_errors: []}, i = a => {
            for (const o of a.issues) if (o.code === "invalid_union") o.unionErrors.map(i); else if (o.code === "invalid_return_type") i(o.returnTypeError); else if (o.code === "invalid_arguments") i(o.argumentsError); else if (o.path.length === 0) n._errors.push(r(o)); else {
                let s = n, l = 0;
                for (; l < o.path.length;) {
                    const f = o.path[l];
                    l === o.path.length - 1 ? (s[f] = s[f] || {_errors: []}, s[f]._errors.push(r(o))) : s[f] = s[f] || {_errors: []}, s = s[f], l++
                }
            }
        };
        return i(this), n
    }

    toString() {
        return this.message
    }

    get message() {
        return JSON.stringify(this.issues, Ni.jsonStringifyReplacer, 2)
    }

    get isEmpty() {
        return this.issues.length === 0
    }

    flatten(e = r => r.message) {
        const r = {}, n = [];
        for (const i of this.issues) i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(e(i))) : n.push(e(i));
        return {formErrors: n, fieldErrors: r}
    }

    get formErrors() {
        return this.flatten()
    }
}

ip.create = t => new ip(t);
const UC = (t, e) => {
    let r;
    switch (t.code) {
        case Mt.invalid_type:
            t.received === or.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
            break;
        case Mt.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(t.expected, Ni.jsonStringifyReplacer)}`;
            break;
        case Mt.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${Ni.joinValues(t.keys, ", ")}`;
            break;
        case Mt.invalid_union:
            r = "Invalid input";
            break;
        case Mt.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${Ni.joinValues(t.options)}`;
            break;
        case Mt.invalid_enum_value:
            r = `Invalid enum value. Expected ${Ni.joinValues(t.options)}, received '${t.received}'`;
            break;
        case Mt.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case Mt.invalid_return_type:
            r = "Invalid function return type";
            break;
        case Mt.invalid_date:
            r = "Invalid date";
            break;
        case Mt.invalid_string:
            typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Ni.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
            break;
        case Mt.too_small:
            t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
            break;
        case Mt.too_big:
            t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
            break;
        case Mt.custom:
            r = "Invalid input";
            break;
        case Mt.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case Mt.not_multiple_of:
            r = `Number must be a multiple of ${t.multipleOf}`;
            break;
        case Mt.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = e.defaultError, Ni.assertNever(t)
    }
    return {message: r}
};
let gge = UC;

function W$e(t) {
    gge = t
}

function xM() {
    return gge
}

const EM = t => {
    const {data: e, path: r, errorMaps: n, issueData: i} = t, a = [...r, ...i.path || []], o = {...i, path: a};
    let s = "";
    const l = n.filter(f => !!f).slice().reverse();
    for (const f of l) s = f(o, {data: e, defaultError: s}).message;
    return {...i, path: a, message: i.message || s}
}, q$e = [];

function fr(t, e) {
    const r = EM({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, xM(), UC].filter(n => !!n)
    });
    t.common.issues.push(r)
}

class Il {
    constructor() {
        this.value = "valid"
    }

    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }

    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }

    static mergeArray(e, r) {
        const n = [];
        for (const i of r) {
            if (i.status === "aborted") return Sn;
            i.status === "dirty" && e.dirty(), n.push(i.value)
        }
        return {status: e.value, value: n}
    }

    static async mergeObjectAsync(e, r) {
        const n = [];
        for (const i of r) n.push({key: await i.key, value: await i.value});
        return Il.mergeObjectSync(e, n)
    }

    static mergeObjectSync(e, r) {
        const n = {};
        for (const i of r) {
            const {key: a, value: o} = i;
            if (a.status === "aborted" || o.status === "aborted") return Sn;
            a.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), (typeof o.value < "u" || i.alwaysSet) && (n[a.value] = o.value)
        }
        return {status: e.value, value: n}
    }
}

const Sn = Object.freeze({status: "aborted"}), yge = t => ({status: "dirty", value: t}),
    du = t => ({status: "valid", value: t}), PW = t => t.status === "aborted", NW = t => t.status === "dirty",
    TM = t => t.status === "valid", CM = t => typeof Promise < "u" && t instanceof Promise;
var Qr;
(function (t) {
    t.errToObj = e => typeof e == "string" ? {message: e} : e || {}, t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
})(Qr || (Qr = {}));
let F0 = class {
    constructor(e, r, n, i) {
        this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = i
    }

    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
    }
};
const $oe = (t, e) => {
    if (TM(e)) return {success: !0, data: e.value};
    if (!t.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1, get error() {
            if (this._error) return this._error;
            const r = new ip(t.common.issues);
            return this._error = r, this._error
        }
    }
};

function Pn(t) {
    if (!t) return {};
    const {errorMap: e, invalid_type_error: r, required_error: n, description: i} = t;
    if (e && (r || n)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: i
    } : {
        errorMap: (o, s) => o.code !== "invalid_type" ? {message: s.defaultError} : typeof s.data > "u" ? {message: n ?? s.defaultError} : {message: r ?? s.defaultError},
        description: i
    }
}

class Yn {
    constructor(e) {
        this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
    }

    get description() {
        return this._def.description
    }

    _getType(e) {
        return wy(e.data)
    }

    _getOrReturnCtx(e, r) {
        return r || {
            common: e.parent.common,
            data: e.data,
            parsedType: wy(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }

    _processInputParams(e) {
        return {
            status: new Il,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: wy(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }

    _parseSync(e) {
        const r = this._parse(e);
        if (CM(r)) throw new Error("Synchronous parse encountered promise.");
        return r
    }

    _parseAsync(e) {
        const r = this._parse(e);
        return Promise.resolve(r)
    }

    parse(e, r) {
        const n = this.safeParse(e, r);
        if (n.success) return n.data;
        throw n.error
    }

    safeParse(e, r) {
        var n;
        const i = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: wy(e)
        }, a = this._parseSync({data: e, path: i.path, parent: i});
        return $oe(i, a)
    }

    async parseAsync(e, r) {
        const n = await this.safeParseAsync(e, r);
        if (n.success) return n.data;
        throw n.error
    }

    async safeParseAsync(e, r) {
        const n = {
            common: {issues: [], contextualErrorMap: r == null ? void 0 : r.errorMap, async: !0},
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: wy(e)
        }, i = this._parse({data: e, path: n.path, parent: n}), a = await (CM(i) ? i : Promise.resolve(i));
        return $oe(n, a)
    }

    refine(e, r) {
        const n = i => typeof r == "string" || typeof r > "u" ? {message: r} : typeof r == "function" ? r(i) : r;
        return this._refinement((i, a) => {
            const o = e(i), s = () => a.addIssue({code: Mt.custom, ...n(i)});
            return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (s(), !1)) : o ? !0 : (s(), !1)
        })
    }

    refinement(e, r) {
        return this._refinement((n, i) => e(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1))
    }

    _refinement(e) {
        return new fp({schema: this, typeName: un.ZodEffects, effect: {type: "refinement", refinement: e}})
    }

    superRefine(e) {
        return this._refinement(e)
    }

    optional() {
        return yv.create(this, this._def)
    }

    nullable() {
        return nS.create(this, this._def)
    }

    nullish() {
        return this.nullable().optional()
    }

    array() {
        return ap.create(this, this._def)
    }

    promise() {
        return x4.create(this, this._def)
    }

    or(e) {
        return HC.create([this, e], this._def)
    }

    and(e) {
        return WC.create(this, e, this._def)
    }

    transform(e) {
        return new fp({
            ...Pn(this._def),
            schema: this,
            typeName: un.ZodEffects,
            effect: {type: "transform", transform: e}
        })
    }

    default(e) {
        const r = typeof e == "function" ? e : () => e;
        return new XC({...Pn(this._def), innerType: this, defaultValue: r, typeName: un.ZodDefault})
    }

    brand() {
        return new wge({typeName: un.ZodBranded, type: this, ...Pn(this._def)})
    }

    catch(e) {
        const r = typeof e == "function" ? e : () => e;
        return new RM({...Pn(this._def), innerType: this, catchValue: r, typeName: un.ZodCatch})
    }

    describe(e) {
        const r = this.constructor;
        return new r({...this._def, description: e})
    }

    pipe(e) {
        return h8.create(this, e)
    }

    isOptional() {
        return this.safeParse(void 0).success
    }

    isNullable() {
        return this.safeParse(null).success
    }
}

const G$e = /^c[^\s-]{8,}$/i, K$e = /^[a-z][a-z0-9]*$/, Y$e = /[0-9A-HJKMNP-TV-Z]{26}/,
    X$e = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i,
    Q$e = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/,
    Z$e = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"),
    J$e = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
    eFe = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    tFe = t => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");

function rFe(t, e) {
    return !!((e === "v4" || !e) && J$e.test(t) || (e === "v6" || !e) && eFe.test(t))
}

class ep extends Yn {
    constructor() {
        super(...arguments), this._regex = (e, r, n) => this.refinement(i => e.test(i), {
            validation: r,
            code: Mt.invalid_string, ...Qr.errToObj(n)
        }), this.nonempty = e => this.min(1, Qr.errToObj(e)), this.trim = () => new ep({
            ...this._def,
            checks: [...this._def.checks, {kind: "trim"}]
        }), this.toLowerCase = () => new ep({
            ...this._def,
            checks: [...this._def.checks, {kind: "toLowerCase"}]
        }), this.toUpperCase = () => new ep({...this._def, checks: [...this._def.checks, {kind: "toUpperCase"}]})
    }

    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== or.string) {
            const a = this._getOrReturnCtx(e);
            return fr(a, {code: Mt.invalid_type, expected: or.string, received: a.parsedType}), Sn
        }
        const n = new Il;
        let i;
        for (const a of this._def.checks) if (a.kind === "min") e.data.length < a.value && (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.too_small,
            minimum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message
        }), n.dirty()); else if (a.kind === "max") e.data.length > a.value && (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.too_big,
            maximum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message
        }), n.dirty()); else if (a.kind === "length") {
            const o = e.data.length > a.value, s = e.data.length < a.value;
            (o || s) && (i = this._getOrReturnCtx(e, i), o ? fr(i, {
                code: Mt.too_big,
                maximum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message
            }) : s && fr(i, {
                code: Mt.too_small,
                minimum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message
            }), n.dirty())
        } else if (a.kind === "email") Q$e.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "email",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()); else if (a.kind === "emoji") Z$e.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "emoji",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()); else if (a.kind === "uuid") X$e.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "uuid",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()); else if (a.kind === "cuid") G$e.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "cuid",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()); else if (a.kind === "cuid2") K$e.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "cuid2",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()); else if (a.kind === "ulid") Y$e.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "ulid",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()); else if (a.kind === "url") try {
            new URL(e.data)
        } catch {
            i = this._getOrReturnCtx(e, i), fr(i, {
                validation: "url",
                code: Mt.invalid_string,
                message: a.message
            }), n.dirty()
        } else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "regex",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.invalid_string,
            validation: {includes: a.value, position: a.position},
            message: a.message
        }), n.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.invalid_string,
            validation: {startsWith: a.value},
            message: a.message
        }), n.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.invalid_string,
            validation: {endsWith: a.value},
            message: a.message
        }), n.dirty()) : a.kind === "datetime" ? tFe(a).test(e.data) || (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.invalid_string,
            validation: "datetime",
            message: a.message
        }), n.dirty()) : a.kind === "ip" ? rFe(e.data, a.version) || (i = this._getOrReturnCtx(e, i), fr(i, {
            validation: "ip",
            code: Mt.invalid_string,
            message: a.message
        }), n.dirty()) : Ni.assertNever(a);
        return {status: n.value, value: e.data}
    }

    _addCheck(e) {
        return new ep({...this._def, checks: [...this._def.checks, e]})
    }

    email(e) {
        return this._addCheck({kind: "email", ...Qr.errToObj(e)})
    }

    url(e) {
        return this._addCheck({kind: "url", ...Qr.errToObj(e)})
    }

    emoji(e) {
        return this._addCheck({kind: "emoji", ...Qr.errToObj(e)})
    }

    uuid(e) {
        return this._addCheck({kind: "uuid", ...Qr.errToObj(e)})
    }

    cuid(e) {
        return this._addCheck({kind: "cuid", ...Qr.errToObj(e)})
    }

    cuid2(e) {
        return this._addCheck({kind: "cuid2", ...Qr.errToObj(e)})
    }

    ulid(e) {
        return this._addCheck({kind: "ulid", ...Qr.errToObj(e)})
    }

    ip(e) {
        return this._addCheck({kind: "ip", ...Qr.errToObj(e)})
    }

    datetime(e) {
        var r;
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : !1, ...Qr.errToObj(e == null ? void 0 : e.message)
        })
    }

    regex(e, r) {
        return this._addCheck({kind: "regex", regex: e, ...Qr.errToObj(r)})
    }

    includes(e, r) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: r == null ? void 0 : r.position, ...Qr.errToObj(r == null ? void 0 : r.message)
        })
    }

    startsWith(e, r) {
        return this._addCheck({kind: "startsWith", value: e, ...Qr.errToObj(r)})
    }

    endsWith(e, r) {
        return this._addCheck({kind: "endsWith", value: e, ...Qr.errToObj(r)})
    }

    min(e, r) {
        return this._addCheck({kind: "min", value: e, ...Qr.errToObj(r)})
    }

    max(e, r) {
        return this._addCheck({kind: "max", value: e, ...Qr.errToObj(r)})
    }

    length(e, r) {
        return this._addCheck({kind: "length", value: e, ...Qr.errToObj(r)})
    }

    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }

    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }

    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }

    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }

    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }

    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }

    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }

    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }

    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }

    get minLength() {
        let e = null;
        for (const r of this._def.checks) r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }

    get maxLength() {
        let e = null;
        for (const r of this._def.checks) r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
}

ep.create = t => {
    var e;
    return new ep({
        checks: [],
        typeName: un.ZodString,
        coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1, ...Pn(t)
    })
};

function nFe(t, e) {
    const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length,
        i = r > n ? r : n, a = parseInt(t.toFixed(i).replace(".", "")), o = parseInt(e.toFixed(i).replace(".", ""));
    return a % o / Math.pow(10, i)
}

class Gy extends Yn {
    constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
    }

    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== or.number) {
            const a = this._getOrReturnCtx(e);
            return fr(a, {code: Mt.invalid_type, expected: or.number, received: a.parsedType}), Sn
        }
        let n;
        const i = new Il;
        for (const a of this._def.checks) a.kind === "int" ? Ni.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.invalid_type,
            expected: "integer",
            received: "float",
            message: a.message
        }), i.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.too_small,
            minimum: a.value,
            type: "number",
            inclusive: a.inclusive,
            exact: !1,
            message: a.message
        }), i.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.too_big,
            maximum: a.value,
            type: "number",
            inclusive: a.inclusive,
            exact: !1,
            message: a.message
        }), i.dirty()) : a.kind === "multipleOf" ? nFe(e.data, a.value) !== 0 && (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.not_multiple_of,
            multipleOf: a.value,
            message: a.message
        }), i.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.not_finite,
            message: a.message
        }), i.dirty()) : Ni.assertNever(a);
        return {status: i.value, value: e.data}
    }

    gte(e, r) {
        return this.setLimit("min", e, !0, Qr.toString(r))
    }

    gt(e, r) {
        return this.setLimit("min", e, !1, Qr.toString(r))
    }

    lte(e, r) {
        return this.setLimit("max", e, !0, Qr.toString(r))
    }

    lt(e, r) {
        return this.setLimit("max", e, !1, Qr.toString(r))
    }

    setLimit(e, r, n, i) {
        return new Gy({
            ...this._def,
            checks: [...this._def.checks, {kind: e, value: r, inclusive: n, message: Qr.toString(i)}]
        })
    }

    _addCheck(e) {
        return new Gy({...this._def, checks: [...this._def.checks, e]})
    }

    int(e) {
        return this._addCheck({kind: "int", message: Qr.toString(e)})
    }

    positive(e) {
        return this._addCheck({kind: "min", value: 0, inclusive: !1, message: Qr.toString(e)})
    }

    negative(e) {
        return this._addCheck({kind: "max", value: 0, inclusive: !1, message: Qr.toString(e)})
    }

    nonpositive(e) {
        return this._addCheck({kind: "max", value: 0, inclusive: !0, message: Qr.toString(e)})
    }

    nonnegative(e) {
        return this._addCheck({kind: "min", value: 0, inclusive: !0, message: Qr.toString(e)})
    }

    multipleOf(e, r) {
        return this._addCheck({kind: "multipleOf", value: e, message: Qr.toString(r)})
    }

    finite(e) {
        return this._addCheck({kind: "finite", message: Qr.toString(e)})
    }

    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Qr.toString(e)
        })._addCheck({kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: Qr.toString(e)})
    }

    get minValue() {
        let e = null;
        for (const r of this._def.checks) r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }

    get maxValue() {
        let e = null;
        for (const r of this._def.checks) r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }

    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && Ni.isInteger(e.value))
    }

    get isFinite() {
        let e = null, r = null;
        for (const n of this._def.checks) {
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf") return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value)
        }
        return Number.isFinite(r) && Number.isFinite(e)
    }
}

Gy.create = t => new Gy({checks: [], typeName: un.ZodNumber, coerce: (t == null ? void 0 : t.coerce) || !1, ...Pn(t)});

class Ky extends Yn {
    constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte
    }

    _parse(e) {
        if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== or.bigint) {
            const a = this._getOrReturnCtx(e);
            return fr(a, {code: Mt.invalid_type, expected: or.bigint, received: a.parsedType}), Sn
        }
        let n;
        const i = new Il;
        for (const a of this._def.checks) a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.too_small,
            type: "bigint",
            minimum: a.value,
            inclusive: a.inclusive,
            message: a.message
        }), i.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.too_big,
            type: "bigint",
            maximum: a.value,
            inclusive: a.inclusive,
            message: a.message
        }), i.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), fr(n, {
            code: Mt.not_multiple_of,
            multipleOf: a.value,
            message: a.message
        }), i.dirty()) : Ni.assertNever(a);
        return {status: i.value, value: e.data}
    }

    gte(e, r) {
        return this.setLimit("min", e, !0, Qr.toString(r))
    }

    gt(e, r) {
        return this.setLimit("min", e, !1, Qr.toString(r))
    }

    lte(e, r) {
        return this.setLimit("max", e, !0, Qr.toString(r))
    }

    lt(e, r) {
        return this.setLimit("max", e, !1, Qr.toString(r))
    }

    setLimit(e, r, n, i) {
        return new Ky({
            ...this._def,
            checks: [...this._def.checks, {kind: e, value: r, inclusive: n, message: Qr.toString(i)}]
        })
    }

    _addCheck(e) {
        return new Ky({...this._def, checks: [...this._def.checks, e]})
    }

    positive(e) {
        return this._addCheck({kind: "min", value: BigInt(0), inclusive: !1, message: Qr.toString(e)})
    }

    negative(e) {
        return this._addCheck({kind: "max", value: BigInt(0), inclusive: !1, message: Qr.toString(e)})
    }

    nonpositive(e) {
        return this._addCheck({kind: "max", value: BigInt(0), inclusive: !0, message: Qr.toString(e)})
    }

    nonnegative(e) {
        return this._addCheck({kind: "min", value: BigInt(0), inclusive: !0, message: Qr.toString(e)})
    }

    multipleOf(e, r) {
        return this._addCheck({kind: "multipleOf", value: e, message: Qr.toString(r)})
    }

    get minValue() {
        let e = null;
        for (const r of this._def.checks) r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }

    get maxValue() {
        let e = null;
        for (const r of this._def.checks) r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
}

Ky.create = t => {
    var e;
    return new Ky({
        checks: [],
        typeName: un.ZodBigInt,
        coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1, ...Pn(t)
    })
};

class jC extends Yn {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== or.boolean) {
            const n = this._getOrReturnCtx(e);
            return fr(n, {code: Mt.invalid_type, expected: or.boolean, received: n.parsedType}), Sn
        }
        return du(e.data)
    }
}

jC.create = t => new jC({typeName: un.ZodBoolean, coerce: (t == null ? void 0 : t.coerce) || !1, ...Pn(t)});

class tS extends Yn {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== or.date) {
            const a = this._getOrReturnCtx(e);
            return fr(a, {code: Mt.invalid_type, expected: or.date, received: a.parsedType}), Sn
        }
        if (isNaN(e.data.getTime())) {
            const a = this._getOrReturnCtx(e);
            return fr(a, {code: Mt.invalid_date}), Sn
        }
        const n = new Il;
        let i;
        for (const a of this._def.checks) a.kind === "min" ? e.data.getTime() < a.value && (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.too_small,
            message: a.message,
            inclusive: !0,
            exact: !1,
            minimum: a.value,
            type: "date"
        }), n.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (i = this._getOrReturnCtx(e, i), fr(i, {
            code: Mt.too_big,
            message: a.message,
            inclusive: !0,
            exact: !1,
            maximum: a.value,
            type: "date"
        }), n.dirty()) : Ni.assertNever(a);
        return {status: n.value, value: new Date(e.data.getTime())}
    }

    _addCheck(e) {
        return new tS({...this._def, checks: [...this._def.checks, e]})
    }

    min(e, r) {
        return this._addCheck({kind: "min", value: e.getTime(), message: Qr.toString(r)})
    }

    max(e, r) {
        return this._addCheck({kind: "max", value: e.getTime(), message: Qr.toString(r)})
    }

    get minDate() {
        let e = null;
        for (const r of this._def.checks) r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e != null ? new Date(e) : null
    }

    get maxDate() {
        let e = null;
        for (const r of this._def.checks) r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e != null ? new Date(e) : null
    }
}

tS.create = t => new tS({checks: [], coerce: (t == null ? void 0 : t.coerce) || !1, typeName: un.ZodDate, ...Pn(t)});

class AM extends Yn {
    _parse(e) {
        if (this._getType(e) !== or.symbol) {
            const n = this._getOrReturnCtx(e);
            return fr(n, {code: Mt.invalid_type, expected: or.symbol, received: n.parsedType}), Sn
        }
        return du(e.data)
    }
}

AM.create = t => new AM({typeName: un.ZodSymbol, ...Pn(t)});

class zC extends Yn {
    _parse(e) {
        if (this._getType(e) !== or.undefined) {
            const n = this._getOrReturnCtx(e);
            return fr(n, {code: Mt.invalid_type, expected: or.undefined, received: n.parsedType}), Sn
        }
        return du(e.data)
    }
}

zC.create = t => new zC({typeName: un.ZodUndefined, ...Pn(t)});

class VC extends Yn {
    _parse(e) {
        if (this._getType(e) !== or.null) {
            const n = this._getOrReturnCtx(e);
            return fr(n, {code: Mt.invalid_type, expected: or.null, received: n.parsedType}), Sn
        }
        return du(e.data)
    }
}

VC.create = t => new VC({typeName: un.ZodNull, ...Pn(t)});

class _4 extends Yn {
    constructor() {
        super(...arguments), this._any = !0
    }

    _parse(e) {
        return du(e.data)
    }
}

_4.create = t => new _4({typeName: un.ZodAny, ...Pn(t)});

class Bw extends Yn {
    constructor() {
        super(...arguments), this._unknown = !0
    }

    _parse(e) {
        return du(e.data)
    }
}

Bw.create = t => new Bw({typeName: un.ZodUnknown, ...Pn(t)});

class kv extends Yn {
    _parse(e) {
        const r = this._getOrReturnCtx(e);
        return fr(r, {code: Mt.invalid_type, expected: or.never, received: r.parsedType}), Sn
    }
}

kv.create = t => new kv({typeName: un.ZodNever, ...Pn(t)});

class IM extends Yn {
    _parse(e) {
        if (this._getType(e) !== or.undefined) {
            const n = this._getOrReturnCtx(e);
            return fr(n, {code: Mt.invalid_type, expected: or.void, received: n.parsedType}), Sn
        }
        return du(e.data)
    }
}

IM.create = t => new IM({typeName: un.ZodVoid, ...Pn(t)});

class ap extends Yn {
    _parse(e) {
        const {ctx: r, status: n} = this._processInputParams(e), i = this._def;
        if (r.parsedType !== or.array) return fr(r, {
            code: Mt.invalid_type,
            expected: or.array,
            received: r.parsedType
        }), Sn;
        if (i.exactLength !== null) {
            const o = r.data.length > i.exactLength.value, s = r.data.length < i.exactLength.value;
            (o || s) && (fr(r, {
                code: o ? Mt.too_big : Mt.too_small,
                minimum: s ? i.exactLength.value : void 0,
                maximum: o ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), n.dirty())
        }
        if (i.minLength !== null && r.data.length < i.minLength.value && (fr(r, {
            code: Mt.too_small,
            minimum: i.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.minLength.message
        }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (fr(r, {
            code: Mt.too_big,
            maximum: i.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: i.maxLength.message
        }), n.dirty()), r.common.async) return Promise.all([...r.data].map((o, s) => i.type._parseAsync(new F0(r, o, r.path, s)))).then(o => Il.mergeArray(n, o));
        const a = [...r.data].map((o, s) => i.type._parseSync(new F0(r, o, r.path, s)));
        return Il.mergeArray(n, a)
    }

    get element() {
        return this._def.type
    }

    min(e, r) {
        return new ap({...this._def, minLength: {value: e, message: Qr.toString(r)}})
    }

    max(e, r) {
        return new ap({...this._def, maxLength: {value: e, message: Qr.toString(r)}})
    }

    length(e, r) {
        return new ap({...this._def, exactLength: {value: e, message: Qr.toString(r)}})
    }

    nonempty(e) {
        return this.min(1, e)
    }
}

ap.create = (t, e) => new ap({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: un.ZodArray, ...Pn(e)
});

function hx(t) {
    if (t instanceof so) {
        const e = {};
        for (const r in t.shape) {
            const n = t.shape[r];
            e[r] = yv.create(hx(n))
        }
        return new so({...t._def, shape: () => e})
    } else return t instanceof ap ? new ap({
        ...t._def,
        type: hx(t.element)
    }) : t instanceof yv ? yv.create(hx(t.unwrap())) : t instanceof nS ? nS.create(hx(t.unwrap())) : t instanceof U0 ? U0.create(t.items.map(e => hx(e))) : t
}

class so extends Yn {
    constructor() {
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
    }

    _getCached() {
        if (this._cached !== null) return this._cached;
        const e = this._def.shape(), r = Ni.objectKeys(e);
        return this._cached = {shape: e, keys: r}
    }

    _parse(e) {
        if (this._getType(e) !== or.object) {
            const f = this._getOrReturnCtx(e);
            return fr(f, {code: Mt.invalid_type, expected: or.object, received: f.parsedType}), Sn
        }
        const {status: n, ctx: i} = this._processInputParams(e), {shape: a, keys: o} = this._getCached(), s = [];
        if (!(this._def.catchall instanceof kv && this._def.unknownKeys === "strip")) for (const f in i.data) o.includes(f) || s.push(f);
        const l = [];
        for (const f of o) {
            const d = a[f], p = i.data[f];
            l.push({key: {status: "valid", value: f}, value: d._parse(new F0(i, p, i.path, f)), alwaysSet: f in i.data})
        }
        if (this._def.catchall instanceof kv) {
            const f = this._def.unknownKeys;
            if (f === "passthrough") for (const d of s) l.push({
                key: {status: "valid", value: d},
                value: {status: "valid", value: i.data[d]}
            }); else if (f === "strict") s.length > 0 && (fr(i, {
                code: Mt.unrecognized_keys,
                keys: s
            }), n.dirty()); else if (f !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const f = this._def.catchall;
            for (const d of s) {
                const p = i.data[d];
                l.push({
                    key: {status: "valid", value: d},
                    value: f._parse(new F0(i, p, i.path, d)),
                    alwaysSet: d in i.data
                })
            }
        }
        return i.common.async ? Promise.resolve().then(async () => {
            const f = [];
            for (const d of l) {
                const p = await d.key;
                f.push({key: p, value: await d.value, alwaysSet: d.alwaysSet})
            }
            return f
        }).then(f => Il.mergeObjectSync(n, f)) : Il.mergeObjectSync(n, l)
    }

    get shape() {
        return this._def.shape()
    }

    strict(e) {
        return new so({
            ...this._def, unknownKeys: "strict", ...e !== void 0 ? {
                errorMap: (r, n) => {
                    var i, a, o, s;
                    const l = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, r, n).message) !== null && o !== void 0 ? o : n.defaultError;
                    return r.code === "unrecognized_keys" ? {message: (s = Qr.errToObj(e).message) !== null && s !== void 0 ? s : l} : {message: l}
                }
            } : {}
        })
    }

    strip() {
        return new so({...this._def, unknownKeys: "strip"})
    }

    passthrough() {
        return new so({...this._def, unknownKeys: "passthrough"})
    }

    extend(e) {
        return new so({...this._def, shape: () => ({...this._def.shape(), ...e})})
    }

    merge(e) {
        return new so({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({...this._def.shape(), ...e._def.shape()}),
            typeName: un.ZodObject
        })
    }

    setKey(e, r) {
        return this.augment({[e]: r})
    }

    catchall(e) {
        return new so({...this._def, catchall: e})
    }

    pick(e) {
        const r = {};
        return Ni.objectKeys(e).forEach(n => {
            e[n] && this.shape[n] && (r[n] = this.shape[n])
        }), new so({...this._def, shape: () => r})
    }

    omit(e) {
        const r = {};
        return Ni.objectKeys(this.shape).forEach(n => {
            e[n] || (r[n] = this.shape[n])
        }), new so({...this._def, shape: () => r})
    }

    deepPartial() {
        return hx(this)
    }

    partial(e) {
        const r = {};
        return Ni.objectKeys(this.shape).forEach(n => {
            const i = this.shape[n];
            e && !e[n] ? r[n] = i : r[n] = i.optional()
        }), new so({...this._def, shape: () => r})
    }

    required(e) {
        const r = {};
        return Ni.objectKeys(this.shape).forEach(n => {
            if (e && !e[n]) r[n] = this.shape[n]; else {
                let a = this.shape[n];
                for (; a instanceof yv;) a = a._def.innerType;
                r[n] = a
            }
        }), new so({...this._def, shape: () => r})
    }

    keyof() {
        return bge(Ni.objectKeys(this.shape))
    }
}

so.create = (t, e) => new so({
    shape: () => t,
    unknownKeys: "strip",
    catchall: kv.create(),
    typeName: un.ZodObject, ...Pn(e)
});
so.strictCreate = (t, e) => new so({
    shape: () => t,
    unknownKeys: "strict",
    catchall: kv.create(),
    typeName: un.ZodObject, ...Pn(e)
});
so.lazycreate = (t, e) => new so({
    shape: t,
    unknownKeys: "strip",
    catchall: kv.create(),
    typeName: un.ZodObject, ...Pn(e)
});

class HC extends Yn {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e), n = this._def.options;

        function i(a) {
            for (const s of a) if (s.result.status === "valid") return s.result;
            for (const s of a) if (s.result.status === "dirty") return r.common.issues.push(...s.ctx.common.issues), s.result;
            const o = a.map(s => new ip(s.ctx.common.issues));
            return fr(r, {code: Mt.invalid_union, unionErrors: o}), Sn
        }

        if (r.common.async) return Promise.all(n.map(async a => {
            const o = {...r, common: {...r.common, issues: []}, parent: null};
            return {result: await a._parseAsync({data: r.data, path: r.path, parent: o}), ctx: o}
        })).then(i);
        {
            let a;
            const o = [];
            for (const l of n) {
                const f = {...r, common: {...r.common, issues: []}, parent: null},
                    d = l._parseSync({data: r.data, path: r.path, parent: f});
                if (d.status === "valid") return d;
                d.status === "dirty" && !a && (a = {
                    result: d,
                    ctx: f
                }), f.common.issues.length && o.push(f.common.issues)
            }
            if (a) return r.common.issues.push(...a.ctx.common.issues), a.result;
            const s = o.map(l => new ip(l));
            return fr(r, {code: Mt.invalid_union, unionErrors: s}), Sn
        }
    }

    get options() {
        return this._def.options
    }
}

HC.create = (t, e) => new HC({options: t, typeName: un.ZodUnion, ...Pn(e)});
const fD = t => t instanceof GC ? fD(t.schema) : t instanceof fp ? fD(t.innerType()) : t instanceof KC ? [t.value] : t instanceof Yy ? t.options : t instanceof YC ? Object.keys(t.enum) : t instanceof XC ? fD(t._def.innerType) : t instanceof zC ? [void 0] : t instanceof VC ? [null] : null;

class jP extends Yn {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== or.object) return fr(r, {
            code: Mt.invalid_type,
            expected: or.object,
            received: r.parsedType
        }), Sn;
        const n = this.discriminator, i = r.data[n], a = this.optionsMap.get(i);
        return a ? r.common.async ? a._parseAsync({data: r.data, path: r.path, parent: r}) : a._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (fr(r, {code: Mt.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n]}), Sn)
    }

    get discriminator() {
        return this._def.discriminator
    }

    get options() {
        return this._def.options
    }

    get optionsMap() {
        return this._def.optionsMap
    }

    static create(e, r, n) {
        const i = new Map;
        for (const a of r) {
            const o = fD(a.shape[e]);
            if (!o) throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const s of o) {
                if (i.has(s)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(s)}`);
                i.set(s, a)
            }
        }
        return new jP({typeName: un.ZodDiscriminatedUnion, discriminator: e, options: r, optionsMap: i, ...Pn(n)})
    }
}

function LW(t, e) {
    const r = wy(t), n = wy(e);
    if (t === e) return {valid: !0, data: t};
    if (r === or.object && n === or.object) {
        const i = Ni.objectKeys(e), a = Ni.objectKeys(t).filter(s => i.indexOf(s) !== -1), o = {...t, ...e};
        for (const s of a) {
            const l = LW(t[s], e[s]);
            if (!l.valid) return {valid: !1};
            o[s] = l.data
        }
        return {valid: !0, data: o}
    } else if (r === or.array && n === or.array) {
        if (t.length !== e.length) return {valid: !1};
        const i = [];
        for (let a = 0; a < t.length; a++) {
            const o = t[a], s = e[a], l = LW(o, s);
            if (!l.valid) return {valid: !1};
            i.push(l.data)
        }
        return {valid: !0, data: i}
    } else return r === or.date && n === or.date && +t == +e ? {valid: !0, data: t} : {valid: !1}
}

class WC extends Yn {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e), i = (a, o) => {
            if (PW(a) || PW(o)) return Sn;
            const s = LW(a.value, o.value);
            return s.valid ? ((NW(a) || NW(o)) && r.dirty(), {
                status: r.value,
                value: s.data
            }) : (fr(n, {code: Mt.invalid_intersection_types}), Sn)
        };
        return n.common.async ? Promise.all([this._def.left._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        })]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({data: n.data, path: n.path, parent: n}))
    }
}

WC.create = (t, e, r) => new WC({left: t, right: e, typeName: un.ZodIntersection, ...Pn(r)});

class U0 extends Yn {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== or.array) return fr(n, {
            code: Mt.invalid_type,
            expected: or.array,
            received: n.parsedType
        }), Sn;
        if (n.data.length < this._def.items.length) return fr(n, {
            code: Mt.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), Sn;
        !this._def.rest && n.data.length > this._def.items.length && (fr(n, {
            code: Mt.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), r.dirty());
        const a = [...n.data].map((o, s) => {
            const l = this._def.items[s] || this._def.rest;
            return l ? l._parse(new F0(n, o, n.path, s)) : null
        }).filter(o => !!o);
        return n.common.async ? Promise.all(a).then(o => Il.mergeArray(r, o)) : Il.mergeArray(r, a)
    }

    get items() {
        return this._def.items
    }

    rest(e) {
        return new U0({...this._def, rest: e})
    }
}

U0.create = (t, e) => {
    if (!Array.isArray(t)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new U0({items: t, typeName: un.ZodTuple, rest: null, ...Pn(e)})
};

class qC extends Yn {
    get keySchema() {
        return this._def.keyType
    }

    get valueSchema() {
        return this._def.valueType
    }

    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== or.object) return fr(n, {
            code: Mt.invalid_type,
            expected: or.object,
            received: n.parsedType
        }), Sn;
        const i = [], a = this._def.keyType, o = this._def.valueType;
        for (const s in n.data) i.push({
            key: a._parse(new F0(n, s, n.path, s)),
            value: o._parse(new F0(n, n.data[s], n.path, s))
        });
        return n.common.async ? Il.mergeObjectAsync(r, i) : Il.mergeObjectSync(r, i)
    }

    get element() {
        return this._def.valueType
    }

    static create(e, r, n) {
        return r instanceof Yn ? new qC({
            keyType: e,
            valueType: r,
            typeName: un.ZodRecord, ...Pn(n)
        }) : new qC({keyType: ep.create(), valueType: e, typeName: un.ZodRecord, ...Pn(r)})
    }
}

class kM extends Yn {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== or.map) return fr(n, {
            code: Mt.invalid_type,
            expected: or.map,
            received: n.parsedType
        }), Sn;
        const i = this._def.keyType, a = this._def.valueType, o = [...n.data.entries()].map(([s, l], f) => ({
            key: i._parse(new F0(n, s, n.path, [f, "key"])),
            value: a._parse(new F0(n, l, n.path, [f, "value"]))
        }));
        if (n.common.async) {
            const s = new Map;
            return Promise.resolve().then(async () => {
                for (const l of o) {
                    const f = await l.key, d = await l.value;
                    if (f.status === "aborted" || d.status === "aborted") return Sn;
                    (f.status === "dirty" || d.status === "dirty") && r.dirty(), s.set(f.value, d.value)
                }
                return {status: r.value, value: s}
            })
        } else {
            const s = new Map;
            for (const l of o) {
                const f = l.key, d = l.value;
                if (f.status === "aborted" || d.status === "aborted") return Sn;
                (f.status === "dirty" || d.status === "dirty") && r.dirty(), s.set(f.value, d.value)
            }
            return {status: r.value, value: s}
        }
    }
}

kM.create = (t, e, r) => new kM({valueType: e, keyType: t, typeName: un.ZodMap, ...Pn(r)});

class rS extends Yn {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== or.set) return fr(n, {
            code: Mt.invalid_type,
            expected: or.set,
            received: n.parsedType
        }), Sn;
        const i = this._def;
        i.minSize !== null && n.data.size < i.minSize.value && (fr(n, {
            code: Mt.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (fr(n, {
            code: Mt.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), r.dirty());
        const a = this._def.valueType;

        function o(l) {
            const f = new Set;
            for (const d of l) {
                if (d.status === "aborted") return Sn;
                d.status === "dirty" && r.dirty(), f.add(d.value)
            }
            return {status: r.value, value: f}
        }

        const s = [...n.data.values()].map((l, f) => a._parse(new F0(n, l, n.path, f)));
        return n.common.async ? Promise.all(s).then(l => o(l)) : o(s)
    }

    min(e, r) {
        return new rS({...this._def, minSize: {value: e, message: Qr.toString(r)}})
    }

    max(e, r) {
        return new rS({...this._def, maxSize: {value: e, message: Qr.toString(r)}})
    }

    size(e, r) {
        return this.min(e, r).max(e, r)
    }

    nonempty(e) {
        return this.min(1, e)
    }
}

rS.create = (t, e) => new rS({valueType: t, minSize: null, maxSize: null, typeName: un.ZodSet, ...Pn(e)});

class qx extends Yn {
    constructor() {
        super(...arguments), this.validate = this.implement
    }

    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== or.function) return fr(r, {
            code: Mt.invalid_type,
            expected: or.function,
            received: r.parsedType
        }), Sn;

        function n(s, l) {
            return EM({
                data: s,
                path: r.path,
                errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, xM(), UC].filter(f => !!f),
                issueData: {code: Mt.invalid_arguments, argumentsError: l}
            })
        }

        function i(s, l) {
            return EM({
                data: s,
                path: r.path,
                errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, xM(), UC].filter(f => !!f),
                issueData: {code: Mt.invalid_return_type, returnTypeError: l}
            })
        }

        const a = {errorMap: r.common.contextualErrorMap}, o = r.data;
        return this._def.returns instanceof x4 ? du(async (...s) => {
            const l = new ip([]), f = await this._def.args.parseAsync(s, a).catch(g => {
                throw l.addIssue(n(s, g)), l
            }), d = await o(...f);
            return await this._def.returns._def.type.parseAsync(d, a).catch(g => {
                throw l.addIssue(i(d, g)), l
            })
        }) : du((...s) => {
            const l = this._def.args.safeParse(s, a);
            if (!l.success) throw new ip([n(s, l.error)]);
            const f = o(...l.data), d = this._def.returns.safeParse(f, a);
            if (!d.success) throw new ip([i(f, d.error)]);
            return d.data
        })
    }

    parameters() {
        return this._def.args
    }

    returnType() {
        return this._def.returns
    }

    args(...e) {
        return new qx({...this._def, args: U0.create(e).rest(Bw.create())})
    }

    returns(e) {
        return new qx({...this._def, returns: e})
    }

    implement(e) {
        return this.parse(e)
    }

    strictImplement(e) {
        return this.parse(e)
    }

    static create(e, r, n) {
        return new qx({
            args: e || U0.create([]).rest(Bw.create()),
            returns: r || Bw.create(),
            typeName: un.ZodFunction, ...Pn(n)
        })
    }
}

class GC extends Yn {
    get schema() {
        return this._def.getter()
    }

    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        return this._def.getter()._parse({data: r.data, path: r.path, parent: r})
    }
}

GC.create = (t, e) => new GC({getter: t, typeName: un.ZodLazy, ...Pn(e)});

class KC extends Yn {
    _parse(e) {
        if (e.data !== this._def.value) {
            const r = this._getOrReturnCtx(e);
            return fr(r, {received: r.data, code: Mt.invalid_literal, expected: this._def.value}), Sn
        }
        return {status: "valid", value: e.data}
    }

    get value() {
        return this._def.value
    }
}

KC.create = (t, e) => new KC({value: t, typeName: un.ZodLiteral, ...Pn(e)});

function bge(t, e) {
    return new Yy({values: t, typeName: un.ZodEnum, ...Pn(e)})
}

class Yy extends Yn {
    _parse(e) {
        if (typeof e.data != "string") {
            const r = this._getOrReturnCtx(e), n = this._def.values;
            return fr(r, {expected: Ni.joinValues(n), received: r.parsedType, code: Mt.invalid_type}), Sn
        }
        if (this._def.values.indexOf(e.data) === -1) {
            const r = this._getOrReturnCtx(e), n = this._def.values;
            return fr(r, {received: r.data, code: Mt.invalid_enum_value, options: n}), Sn
        }
        return du(e.data)
    }

    get options() {
        return this._def.values
    }

    get enum() {
        const e = {};
        for (const r of this._def.values) e[r] = r;
        return e
    }

    get Values() {
        const e = {};
        for (const r of this._def.values) e[r] = r;
        return e
    }

    get Enum() {
        const e = {};
        for (const r of this._def.values) e[r] = r;
        return e
    }

    extract(e) {
        return Yy.create(e)
    }

    exclude(e) {
        return Yy.create(this.options.filter(r => !e.includes(r)))
    }
}

Yy.create = bge;

class YC extends Yn {
    _parse(e) {
        const r = Ni.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
        if (n.parsedType !== or.string && n.parsedType !== or.number) {
            const i = Ni.objectValues(r);
            return fr(n, {expected: Ni.joinValues(i), received: n.parsedType, code: Mt.invalid_type}), Sn
        }
        if (r.indexOf(e.data) === -1) {
            const i = Ni.objectValues(r);
            return fr(n, {received: n.data, code: Mt.invalid_enum_value, options: i}), Sn
        }
        return du(e.data)
    }

    get enum() {
        return this._def.values
    }
}

YC.create = (t, e) => new YC({values: t, typeName: un.ZodNativeEnum, ...Pn(e)});

class x4 extends Yn {
    unwrap() {
        return this._def.type
    }

    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== or.promise && r.common.async === !1) return fr(r, {
            code: Mt.invalid_type,
            expected: or.promise,
            received: r.parsedType
        }), Sn;
        const n = r.parsedType === or.promise ? r.data : Promise.resolve(r.data);
        return du(n.then(i => this._def.type.parseAsync(i, {path: r.path, errorMap: r.common.contextualErrorMap})))
    }
}

x4.create = (t, e) => new x4({type: t, typeName: un.ZodPromise, ...Pn(e)});

class fp extends Yn {
    innerType() {
        return this._def.schema
    }

    sourceType() {
        return this._def.schema._def.typeName === un.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }

    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e), i = this._def.effect || null;
        if (i.type === "preprocess") {
            const o = i.transform(n.data);
            return n.common.async ? Promise.resolve(o).then(s => this._def.schema._parseAsync({
                data: s,
                path: n.path,
                parent: n
            })) : this._def.schema._parseSync({data: o, path: n.path, parent: n})
        }
        const a = {
            addIssue: o => {
                fr(n, o), o.fatal ? r.abort() : r.dirty()
            }, get path() {
                return n.path
            }
        };
        if (a.addIssue = a.addIssue.bind(a), i.type === "refinement") {
            const o = s => {
                const l = i.refinement(s, a);
                if (n.common.async) return Promise.resolve(l);
                if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return s
            };
            if (n.common.async === !1) {
                const s = this._def.schema._parseSync({data: n.data, path: n.path, parent: n});
                return s.status === "aborted" ? Sn : (s.status === "dirty" && r.dirty(), o(s.value), {
                    status: r.value,
                    value: s.value
                })
            } else return this._def.schema._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }).then(s => s.status === "aborted" ? Sn : (s.status === "dirty" && r.dirty(), o(s.value).then(() => ({
                status: r.value,
                value: s.value
            }))))
        }
        if (i.type === "transform") if (n.common.async === !1) {
            const o = this._def.schema._parseSync({data: n.data, path: n.path, parent: n});
            if (!TM(o)) return o;
            const s = i.transform(o.value, a);
            if (s instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {status: r.value, value: s}
        } else return this._def.schema._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }).then(o => TM(o) ? Promise.resolve(i.transform(o.value, a)).then(s => ({status: r.value, value: s})) : o);
        Ni.assertNever(i)
    }
}

fp.create = (t, e, r) => new fp({schema: t, typeName: un.ZodEffects, effect: e, ...Pn(r)});
fp.createWithPreprocess = (t, e, r) => new fp({
    schema: e,
    effect: {type: "preprocess", transform: t},
    typeName: un.ZodEffects, ...Pn(r)
});

class yv extends Yn {
    _parse(e) {
        return this._getType(e) === or.undefined ? du(void 0) : this._def.innerType._parse(e)
    }

    unwrap() {
        return this._def.innerType
    }
}

yv.create = (t, e) => new yv({innerType: t, typeName: un.ZodOptional, ...Pn(e)});

class nS extends Yn {
    _parse(e) {
        return this._getType(e) === or.null ? du(null) : this._def.innerType._parse(e)
    }

    unwrap() {
        return this._def.innerType
    }
}

nS.create = (t, e) => new nS({innerType: t, typeName: un.ZodNullable, ...Pn(e)});

class XC extends Yn {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        let n = r.data;
        return r.parsedType === or.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }

    removeDefault() {
        return this._def.innerType
    }
}

XC.create = (t, e) => new XC({
    innerType: t,
    typeName: un.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default, ...Pn(e)
});

class RM extends Yn {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e), n = {...r, common: {...r.common, issues: []}},
            i = this._def.innerType._parse({data: n.data, path: n.path, parent: {...n}});
        return CM(i) ? i.then(a => ({
            status: "valid",
            value: a.status === "valid" ? a.value : this._def.catchValue({
                get error() {
                    return new ip(n.common.issues)
                }, input: n.data
            })
        })) : {
            status: "valid", value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new ip(n.common.issues)
                }, input: n.data
            })
        }
    }

    removeCatch() {
        return this._def.innerType
    }
}

RM.create = (t, e) => new RM({
    innerType: t,
    typeName: un.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch, ...Pn(e)
});

class DM extends Yn {
    _parse(e) {
        if (this._getType(e) !== or.nan) {
            const n = this._getOrReturnCtx(e);
            return fr(n, {code: Mt.invalid_type, expected: or.nan, received: n.parsedType}), Sn
        }
        return {status: "valid", value: e.data}
    }
}

DM.create = t => new DM({typeName: un.ZodNaN, ...Pn(t)});
const iFe = Symbol("zod_brand");

class wge extends Yn {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e), n = r.data;
        return this._def.type._parse({data: n, path: r.path, parent: r})
    }

    unwrap() {
        return this._def.type
    }
}

class h8 extends Yn {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.common.async) return (async () => {
            const a = await this._def.in._parseAsync({data: n.data, path: n.path, parent: n});
            return a.status === "aborted" ? Sn : a.status === "dirty" ? (r.dirty(), yge(a.value)) : this._def.out._parseAsync({
                data: a.value,
                path: n.path,
                parent: n
            })
        })();
        {
            const i = this._def.in._parseSync({data: n.data, path: n.path, parent: n});
            return i.status === "aborted" ? Sn : i.status === "dirty" ? (r.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({data: i.value, path: n.path, parent: n})
        }
    }

    static create(e, r) {
        return new h8({in: e, out: r, typeName: un.ZodPipeline})
    }
}

const Sge = (t, e = {}, r) => t ? _4.create().superRefine((n, i) => {
    var a, o;
    if (!t(n)) {
        const s = typeof e == "function" ? e(n) : typeof e == "string" ? {message: e} : e,
            l = (o = (a = s.fatal) !== null && a !== void 0 ? a : r) !== null && o !== void 0 ? o : !0,
            f = typeof s == "string" ? {message: s} : s;
        i.addIssue({code: "custom", ...f, fatal: l})
    }
}) : _4.create(), aFe = {object: so.lazycreate};
var un;
(function (t) {
    t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline"
})(un || (un = {}));
const oFe = (t, e = {message: `Input not instance of ${t.name}`}) => Sge(r => r instanceof t, e), _ge = ep.create,
    xge = Gy.create, sFe = DM.create, cFe = Ky.create, Ege = jC.create, lFe = tS.create, uFe = AM.create,
    fFe = zC.create, dFe = VC.create, hFe = _4.create, pFe = Bw.create, mFe = kv.create, vFe = IM.create,
    gFe = ap.create, yFe = so.create, bFe = so.strictCreate, wFe = HC.create, SFe = jP.create, _Fe = WC.create,
    xFe = U0.create, EFe = qC.create, TFe = kM.create, CFe = rS.create, AFe = qx.create, IFe = GC.create,
    kFe = KC.create, RFe = Yy.create, DFe = YC.create, MFe = x4.create, Foe = fp.create, OFe = yv.create,
    PFe = nS.create, NFe = fp.createWithPreprocess, LFe = h8.create, BFe = () => _ge().optional(),
    $Fe = () => xge().optional(), FFe = () => Ege().optional(), UFe = {
        string: t => ep.create({...t, coerce: !0}),
        number: t => Gy.create({...t, coerce: !0}),
        boolean: t => jC.create({...t, coerce: !0}),
        bigint: t => Ky.create({...t, coerce: !0}),
        date: t => tS.create({...t, coerce: !0})
    }, jFe = Sn;
var _ = Object.freeze({
    __proto__: null,
    defaultErrorMap: UC,
    setErrorMap: W$e,
    getErrorMap: xM,
    makeIssue: EM,
    EMPTY_PATH: q$e,
    addIssueToContext: fr,
    ParseStatus: Il,
    INVALID: Sn,
    DIRTY: yge,
    OK: du,
    isAborted: PW,
    isDirty: NW,
    isValid: TM,
    isAsync: CM,
    get util() {
        return Ni
    },
    get objectUtil() {
        return OW
    },
    ZodParsedType: or,
    getParsedType: wy,
    ZodType: Yn,
    ZodString: ep,
    ZodNumber: Gy,
    ZodBigInt: Ky,
    ZodBoolean: jC,
    ZodDate: tS,
    ZodSymbol: AM,
    ZodUndefined: zC,
    ZodNull: VC,
    ZodAny: _4,
    ZodUnknown: Bw,
    ZodNever: kv,
    ZodVoid: IM,
    ZodArray: ap,
    ZodObject: so,
    ZodUnion: HC,
    ZodDiscriminatedUnion: jP,
    ZodIntersection: WC,
    ZodTuple: U0,
    ZodRecord: qC,
    ZodMap: kM,
    ZodSet: rS,
    ZodFunction: qx,
    ZodLazy: GC,
    ZodLiteral: KC,
    ZodEnum: Yy,
    ZodNativeEnum: YC,
    ZodPromise: x4,
    ZodEffects: fp,
    ZodTransformer: fp,
    ZodOptional: yv,
    ZodNullable: nS,
    ZodDefault: XC,
    ZodCatch: RM,
    ZodNaN: DM,
    BRAND: iFe,
    ZodBranded: wge,
    ZodPipeline: h8,
    custom: Sge,
    Schema: Yn,
    ZodSchema: Yn,
    late: aFe,
    get ZodFirstPartyTypeKind() {
        return un
    },
    coerce: UFe,
    any: hFe,
    array: gFe,
    bigint: cFe,
    boolean: Ege,
    date: lFe,
    discriminatedUnion: SFe,
    effect: Foe,
    enum: RFe,
    function: AFe,
    instanceof: oFe,
    intersection: _Fe,
    lazy: IFe,
    literal: kFe,
    map: TFe,
    nan: sFe,
    nativeEnum: DFe,
    never: mFe,
    null: dFe,
    nullable: PFe,
    number: xge,
    object: yFe,
    oboolean: FFe,
    onumber: $Fe,
    optional: OFe,
    ostring: BFe,
    pipeline: LFe,
    preprocess: NFe,
    promise: MFe,
    record: EFe,
    set: CFe,
    strictObject: bFe,
    string: _ge,
    symbol: uFe,
    transformer: Foe,
    tuple: xFe,
    undefined: fFe,
    union: wFe,
    unknown: pFe,
    void: vFe,
    NEVER: jFe,
    ZodIssueCode: Mt,
    quotelessJson: H$e,
    ZodError: ip
}), Tge = {}, Xs = {};
Object.defineProperty(Xs, "__esModule", {value: !0});
Xs.constVoid = Xs.memoMany = Xs.memo0 = Xs.memo1 = Xs.memo2 = Xs.memo3 = Xs.memo4 = Xs.memo5 = void 0;
const zFe = t => {
    let e = !1, r, n, i, a, o, s;
    return (l, f, d, p, g) => ((!e || l !== r || f !== n || d !== i || p !== a || g !== o) && (e = !0, r = l, n = f, i = d, a = p, o = g, s = t(l, f, d, p, g)), s)
};
Xs.memo5 = zFe;
const VFe = t => {
    let e = !1, r, n, i, a, o;
    return (s, l, f, d) => ((!e || s !== r || l !== n || f !== i || d !== a) && (e = !0, r = s, n = l, i = f, a = d, o = t(s, l, f, d)), o)
};
Xs.memo4 = VFe;
const HFe = t => {
    let e = !1, r, n, i, a;
    return (o, s, l) => ((!e || o !== r || s !== n || l !== i) && (e = !0, r = o, n = s, i = l, a = t(o, s, l)), a)
};
Xs.memo3 = HFe;
const WFe = t => {
    let e = !1, r, n, i;
    return (a, o) => ((!e || a !== r || o !== n) && (e = !0, r = a, n = o, i = t(a, o)), i)
};
Xs.memo2 = WFe;
const qFe = t => {
    let e = !1, r, n;
    return i => ((!e || i !== r) && (e = !0, r = i, n = t(i)), n)
};
Xs.memo1 = qFe;
const GFe = t => {
    let e = !1, r;
    return () => (e || (e = !0, r = t()), r)
};
Xs.memo0 = GFe;
const KFe = t => {
    let e = !1, r, n;
    const i = a => {
        r = t(...a), e = !0, n = a
    };
    return (...a) => {
        const o = a.length;
        if (e && o === 0) return r;
        if (!e || n.length !== o) return i(a), r;
        for (let s = 0; s < o; s++) if (n[s] !== a[s]) return i(a), r;
        return r
    }
};
Xs.memoMany = KFe;
const YFe = () => {
};
Xs.constVoid = YFe;
(function (t) {
    Object.defineProperty(t, "__esModule", {value: !0}), t.constVoid = t.memoMany = t.memo5 = t.memo4 = t.memo3 = t.memo2 = t.memo1 = t.memo0 = void 0;
    var e = Xs;
    Object.defineProperty(t, "memo0", {
        enumerable: !0, get: function () {
            return e.memo0
        }
    }), Object.defineProperty(t, "memo1", {
        enumerable: !0, get: function () {
            return e.memo1
        }
    }), Object.defineProperty(t, "memo2", {
        enumerable: !0, get: function () {
            return e.memo2
        }
    }), Object.defineProperty(t, "memo3", {
        enumerable: !0, get: function () {
            return e.memo3
        }
    }), Object.defineProperty(t, "memo4", {
        enumerable: !0, get: function () {
            return e.memo4
        }
    }), Object.defineProperty(t, "memo5", {
        enumerable: !0, get: function () {
            return e.memo5
        }
    }), Object.defineProperty(t, "memoMany", {
        enumerable: !0, get: function () {
            return e.memoMany
        }
    }), Object.defineProperty(t, "constVoid", {
        enumerable: !0, get: function () {
            return e.constVoid
        }
    })
})(Tge);
const BW = t => typeof t == "object" && t !== null && !Array.isArray(t) && !(t instanceof Date) && !(t instanceof Map) && !(t instanceof Set) && !(t instanceof WeakSet) && !(t instanceof WeakMap),
    iX = t => typeof t == "string" || typeof t == "number" || typeof t == "symbol";

function pt(...t) {
    return BW(t[0]) || iX(t[0]) && BW(t[1]) ? XFe(t) : QFe(t)
}

function XFe(t) {
    const e = iX(t[0]) ? t[0] : void 0;
    let r, n;
    BW(t[0]) ? (r = t[0], n = t[1]) : (r = t[1], n = t[2]);
    let i, a, o = !1;
    const s = Object.keys(r), l = d => {
        i = n(d), o = !0, a = d
    }, f = d => {
        if (e !== void 0) {
            const g = d[e];
            if (g !== void 0) return g
        }
        const p = {};
        for (const g of s) p[g] = r[g](d);
        if (o) {
            for (const g of s) if (a[g] !== p[g]) return l(p), i;
            return i
        } else return l(p), i
    };
    return f.key = e, f
}

function QFe(t) {
    const e = iX(t[0]) ? t[0] : void 0, r = t.slice(e !== void 0 ? 1 : 0, t.length - 1), n = t[t.length - 1],
        i = Tge.memoMany(n), a = o => {
            if (e !== void 0) {
                const l = o[e];
                if (l !== void 0) return l
            }
            const s = r.map(l => l(o));
            return i(...s)
        };
    return a.key = e, a
}

const Cge = "@injectable-ts/core//TOKEN_ACCESSOR";

function mn(t) {
    return () => {
        const e = r => {
            const n = r[Cge];
            return n ? n(r, t) : r[t]
        };
        return e.key = t, e
    }
}

var ZFe = Error, JFe = EvalError, eUe = RangeError, tUe = ReferenceError, Age = SyntaxError, p8 = TypeError,
    rUe = URIError, Ige = function () {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {}, r = Symbol("test"), n = Object(r);
        if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]") return !1;
        var i = 42;
        e[r] = i;
        for (r in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var a = Object.getOwnPropertySymbols(e);
        if (a.length !== 1 || a[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var o = Object.getOwnPropertyDescriptor(e, r);
            if (o.value !== i || o.enumerable !== !0) return !1
        }
        return !0
    }, Uoe = typeof Symbol < "u" && Symbol, nUe = Ige, iUe = function () {
        return typeof Uoe != "function" || typeof Symbol != "function" || typeof Uoe("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : nUe()
    }, yj = {__proto__: null, foo: {}}, aUe = Object, oUe = function () {
        return {__proto__: yj}.foo === yj.foo && !(yj instanceof aUe)
    }, sUe = "Function.prototype.bind called on incompatible ", cUe = Object.prototype.toString, lUe = Math.max,
    uUe = "[object Function]", joe = function (e, r) {
        for (var n = [], i = 0; i < e.length; i += 1) n[i] = e[i];
        for (var a = 0; a < r.length; a += 1) n[a + e.length] = r[a];
        return n
    }, fUe = function (e, r) {
        for (var n = [], i = r || 0, a = 0; i < e.length; i += 1, a += 1) n[a] = e[i];
        return n
    }, dUe = function (t, e) {
        for (var r = "", n = 0; n < t.length; n += 1) r += t[n], n + 1 < t.length && (r += e);
        return r
    }, hUe = function (e) {
        var r = this;
        if (typeof r != "function" || cUe.apply(r) !== uUe) throw new TypeError(sUe + r);
        for (var n = fUe(arguments, 1), i, a = function () {
            if (this instanceof i) {
                var d = r.apply(this, joe(n, arguments));
                return Object(d) === d ? d : this
            }
            return r.apply(e, joe(n, arguments))
        }, o = lUe(0, r.length - n.length), s = [], l = 0; l < o; l++) s[l] = "$" + l;
        if (i = Function("binder", "return function (" + dUe(s, ",") + "){ return binder.apply(this,arguments); }")(a), r.prototype) {
            var f = function () {
            };
            f.prototype = r.prototype, i.prototype = new f, f.prototype = null
        }
        return i
    }, pUe = hUe, aX = Function.prototype.bind || pUe, mUe = Function.prototype.call, vUe = Object.prototype.hasOwnProperty,
    gUe = aX, yUe = gUe.call(mUe, vUe), oi, bUe = ZFe, wUe = JFe, SUe = eUe, _Ue = tUe, E4 = Age, Gx = p8, xUe = rUe,
    kge = Function, bj = function (t) {
        try {
            return kge('"use strict"; return (' + t + ").constructor;")()
        } catch {
        }
    }, MM = Object.getOwnPropertyDescriptor, wj = function () {
        throw new Gx
    }, EUe = MM ? function () {
        try {
            return wj
        } catch {
            try {
                return MM(arguments, "callee").get
            } catch {
                return wj
            }
        }
    }() : wj, W_ = iUe(), TUe = oUe(), Jl = Object.getPrototypeOf || (TUe ? function (t) {
        return t.__proto__
    } : null), px = {}, CUe = typeof Uint8Array > "u" || !Jl ? oi : Jl(Uint8Array), Kx = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? oi : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? oi : ArrayBuffer,
        "%ArrayIteratorPrototype%": W_ && Jl ? Jl([][Symbol.iterator]()) : oi,
        "%AsyncFromSyncIteratorPrototype%": oi,
        "%AsyncFunction%": px,
        "%AsyncGenerator%": px,
        "%AsyncGeneratorFunction%": px,
        "%AsyncIteratorPrototype%": px,
        "%Atomics%": typeof Atomics > "u" ? oi : Atomics,
        "%BigInt%": typeof BigInt > "u" ? oi : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? oi : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? oi : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? oi : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": bUe,
        "%eval%": eval,
        "%EvalError%": wUe,
        "%Float32Array%": typeof Float32Array > "u" ? oi : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? oi : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? oi : FinalizationRegistry,
        "%Function%": kge,
        "%GeneratorFunction%": px,
        "%Int8Array%": typeof Int8Array > "u" ? oi : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? oi : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? oi : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": W_ && Jl ? Jl(Jl([][Symbol.iterator]())) : oi,
        "%JSON%": typeof JSON == "object" ? JSON : oi,
        "%Map%": typeof Map > "u" ? oi : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !W_ || !Jl ? oi : Jl(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? oi : Promise,
        "%Proxy%": typeof Proxy > "u" ? oi : Proxy,
        "%RangeError%": SUe,
        "%ReferenceError%": _Ue,
        "%Reflect%": typeof Reflect > "u" ? oi : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? oi : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !W_ || !Jl ? oi : Jl(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? oi : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": W_ && Jl ? Jl(""[Symbol.iterator]()) : oi,
        "%Symbol%": W_ ? Symbol : oi,
        "%SyntaxError%": E4,
        "%ThrowTypeError%": EUe,
        "%TypedArray%": CUe,
        "%TypeError%": Gx,
        "%Uint8Array%": typeof Uint8Array > "u" ? oi : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? oi : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? oi : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? oi : Uint32Array,
        "%URIError%": xUe,
        "%WeakMap%": typeof WeakMap > "u" ? oi : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? oi : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? oi : WeakSet
    }, AUe = function t(e) {
        var r;
        if (e === "%AsyncFunction%") r = bj("async function () {}"); else if (e === "%GeneratorFunction%") r = bj("function* () {}"); else if (e === "%AsyncGeneratorFunction%") r = bj("async function* () {}"); else if (e === "%AsyncGenerator%") {
            var n = t("%AsyncGeneratorFunction%");
            n && (r = n.prototype)
        } else if (e === "%AsyncIteratorPrototype%") {
            var i = t("%AsyncGenerator%");
            i && Jl && (r = Jl(i.prototype))
        }
        return Kx[e] = r, r
    }, zoe = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, m8 = aX, OM = yUe, IUe = m8.call(Function.call, Array.prototype.concat),
    kUe = m8.call(Function.apply, Array.prototype.splice), Voe = m8.call(Function.call, String.prototype.replace),
    PM = m8.call(Function.call, String.prototype.slice), RUe = m8.call(Function.call, RegExp.prototype.exec),
    DUe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    MUe = /\\(\\)?/g, OUe = function (e) {
        var r = PM(e, 0, 1), n = PM(e, -1);
        if (r === "%" && n !== "%") throw new E4("invalid intrinsic syntax, expected closing `%`");
        if (n === "%" && r !== "%") throw new E4("invalid intrinsic syntax, expected opening `%`");
        var i = [];
        return Voe(e, DUe, function (a, o, s, l) {
            i[i.length] = s ? Voe(l, MUe, "$1") : o || a
        }), i
    }, PUe = function (e, r) {
        var n = e, i;
        if (OM(zoe, n) && (i = zoe[n], n = "%" + i[0] + "%"), OM(Kx, n)) {
            var a = Kx[n];
            if (a === px && (a = AUe(n)), typeof a > "u" && !r) throw new Gx("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {alias: i, name: n, value: a}
        }
        throw new E4("intrinsic " + e + " does not exist!")
    }, DE = function (e, r) {
        if (typeof e != "string" || e.length === 0) throw new Gx("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof r != "boolean") throw new Gx('"allowMissing" argument must be a boolean');
        if (RUe(/^%?[^%]*%?$/, e) === null) throw new E4("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var n = OUe(e), i = n.length > 0 ? n[0] : "", a = PUe("%" + i + "%", r), o = a.name, s = a.value, l = !1,
            f = a.alias;
        f && (i = f[0], kUe(n, IUe([0, 1], f)));
        for (var d = 1, p = !0; d < n.length; d += 1) {
            var g = n[d], b = PM(g, 0, 1), S = PM(g, -1);
            if ((b === '"' || b === "'" || b === "`" || S === '"' || S === "'" || S === "`") && b !== S) throw new E4("property names with quotes must have matching quotes");
            if ((g === "constructor" || !p) && (l = !0), i += "." + g, o = "%" + i + "%", OM(Kx, o)) s = Kx[o]; else if (s != null) {
                if (!(g in s)) {
                    if (!r) throw new Gx("base intrinsic for " + e + " exists, but the property is not available.");
                    return
                }
                if (MM && d + 1 >= n.length) {
                    var T = MM(s, g);
                    p = !!T, p && "get" in T && !("originalValue" in T.get) ? s = T.get : s = s[g]
                } else p = OM(s, g), s = s[g];
                p && !l && (Kx[o] = s)
            }
        }
        return s
    }, Rge = {exports: {}}, Sj, Hoe;

function oX() {
    if (Hoe) return Sj;
    Hoe = 1;
    var t = DE, e = t("%Object.defineProperty%", !0) || !1;
    if (e) try {
        e({}, "a", {value: 1})
    } catch {
        e = !1
    }
    return Sj = e, Sj
}

var NUe = DE, dD = NUe("%Object.getOwnPropertyDescriptor%", !0);
if (dD) try {
    dD([], "length")
} catch {
    dD = null
}
var sX = dD, Woe = oX(), LUe = Age, q_ = p8, qoe = sX, BUe = function (e, r, n) {
    if (!e || typeof e != "object" && typeof e != "function") throw new q_("`obj` must be an object or a function`");
    if (typeof r != "string" && typeof r != "symbol") throw new q_("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new q_("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new q_("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new q_("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new q_("`loose`, if provided, must be a boolean");
    var i = arguments.length > 3 ? arguments[3] : null, a = arguments.length > 4 ? arguments[4] : null,
        o = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : !1,
        l = !!qoe && qoe(e, r);
    if (Woe) Woe(e, r, {
        configurable: o === null && l ? l.configurable : !o,
        enumerable: i === null && l ? l.enumerable : !i,
        value: n,
        writable: a === null && l ? l.writable : !a
    }); else if (s || !i && !a && !o) e[r] = n; else throw new LUe("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
}, $W = oX(), Dge = function () {
    return !!$W
};
Dge.hasArrayLengthDefineBug = function () {
    if (!$W) return null;
    try {
        return $W([], "length", {value: 1}).length !== 1
    } catch {
        return !0
    }
};
var $Ue = Dge, FUe = DE, Goe = BUe, UUe = $Ue(), Koe = sX, Yoe = p8, jUe = FUe("%Math.floor%"), zUe = function (e, r) {
    if (typeof e != "function") throw new Yoe("`fn` is not a function");
    if (typeof r != "number" || r < 0 || r > 4294967295 || jUe(r) !== r) throw new Yoe("`length` must be a positive 32-bit integer");
    var n = arguments.length > 2 && !!arguments[2], i = !0, a = !0;
    if ("length" in e && Koe) {
        var o = Koe(e, "length");
        o && !o.configurable && (i = !1), o && !o.writable && (a = !1)
    }
    return (i || a || !n) && (UUe ? Goe(e, "length", r, !0, !0) : Goe(e, "length", r)), e
};
(function (t) {
    var e = aX, r = DE, n = zUe, i = p8, a = r("%Function.prototype.apply%"), o = r("%Function.prototype.call%"),
        s = r("%Reflect.apply%", !0) || e.call(o, a), l = oX(), f = r("%Math.max%");
    t.exports = function (g) {
        if (typeof g != "function") throw new i("a function is required");
        var b = s(e, o, arguments);
        return n(b, 1 + f(0, g.length - (arguments.length - 1)), !0)
    };
    var d = function () {
        return s(e, a, arguments)
    };
    l ? l(t.exports, "apply", {value: d}) : t.exports.apply = d
})(Rge);
var Mge = Rge.exports, Oge = DE, Pge = Mge, VUe = Pge(Oge("String.prototype.indexOf")), cX = function (e, r) {
    var n = Oge(e, !!r);
    return typeof n == "function" && VUe(e, ".prototype.") > -1 ? Pge(n) : n
};
const HUe = {},
    WUe = Object.freeze(Object.defineProperty({__proto__: null, default: HUe}, Symbol.toStringTag, {value: "Module"})),
    ME = $P(WUe);
var lX = typeof Map == "function" && Map.prototype,
    _j = Object.getOwnPropertyDescriptor && lX ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
    NM = lX && _j && typeof _j.get == "function" ? _j.get : null, Xoe = lX && Map.prototype.forEach,
    uX = typeof Set == "function" && Set.prototype,
    xj = Object.getOwnPropertyDescriptor && uX ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
    LM = uX && xj && typeof xj.get == "function" ? xj.get : null, Qoe = uX && Set.prototype.forEach,
    qUe = typeof WeakMap == "function" && WeakMap.prototype, GT = qUe ? WeakMap.prototype.has : null,
    GUe = typeof WeakSet == "function" && WeakSet.prototype, KT = GUe ? WeakSet.prototype.has : null,
    KUe = typeof WeakRef == "function" && WeakRef.prototype, Zoe = KUe ? WeakRef.prototype.deref : null,
    YUe = Boolean.prototype.valueOf, XUe = Object.prototype.toString, QUe = Function.prototype.toString,
    ZUe = String.prototype.match, fX = String.prototype.slice, Ty = String.prototype.replace,
    JUe = String.prototype.toUpperCase, Joe = String.prototype.toLowerCase, Nge = RegExp.prototype.test,
    ese = Array.prototype.concat, g0 = Array.prototype.join, eje = Array.prototype.slice, tse = Math.floor,
    FW = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Ej = Object.getOwnPropertySymbols,
    UW = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
    T4 = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    kl = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === T4 || !0) ? Symbol.toStringTag : null,
    Lge = Object.prototype.propertyIsEnumerable,
    rse = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (t) {
        return t.__proto__
    } : null);

function nse(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || Nge.call(/e/, e)) return e;
    var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
        var n = t < 0 ? -tse(-t) : tse(t);
        if (n !== t) {
            var i = String(n), a = fX.call(e, i.length + 1);
            return Ty.call(i, r, "$&_") + "." + Ty.call(Ty.call(a, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return Ty.call(e, r, "$&_")
}

var jW = ME, ise = jW.custom, ase = $ge(ise) ? ise : null, tje = function t(e, r, n, i) {
    var a = r || {};
    if (vy(a, "quoteStyle") && a.quoteStyle !== "single" && a.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (vy(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var o = vy(a, "customInspect") ? a.customInspect : !0;
    if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (vy(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (vy(a, "numericSeparator") && typeof a.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var s = a.numericSeparator;
    if (typeof e > "u") return "undefined";
    if (e === null) return "null";
    if (typeof e == "boolean") return e ? "true" : "false";
    if (typeof e == "string") return Uge(e, a);
    if (typeof e == "number") {
        if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
        var l = String(e);
        return s ? nse(e, l) : l
    }
    if (typeof e == "bigint") {
        var f = String(e) + "n";
        return s ? nse(e, f) : f
    }
    var d = typeof a.depth > "u" ? 5 : a.depth;
    if (typeof n > "u" && (n = 0), n >= d && d > 0 && typeof e == "object") return zW(e) ? "[Array]" : "[Object]";
    var p = bje(a, n);
    if (typeof i > "u") i = []; else if (Fge(i, e) >= 0) return "[Circular]";

    function g(D, x, A) {
        if (x && (i = eje.call(i), i.push(x)), A) {
            var B = {depth: a.depth};
            return vy(a, "quoteStyle") && (B.quoteStyle = a.quoteStyle), t(D, B, n + 1, i)
        }
        return t(D, a, n + 1, i)
    }

    if (typeof e == "function" && !ose(e)) {
        var b = uje(e), S = W9(e, g);
        return "[Function" + (b ? ": " + b : " (anonymous)") + "]" + (S.length > 0 ? " { " + g0.call(S, ", ") + " }" : "")
    }
    if ($ge(e)) {
        var T = T4 ? Ty.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : UW.call(e);
        return typeof e == "object" && !T4 ? N5(T) : T
    }
    if (vje(e)) {
        for (var I = "<" + Joe.call(String(e.nodeName)), N = e.attributes || [], P = 0; P < N.length; P++) I += " " + N[P].name + "=" + Bge(rje(N[P].value), "double", a);
        return I += ">", e.childNodes && e.childNodes.length && (I += "..."), I += "</" + Joe.call(String(e.nodeName)) + ">", I
    }
    if (zW(e)) {
        if (e.length === 0) return "[]";
        var F = W9(e, g);
        return p && !yje(F) ? "[" + VW(F, p) + "]" : "[ " + g0.call(F, ", ") + " ]"
    }
    if (ije(e)) {
        var V = W9(e, g);
        return !("cause" in Error.prototype) && "cause" in e && !Lge.call(e, "cause") ? "{ [" + String(e) + "] " + g0.call(ese.call("[cause]: " + g(e.cause), V), ", ") + " }" : V.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + g0.call(V, ", ") + " }"
    }
    if (typeof e == "object" && o) {
        if (ase && typeof e[ase] == "function" && jW) return jW(e, {depth: d - n});
        if (o !== "symbol" && typeof e.inspect == "function") return e.inspect()
    }
    if (fje(e)) {
        var Y = [];
        return Xoe && Xoe.call(e, function (D, x) {
            Y.push(g(x, e, !0) + " => " + g(D, e))
        }), sse("Map", NM.call(e), Y, p)
    }
    if (pje(e)) {
        var ee = [];
        return Qoe && Qoe.call(e, function (D) {
            ee.push(g(D, e))
        }), sse("Set", LM.call(e), ee, p)
    }
    if (dje(e)) return Tj("WeakMap");
    if (mje(e)) return Tj("WeakSet");
    if (hje(e)) return Tj("WeakRef");
    if (oje(e)) return N5(g(Number(e)));
    if (cje(e)) return N5(g(FW.call(e)));
    if (sje(e)) return N5(YUe.call(e));
    if (aje(e)) return N5(g(String(e)));
    if (typeof window < "u" && e === window) return "{ [object Window] }";
    if (e === tn) return "{ [object globalThis] }";
    if (!nje(e) && !ose(e)) {
        var oe = W9(e, g), G = rse ? rse(e) === Object.prototype : e instanceof Object || e.constructor === Object,
            J = e instanceof Object ? "" : "null prototype",
            ce = !G && kl && Object(e) === e && kl in e ? fX.call(v1(e), 8, -1) : J ? "Object" : "",
            re = G || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
            M = re + (ce || J ? "[" + g0.call(ese.call([], ce || [], J || []), ": ") + "] " : "");
        return oe.length === 0 ? M + "{}" : p ? M + "{" + VW(oe, p) + "}" : M + "{ " + g0.call(oe, ", ") + " }"
    }
    return String(e)
};

function Bge(t, e, r) {
    var n = (r.quoteStyle || e) === "double" ? '"' : "'";
    return n + t + n
}

function rje(t) {
    return Ty.call(String(t), /"/g, "&quot;")
}

function zW(t) {
    return v1(t) === "[object Array]" && (!kl || !(typeof t == "object" && kl in t))
}

function nje(t) {
    return v1(t) === "[object Date]" && (!kl || !(typeof t == "object" && kl in t))
}

function ose(t) {
    return v1(t) === "[object RegExp]" && (!kl || !(typeof t == "object" && kl in t))
}

function ije(t) {
    return v1(t) === "[object Error]" && (!kl || !(typeof t == "object" && kl in t))
}

function aje(t) {
    return v1(t) === "[object String]" && (!kl || !(typeof t == "object" && kl in t))
}

function oje(t) {
    return v1(t) === "[object Number]" && (!kl || !(typeof t == "object" && kl in t))
}

function sje(t) {
    return v1(t) === "[object Boolean]" && (!kl || !(typeof t == "object" && kl in t))
}

function $ge(t) {
    if (T4) return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol") return !0;
    if (!t || typeof t != "object" || !UW) return !1;
    try {
        return UW.call(t), !0
    } catch {
    }
    return !1
}

function cje(t) {
    if (!t || typeof t != "object" || !FW) return !1;
    try {
        return FW.call(t), !0
    } catch {
    }
    return !1
}

var lje = Object.prototype.hasOwnProperty || function (t) {
    return t in this
};

function vy(t, e) {
    return lje.call(t, e)
}

function v1(t) {
    return XUe.call(t)
}

function uje(t) {
    if (t.name) return t.name;
    var e = ZUe.call(QUe.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}

function Fge(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var r = 0, n = t.length; r < n; r++) if (t[r] === e) return r;
    return -1
}

function fje(t) {
    if (!NM || !t || typeof t != "object") return !1;
    try {
        NM.call(t);
        try {
            LM.call(t)
        } catch {
            return !0
        }
        return t instanceof Map
    } catch {
    }
    return !1
}

function dje(t) {
    if (!GT || !t || typeof t != "object") return !1;
    try {
        GT.call(t, GT);
        try {
            KT.call(t, KT)
        } catch {
            return !0
        }
        return t instanceof WeakMap
    } catch {
    }
    return !1
}

function hje(t) {
    if (!Zoe || !t || typeof t != "object") return !1;
    try {
        return Zoe.call(t), !0
    } catch {
    }
    return !1
}

function pje(t) {
    if (!LM || !t || typeof t != "object") return !1;
    try {
        LM.call(t);
        try {
            NM.call(t)
        } catch {
            return !0
        }
        return t instanceof Set
    } catch {
    }
    return !1
}

function mje(t) {
    if (!KT || !t || typeof t != "object") return !1;
    try {
        KT.call(t, KT);
        try {
            GT.call(t, GT)
        } catch {
            return !0
        }
        return t instanceof WeakSet
    } catch {
    }
    return !1
}

function vje(t) {
    return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
}

function Uge(t, e) {
    if (t.length > e.maxStringLength) {
        var r = t.length - e.maxStringLength, n = "... " + r + " more character" + (r > 1 ? "s" : "");
        return Uge(fX.call(t, 0, e.maxStringLength), e) + n
    }
    var i = Ty.call(Ty.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, gje);
    return Bge(i, "single", e)
}

function gje(t) {
    var e = t.charCodeAt(0), r = {8: "b", 9: "t", 10: "n", 12: "f", 13: "r"}[e];
    return r ? "\\" + r : "\\x" + (e < 16 ? "0" : "") + JUe.call(e.toString(16))
}

function N5(t) {
    return "Object(" + t + ")"
}

function Tj(t) {
    return t + " { ? }"
}

function sse(t, e, r, n) {
    var i = n ? VW(r, n) : g0.call(r, ", ");
    return t + " (" + e + ") {" + i + "}"
}

function yje(t) {
    for (var e = 0; e < t.length; e++) if (Fge(t[e], `
`) >= 0) return !1;
    return !0
}

function bje(t, e) {
    var r;
    if (t.indent === "	") r = "	"; else if (typeof t.indent == "number" && t.indent > 0) r = g0.call(Array(t.indent + 1), " "); else return null;
    return {base: r, prev: g0.call(Array(e + 1), r)}
}

function VW(t, e) {
    if (t.length === 0) return "";
    var r = `
` + e.prev + e.base;
    return r + g0.call(t, "," + r) + `
` + e.prev
}

function W9(t, e) {
    var r = zW(t), n = [];
    if (r) {
        n.length = t.length;
        for (var i = 0; i < t.length; i++) n[i] = vy(t, i) ? e(t[i], t) : ""
    }
    var a = typeof Ej == "function" ? Ej(t) : [], o;
    if (T4) {
        o = {};
        for (var s = 0; s < a.length; s++) o["$" + a[s]] = a[s]
    }
    for (var l in t) vy(t, l) && (r && String(Number(l)) === l && l < t.length || T4 && o["$" + l] instanceof Symbol || (Nge.call(/[^\w$]/, l) ? n.push(e(l, t) + ": " + e(t[l], t)) : n.push(l + ": " + e(t[l], t))));
    if (typeof Ej == "function") for (var f = 0; f < a.length; f++) Lge.call(t, a[f]) && n.push("[" + e(a[f]) + "]: " + e(t[a[f]], t));
    return n
}

var jge = DE, OE = cX, wje = tje, Sje = p8, q9 = jge("%WeakMap%", !0), G9 = jge("%Map%", !0),
    _je = OE("WeakMap.prototype.get", !0), xje = OE("WeakMap.prototype.set", !0), Eje = OE("WeakMap.prototype.has", !0),
    Tje = OE("Map.prototype.get", !0), Cje = OE("Map.prototype.set", !0), Aje = OE("Map.prototype.has", !0),
    dX = function (t, e) {
        for (var r = t, n; (n = r.next) !== null; r = n) if (n.key === e) return r.next = n.next, n.next = t.next, t.next = n, n
    }, Ije = function (t, e) {
        var r = dX(t, e);
        return r && r.value
    }, kje = function (t, e, r) {
        var n = dX(t, e);
        n ? n.value = r : t.next = {key: e, next: t.next, value: r}
    }, Rje = function (t, e) {
        return !!dX(t, e)
    }, Dje = function () {
        var e, r, n, i = {
            assert: function (a) {
                if (!i.has(a)) throw new Sje("Side channel does not contain " + wje(a))
            }, get: function (a) {
                if (q9 && a && (typeof a == "object" || typeof a == "function")) {
                    if (e) return _je(e, a)
                } else if (G9) {
                    if (r) return Tje(r, a)
                } else if (n) return Ije(n, a)
            }, has: function (a) {
                if (q9 && a && (typeof a == "object" || typeof a == "function")) {
                    if (e) return Eje(e, a)
                } else if (G9) {
                    if (r) return Aje(r, a)
                } else if (n) return Rje(n, a);
                return !1
            }, set: function (a, o) {
                q9 && a && (typeof a == "object" || typeof a == "function") ? (e || (e = new q9), xje(e, a, o)) : G9 ? (r || (r = new G9), Cje(r, a, o)) : (n || (n = {
                    key: {},
                    next: null
                }), kje(n, a, o))
            }
        };
        return i
    }, Mje = String.prototype.replace, Oje = /%20/g, Cj = {RFC1738: "RFC1738", RFC3986: "RFC3986"}, hX = {
        default: Cj.RFC3986, formatters: {
            RFC1738: function (t) {
                return Mje.call(t, Oje, "+")
            }, RFC3986: function (t) {
                return String(t)
            }
        }, RFC1738: Cj.RFC1738, RFC3986: Cj.RFC3986
    }, Pje = hX, Aj = Object.prototype.hasOwnProperty, lw = Array.isArray, c0 = function () {
        for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t
    }(), Nje = function (e) {
        for (; e.length > 1;) {
            var r = e.pop(), n = r.obj[r.prop];
            if (lw(n)) {
                for (var i = [], a = 0; a < n.length; ++a) typeof n[a] < "u" && i.push(n[a]);
                r.obj[r.prop] = i
            }
        }
    }, zge = function (e, r) {
        for (var n = r && r.plainObjects ? Object.create(null) : {}, i = 0; i < e.length; ++i) typeof e[i] < "u" && (n[i] = e[i]);
        return n
    }, Lje = function t(e, r, n) {
        if (!r) return e;
        if (typeof r != "object") {
            if (lw(e)) e.push(r); else if (e && typeof e == "object") (n && (n.plainObjects || n.allowPrototypes) || !Aj.call(Object.prototype, r)) && (e[r] = !0); else return [e, r];
            return e
        }
        if (!e || typeof e != "object") return [e].concat(r);
        var i = e;
        return lw(e) && !lw(r) && (i = zge(e, n)), lw(e) && lw(r) ? (r.forEach(function (a, o) {
            if (Aj.call(e, o)) {
                var s = e[o];
                s && typeof s == "object" && a && typeof a == "object" ? e[o] = t(s, a, n) : e.push(a)
            } else e[o] = a
        }), e) : Object.keys(r).reduce(function (a, o) {
            var s = r[o];
            return Aj.call(a, o) ? a[o] = t(a[o], s, n) : a[o] = s, a
        }, i)
    }, Bje = function (e, r) {
        return Object.keys(r).reduce(function (n, i) {
            return n[i] = r[i], n
        }, e)
    }, $je = function (t, e, r) {
        var n = t.replace(/\+/g, " ");
        if (r === "iso-8859-1") return n.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(n)
        } catch {
            return n
        }
    }, Ij = 1024, Fje = function (e, r, n, i, a) {
        if (e.length === 0) return e;
        var o = e;
        if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), n === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function (b) {
            return "%26%23" + parseInt(b.slice(2), 16) + "%3B"
        });
        for (var s = "", l = 0; l < o.length; l += Ij) {
            for (var f = o.length >= Ij ? o.slice(l, l + Ij) : o, d = [], p = 0; p < f.length; ++p) {
                var g = f.charCodeAt(p);
                if (g === 45 || g === 46 || g === 95 || g === 126 || g >= 48 && g <= 57 || g >= 65 && g <= 90 || g >= 97 && g <= 122 || a === Pje.RFC1738 && (g === 40 || g === 41)) {
                    d[d.length] = f.charAt(p);
                    continue
                }
                if (g < 128) {
                    d[d.length] = c0[g];
                    continue
                }
                if (g < 2048) {
                    d[d.length] = c0[192 | g >> 6] + c0[128 | g & 63];
                    continue
                }
                if (g < 55296 || g >= 57344) {
                    d[d.length] = c0[224 | g >> 12] + c0[128 | g >> 6 & 63] + c0[128 | g & 63];
                    continue
                }
                p += 1, g = 65536 + ((g & 1023) << 10 | f.charCodeAt(p) & 1023), d[d.length] = c0[240 | g >> 18] + c0[128 | g >> 12 & 63] + c0[128 | g >> 6 & 63] + c0[128 | g & 63]
            }
            s += d.join("")
        }
        return s
    }, Uje = function (e) {
        for (var r = [{
            obj: {o: e},
            prop: "o"
        }], n = [], i = 0; i < r.length; ++i) for (var a = r[i], o = a.obj[a.prop], s = Object.keys(o), l = 0; l < s.length; ++l) {
            var f = s[l], d = o[f];
            typeof d == "object" && d !== null && n.indexOf(d) === -1 && (r.push({obj: o, prop: f}), n.push(d))
        }
        return Nje(r), e
    }, jje = function (e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    }, zje = function (e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    }, Vje = function (e, r) {
        return [].concat(e, r)
    }, Hje = function (e, r) {
        if (lw(e)) {
            for (var n = [], i = 0; i < e.length; i += 1) n.push(r(e[i]));
            return n
        }
        return r(e)
    }, Vge = {
        arrayToObject: zge,
        assign: Bje,
        combine: Vje,
        compact: Uje,
        decode: $je,
        encode: Fje,
        isBuffer: zje,
        isRegExp: jje,
        maybeMap: Hje,
        merge: Lje
    }, Hge = Dje, hD = Vge, YT = hX, Wje = Object.prototype.hasOwnProperty, Wge = {
        brackets: function (e) {
            return e + "[]"
        }, comma: "comma", indices: function (e, r) {
            return e + "[" + r + "]"
        }, repeat: function (e) {
            return e
        }
    }, m0 = Array.isArray, qje = Array.prototype.push, qge = function (t, e) {
        qje.apply(t, m0(e) ? e : [e])
    }, Gje = Date.prototype.toISOString, cse = YT.default, Cs = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: hD.encode,
        encodeValuesOnly: !1,
        format: cse,
        formatter: YT.formatters[cse],
        indices: !1,
        serializeDate: function (e) {
            return Gje.call(e)
        },
        skipNulls: !1,
        strictNullHandling: !1
    }, Kje = function (e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    }, kj = {}, Yje = function t(e, r, n, i, a, o, s, l, f, d, p, g, b, S, T, I, N, P) {
        for (var F = e, V = P, Y = 0, ee = !1; (V = V.get(kj)) !== void 0 && !ee;) {
            var oe = V.get(e);
            if (Y += 1, typeof oe < "u") {
                if (oe === Y) throw new RangeError("Cyclic object value");
                ee = !0
            }
            typeof V.get(kj) > "u" && (Y = 0)
        }
        if (typeof d == "function" ? F = d(r, F) : F instanceof Date ? F = b(F) : n === "comma" && m0(F) && (F = hD.maybeMap(F, function (C) {
            return C instanceof Date ? b(C) : C
        })), F === null) {
            if (o) return f && !I ? f(r, Cs.encoder, N, "key", S) : r;
            F = ""
        }
        if (Kje(F) || hD.isBuffer(F)) {
            if (f) {
                var G = I ? r : f(r, Cs.encoder, N, "key", S);
                return [T(G) + "=" + T(f(F, Cs.encoder, N, "value", S))]
            }
            return [T(r) + "=" + T(String(F))]
        }
        var J = [];
        if (typeof F > "u") return J;
        var ce;
        if (n === "comma" && m0(F)) I && f && (F = hD.maybeMap(F, f)), ce = [{value: F.length > 0 ? F.join(",") || null : void 0}]; else if (m0(d)) ce = d; else {
            var re = Object.keys(F);
            ce = p ? re.sort(p) : re
        }
        var M = l ? r.replace(/\./g, "%2E") : r, D = i && m0(F) && F.length === 1 ? M + "[]" : M;
        if (a && m0(F) && F.length === 0) return D + "[]";
        for (var x = 0; x < ce.length; ++x) {
            var A = ce[x], B = typeof A == "object" && typeof A.value < "u" ? A.value : F[A];
            if (!(s && B === null)) {
                var z = g && l ? A.replace(/\./g, "%2E") : A,
                    j = m0(F) ? typeof n == "function" ? n(D, z) : D : D + (g ? "." + z : "[" + z + "]");
                P.set(e, Y);
                var $ = Hge();
                $.set(kj, P), qge(J, t(B, j, n, i, a, o, s, l, n === "comma" && I && m0(F) ? null : f, d, p, g, b, S, T, I, N, $))
            }
        }
        return J
    }, Xje = function (e) {
        if (!e) return Cs;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var r = e.charset || Cs.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var n = YT.default;
        if (typeof e.format < "u") {
            if (!Wje.call(YT.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            n = e.format
        }
        var i = YT.formatters[n], a = Cs.filter;
        (typeof e.filter == "function" || m0(e.filter)) && (a = e.filter);
        var o;
        if (e.arrayFormat in Wge ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = Cs.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var s = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : Cs.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Cs.addQueryPrefix,
            allowDots: s,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Cs.allowEmptyArrays,
            arrayFormat: o,
            charset: r,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Cs.charsetSentinel,
            commaRoundTrip: e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? Cs.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : Cs.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : Cs.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : Cs.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Cs.encodeValuesOnly,
            filter: a,
            format: n,
            formatter: i,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Cs.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Cs.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Cs.strictNullHandling
        }
    }, Qje = function (t, e) {
        var r = t, n = Xje(e), i, a;
        typeof n.filter == "function" ? (a = n.filter, r = a("", r)) : m0(n.filter) && (a = n.filter, i = a);
        var o = [];
        if (typeof r != "object" || r === null) return "";
        var s = Wge[n.arrayFormat], l = s === "comma" && n.commaRoundTrip;
        i || (i = Object.keys(r)), n.sort && i.sort(n.sort);
        for (var f = Hge(), d = 0; d < i.length; ++d) {
            var p = i[d];
            n.skipNulls && r[p] === null || qge(o, Yje(r[p], p, s, l, n.allowEmptyArrays, n.strictNullHandling, n.skipNulls, n.encodeDotInKeys, n.encode ? n.encoder : null, n.filter, n.sort, n.allowDots, n.serializeDate, n.format, n.formatter, n.encodeValuesOnly, n.charset, f))
        }
        var g = o.join(n.delimiter), b = n.addQueryPrefix === !0 ? "?" : "";
        return n.charsetSentinel && (n.charset === "iso-8859-1" ? b += "utf8=%26%2310003%3B&" : b += "utf8=%E2%9C%93&"), g.length > 0 ? b + g : ""
    }, C4 = Vge, HW = Object.prototype.hasOwnProperty, Zje = Array.isArray, Uo = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: C4.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictNullHandling: !1
    }, Jje = function (t) {
        return t.replace(/&#(\d+);/g, function (e, r) {
            return String.fromCharCode(parseInt(r, 10))
        })
    }, Gge = function (t, e) {
        return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
    }, eze = "utf8=%26%2310003%3B", tze = "utf8=%E2%9C%93", rze = function (e, r) {
        var n = {__proto__: null}, i = r.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
            a = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, o = i.split(r.delimiter, a), s = -1, l,
            f = r.charset;
        if (r.charsetSentinel) for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === tze ? f = "utf-8" : o[l] === eze && (f = "iso-8859-1"), s = l, l = o.length);
        for (l = 0; l < o.length; ++l) if (l !== s) {
            var d = o[l], p = d.indexOf("]="), g = p === -1 ? d.indexOf("=") : p + 1, b, S;
            g === -1 ? (b = r.decoder(d, Uo.decoder, f, "key"), S = r.strictNullHandling ? null : "") : (b = r.decoder(d.slice(0, g), Uo.decoder, f, "key"), S = C4.maybeMap(Gge(d.slice(g + 1), r), function (I) {
                return r.decoder(I, Uo.decoder, f, "value")
            })), S && r.interpretNumericEntities && f === "iso-8859-1" && (S = Jje(S)), d.indexOf("[]=") > -1 && (S = Zje(S) ? [S] : S);
            var T = HW.call(n, b);
            T && r.duplicates === "combine" ? n[b] = C4.combine(n[b], S) : (!T || r.duplicates === "last") && (n[b] = S)
        }
        return n
    }, nze = function (t, e, r, n) {
        for (var i = n ? e : Gge(e, r), a = t.length - 1; a >= 0; --a) {
            var o, s = t[a];
            if (s === "[]" && r.parseArrays) o = r.allowEmptyArrays && i === "" ? [] : [].concat(i); else {
                o = r.plainObjects ? Object.create(null) : {};
                var l = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s,
                    f = r.decodeDotInKeys ? l.replace(/%2E/g, ".") : l, d = parseInt(f, 10);
                !r.parseArrays && f === "" ? o = {0: i} : !isNaN(d) && s !== f && String(d) === f && d >= 0 && r.parseArrays && d <= r.arrayLimit ? (o = [], o[d] = i) : f !== "__proto__" && (o[f] = i)
            }
            i = o
        }
        return i
    }, ize = function (e, r, n, i) {
        if (e) {
            var a = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g,
                l = n.depth > 0 && o.exec(a), f = l ? a.slice(0, l.index) : a, d = [];
            if (f) {
                if (!n.plainObjects && HW.call(Object.prototype, f) && !n.allowPrototypes) return;
                d.push(f)
            }
            for (var p = 0; n.depth > 0 && (l = s.exec(a)) !== null && p < n.depth;) {
                if (p += 1, !n.plainObjects && HW.call(Object.prototype, l[1].slice(1, -1)) && !n.allowPrototypes) return;
                d.push(l[1])
            }
            return l && d.push("[" + a.slice(l.index) + "]"), nze(d, r, n, i)
        }
    }, aze = function (e) {
        if (!e) return Uo;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var r = typeof e.charset > "u" ? Uo.charset : e.charset,
            n = typeof e.duplicates > "u" ? Uo.duplicates : e.duplicates;
        if (n !== "combine" && n !== "first" && n !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var i = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : Uo.allowDots : !!e.allowDots;
        return {
            allowDots: i,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Uo.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Uo.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Uo.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Uo.arrayLimit,
            charset: r,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Uo.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : Uo.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : Uo.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : Uo.decoder,
            delimiter: typeof e.delimiter == "string" || C4.isRegExp(e.delimiter) ? e.delimiter : Uo.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Uo.depth,
            duplicates: n,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Uo.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Uo.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Uo.plainObjects,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Uo.strictNullHandling
        }
    }, oze = function (t, e) {
        var r = aze(e);
        if (t === "" || t === null || typeof t > "u") return r.plainObjects ? Object.create(null) : {};
        for (var n = typeof t == "string" ? rze(t, r) : t, i = r.plainObjects ? Object.create(null) : {}, a = Object.keys(n), o = 0; o < a.length; ++o) {
            var s = a[o], l = ize(s, n[s], r, typeof t == "string");
            i = C4.merge(i, l, r)
        }
        return r.allowSparse === !0 ? i : C4.compact(i)
    }, sze = Qje, cze = oze, lze = hX, uze = {formats: lze, parse: cze, stringify: sze};
const pX = za(uze), Kge = mn("@dexscreener/data-access-assets-worker/assetsWorkerHost")(), fze = pt(Kge, t => ({
    buildUrl: e => {
        const r = new URL(t);
        return r.pathname = "/fetch", r.search = pX.stringify(e), r.toString()
    }
}));

function Rv(t) {
    return Array.isArray(t)
}

function au(t) {
    return t.length > 0
}

function Zg(t) {
    return t.length > 1
}

function L5(t) {
    return t.length > 2
}

function dze(t) {
    return t.length > 3
}

function BM(t, e) {
    const [r, ...n] = t;
    return [e(r), ...n.map(e)]
}

const Wd = [];

function hze(t, e) {
    const r = [];
    let n = !1;
    for (const i of t) e(i) ? r.push(i) : n = !0;
    return n ? r : t
}

function uw(t) {
    const e = [];
    let r = 0;
    for (const a of t.items) a.weight > 0 && (e.push(a), r += a.weight);
    if (e.length === 0) return;
    const n = (t.random ?? Math.random()) * r;
    let i = 0;
    for (const a of e) if (i += a.weight, n < i) return a;
    return e[e.length - 1]
}

function pze(t) {
    const e = new Set(t.items.filter(({weight: n}) => n > 0));
    if (e.size === 0 || t.numberOfItems <= 0) return [];
    if (t.numberOfItems >= e.size) return Array.from(e);
    const r = new Set;
    for (let n = 0; n < t.numberOfItems; n++) {
        const i = uw({items: Array.from(e), random: t.random});
        if (i === void 0 || (e.delete(i), r.add(i), e.size === 0) || r.size === t.numberOfItems) break
    }
    return Array.from(r)
}

const XT = {kind: "AsyncPending"}, GZt = t => ({kind: "AsyncFailure", error: t}),
    Rj = t => ({kind: "AsyncSuccess", value: t}), KZt = t => ({kind: "AsyncPendingWithData", value: t}), Py = t => {
        switch (t.value.kind) {
            case"AsyncPending":
                return t.onPending();
            case"AsyncFailure":
                return t.onFailure(t.value.error);
            case"AsyncSuccess":
                return t.onSuccess(t.value.value);
            case"AsyncFailureWithData":
                return t.onFailureWithData ? t.onFailureWithData(t.value.value, t.value.error) : t.onSuccess(t.value.value);
            case"AsyncPendingWithData":
                return t.onPendingWithData ? t.onPendingWithData(t.value.value) : t.onSuccess(t.value.value)
        }
    }, mze = (t, e, r) => {
        switch (t.kind) {
            case"AsyncPending": {
                switch (e.kind) {
                    case"AsyncPending":
                        return t;
                    case"AsyncFailure":
                        return e;
                    case"AsyncSuccess":
                        return t;
                    case"AsyncFailureWithData":
                        return t;
                    case"AsyncPendingWithData":
                        return t
                }
                break
            }
            case"AsyncFailure": {
                switch (e.kind) {
                    case"AsyncPending":
                        return t;
                    case"AsyncFailure":
                        return t;
                    case"AsyncSuccess":
                        return t;
                    case"AsyncFailureWithData":
                        return t;
                    case"AsyncPendingWithData":
                        return t
                }
                break
            }
            case"AsyncSuccess": {
                switch (e.kind) {
                    case"AsyncPending":
                        return e;
                    case"AsyncFailure":
                        return e;
                    case"AsyncSuccess":
                        return {kind: "AsyncSuccess", value: r(t.value, e.value)};
                    case"AsyncFailureWithData":
                        return {kind: "AsyncFailureWithData", value: r(t.value, e.value), error: e.error};
                    case"AsyncPendingWithData":
                        return {kind: "AsyncPendingWithData", value: r(t.value, e.value)}
                }
                break
            }
            case"AsyncFailureWithData": {
                switch (e.kind) {
                    case"AsyncPending":
                        return e;
                    case"AsyncFailure":
                        return e;
                    case"AsyncSuccess":
                        return {kind: "AsyncFailureWithData", value: r(t.value, e.value), error: t.error};
                    case"AsyncFailureWithData":
                        return {kind: "AsyncFailureWithData", value: r(t.value, e.value), error: t.error};
                    case"AsyncPendingWithData":
                        return {kind: "AsyncFailureWithData", value: r(t.value, e.value), error: t.error}
                }
                break
            }
            case"AsyncPendingWithData": {
                switch (e.kind) {
                    case"AsyncPending":
                        return e;
                    case"AsyncFailure":
                        return e;
                    case"AsyncSuccess":
                        return {kind: "AsyncPendingWithData", value: r(t.value, e.value)};
                    case"AsyncFailureWithData":
                        return {kind: "AsyncFailureWithData", value: r(t.value, e.value), error: e.error};
                    case"AsyncPendingWithData":
                        return {kind: "AsyncPendingWithData", value: r(t.value, e.value)}
                }
                break
            }
        }
    }, Dj = (t, e) => {
        switch (t.kind) {
            case"AsyncPending":
                return t;
            case"AsyncFailure":
                return t;
            case"AsyncSuccess":
                return {kind: "AsyncSuccess", value: e(t.value)};
            case"AsyncFailureWithData":
                return {kind: "AsyncFailureWithData", value: e(t.value), error: t.error};
            case"AsyncPendingWithData":
                return {kind: "AsyncPendingWithData", value: e(t.value)}
        }
    }, vze = (...t) => t;

function YZt(...t) {
    const e = t[t.length - 1];
    let r, n;
    if (typeof e == "function" ? (r = t[t.length - 1], n = t.slice(0, t.length - 1)) : (r = vze, n = t), n.length > 1) {
        const i = n[0];
        if (i !== void 0) {
            let a = Dj(i, o => [o]);
            for (let o = 1; o < n.length; o++) {
                const s = n[o];
                s !== void 0 && (a = mze(a, s, (l, f) => [...l, f]))
            }
            return Dj(a, o => r(...o))
        }
    }
    if (n.length === 1) {
        const i = n[0];
        if (i !== void 0) return Dj(i, r)
    }
    return {kind: "AsyncSuccess", value: r()}
}

function $c(t) {
    if (t === null || t === !0 || t === !1) return NaN;
    var e = Number(t);
    return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e)
}

function ii(t, e) {
    if (e.length < t) throw new TypeError(t + " argument" + (t > 1 ? "s" : "") + " required, but only " + e.length + " present")
}

function pD(t) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? pD = function (r) {
        return typeof r
    } : pD = function (r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
    }, pD(t)
}

function Nn(t) {
    ii(1, arguments);
    var e = Object.prototype.toString.call(t);
    return t instanceof Date || pD(t) === "object" && e === "[object Date]" ? new Date(t.getTime()) : typeof t == "number" || e === "[object Number]" ? new Date(t) : ((typeof t == "string" || e === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN))
}

function gze(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = $c(e);
    return isNaN(n) ? new Date(NaN) : (n && r.setDate(r.getDate() + n), r)
}

function yze(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = $c(e);
    if (isNaN(n)) return new Date(NaN);
    if (!n) return r;
    var i = r.getDate(), a = new Date(r.getTime());
    a.setMonth(r.getMonth() + n + 1, 0);
    var o = a.getDate();
    return i >= o ? a : (r.setFullYear(a.getFullYear(), a.getMonth(), i), r)
}

function mD(t) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? mD = function (r) {
        return typeof r
    } : mD = function (r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
    }, mD(t)
}

function B5(t, e) {
    if (ii(2, arguments), !e || mD(e) !== "object") return new Date(NaN);
    var r = e.years ? $c(e.years) : 0, n = e.months ? $c(e.months) : 0, i = e.weeks ? $c(e.weeks) : 0,
        a = e.days ? $c(e.days) : 0, o = e.hours ? $c(e.hours) : 0, s = e.minutes ? $c(e.minutes) : 0,
        l = e.seconds ? $c(e.seconds) : 0, f = Nn(t), d = n || r ? yze(f, n + r * 12) : f,
        p = a || i ? gze(d, a + i * 7) : d, g = s + o * 60, b = l + g * 60, S = b * 1e3, T = new Date(p.getTime() + S);
    return T
}

function bze(t, e) {
    ii(2, arguments);
    var r = Nn(t).getTime(), n = $c(e);
    return new Date(r + n)
}

var wze = {};

function v8() {
    return wze
}

function QC(t) {
    var e = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return e.setUTCFullYear(t.getFullYear()), t.getTime() - e.getTime()
}

function lse(t) {
    ii(1, arguments);
    var e = Nn(t);
    return e.setHours(0, 0, 0, 0), e
}

var Sze = 864e5;

function _ze(t, e) {
    ii(2, arguments);
    var r = lse(t), n = lse(e), i = r.getTime() - QC(r), a = n.getTime() - QC(n);
    return Math.round((i - a) / Sze)
}

function $w(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e), i = r.getTime() - n.getTime();
    return i < 0 ? -1 : i > 0 ? 1 : i
}

var xze = 6e4, Eze = 36e5;

function vD(t) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? vD = function (r) {
        return typeof r
    } : vD = function (r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
    }, vD(t)
}

function Tze(t) {
    return ii(1, arguments), t instanceof Date || vD(t) === "object" && Object.prototype.toString.call(t) === "[object Date]"
}

function Yge(t) {
    if (ii(1, arguments), !Tze(t) && typeof t != "number") return !1;
    var e = Nn(t);
    return !isNaN(Number(e))
}

function Cze(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e), i = r.getFullYear() - n.getFullYear(), a = r.getMonth() - n.getMonth();
    return i * 12 + a
}

function Aze(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e);
    return r.getFullYear() - n.getFullYear()
}

function use(t, e) {
    var r = t.getFullYear() - e.getFullYear() || t.getMonth() - e.getMonth() || t.getDate() - e.getDate() || t.getHours() - e.getHours() || t.getMinutes() - e.getMinutes() || t.getSeconds() - e.getSeconds() || t.getMilliseconds() - e.getMilliseconds();
    return r < 0 ? -1 : r > 0 ? 1 : r
}

function Ize(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e), i = use(r, n), a = Math.abs(_ze(r, n));
    r.setDate(r.getDate() - i * a);
    var o = +(use(r, n) === -i), s = i * (a - o);
    return s === 0 ? 0 : s
}

function mX(t, e) {
    return ii(2, arguments), Nn(t).getTime() - Nn(e).getTime()
}

var fse = {
    ceil: Math.ceil, round: Math.round, floor: Math.floor, trunc: function (e) {
        return e < 0 ? Math.ceil(e) : Math.floor(e)
    }
}, kze = "trunc";

function zP(t) {
    return t ? fse[t] : fse[kze]
}

function Rze(t, e, r) {
    ii(2, arguments);
    var n = mX(t, e) / Eze;
    return zP(r == null ? void 0 : r.roundingMethod)(n)
}

function Dze(t, e, r) {
    ii(2, arguments);
    var n = mX(t, e) / xze;
    return zP(r == null ? void 0 : r.roundingMethod)(n)
}

function Mze(t) {
    ii(1, arguments);
    var e = Nn(t);
    return e.setHours(23, 59, 59, 999), e
}

function Oze(t) {
    ii(1, arguments);
    var e = Nn(t), r = e.getMonth();
    return e.setFullYear(e.getFullYear(), r + 1, 0), e.setHours(23, 59, 59, 999), e
}

function Pze(t) {
    ii(1, arguments);
    var e = Nn(t);
    return Mze(e).getTime() === Oze(e).getTime()
}

function Xge(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e), i = $w(r, n), a = Math.abs(Cze(r, n)), o;
    if (a < 1) o = 0; else {
        r.getMonth() === 1 && r.getDate() > 27 && r.setDate(30), r.setMonth(r.getMonth() - i * a);
        var s = $w(r, n) === -i;
        Pze(Nn(t)) && a === 1 && $w(t, n) === 1 && (s = !1), o = i * (a - Number(s))
    }
    return o === 0 ? 0 : o
}

function Qge(t, e, r) {
    ii(2, arguments);
    var n = mX(t, e) / 1e3;
    return zP(r == null ? void 0 : r.roundingMethod)(n)
}

function Nze(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e), i = $w(r, n), a = Math.abs(Aze(r, n));
    r.setFullYear(1584), n.setFullYear(1584);
    var o = $w(r, n) === -i, s = i * (a - Number(o));
    return s === 0 ? 0 : s
}

function Lze(t, e) {
    ii(2, arguments);
    var r = $c(e);
    return bze(t, -r)
}

var Bze = 864e5;

function $ze(t) {
    ii(1, arguments);
    var e = Nn(t), r = e.getTime();
    e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
    var n = e.getTime(), i = r - n;
    return Math.floor(i / Bze) + 1
}

function $M(t) {
    ii(1, arguments);
    var e = 1, r = Nn(t), n = r.getUTCDay(), i = (n < e ? 7 : 0) + n - e;
    return r.setUTCDate(r.getUTCDate() - i), r.setUTCHours(0, 0, 0, 0), r
}

function Zge(t) {
    ii(1, arguments);
    var e = Nn(t), r = e.getUTCFullYear(), n = new Date(0);
    n.setUTCFullYear(r + 1, 0, 4), n.setUTCHours(0, 0, 0, 0);
    var i = $M(n), a = new Date(0);
    a.setUTCFullYear(r, 0, 4), a.setUTCHours(0, 0, 0, 0);
    var o = $M(a);
    return e.getTime() >= i.getTime() ? r + 1 : e.getTime() >= o.getTime() ? r : r - 1
}

function Fze(t) {
    ii(1, arguments);
    var e = Zge(t), r = new Date(0);
    r.setUTCFullYear(e, 0, 4), r.setUTCHours(0, 0, 0, 0);
    var n = $M(r);
    return n
}

var Uze = 6048e5;

function jze(t) {
    ii(1, arguments);
    var e = Nn(t), r = $M(e).getTime() - Fze(e).getTime();
    return Math.round(r / Uze) + 1
}

function FM(t, e) {
    var r, n, i, a, o, s, l, f;
    ii(1, arguments);
    var d = v8(),
        p = $c((r = (n = (i = (a = e == null ? void 0 : e.weekStartsOn) !== null && a !== void 0 ? a : e == null || (o = e.locale) === null || o === void 0 || (s = o.options) === null || s === void 0 ? void 0 : s.weekStartsOn) !== null && i !== void 0 ? i : d.weekStartsOn) !== null && n !== void 0 ? n : (l = d.locale) === null || l === void 0 || (f = l.options) === null || f === void 0 ? void 0 : f.weekStartsOn) !== null && r !== void 0 ? r : 0);
    if (!(p >= 0 && p <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var g = Nn(t), b = g.getUTCDay(), S = (b < p ? 7 : 0) + b - p;
    return g.setUTCDate(g.getUTCDate() - S), g.setUTCHours(0, 0, 0, 0), g
}

function Jge(t, e) {
    var r, n, i, a, o, s, l, f;
    ii(1, arguments);
    var d = Nn(t), p = d.getUTCFullYear(), g = v8(),
        b = $c((r = (n = (i = (a = e == null ? void 0 : e.firstWeekContainsDate) !== null && a !== void 0 ? a : e == null || (o = e.locale) === null || o === void 0 || (s = o.options) === null || s === void 0 ? void 0 : s.firstWeekContainsDate) !== null && i !== void 0 ? i : g.firstWeekContainsDate) !== null && n !== void 0 ? n : (l = g.locale) === null || l === void 0 || (f = l.options) === null || f === void 0 ? void 0 : f.firstWeekContainsDate) !== null && r !== void 0 ? r : 1);
    if (!(b >= 1 && b <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var S = new Date(0);
    S.setUTCFullYear(p + 1, 0, b), S.setUTCHours(0, 0, 0, 0);
    var T = FM(S, e), I = new Date(0);
    I.setUTCFullYear(p, 0, b), I.setUTCHours(0, 0, 0, 0);
    var N = FM(I, e);
    return d.getTime() >= T.getTime() ? p + 1 : d.getTime() >= N.getTime() ? p : p - 1
}

function zze(t, e) {
    var r, n, i, a, o, s, l, f;
    ii(1, arguments);
    var d = v8(),
        p = $c((r = (n = (i = (a = e == null ? void 0 : e.firstWeekContainsDate) !== null && a !== void 0 ? a : e == null || (o = e.locale) === null || o === void 0 || (s = o.options) === null || s === void 0 ? void 0 : s.firstWeekContainsDate) !== null && i !== void 0 ? i : d.firstWeekContainsDate) !== null && n !== void 0 ? n : (l = d.locale) === null || l === void 0 || (f = l.options) === null || f === void 0 ? void 0 : f.firstWeekContainsDate) !== null && r !== void 0 ? r : 1),
        g = Jge(t, e), b = new Date(0);
    b.setUTCFullYear(g, 0, p), b.setUTCHours(0, 0, 0, 0);
    var S = FM(b, e);
    return S
}

var Vze = 6048e5;

function Hze(t, e) {
    ii(1, arguments);
    var r = Nn(t), n = FM(r, e).getTime() - zze(r, e).getTime();
    return Math.round(n / Vze) + 1
}

function ta(t, e) {
    for (var r = t < 0 ? "-" : "", n = Math.abs(t).toString(); n.length < e;) n = "0" + n;
    return r + n
}

var Wze = {
    y: function (e, r) {
        var n = e.getUTCFullYear(), i = n > 0 ? n : 1 - n;
        return ta(r === "yy" ? i % 100 : i, r.length)
    }, M: function (e, r) {
        var n = e.getUTCMonth();
        return r === "M" ? String(n + 1) : ta(n + 1, 2)
    }, d: function (e, r) {
        return ta(e.getUTCDate(), r.length)
    }, a: function (e, r) {
        var n = e.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (r) {
            case"a":
            case"aa":
                return n.toUpperCase();
            case"aaa":
                return n;
            case"aaaaa":
                return n[0];
            case"aaaa":
            default:
                return n === "am" ? "a.m." : "p.m."
        }
    }, h: function (e, r) {
        return ta(e.getUTCHours() % 12 || 12, r.length)
    }, H: function (e, r) {
        return ta(e.getUTCHours(), r.length)
    }, m: function (e, r) {
        return ta(e.getUTCMinutes(), r.length)
    }, s: function (e, r) {
        return ta(e.getUTCSeconds(), r.length)
    }, S: function (e, r) {
        var n = r.length, i = e.getUTCMilliseconds(), a = Math.floor(i * Math.pow(10, n - 3));
        return ta(a, r.length)
    }
};
const Jg = Wze;
var G_ = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}, qze = {
    G: function (e, r, n) {
        var i = e.getUTCFullYear() > 0 ? 1 : 0;
        switch (r) {
            case"G":
            case"GG":
            case"GGG":
                return n.era(i, {width: "abbreviated"});
            case"GGGGG":
                return n.era(i, {width: "narrow"});
            case"GGGG":
            default:
                return n.era(i, {width: "wide"})
        }
    }, y: function (e, r, n) {
        if (r === "yo") {
            var i = e.getUTCFullYear(), a = i > 0 ? i : 1 - i;
            return n.ordinalNumber(a, {unit: "year"})
        }
        return Jg.y(e, r)
    }, Y: function (e, r, n, i) {
        var a = Jge(e, i), o = a > 0 ? a : 1 - a;
        if (r === "YY") {
            var s = o % 100;
            return ta(s, 2)
        }
        return r === "Yo" ? n.ordinalNumber(o, {unit: "year"}) : ta(o, r.length)
    }, R: function (e, r) {
        var n = Zge(e);
        return ta(n, r.length)
    }, u: function (e, r) {
        var n = e.getUTCFullYear();
        return ta(n, r.length)
    }, Q: function (e, r, n) {
        var i = Math.ceil((e.getUTCMonth() + 1) / 3);
        switch (r) {
            case"Q":
                return String(i);
            case"QQ":
                return ta(i, 2);
            case"Qo":
                return n.ordinalNumber(i, {unit: "quarter"});
            case"QQQ":
                return n.quarter(i, {width: "abbreviated", context: "formatting"});
            case"QQQQQ":
                return n.quarter(i, {width: "narrow", context: "formatting"});
            case"QQQQ":
            default:
                return n.quarter(i, {width: "wide", context: "formatting"})
        }
    }, q: function (e, r, n) {
        var i = Math.ceil((e.getUTCMonth() + 1) / 3);
        switch (r) {
            case"q":
                return String(i);
            case"qq":
                return ta(i, 2);
            case"qo":
                return n.ordinalNumber(i, {unit: "quarter"});
            case"qqq":
                return n.quarter(i, {width: "abbreviated", context: "standalone"});
            case"qqqqq":
                return n.quarter(i, {width: "narrow", context: "standalone"});
            case"qqqq":
            default:
                return n.quarter(i, {width: "wide", context: "standalone"})
        }
    }, M: function (e, r, n) {
        var i = e.getUTCMonth();
        switch (r) {
            case"M":
            case"MM":
                return Jg.M(e, r);
            case"Mo":
                return n.ordinalNumber(i + 1, {unit: "month"});
            case"MMM":
                return n.month(i, {width: "abbreviated", context: "formatting"});
            case"MMMMM":
                return n.month(i, {width: "narrow", context: "formatting"});
            case"MMMM":
            default:
                return n.month(i, {width: "wide", context: "formatting"})
        }
    }, L: function (e, r, n) {
        var i = e.getUTCMonth();
        switch (r) {
            case"L":
                return String(i + 1);
            case"LL":
                return ta(i + 1, 2);
            case"Lo":
                return n.ordinalNumber(i + 1, {unit: "month"});
            case"LLL":
                return n.month(i, {width: "abbreviated", context: "standalone"});
            case"LLLLL":
                return n.month(i, {width: "narrow", context: "standalone"});
            case"LLLL":
            default:
                return n.month(i, {width: "wide", context: "standalone"})
        }
    }, w: function (e, r, n, i) {
        var a = Hze(e, i);
        return r === "wo" ? n.ordinalNumber(a, {unit: "week"}) : ta(a, r.length)
    }, I: function (e, r, n) {
        var i = jze(e);
        return r === "Io" ? n.ordinalNumber(i, {unit: "week"}) : ta(i, r.length)
    }, d: function (e, r, n) {
        return r === "do" ? n.ordinalNumber(e.getUTCDate(), {unit: "date"}) : Jg.d(e, r)
    }, D: function (e, r, n) {
        var i = $ze(e);
        return r === "Do" ? n.ordinalNumber(i, {unit: "dayOfYear"}) : ta(i, r.length)
    }, E: function (e, r, n) {
        var i = e.getUTCDay();
        switch (r) {
            case"E":
            case"EE":
            case"EEE":
                return n.day(i, {width: "abbreviated", context: "formatting"});
            case"EEEEE":
                return n.day(i, {width: "narrow", context: "formatting"});
            case"EEEEEE":
                return n.day(i, {width: "short", context: "formatting"});
            case"EEEE":
            default:
                return n.day(i, {width: "wide", context: "formatting"})
        }
    }, e: function (e, r, n, i) {
        var a = e.getUTCDay(), o = (a - i.weekStartsOn + 8) % 7 || 7;
        switch (r) {
            case"e":
                return String(o);
            case"ee":
                return ta(o, 2);
            case"eo":
                return n.ordinalNumber(o, {unit: "day"});
            case"eee":
                return n.day(a, {width: "abbreviated", context: "formatting"});
            case"eeeee":
                return n.day(a, {width: "narrow", context: "formatting"});
            case"eeeeee":
                return n.day(a, {width: "short", context: "formatting"});
            case"eeee":
            default:
                return n.day(a, {width: "wide", context: "formatting"})
        }
    }, c: function (e, r, n, i) {
        var a = e.getUTCDay(), o = (a - i.weekStartsOn + 8) % 7 || 7;
        switch (r) {
            case"c":
                return String(o);
            case"cc":
                return ta(o, r.length);
            case"co":
                return n.ordinalNumber(o, {unit: "day"});
            case"ccc":
                return n.day(a, {width: "abbreviated", context: "standalone"});
            case"ccccc":
                return n.day(a, {width: "narrow", context: "standalone"});
            case"cccccc":
                return n.day(a, {width: "short", context: "standalone"});
            case"cccc":
            default:
                return n.day(a, {width: "wide", context: "standalone"})
        }
    }, i: function (e, r, n) {
        var i = e.getUTCDay(), a = i === 0 ? 7 : i;
        switch (r) {
            case"i":
                return String(a);
            case"ii":
                return ta(a, r.length);
            case"io":
                return n.ordinalNumber(a, {unit: "day"});
            case"iii":
                return n.day(i, {width: "abbreviated", context: "formatting"});
            case"iiiii":
                return n.day(i, {width: "narrow", context: "formatting"});
            case"iiiiii":
                return n.day(i, {width: "short", context: "formatting"});
            case"iiii":
            default:
                return n.day(i, {width: "wide", context: "formatting"})
        }
    }, a: function (e, r, n) {
        var i = e.getUTCHours(), a = i / 12 >= 1 ? "pm" : "am";
        switch (r) {
            case"a":
            case"aa":
                return n.dayPeriod(a, {width: "abbreviated", context: "formatting"});
            case"aaa":
                return n.dayPeriod(a, {width: "abbreviated", context: "formatting"}).toLowerCase();
            case"aaaaa":
                return n.dayPeriod(a, {width: "narrow", context: "formatting"});
            case"aaaa":
            default:
                return n.dayPeriod(a, {width: "wide", context: "formatting"})
        }
    }, b: function (e, r, n) {
        var i = e.getUTCHours(), a;
        switch (i === 12 ? a = G_.noon : i === 0 ? a = G_.midnight : a = i / 12 >= 1 ? "pm" : "am", r) {
            case"b":
            case"bb":
                return n.dayPeriod(a, {width: "abbreviated", context: "formatting"});
            case"bbb":
                return n.dayPeriod(a, {width: "abbreviated", context: "formatting"}).toLowerCase();
            case"bbbbb":
                return n.dayPeriod(a, {width: "narrow", context: "formatting"});
            case"bbbb":
            default:
                return n.dayPeriod(a, {width: "wide", context: "formatting"})
        }
    }, B: function (e, r, n) {
        var i = e.getUTCHours(), a;
        switch (i >= 17 ? a = G_.evening : i >= 12 ? a = G_.afternoon : i >= 4 ? a = G_.morning : a = G_.night, r) {
            case"B":
            case"BB":
            case"BBB":
                return n.dayPeriod(a, {width: "abbreviated", context: "formatting"});
            case"BBBBB":
                return n.dayPeriod(a, {width: "narrow", context: "formatting"});
            case"BBBB":
            default:
                return n.dayPeriod(a, {width: "wide", context: "formatting"})
        }
    }, h: function (e, r, n) {
        if (r === "ho") {
            var i = e.getUTCHours() % 12;
            return i === 0 && (i = 12), n.ordinalNumber(i, {unit: "hour"})
        }
        return Jg.h(e, r)
    }, H: function (e, r, n) {
        return r === "Ho" ? n.ordinalNumber(e.getUTCHours(), {unit: "hour"}) : Jg.H(e, r)
    }, K: function (e, r, n) {
        var i = e.getUTCHours() % 12;
        return r === "Ko" ? n.ordinalNumber(i, {unit: "hour"}) : ta(i, r.length)
    }, k: function (e, r, n) {
        var i = e.getUTCHours();
        return i === 0 && (i = 24), r === "ko" ? n.ordinalNumber(i, {unit: "hour"}) : ta(i, r.length)
    }, m: function (e, r, n) {
        return r === "mo" ? n.ordinalNumber(e.getUTCMinutes(), {unit: "minute"}) : Jg.m(e, r)
    }, s: function (e, r, n) {
        return r === "so" ? n.ordinalNumber(e.getUTCSeconds(), {unit: "second"}) : Jg.s(e, r)
    }, S: function (e, r) {
        return Jg.S(e, r)
    }, X: function (e, r, n, i) {
        var a = i._originalDate || e, o = a.getTimezoneOffset();
        if (o === 0) return "Z";
        switch (r) {
            case"X":
                return hse(o);
            case"XXXX":
            case"XX":
                return Jb(o);
            case"XXXXX":
            case"XXX":
            default:
                return Jb(o, ":")
        }
    }, x: function (e, r, n, i) {
        var a = i._originalDate || e, o = a.getTimezoneOffset();
        switch (r) {
            case"x":
                return hse(o);
            case"xxxx":
            case"xx":
                return Jb(o);
            case"xxxxx":
            case"xxx":
            default:
                return Jb(o, ":")
        }
    }, O: function (e, r, n, i) {
        var a = i._originalDate || e, o = a.getTimezoneOffset();
        switch (r) {
            case"O":
            case"OO":
            case"OOO":
                return "GMT" + dse(o, ":");
            case"OOOO":
            default:
                return "GMT" + Jb(o, ":")
        }
    }, z: function (e, r, n, i) {
        var a = i._originalDate || e, o = a.getTimezoneOffset();
        switch (r) {
            case"z":
            case"zz":
            case"zzz":
                return "GMT" + dse(o, ":");
            case"zzzz":
            default:
                return "GMT" + Jb(o, ":")
        }
    }, t: function (e, r, n, i) {
        var a = i._originalDate || e, o = Math.floor(a.getTime() / 1e3);
        return ta(o, r.length)
    }, T: function (e, r, n, i) {
        var a = i._originalDate || e, o = a.getTime();
        return ta(o, r.length)
    }
};

function dse(t, e) {
    var r = t > 0 ? "-" : "+", n = Math.abs(t), i = Math.floor(n / 60), a = n % 60;
    if (a === 0) return r + String(i);
    var o = e || "";
    return r + String(i) + o + ta(a, 2)
}

function hse(t, e) {
    if (t % 60 === 0) {
        var r = t > 0 ? "-" : "+";
        return r + ta(Math.abs(t) / 60, 2)
    }
    return Jb(t, e)
}

function Jb(t, e) {
    var r = e || "", n = t > 0 ? "-" : "+", i = Math.abs(t), a = ta(Math.floor(i / 60), 2), o = ta(i % 60, 2);
    return n + a + r + o
}

var pse = function (e, r) {
    switch (e) {
        case"P":
            return r.date({width: "short"});
        case"PP":
            return r.date({width: "medium"});
        case"PPP":
            return r.date({width: "long"});
        case"PPPP":
        default:
            return r.date({width: "full"})
    }
}, eye = function (e, r) {
    switch (e) {
        case"p":
            return r.time({width: "short"});
        case"pp":
            return r.time({width: "medium"});
        case"ppp":
            return r.time({width: "long"});
        case"pppp":
        default:
            return r.time({width: "full"})
    }
}, Gze = function (e, r) {
    var n = e.match(/(P+)(p+)?/) || [], i = n[1], a = n[2];
    if (!a) return pse(e, r);
    var o;
    switch (i) {
        case"P":
            o = r.dateTime({width: "short"});
            break;
        case"PP":
            o = r.dateTime({width: "medium"});
            break;
        case"PPP":
            o = r.dateTime({width: "long"});
            break;
        case"PPPP":
        default:
            o = r.dateTime({width: "full"});
            break
    }
    return o.replace("{{date}}", pse(i, r)).replace("{{time}}", eye(a, r))
}, Kze = {p: eye, P: Gze};
const Yze = Kze;
var Xze = ["D", "DD"], Qze = ["YY", "YYYY"];

function Zze(t) {
    return Xze.indexOf(t) !== -1
}

function Jze(t) {
    return Qze.indexOf(t) !== -1
}

function mse(t, e, r) {
    if (t === "YYYY") throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(e, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "YY") throw new RangeError("Use `yy` instead of `YY` (in `".concat(e, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "D") throw new RangeError("Use `d` instead of `D` (in `".concat(e, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "DD") throw new RangeError("Use `dd` instead of `DD` (in `".concat(e, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}

var eVe = {
    lessThanXSeconds: {one: "less than a second", other: "less than {{count}} seconds"},
    xSeconds: {one: "1 second", other: "{{count}} seconds"},
    halfAMinute: "half a minute",
    lessThanXMinutes: {one: "less than a minute", other: "less than {{count}} minutes"},
    xMinutes: {one: "1 minute", other: "{{count}} minutes"},
    aboutXHours: {one: "about 1 hour", other: "about {{count}} hours"},
    xHours: {one: "1 hour", other: "{{count}} hours"},
    xDays: {one: "1 day", other: "{{count}} days"},
    aboutXWeeks: {one: "about 1 week", other: "about {{count}} weeks"},
    xWeeks: {one: "1 week", other: "{{count}} weeks"},
    aboutXMonths: {one: "about 1 month", other: "about {{count}} months"},
    xMonths: {one: "1 month", other: "{{count}} months"},
    aboutXYears: {one: "about 1 year", other: "about {{count}} years"},
    xYears: {one: "1 year", other: "{{count}} years"},
    overXYears: {one: "over 1 year", other: "over {{count}} years"},
    almostXYears: {one: "almost 1 year", other: "almost {{count}} years"}
}, tVe = function (e, r, n) {
    var i, a = eVe[e];
    return typeof a == "string" ? i = a : r === 1 ? i = a.one : i = a.other.replace("{{count}}", r.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + i : i + " ago" : i
};
const rVe = tVe;

function Mj(t) {
    return function () {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            r = e.width ? String(e.width) : t.defaultWidth, n = t.formats[r] || t.formats[t.defaultWidth];
        return n
    }
}

var nVe = {full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy"},
    iVe = {full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a"}, aVe = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
    }, oVe = {
        date: Mj({formats: nVe, defaultWidth: "full"}),
        time: Mj({formats: iVe, defaultWidth: "full"}),
        dateTime: Mj({formats: aVe, defaultWidth: "full"})
    };
const sVe = oVe;
var cVe = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}, lVe = function (e, r, n, i) {
    return cVe[e]
};
const uVe = lVe;

function $5(t) {
    return function (e, r) {
        var n = r != null && r.context ? String(r.context) : "standalone", i;
        if (n === "formatting" && t.formattingValues) {
            var a = t.defaultFormattingWidth || t.defaultWidth, o = r != null && r.width ? String(r.width) : a;
            i = t.formattingValues[o] || t.formattingValues[a]
        } else {
            var s = t.defaultWidth, l = r != null && r.width ? String(r.width) : t.defaultWidth;
            i = t.values[l] || t.values[s]
        }
        var f = t.argumentCallback ? t.argumentCallback(e) : e;
        return i[f]
    }
}

var fVe = {narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"]}, dVe = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, hVe = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, pVe = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, mVe = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}, vVe = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}, gVe = function (e, r) {
    var n = Number(e), i = n % 100;
    if (i > 20 || i < 10) switch (i % 10) {
        case 1:
            return n + "st";
        case 2:
            return n + "nd";
        case 3:
            return n + "rd"
    }
    return n + "th"
}, yVe = {
    ordinalNumber: gVe,
    era: $5({values: fVe, defaultWidth: "wide"}),
    quarter: $5({
        values: dVe, defaultWidth: "wide", argumentCallback: function (e) {
            return e - 1
        }
    }),
    month: $5({values: hVe, defaultWidth: "wide"}),
    day: $5({values: pVe, defaultWidth: "wide"}),
    dayPeriod: $5({values: mVe, defaultWidth: "wide", formattingValues: vVe, defaultFormattingWidth: "wide"})
};
const bVe = yVe;

function F5(t) {
    return function (e) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = r.width,
            i = n && t.matchPatterns[n] || t.matchPatterns[t.defaultMatchWidth], a = e.match(i);
        if (!a) return null;
        var o = a[0], s = n && t.parsePatterns[n] || t.parsePatterns[t.defaultParseWidth],
            l = Array.isArray(s) ? SVe(s, function (p) {
                return p.test(o)
            }) : wVe(s, function (p) {
                return p.test(o)
            }), f;
        f = t.valueCallback ? t.valueCallback(l) : l, f = r.valueCallback ? r.valueCallback(f) : f;
        var d = e.slice(o.length);
        return {value: f, rest: d}
    }
}

function wVe(t, e) {
    for (var r in t) if (t.hasOwnProperty(r) && e(t[r])) return r
}

function SVe(t, e) {
    for (var r = 0; r < t.length; r++) if (e(t[r])) return r
}

function _Ve(t) {
    return function (e) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.match(t.matchPattern);
        if (!n) return null;
        var i = n[0], a = e.match(t.parsePattern);
        if (!a) return null;
        var o = t.valueCallback ? t.valueCallback(a[0]) : a[0];
        o = r.valueCallback ? r.valueCallback(o) : o;
        var s = e.slice(i.length);
        return {value: o, rest: s}
    }
}

var xVe = /^(\d+)(th|st|nd|rd)?/i, EVe = /\d+/i, TVe = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
    }, CVe = {any: [/^b/i, /^(a|c)/i]},
    AVe = {narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i},
    IVe = {any: [/1/i, /2/i, /3/i, /4/i]}, kVe = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    }, RVe = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    }, DVe = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    }, MVe = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    }, OVe = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    }, PVe = {
        any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
        }
    }, NVe = {
        ordinalNumber: _Ve({
            matchPattern: xVe, parsePattern: EVe, valueCallback: function (e) {
                return parseInt(e, 10)
            }
        }),
        era: F5({matchPatterns: TVe, defaultMatchWidth: "wide", parsePatterns: CVe, defaultParseWidth: "any"}),
        quarter: F5({
            matchPatterns: AVe,
            defaultMatchWidth: "wide",
            parsePatterns: IVe,
            defaultParseWidth: "any",
            valueCallback: function (e) {
                return e + 1
            }
        }),
        month: F5({matchPatterns: kVe, defaultMatchWidth: "wide", parsePatterns: RVe, defaultParseWidth: "any"}),
        day: F5({matchPatterns: DVe, defaultMatchWidth: "wide", parsePatterns: MVe, defaultParseWidth: "any"}),
        dayPeriod: F5({matchPatterns: OVe, defaultMatchWidth: "any", parsePatterns: PVe, defaultParseWidth: "any"})
    };
const LVe = NVe;
var BVe = {
    code: "en-US",
    formatDistance: rVe,
    formatLong: sVe,
    formatRelative: uVe,
    localize: bVe,
    match: LVe,
    options: {weekStartsOn: 0, firstWeekContainsDate: 1}
};
const tye = BVe;
var $Ve = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, FVe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
    UVe = /^'([^]*?)'?$/, jVe = /''/g, zVe = /[a-zA-Z]/;

function VVe(t, e, r) {
    var n, i, a, o, s, l, f, d, p, g, b, S, T, I, N, P, F, V;
    ii(2, arguments);
    var Y = String(e), ee = v8(),
        oe = (n = (i = r == null ? void 0 : r.locale) !== null && i !== void 0 ? i : ee.locale) !== null && n !== void 0 ? n : tye,
        G = $c((a = (o = (s = (l = r == null ? void 0 : r.firstWeekContainsDate) !== null && l !== void 0 ? l : r == null || (f = r.locale) === null || f === void 0 || (d = f.options) === null || d === void 0 ? void 0 : d.firstWeekContainsDate) !== null && s !== void 0 ? s : ee.firstWeekContainsDate) !== null && o !== void 0 ? o : (p = ee.locale) === null || p === void 0 || (g = p.options) === null || g === void 0 ? void 0 : g.firstWeekContainsDate) !== null && a !== void 0 ? a : 1);
    if (!(G >= 1 && G <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var J = $c((b = (S = (T = (I = r == null ? void 0 : r.weekStartsOn) !== null && I !== void 0 ? I : r == null || (N = r.locale) === null || N === void 0 || (P = N.options) === null || P === void 0 ? void 0 : P.weekStartsOn) !== null && T !== void 0 ? T : ee.weekStartsOn) !== null && S !== void 0 ? S : (F = ee.locale) === null || F === void 0 || (V = F.options) === null || V === void 0 ? void 0 : V.weekStartsOn) !== null && b !== void 0 ? b : 0);
    if (!(J >= 0 && J <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (!oe.localize) throw new RangeError("locale must contain localize property");
    if (!oe.formatLong) throw new RangeError("locale must contain formatLong property");
    var ce = Nn(t);
    if (!Yge(ce)) throw new RangeError("Invalid time value");
    var re = QC(ce), M = Lze(ce, re), D = {firstWeekContainsDate: G, weekStartsOn: J, locale: oe, _originalDate: ce},
        x = Y.match(FVe).map(function (A) {
            var B = A[0];
            if (B === "p" || B === "P") {
                var z = Yze[B];
                return z(A, oe.formatLong)
            }
            return A
        }).join("").match($Ve).map(function (A) {
            if (A === "''") return "'";
            var B = A[0];
            if (B === "'") return HVe(A);
            var z = qze[B];
            if (z) return !(r != null && r.useAdditionalWeekYearTokens) && Jze(A) && mse(A, e, String(t)), !(r != null && r.useAdditionalDayOfYearTokens) && Zze(A) && mse(A, e, String(t)), z(M, A, oe.localize, D);
            if (B.match(zVe)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + B + "`");
            return A
        }).join("");
    return x
}

function HVe(t) {
    var e = t.match(UVe);
    return e ? e[1].replace(jVe, "'") : t
}

function rye(t, e) {
    if (t == null) throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
    return t
}

function WVe(t) {
    return rye({}, t)
}

var vse = 1440, qVe = 2520, Oj = 43200, GVe = 86400;

function KVe(t, e, r) {
    var n, i;
    ii(2, arguments);
    var a = v8(),
        o = (n = (i = r == null ? void 0 : r.locale) !== null && i !== void 0 ? i : a.locale) !== null && n !== void 0 ? n : tye;
    if (!o.formatDistance) throw new RangeError("locale must contain formatDistance property");
    var s = $w(t, e);
    if (isNaN(s)) throw new RangeError("Invalid time value");
    var l = rye(WVe(r), {addSuffix: !!(r != null && r.addSuffix), comparison: s}), f, d;
    s > 0 ? (f = Nn(e), d = Nn(t)) : (f = Nn(t), d = Nn(e));
    var p = Qge(d, f), g = (QC(d) - QC(f)) / 1e3, b = Math.round((p - g) / 60), S;
    if (b < 2) return r != null && r.includeSeconds ? p < 5 ? o.formatDistance("lessThanXSeconds", 5, l) : p < 10 ? o.formatDistance("lessThanXSeconds", 10, l) : p < 20 ? o.formatDistance("lessThanXSeconds", 20, l) : p < 40 ? o.formatDistance("halfAMinute", 0, l) : p < 60 ? o.formatDistance("lessThanXMinutes", 1, l) : o.formatDistance("xMinutes", 1, l) : b === 0 ? o.formatDistance("lessThanXMinutes", 1, l) : o.formatDistance("xMinutes", b, l);
    if (b < 45) return o.formatDistance("xMinutes", b, l);
    if (b < 90) return o.formatDistance("aboutXHours", 1, l);
    if (b < vse) {
        var T = Math.round(b / 60);
        return o.formatDistance("aboutXHours", T, l)
    } else {
        if (b < qVe) return o.formatDistance("xDays", 1, l);
        if (b < Oj) {
            var I = Math.round(b / vse);
            return o.formatDistance("xDays", I, l)
        } else if (b < GVe) return S = Math.round(b / Oj), o.formatDistance("aboutXMonths", S, l)
    }
    if (S = Xge(d, f), S < 12) {
        var N = Math.round(b / Oj);
        return o.formatDistance("xMonths", N, l)
    } else {
        var P = S % 12, F = Math.floor(S / 12);
        return P < 3 ? o.formatDistance("aboutXYears", F, l) : P < 9 ? o.formatDistance("overXYears", F, l) : o.formatDistance("almostXYears", F + 1, l)
    }
}

function YVe(t, e) {
    return ii(1, arguments), KVe(t, Date.now(), e)
}

function XVe(t) {
    ii(1, arguments);
    var e = Nn(t.start), r = Nn(t.end);
    if (isNaN(e.getTime())) throw new RangeError("Start Date is invalid");
    if (isNaN(r.getTime())) throw new RangeError("End Date is invalid");
    var n = {};
    n.years = Math.abs(Nze(r, e));
    var i = $w(r, e), a = B5(e, {years: i * n.years});
    n.months = Math.abs(Xge(r, a));
    var o = B5(a, {months: i * n.months});
    n.days = Math.abs(Ize(r, o));
    var s = B5(o, {days: i * n.days});
    n.hours = Math.abs(Rze(r, s));
    var l = B5(s, {hours: i * n.hours});
    n.minutes = Math.abs(Dze(r, l));
    var f = B5(l, {minutes: i * n.minutes});
    return n.seconds = Math.abs(Qge(r, f)), n
}

function QVe(t, e) {
    ii(2, arguments);
    var r = Nn(t), n = Nn(e);
    return r.getTime() > n.getTime()
}

function ZVe(t, e) {
    var r;
    if (arguments.length < 1) throw new TypeError("1 argument required, but only none provided present");
    var n = $c((r = e == null ? void 0 : e.nearestTo) !== null && r !== void 0 ? r : 1);
    if (n < 1 || n > 30) throw new RangeError("`options.nearestTo` must be between 1 and 30");
    var i = Nn(t), a = i.getSeconds(), o = i.getMinutes() + a / 60, s = zP(e == null ? void 0 : e.roundingMethod),
        l = s(o / n) * n, f = o % n, d = Math.round(f / n) * n;
    return new Date(i.getFullYear(), i.getMonth(), i.getDate(), i.getHours(), l + d)
}

var JVe = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, Pj = Math.ceil, h0 = Math.floor, Vu = "[BigNumber Error] ",
    gse = Vu + "Number primitive has more than 15 significant digits: ", $h = 1e14, xn = 14, Nj = 9007199254740991,
    Lj = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], ey = 1e7, qs = 1e9;

function nye(t) {
    var e, r, n, i = P.prototype = {constructor: P, toString: null, valueOf: null}, a = new P(1), o = 20, s = 4, l = -7,
        f = 21, d = -1e7, p = 1e7, g = !1, b = 1, S = 0, T = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: " ",
            suffix: ""
        }, I = "0123456789abcdefghijklmnopqrstuvwxyz", N = !0;

    function P(G, J) {
        var ce, re, M, D, x, A, B, z, j = this;
        if (!(j instanceof P)) return new P(G, J);
        if (J == null) {
            if (G && G._isBigNumber === !0) {
                j.s = G.s, !G.c || G.e > p ? j.c = j.e = null : G.e < d ? j.c = [j.e = 0] : (j.e = G.e, j.c = G.c.slice());
                return
            }
            if ((A = typeof G == "number") && G * 0 == 0) {
                if (j.s = 1 / G < 0 ? (G = -G, -1) : 1, G === ~~G) {
                    for (D = 0, x = G; x >= 10; x /= 10, D++) ;
                    D > p ? j.c = j.e = null : (j.e = D, j.c = [G]);
                    return
                }
                z = String(G)
            } else {
                if (!JVe.test(z = String(G))) return n(j, z, A);
                j.s = z.charCodeAt(0) == 45 ? (z = z.slice(1), -1) : 1
            }
            (D = z.indexOf(".")) > -1 && (z = z.replace(".", "")), (x = z.search(/e/i)) > 0 ? (D < 0 && (D = x), D += +z.slice(x + 1), z = z.substring(0, x)) : D < 0 && (D = z.length)
        } else {
            if (oo(J, 2, I.length, "Base"), J == 10 && N) return j = new P(G), ee(j, o + j.e + 1, s);
            if (z = String(G), A = typeof G == "number") {
                if (G * 0 != 0) return n(j, z, A, J);
                if (j.s = 1 / G < 0 ? (z = z.slice(1), -1) : 1, P.DEBUG && z.replace(/^0\.0*|\./, "").length > 15) throw Error(gse + G)
            } else j.s = z.charCodeAt(0) === 45 ? (z = z.slice(1), -1) : 1;
            for (ce = I.slice(0, J), D = x = 0, B = z.length; x < B; x++) if (ce.indexOf(re = z.charAt(x)) < 0) {
                if (re == ".") {
                    if (x > D) {
                        D = B;
                        continue
                    }
                } else if (!M && (z == z.toUpperCase() && (z = z.toLowerCase()) || z == z.toLowerCase() && (z = z.toUpperCase()))) {
                    M = !0, x = -1, D = 0;
                    continue
                }
                return n(j, String(G), A, J)
            }
            A = !1, z = r(z, J, 10, j.s), (D = z.indexOf(".")) > -1 ? z = z.replace(".", "") : D = z.length
        }
        for (x = 0; z.charCodeAt(x) === 48; x++) ;
        for (B = z.length; z.charCodeAt(--B) === 48;) ;
        if (z = z.slice(x, ++B)) {
            if (B -= x, A && P.DEBUG && B > 15 && (G > Nj || G !== h0(G))) throw Error(gse + j.s * G);
            if ((D = D - x - 1) > p) j.c = j.e = null; else if (D < d) j.c = [j.e = 0]; else {
                if (j.e = D, j.c = [], x = (D + 1) % xn, D < 0 && (x += xn), x < B) {
                    for (x && j.c.push(+z.slice(0, x)), B -= xn; x < B;) j.c.push(+z.slice(x, x += xn));
                    x = xn - (z = z.slice(x)).length
                } else x -= B;
                for (; x--; z += "0") ;
                j.c.push(+z)
            }
        } else j.c = [j.e = 0]
    }

    P.clone = nye, P.ROUND_UP = 0, P.ROUND_DOWN = 1, P.ROUND_CEIL = 2, P.ROUND_FLOOR = 3, P.ROUND_HALF_UP = 4, P.ROUND_HALF_DOWN = 5, P.ROUND_HALF_EVEN = 6, P.ROUND_HALF_CEIL = 7, P.ROUND_HALF_FLOOR = 8, P.EUCLID = 9, P.config = P.set = function (G) {
        var J, ce;
        if (G != null) if (typeof G == "object") {
            if (G.hasOwnProperty(J = "DECIMAL_PLACES") && (ce = G[J], oo(ce, 0, qs, J), o = ce), G.hasOwnProperty(J = "ROUNDING_MODE") && (ce = G[J], oo(ce, 0, 8, J), s = ce), G.hasOwnProperty(J = "EXPONENTIAL_AT") && (ce = G[J], ce && ce.pop ? (oo(ce[0], -qs, 0, J), oo(ce[1], 0, qs, J), l = ce[0], f = ce[1]) : (oo(ce, -qs, qs, J), l = -(f = ce < 0 ? -ce : ce))), G.hasOwnProperty(J = "RANGE")) if (ce = G[J], ce && ce.pop) oo(ce[0], -qs, -1, J), oo(ce[1], 1, qs, J), d = ce[0], p = ce[1]; else if (oo(ce, -qs, qs, J), ce) d = -(p = ce < 0 ? -ce : ce); else throw Error(Vu + J + " cannot be zero: " + ce);
            if (G.hasOwnProperty(J = "CRYPTO")) if (ce = G[J], ce === !!ce) if (ce) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) g = ce; else throw g = !ce, Error(Vu + "crypto unavailable"); else g = ce; else throw Error(Vu + J + " not true or false: " + ce);
            if (G.hasOwnProperty(J = "MODULO_MODE") && (ce = G[J], oo(ce, 0, 9, J), b = ce), G.hasOwnProperty(J = "POW_PRECISION") && (ce = G[J], oo(ce, 0, qs, J), S = ce), G.hasOwnProperty(J = "FORMAT")) if (ce = G[J], typeof ce == "object") T = ce; else throw Error(Vu + J + " not an object: " + ce);
            if (G.hasOwnProperty(J = "ALPHABET")) if (ce = G[J], typeof ce == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(ce)) N = ce.slice(0, 10) == "0123456789", I = ce; else throw Error(Vu + J + " invalid: " + ce)
        } else throw Error(Vu + "Object expected: " + G);
        return {
            DECIMAL_PLACES: o,
            ROUNDING_MODE: s,
            EXPONENTIAL_AT: [l, f],
            RANGE: [d, p],
            CRYPTO: g,
            MODULO_MODE: b,
            POW_PRECISION: S,
            FORMAT: T,
            ALPHABET: I
        }
    }, P.isBigNumber = function (G) {
        if (!G || G._isBigNumber !== !0) return !1;
        if (!P.DEBUG) return !0;
        var J, ce, re = G.c, M = G.e, D = G.s;
        e:if ({}.toString.call(re) == "[object Array]") {
            if ((D === 1 || D === -1) && M >= -qs && M <= qs && M === h0(M)) {
                if (re[0] === 0) {
                    if (M === 0 && re.length === 1) return !0;
                    break e
                }
                if (J = (M + 1) % xn, J < 1 && (J += xn), String(re[0]).length == J) {
                    for (J = 0; J < re.length; J++) if (ce = re[J], ce < 0 || ce >= $h || ce !== h0(ce)) break e;
                    if (ce !== 0) return !0
                }
            }
        } else if (re === null && M === null && (D === null || D === 1 || D === -1)) return !0;
        throw Error(Vu + "Invalid BigNumber: " + G)
    }, P.maximum = P.max = function () {
        return V(arguments, i.lt)
    }, P.minimum = P.min = function () {
        return V(arguments, i.gt)
    }, P.random = function () {
        var G = 9007199254740992, J = Math.random() * G & 2097151 ? function () {
            return h0(Math.random() * G)
        } : function () {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
        };
        return function (ce) {
            var re, M, D, x, A, B = 0, z = [], j = new P(a);
            if (ce == null ? ce = o : oo(ce, 0, qs), x = Pj(ce / xn), g) if (crypto.getRandomValues) {
                for (re = crypto.getRandomValues(new Uint32Array(x *= 2)); B < x;) A = re[B] * 131072 + (re[B + 1] >>> 11), A >= 9e15 ? (M = crypto.getRandomValues(new Uint32Array(2)), re[B] = M[0], re[B + 1] = M[1]) : (z.push(A % 1e14), B += 2);
                B = x / 2
            } else if (crypto.randomBytes) {
                for (re = crypto.randomBytes(x *= 7); B < x;) A = (re[B] & 31) * 281474976710656 + re[B + 1] * 1099511627776 + re[B + 2] * 4294967296 + re[B + 3] * 16777216 + (re[B + 4] << 16) + (re[B + 5] << 8) + re[B + 6], A >= 9e15 ? crypto.randomBytes(7).copy(re, B) : (z.push(A % 1e14), B += 7);
                B = x / 7
            } else throw g = !1, Error(Vu + "crypto unavailable");
            if (!g) for (; B < x;) A = J(), A < 9e15 && (z[B++] = A % 1e14);
            for (x = z[--B], ce %= xn, x && ce && (A = Lj[xn - ce], z[B] = h0(x / A) * A); z[B] === 0; z.pop(), B--) ;
            if (B < 0) z = [D = 0]; else {
                for (D = -1; z[0] === 0; z.splice(0, 1), D -= xn) ;
                for (B = 1, A = z[0]; A >= 10; A /= 10, B++) ;
                B < xn && (D -= xn - B)
            }
            return j.e = D, j.c = z, j
        }
    }(), P.sum = function () {
        for (var G = 1, J = arguments, ce = new P(J[0]); G < J.length;) ce = ce.plus(J[G++]);
        return ce
    }, r = function () {
        var G = "0123456789";

        function J(ce, re, M, D) {
            for (var x, A = [0], B, z = 0, j = ce.length; z < j;) {
                for (B = A.length; B--; A[B] *= re) ;
                for (A[0] += D.indexOf(ce.charAt(z++)), x = 0; x < A.length; x++) A[x] > M - 1 && (A[x + 1] == null && (A[x + 1] = 0), A[x + 1] += A[x] / M | 0, A[x] %= M)
            }
            return A.reverse()
        }

        return function (ce, re, M, D, x) {
            var A, B, z, j, $, C, R, k, Q = ce.indexOf("."), fe = o, ye = s;
            for (Q >= 0 && (j = S, S = 0, ce = ce.replace(".", ""), k = new P(re), C = k.pow(ce.length - Q), S = j, k.c = J(Qm(Id(C.c), C.e, "0"), 10, M, G), k.e = k.c.length), R = J(ce, re, M, x ? (A = I, G) : (A = G, I)), z = j = R.length; R[--j] == 0; R.pop()) ;
            if (!R[0]) return A.charAt(0);
            if (Q < 0 ? --z : (C.c = R, C.e = z, C.s = D, C = e(C, k, fe, ye, M), R = C.c, $ = C.r, z = C.e), B = z + fe + 1, Q = R[B], j = M / 2, $ = $ || B < 0 || R[B + 1] != null, $ = ye < 4 ? (Q != null || $) && (ye == 0 || ye == (C.s < 0 ? 3 : 2)) : Q > j || Q == j && (ye == 4 || $ || ye == 6 && R[B - 1] & 1 || ye == (C.s < 0 ? 8 : 7)), B < 1 || !R[0]) ce = $ ? Qm(A.charAt(1), -fe, A.charAt(0)) : A.charAt(0); else {
                if (R.length = B, $) for (--M; ++R[--B] > M;) R[B] = 0, B || (++z, R = [1].concat(R));
                for (j = R.length; !R[--j];) ;
                for (Q = 0, ce = ""; Q <= j; ce += A.charAt(R[Q++])) ;
                ce = Qm(ce, z, A.charAt(0))
            }
            return ce
        }
    }(), e = function () {
        function G(re, M, D) {
            var x, A, B, z, j = 0, $ = re.length, C = M % ey, R = M / ey | 0;
            for (re = re.slice(); $--;) B = re[$] % ey, z = re[$] / ey | 0, x = R * B + z * C, A = C * B + x % ey * ey + j, j = (A / D | 0) + (x / ey | 0) + R * z, re[$] = A % D;
            return j && (re = [j].concat(re)), re
        }

        function J(re, M, D, x) {
            var A, B;
            if (D != x) B = D > x ? 1 : -1; else for (A = B = 0; A < D; A++) if (re[A] != M[A]) {
                B = re[A] > M[A] ? 1 : -1;
                break
            }
            return B
        }

        function ce(re, M, D, x) {
            for (var A = 0; D--;) re[D] -= A, A = re[D] < M[D] ? 1 : 0, re[D] = A * x + re[D] - M[D];
            for (; !re[0] && re.length > 1; re.splice(0, 1)) ;
        }

        return function (re, M, D, x, A) {
            var B, z, j, $, C, R, k, Q, fe, ye, ue, me, Se, Ce, Me, ve, ne, be = re.s == M.s ? 1 : -1, Ee = re.c,
                Oe = M.c;
            if (!Ee || !Ee[0] || !Oe || !Oe[0]) return new P(!re.s || !M.s || (Ee ? Oe && Ee[0] == Oe[0] : !Oe) ? NaN : Ee && Ee[0] == 0 || !Oe ? be * 0 : be / 0);
            for (Q = new P(be), fe = Q.c = [], z = re.e - M.e, be = D + z + 1, A || (A = $h, z = Pd(re.e / xn) - Pd(M.e / xn), be = be / xn | 0), j = 0; Oe[j] == (Ee[j] || 0); j++) ;
            if (Oe[j] > (Ee[j] || 0) && z--, be < 0) fe.push(1), $ = !0; else {
                for (Ce = Ee.length, ve = Oe.length, j = 0, be += 2, C = h0(A / (Oe[0] + 1)), C > 1 && (Oe = G(Oe, C, A), Ee = G(Ee, C, A), ve = Oe.length, Ce = Ee.length), Se = ve, ye = Ee.slice(0, ve), ue = ye.length; ue < ve; ye[ue++] = 0) ;
                ne = Oe.slice(), ne = [0].concat(ne), Me = Oe[0], Oe[1] >= A / 2 && Me++;
                do {
                    if (C = 0, B = J(Oe, ye, ve, ue), B < 0) {
                        if (me = ye[0], ve != ue && (me = me * A + (ye[1] || 0)), C = h0(me / Me), C > 1) for (C >= A && (C = A - 1), R = G(Oe, C, A), k = R.length, ue = ye.length; J(R, ye, k, ue) == 1;) C--, ce(R, ve < k ? ne : Oe, k, A), k = R.length, B = 1; else C == 0 && (B = C = 1), R = Oe.slice(), k = R.length;
                        if (k < ue && (R = [0].concat(R)), ce(ye, R, ue, A), ue = ye.length, B == -1) for (; J(Oe, ye, ve, ue) < 1;) C++, ce(ye, ve < ue ? ne : Oe, ue, A), ue = ye.length
                    } else B === 0 && (C++, ye = [0]);
                    fe[j++] = C, ye[0] ? ye[ue++] = Ee[Se] || 0 : (ye = [Ee[Se]], ue = 1)
                } while ((Se++ < Ce || ye[0] != null) && be--);
                $ = ye[0] != null, fe[0] || fe.splice(0, 1)
            }
            if (A == $h) {
                for (j = 1, be = fe[0]; be >= 10; be /= 10, j++) ;
                ee(Q, D + (Q.e = j + z * xn - 1) + 1, x, $)
            } else Q.e = z, Q.r = +$;
            return Q
        }
    }();

    function F(G, J, ce, re) {
        var M, D, x, A, B;
        if (ce == null ? ce = s : oo(ce, 0, 8), !G.c) return G.toString();
        if (M = G.c[0], x = G.e, J == null) B = Id(G.c), B = re == 1 || re == 2 && (x <= l || x >= f) ? Y9(B, x) : Qm(B, x, "0"); else if (G = ee(new P(G), J, ce), D = G.e, B = Id(G.c), A = B.length, re == 1 || re == 2 && (J <= D || D <= l)) {
            for (; A < J; B += "0", A++) ;
            B = Y9(B, D)
        } else if (J -= x, B = Qm(B, D, "0"), D + 1 > A) {
            if (--J > 0) for (B += "."; J--; B += "0") ;
        } else if (J += D - A, J > 0) for (D + 1 == A && (B += "."); J--; B += "0") ;
        return G.s < 0 && M ? "-" + B : B
    }

    function V(G, J) {
        for (var ce, re = 1, M = new P(G[0]); re < G.length; re++) if (ce = new P(G[re]), ce.s) J.call(M, ce) && (M = ce); else {
            M = ce;
            break
        }
        return M
    }

    function Y(G, J, ce) {
        for (var re = 1, M = J.length; !J[--M]; J.pop()) ;
        for (M = J[0]; M >= 10; M /= 10, re++) ;
        return (ce = re + ce * xn - 1) > p ? G.c = G.e = null : ce < d ? G.c = [G.e = 0] : (G.e = ce, G.c = J), G
    }

    n = function () {
        var G = /^(-?)0([xbo])(?=\w[\w.]*$)/i, J = /^([^.]+)\.$/, ce = /^\.([^.]+)$/, re = /^-?(Infinity|NaN)$/,
            M = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function (D, x, A, B) {
            var z, j = A ? x : x.replace(M, "");
            if (re.test(j)) D.s = isNaN(j) ? null : j < 0 ? -1 : 1; else {
                if (!A && (j = j.replace(G, function ($, C, R) {
                    return z = (R = R.toLowerCase()) == "x" ? 16 : R == "b" ? 2 : 8, !B || B == z ? C : $
                }), B && (z = B, j = j.replace(J, "$1").replace(ce, "0.$1")), x != j)) return new P(j, z);
                if (P.DEBUG) throw Error(Vu + "Not a" + (B ? " base " + B : "") + " number: " + x);
                D.s = null
            }
            D.c = D.e = null
        }
    }();

    function ee(G, J, ce, re) {
        var M, D, x, A, B, z, j, $ = G.c, C = Lj;
        if ($) {
            e:{
                for (M = 1, A = $[0]; A >= 10; A /= 10, M++) ;
                if (D = J - M, D < 0) D += xn, x = J, B = $[z = 0], j = B / C[M - x - 1] % 10 | 0; else if (z = Pj((D + 1) / xn), z >= $.length) if (re) {
                    for (; $.length <= z; $.push(0)) ;
                    B = j = 0, M = 1, D %= xn, x = D - xn + 1
                } else break e; else {
                    for (B = A = $[z], M = 1; A >= 10; A /= 10, M++) ;
                    D %= xn, x = D - xn + M, j = x < 0 ? 0 : B / C[M - x - 1] % 10 | 0
                }
                if (re = re || J < 0 || $[z + 1] != null || (x < 0 ? B : B % C[M - x - 1]), re = ce < 4 ? (j || re) && (ce == 0 || ce == (G.s < 0 ? 3 : 2)) : j > 5 || j == 5 && (ce == 4 || re || ce == 6 && (D > 0 ? x > 0 ? B / C[M - x] : 0 : $[z - 1]) % 10 & 1 || ce == (G.s < 0 ? 8 : 7)), J < 1 || !$[0]) return $.length = 0, re ? (J -= G.e + 1, $[0] = C[(xn - J % xn) % xn], G.e = -J || 0) : $[0] = G.e = 0, G;
                if (D == 0 ? ($.length = z, A = 1, z--) : ($.length = z + 1, A = C[xn - D], $[z] = x > 0 ? h0(B / C[M - x] % C[x]) * A : 0), re) for (; ;) if (z == 0) {
                    for (D = 1, x = $[0]; x >= 10; x /= 10, D++) ;
                    for (x = $[0] += A, A = 1; x >= 10; x /= 10, A++) ;
                    D != A && (G.e++, $[0] == $h && ($[0] = 1));
                    break
                } else {
                    if ($[z] += A, $[z] != $h) break;
                    $[z--] = 0, A = 1
                }
                for (D = $.length; $[--D] === 0; $.pop()) ;
            }
            G.e > p ? G.c = G.e = null : G.e < d && (G.c = [G.e = 0])
        }
        return G
    }

    function oe(G) {
        var J, ce = G.e;
        return ce === null ? G.toString() : (J = Id(G.c), J = ce <= l || ce >= f ? Y9(J, ce) : Qm(J, ce, "0"), G.s < 0 ? "-" + J : J)
    }

    return i.absoluteValue = i.abs = function () {
        var G = new P(this);
        return G.s < 0 && (G.s = 1), G
    }, i.comparedTo = function (G, J) {
        return K_(this, new P(G, J))
    }, i.decimalPlaces = i.dp = function (G, J) {
        var ce, re, M, D = this;
        if (G != null) return oo(G, 0, qs), J == null ? J = s : oo(J, 0, 8), ee(new P(D), G + D.e + 1, J);
        if (!(ce = D.c)) return null;
        if (re = ((M = ce.length - 1) - Pd(this.e / xn)) * xn, M = ce[M]) for (; M % 10 == 0; M /= 10, re--) ;
        return re < 0 && (re = 0), re
    }, i.dividedBy = i.div = function (G, J) {
        return e(this, new P(G, J), o, s)
    }, i.dividedToIntegerBy = i.idiv = function (G, J) {
        return e(this, new P(G, J), 0, 1)
    }, i.exponentiatedBy = i.pow = function (G, J) {
        var ce, re, M, D, x, A, B, z, j, $ = this;
        if (G = new P(G), G.c && !G.isInteger()) throw Error(Vu + "Exponent not an integer: " + oe(G));
        if (J != null && (J = new P(J)), A = G.e > 14, !$.c || !$.c[0] || $.c[0] == 1 && !$.e && $.c.length == 1 || !G.c || !G.c[0]) return j = new P(Math.pow(+oe($), A ? 2 - K9(G) : +oe(G))), J ? j.mod(J) : j;
        if (B = G.s < 0, J) {
            if (J.c ? !J.c[0] : !J.s) return new P(NaN);
            re = !B && $.isInteger() && J.isInteger(), re && ($ = $.mod(J))
        } else {
            if (G.e > 9 && ($.e > 0 || $.e < -1 || ($.e == 0 ? $.c[0] > 1 || A && $.c[1] >= 24e7 : $.c[0] < 8e13 || A && $.c[0] <= 9999975e7))) return D = $.s < 0 && K9(G) ? -0 : 0, $.e > -1 && (D = 1 / D), new P(B ? 1 / D : D);
            S && (D = Pj(S / xn + 2))
        }
        for (A ? (ce = new P(.5), B && (G.s = 1), z = K9(G)) : (M = Math.abs(+oe(G)), z = M % 2), j = new P(a); ;) {
            if (z) {
                if (j = j.times($), !j.c) break;
                D ? j.c.length > D && (j.c.length = D) : re && (j = j.mod(J))
            }
            if (M) {
                if (M = h0(M / 2), M === 0) break;
                z = M % 2
            } else if (G = G.times(ce), ee(G, G.e + 1, 1), G.e > 14) z = K9(G); else {
                if (M = +oe(G), M === 0) break;
                z = M % 2
            }
            $ = $.times($), D ? $.c && $.c.length > D && ($.c.length = D) : re && ($ = $.mod(J))
        }
        return re ? j : (B && (j = a.div(j)), J ? j.mod(J) : D ? ee(j, S, s, x) : j)
    }, i.integerValue = function (G) {
        var J = new P(this);
        return G == null ? G = s : oo(G, 0, 8), ee(J, J.e + 1, G)
    }, i.isEqualTo = i.eq = function (G, J) {
        return K_(this, new P(G, J)) === 0
    }, i.isFinite = function () {
        return !!this.c
    }, i.isGreaterThan = i.gt = function (G, J) {
        return K_(this, new P(G, J)) > 0
    }, i.isGreaterThanOrEqualTo = i.gte = function (G, J) {
        return (J = K_(this, new P(G, J))) === 1 || J === 0
    }, i.isInteger = function () {
        return !!this.c && Pd(this.e / xn) > this.c.length - 2
    }, i.isLessThan = i.lt = function (G, J) {
        return K_(this, new P(G, J)) < 0
    }, i.isLessThanOrEqualTo = i.lte = function (G, J) {
        return (J = K_(this, new P(G, J))) === -1 || J === 0
    }, i.isNaN = function () {
        return !this.s
    }, i.isNegative = function () {
        return this.s < 0
    }, i.isPositive = function () {
        return this.s > 0
    }, i.isZero = function () {
        return !!this.c && this.c[0] == 0
    }, i.minus = function (G, J) {
        var ce, re, M, D, x = this, A = x.s;
        if (G = new P(G, J), J = G.s, !A || !J) return new P(NaN);
        if (A != J) return G.s = -J, x.plus(G);
        var B = x.e / xn, z = G.e / xn, j = x.c, $ = G.c;
        if (!B || !z) {
            if (!j || !$) return j ? (G.s = -J, G) : new P($ ? x : NaN);
            if (!j[0] || !$[0]) return $[0] ? (G.s = -J, G) : new P(j[0] ? x : s == 3 ? -0 : 0)
        }
        if (B = Pd(B), z = Pd(z), j = j.slice(), A = B - z) {
            for ((D = A < 0) ? (A = -A, M = j) : (z = B, M = $), M.reverse(), J = A; J--; M.push(0)) ;
            M.reverse()
        } else for (re = (D = (A = j.length) < (J = $.length)) ? A : J, A = J = 0; J < re; J++) if (j[J] != $[J]) {
            D = j[J] < $[J];
            break
        }
        if (D && (M = j, j = $, $ = M, G.s = -G.s), J = (re = $.length) - (ce = j.length), J > 0) for (; J--; j[ce++] = 0) ;
        for (J = $h - 1; re > A;) {
            if (j[--re] < $[re]) {
                for (ce = re; ce && !j[--ce]; j[ce] = J) ;
                --j[ce], j[re] += $h
            }
            j[re] -= $[re]
        }
        for (; j[0] == 0; j.splice(0, 1), --z) ;
        return j[0] ? Y(G, j, z) : (G.s = s == 3 ? -1 : 1, G.c = [G.e = 0], G)
    }, i.modulo = i.mod = function (G, J) {
        var ce, re, M = this;
        return G = new P(G, J), !M.c || !G.s || G.c && !G.c[0] ? new P(NaN) : !G.c || M.c && !M.c[0] ? new P(M) : (b == 9 ? (re = G.s, G.s = 1, ce = e(M, G, 0, 3), G.s = re, ce.s *= re) : ce = e(M, G, 0, b), G = M.minus(ce.times(G)), !G.c[0] && b == 1 && (G.s = M.s), G)
    }, i.multipliedBy = i.times = function (G, J) {
        var ce, re, M, D, x, A, B, z, j, $, C, R, k, Q, fe, ye = this, ue = ye.c, me = (G = new P(G, J)).c;
        if (!ue || !me || !ue[0] || !me[0]) return !ye.s || !G.s || ue && !ue[0] && !me || me && !me[0] && !ue ? G.c = G.e = G.s = null : (G.s *= ye.s, !ue || !me ? G.c = G.e = null : (G.c = [0], G.e = 0)), G;
        for (re = Pd(ye.e / xn) + Pd(G.e / xn), G.s *= ye.s, B = ue.length, $ = me.length, B < $ && (k = ue, ue = me, me = k, M = B, B = $, $ = M), M = B + $, k = []; M--; k.push(0)) ;
        for (Q = $h, fe = ey, M = $; --M >= 0;) {
            for (ce = 0, C = me[M] % fe, R = me[M] / fe | 0, x = B, D = M + x; D > M;) z = ue[--x] % fe, j = ue[x] / fe | 0, A = R * z + j * C, z = C * z + A % fe * fe + k[D] + ce, ce = (z / Q | 0) + (A / fe | 0) + R * j, k[D--] = z % Q;
            k[D] = ce
        }
        return ce ? ++re : k.splice(0, 1), Y(G, k, re)
    }, i.negated = function () {
        var G = new P(this);
        return G.s = -G.s || null, G
    }, i.plus = function (G, J) {
        var ce, re = this, M = re.s;
        if (G = new P(G, J), J = G.s, !M || !J) return new P(NaN);
        if (M != J) return G.s = -J, re.minus(G);
        var D = re.e / xn, x = G.e / xn, A = re.c, B = G.c;
        if (!D || !x) {
            if (!A || !B) return new P(M / 0);
            if (!A[0] || !B[0]) return B[0] ? G : new P(A[0] ? re : M * 0)
        }
        if (D = Pd(D), x = Pd(x), A = A.slice(), M = D - x) {
            for (M > 0 ? (x = D, ce = B) : (M = -M, ce = A), ce.reverse(); M--; ce.push(0)) ;
            ce.reverse()
        }
        for (M = A.length, J = B.length, M - J < 0 && (ce = B, B = A, A = ce, J = M), M = 0; J;) M = (A[--J] = A[J] + B[J] + M) / $h | 0, A[J] = $h === A[J] ? 0 : A[J] % $h;
        return M && (A = [M].concat(A), ++x), Y(G, A, x)
    }, i.precision = i.sd = function (G, J) {
        var ce, re, M, D = this;
        if (G != null && G !== !!G) return oo(G, 1, qs), J == null ? J = s : oo(J, 0, 8), ee(new P(D), G, J);
        if (!(ce = D.c)) return null;
        if (M = ce.length - 1, re = M * xn + 1, M = ce[M]) {
            for (; M % 10 == 0; M /= 10, re--) ;
            for (M = ce[0]; M >= 10; M /= 10, re++) ;
        }
        return G && D.e + 1 > re && (re = D.e + 1), re
    }, i.shiftedBy = function (G) {
        return oo(G, -Nj, Nj), this.times("1e" + G)
    }, i.squareRoot = i.sqrt = function () {
        var G, J, ce, re, M, D = this, x = D.c, A = D.s, B = D.e, z = o + 4, j = new P("0.5");
        if (A !== 1 || !x || !x[0]) return new P(!A || A < 0 && (!x || x[0]) ? NaN : x ? D : 1 / 0);
        if (A = Math.sqrt(+oe(D)), A == 0 || A == 1 / 0 ? (J = Id(x), (J.length + B) % 2 == 0 && (J += "0"), A = Math.sqrt(+J), B = Pd((B + 1) / 2) - (B < 0 || B % 2), A == 1 / 0 ? J = "5e" + B : (J = A.toExponential(), J = J.slice(0, J.indexOf("e") + 1) + B), ce = new P(J)) : ce = new P(A + ""), ce.c[0]) {
            for (B = ce.e, A = B + z, A < 3 && (A = 0); ;) if (M = ce, ce = j.times(M.plus(e(D, M, z, 1))), Id(M.c).slice(0, A) === (J = Id(ce.c)).slice(0, A)) if (ce.e < B && --A, J = J.slice(A - 3, A + 1), J == "9999" || !re && J == "4999") {
                if (!re && (ee(M, M.e + o + 2, 0), M.times(M).eq(D))) {
                    ce = M;
                    break
                }
                z += 4, A += 4, re = 1
            } else {
                (!+J || !+J.slice(1) && J.charAt(0) == "5") && (ee(ce, ce.e + o + 2, 1), G = !ce.times(ce).eq(D));
                break
            }
        }
        return ee(ce, ce.e + o + 1, s, G)
    }, i.toExponential = function (G, J) {
        return G != null && (oo(G, 0, qs), G++), F(this, G, J, 1)
    }, i.toFixed = function (G, J) {
        return G != null && (oo(G, 0, qs), G = G + this.e + 1), F(this, G, J)
    }, i.toFormat = function (G, J, ce) {
        var re, M = this;
        if (ce == null) G != null && J && typeof J == "object" ? (ce = J, J = null) : G && typeof G == "object" ? (ce = G, G = J = null) : ce = T; else if (typeof ce != "object") throw Error(Vu + "Argument not an object: " + ce);
        if (re = M.toFixed(G, J), M.c) {
            var D, x = re.split("."), A = +ce.groupSize, B = +ce.secondaryGroupSize, z = ce.groupSeparator || "",
                j = x[0], $ = x[1], C = M.s < 0, R = C ? j.slice(1) : j, k = R.length;
            if (B && (D = A, A = B, B = D, k -= D), A > 0 && k > 0) {
                for (D = k % A || A, j = R.substr(0, D); D < k; D += A) j += z + R.substr(D, A);
                B > 0 && (j += z + R.slice(D)), C && (j = "-" + j)
            }
            re = $ ? j + (ce.decimalSeparator || "") + ((B = +ce.fractionGroupSize) ? $.replace(new RegExp("\\d{" + B + "}\\B", "g"), "$&" + (ce.fractionGroupSeparator || "")) : $) : j
        }
        return (ce.prefix || "") + re + (ce.suffix || "")
    }, i.toFraction = function (G) {
        var J, ce, re, M, D, x, A, B, z, j, $, C, R = this, k = R.c;
        if (G != null && (A = new P(G), !A.isInteger() && (A.c || A.s !== 1) || A.lt(a))) throw Error(Vu + "Argument " + (A.isInteger() ? "out of range: " : "not an integer: ") + oe(A));
        if (!k) return new P(R);
        for (J = new P(a), z = ce = new P(a), re = B = new P(a), C = Id(k), D = J.e = C.length - R.e - 1, J.c[0] = Lj[(x = D % xn) < 0 ? xn + x : x], G = !G || A.comparedTo(J) > 0 ? D > 0 ? J : z : A, x = p, p = 1 / 0, A = new P(C), B.c[0] = 0; j = e(A, J, 0, 1), M = ce.plus(j.times(re)), M.comparedTo(G) != 1;) ce = re, re = M, z = B.plus(j.times(M = z)), B = M, J = A.minus(j.times(M = J)), A = M;
        return M = e(G.minus(ce), re, 0, 1), B = B.plus(M.times(z)), ce = ce.plus(M.times(re)), B.s = z.s = R.s, D = D * 2, $ = e(z, re, D, s).minus(R).abs().comparedTo(e(B, ce, D, s).minus(R).abs()) < 1 ? [z, re] : [B, ce], p = x, $
    }, i.toNumber = function () {
        return +oe(this)
    }, i.toPrecision = function (G, J) {
        return G != null && oo(G, 1, qs), F(this, G, J, 2)
    }, i.toString = function (G) {
        var J, ce = this, re = ce.s, M = ce.e;
        return M === null ? re ? (J = "Infinity", re < 0 && (J = "-" + J)) : J = "NaN" : (G == null ? J = M <= l || M >= f ? Y9(Id(ce.c), M) : Qm(Id(ce.c), M, "0") : G === 10 && N ? (ce = ee(new P(ce), o + M + 1, s), J = Qm(Id(ce.c), ce.e, "0")) : (oo(G, 2, I.length, "Base"), J = r(Qm(Id(ce.c), M, "0"), 10, G, re, !0)), re < 0 && ce.c[0] && (J = "-" + J)), J
    }, i.valueOf = i.toJSON = function () {
        return oe(this)
    }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, t != null && P.set(t), P
}

function Pd(t) {
    var e = t | 0;
    return t > 0 || t === e ? e : e - 1
}

function Id(t) {
    for (var e, r, n = 1, i = t.length, a = t[0] + ""; n < i;) {
        for (e = t[n++] + "", r = xn - e.length; r--; e = "0" + e) ;
        a += e
    }
    for (i = a.length; a.charCodeAt(--i) === 48;) ;
    return a.slice(0, i + 1 || 1)
}

function K_(t, e) {
    var r, n, i = t.c, a = e.c, o = t.s, s = e.s, l = t.e, f = e.e;
    if (!o || !s) return null;
    if (r = i && !i[0], n = a && !a[0], r || n) return r ? n ? 0 : -s : o;
    if (o != s) return o;
    if (r = o < 0, n = l == f, !i || !a) return n ? 0 : !i ^ r ? 1 : -1;
    if (!n) return l > f ^ r ? 1 : -1;
    for (s = (l = i.length) < (f = a.length) ? l : f, o = 0; o < s; o++) if (i[o] != a[o]) return i[o] > a[o] ^ r ? 1 : -1;
    return l == f ? 0 : l > f ^ r ? 1 : -1
}

function oo(t, e, r, n) {
    if (t < e || t > r || t !== h0(t)) throw Error(Vu + (n || "Argument") + (typeof t == "number" ? t < e || t > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t))
}

function K9(t) {
    var e = t.c.length - 1;
    return Pd(t.e / xn) == e && t.c[e] % 2 != 0
}

function Y9(t, e) {
    return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (e < 0 ? "e" : "e+") + e
}

function Qm(t, e, r) {
    var n, i;
    if (e < 0) {
        for (i = r + "."; ++e; i += r) ;
        t = i + t
    } else if (n = t.length, ++e > n) {
        for (i = r, e -= n; --e; i += r) ;
        t += i
    } else e < n && (t = t.slice(0, e) + "." + t.slice(e));
    return t
}

var Kn = nye();
const iye = Kn.clone({DECIMAL_PLACES: 32}), UM = Kn.clone({DECIMAL_PLACES: 50}), WW = Kn.clone({EXPONENTIAL_AT: 1e9}),
    eHe = (t, e) => {
        let r;
        return e <= 20 ? r = Kn : e <= 32 ? r = iye : r = UM, new r(t).multipliedBy(10 ** e).decimalPlaces(0, 3)
    }, qW = (t, e) => {
        let r;
        return e <= 20 ? r = Kn : e <= 32 ? r = iye : r = UM, new r(t).div(10 ** e).decimalPlaces(e, 3)
    }, aye = (t, e) => {
        if (Kn.isBigNumber(t)) return !(!t.isFinite() || t.isNaN() || e !== void 0 && t.lte(e));
        if (typeof t == "string") {
            const r = new Kn(t);
            return !(!r.isFinite() || r.isNaN() || e !== void 0 && r.lte(e))
        }
        return !(!Number.isFinite(t) || Number.isNaN(t) || e !== void 0 && t <= e)
    };

function jM(t) {
    if (t !== void 0) return Kn.isBigNumber(t) ? t.toNumber() : typeof t == "string" ? new Kn(t.replace(/,/g, "")).toNumber() : t
}

const XZt = t => Kn.isBigNumber(t) ? t : new Kn(t),
    Js = t => Kn.isBigNumber(t) ? t : typeof t == "string" ? new UM(t.replace(/,/g, "")) : new UM(t);

function QZt(t, e, r) {
    return e < t ? t : e > r ? r : e
}

const tHe = (t, e) => Number.isNaN(t.getTime()) ? !1 : e ? t.getFullYear() >= e : !0, rHe = /^\d{10}$|^\d{13}$/,
    nHe = t => aye(t) && rHe.test(t.toString()) && Yge(t), $f = t => t instanceof Error ? t : new Error(`${t}`),
    ls = t => {
        let e = !1, r, n;
        const i = a => {
            r = t(...a), e = !0, n = a
        };
        return (...a) => {
            const o = a.length;
            if (e && o === 0) return r;
            if (!e || n.length !== o) return i(a), r;
            for (let s = 0; s < o; s += 1) if (n[s] !== a[s]) return i(a), r;
            return r
        }
    }, ZC = () => {
    }, X9 = async () => Promise.reject(), ZZt = () => {
    }, oye = t => t, JZt = () => !1, eJt = () => !0, JC = () => null, Bj = t => {
        (!t.threshold || Math.random() < t.threshold) && t.callback()
    }, iHe = t => t != null, aHe = t => t !== void 0;

function Dv(t) {
    return typeof t == "object" && t !== null && !Array.isArray(t)
}

function VP(t) {
    return Object.keys(t)
}

function kf(t) {
    const e = {...t};
    for (const r of VP(t)) t[r] === void 0 && delete e[r];
    return e
}

var GW = function (t, e) {
    return GW = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (r, n) {
        r.__proto__ = n
    } || function (r, n) {
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i])
    }, GW(t, e)
};

function yp(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    GW(t, e);

    function r() {
        this.constructor = t
    }

    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r)
}

var KW = function () {
    return KW = Object.assign || function (e) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
            r = arguments[n];
            for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a])
        }
        return e
    }, KW.apply(this, arguments)
};

function oHe(t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
}

function sHe(t, e, r, n) {
    var i = arguments.length, a = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") a = Reflect.decorate(t, e, r, n); else for (var s = t.length - 1; s >= 0; s--) (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, r, a) : o(e, r)) || a);
    return i > 3 && a && Object.defineProperty(e, r, a), a
}

function cHe(t, e) {
    return function (r, n) {
        e(r, n, t)
    }
}

function lHe(t, e, r, n, i, a) {
    function o(N) {
        if (N !== void 0 && typeof N != "function") throw new TypeError("Function expected");
        return N
    }

    for (var s = n.kind, l = s === "getter" ? "get" : s === "setter" ? "set" : "value", f = !e && t ? n.static ? t : t.prototype : null, d = e || (f ? Object.getOwnPropertyDescriptor(f, n.name) : {}), p, g = !1, b = r.length - 1; b >= 0; b--) {
        var S = {};
        for (var T in n) S[T] = T === "access" ? {} : n[T];
        for (var T in n.access) S.access[T] = n.access[T];
        S.addInitializer = function (N) {
            if (g) throw new TypeError("Cannot add initializers after decoration has completed");
            a.push(o(N || null))
        };
        var I = (0, r[b])(s === "accessor" ? {get: d.get, set: d.set} : d[l], S);
        if (s === "accessor") {
            if (I === void 0) continue;
            if (I === null || typeof I != "object") throw new TypeError("Object expected");
            (p = o(I.get)) && (d.get = p), (p = o(I.set)) && (d.set = p), (p = o(I.init)) && i.push(p)
        } else (p = o(I)) && (s === "field" ? i.push(p) : d[l] = p)
    }
    f && Object.defineProperty(f, n.name, d), g = !0
}

function uHe(t, e, r) {
    for (var n = arguments.length > 2, i = 0; i < e.length; i++) r = n ? e[i].call(t, r) : e[i].call(t);
    return n ? r : void 0
}

function fHe(t) {
    return typeof t == "symbol" ? t : "".concat(t)
}

function dHe(t, e, r) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", {
        configurable: !0,
        value: r ? "".concat(r, " ", e) : e
    })
}

function hHe(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e)
}

function sye(t, e, r, n) {
    function i(a) {
        return a instanceof r ? a : new r(function (o) {
            o(a)
        })
    }

    return new (r || (r = Promise))(function (a, o) {
        function s(d) {
            try {
                f(n.next(d))
            } catch (p) {
                o(p)
            }
        }

        function l(d) {
            try {
                f(n.throw(d))
            } catch (p) {
                o(p)
            }
        }

        function f(d) {
            d.done ? a(d.value) : i(d.value).then(s, l)
        }

        f((n = n.apply(t, e || [])).next())
    })
}

function vX(t, e) {
    var r = {
        label: 0, sent: function () {
            if (a[0] & 1) throw a[1];
            return a[1]
        }, trys: [], ops: []
    }, n, i, a, o;
    return o = {
        next: s(0),
        throw: s(1),
        return: s(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this
    }), o;

    function s(f) {
        return function (d) {
            return l([f, d])
        }
    }

    function l(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; o && (o = 0, f[0] && (r = 0)), r;) try {
            if (n = 1, i && (a = f[0] & 2 ? i.return : f[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, f[1])).done) return a;
            switch (i = 0, a && (f = [f[0] & 2, a.value]), f[0]) {
                case 0:
                case 1:
                    a = f;
                    break;
                case 4:
                    return r.label++, {value: f[1], done: !1};
                case 5:
                    r.label++, i = f[1], f = [0];
                    continue;
                case 7:
                    f = r.ops.pop(), r.trys.pop();
                    continue;
                default:
                    if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (f[0] === 3 && (!a || f[1] > a[0] && f[1] < a[3])) {
                        r.label = f[1];
                        break
                    }
                    if (f[0] === 6 && r.label < a[1]) {
                        r.label = a[1], a = f;
                        break
                    }
                    if (a && r.label < a[2]) {
                        r.label = a[2], r.ops.push(f);
                        break
                    }
                    a[2] && r.ops.pop(), r.trys.pop();
                    continue
            }
            f = e.call(t, r)
        } catch (d) {
            f = [6, d], i = 0
        } finally {
            n = a = 0
        }
        if (f[0] & 5) throw f[1];
        return {value: f[0] ? f[1] : void 0, done: !0}
    }
}

var gX = Object.create ? function (t, e, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(e, r);
    (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0, get: function () {
            return e[r]
        }
    }), Object.defineProperty(t, n, i)
} : function (t, e, r, n) {
    n === void 0 && (n = r), t[n] = e[r]
};

function pHe(t, e) {
    for (var r in t) r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && gX(e, t, r)
}

function iS(t) {
    var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
    if (r) return r.call(t);
    if (t && typeof t.length == "number") return {
        next: function () {
            return t && n >= t.length && (t = void 0), {value: t && t[n++], done: !t}
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function Xy(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r) return t;
    var n = r.call(t), i, a = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(i = n.next()).done;) a.push(i.value)
    } catch (s) {
        o = {error: s}
    } finally {
        try {
            i && !i.done && (r = n.return) && r.call(n)
        } finally {
            if (o) throw o.error
        }
    }
    return a
}

function mHe() {
    for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(Xy(arguments[e]));
    return t
}

function vHe() {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
    for (var n = Array(t), i = 0, e = 0; e < r; e++) for (var a = arguments[e], o = 0, s = a.length; o < s; o++, i++) n[i] = a[o];
    return n
}

function aS(t, e, r) {
    if (r || arguments.length === 2) for (var n = 0, i = e.length, a; n < i; n++) (a || !(n in e)) && (a || (a = Array.prototype.slice.call(e, 0, n)), a[n] = e[n]);
    return t.concat(a || Array.prototype.slice.call(e))
}

function Ny(t) {
    return this instanceof Ny ? (this.v = t, this) : new Ny(t)
}

function cye(t, e, r) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = r.apply(t, e || []), i, a = [];
    return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function () {
        return this
    }, i;

    function o(g) {
        n[g] && (i[g] = function (b) {
            return new Promise(function (S, T) {
                a.push([g, b, S, T]) > 1 || s(g, b)
            })
        })
    }

    function s(g, b) {
        try {
            l(n[g](b))
        } catch (S) {
            p(a[0][3], S)
        }
    }

    function l(g) {
        g.value instanceof Ny ? Promise.resolve(g.value.v).then(f, d) : p(a[0][2], g)
    }

    function f(g) {
        s("next", g)
    }

    function d(g) {
        s("throw", g)
    }

    function p(g, b) {
        g(b), a.shift(), a.length && s(a[0][0], a[0][1])
    }
}

function gHe(t) {
    var e, r;
    return e = {}, n("next"), n("throw", function (i) {
        throw i
    }), n("return"), e[Symbol.iterator] = function () {
        return this
    }, e;

    function n(i, a) {
        e[i] = t[i] ? function (o) {
            return (r = !r) ? {value: Ny(t[i](o)), done: !1} : a ? a(o) : o
        } : a
    }
}

function lye(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator], r;
    return e ? e.call(t) : (t = typeof iS == "function" ? iS(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function () {
        return this
    }, r);

    function n(a) {
        r[a] = t[a] && function (o) {
            return new Promise(function (s, l) {
                o = t[a](o), i(s, l, o.done, o.value)
            })
        }
    }

    function i(a, o, s, l) {
        Promise.resolve(l).then(function (f) {
            a({value: f, done: s})
        }, o)
    }
}

function yHe(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {value: e}) : t.raw = e, t
}

var bHe = Object.create ? function (t, e) {
    Object.defineProperty(t, "default", {enumerable: !0, value: e})
} : function (t, e) {
    t.default = e
};

function wHe(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && gX(e, t, r);
    return bHe(e, t), e
}

function SHe(t) {
    return t && t.__esModule ? t : {default: t}
}

function _He(t, e, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t)
}

function xHe(t, e, r, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
}

function EHe(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof t == "function" ? e === t : t.has(e)
}

const THe = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return KW
    },
    __asyncDelegator: gHe,
    __asyncGenerator: cye,
    __asyncValues: lye,
    __await: Ny,
    __awaiter: sye,
    __classPrivateFieldGet: _He,
    __classPrivateFieldIn: EHe,
    __classPrivateFieldSet: xHe,
    __createBinding: gX,
    __decorate: sHe,
    __esDecorate: lHe,
    __exportStar: pHe,
    __extends: yp,
    __generator: vX,
    __importDefault: SHe,
    __importStar: wHe,
    __makeTemplateObject: yHe,
    __metadata: hHe,
    __param: cHe,
    __propKey: fHe,
    __read: Xy,
    __rest: oHe,
    __runInitializers: uHe,
    __setFunctionName: dHe,
    __spread: mHe,
    __spreadArray: aS,
    __spreadArrays: vHe,
    __values: iS
}, Symbol.toStringTag, {value: "Module"}));

function Wo(t) {
    return typeof t == "function"
}

function yX(t) {
    var e = function (n) {
        Error.call(n), n.stack = new Error().stack
    }, r = t(e);
    return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r
}

var $j = yX(function (t) {
    return function (r) {
        t(this), this.message = r ? r.length + ` errors occurred during unsubscription:
` + r.map(function (n, i) {
            return i + 1 + ") " + n.toString()
        }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = r
    }
});

function zM(t, e) {
    if (t) {
        var r = t.indexOf(e);
        0 <= r && t.splice(r, 1)
    }
}

var g8 = function () {
    function t(e) {
        this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null
    }

    return t.prototype.unsubscribe = function () {
        var e, r, n, i, a;
        if (!this.closed) {
            this.closed = !0;
            var o = this._parentage;
            if (o) if (this._parentage = null, Array.isArray(o)) try {
                for (var s = iS(o), l = s.next(); !l.done; l = s.next()) {
                    var f = l.value;
                    f.remove(this)
                }
            } catch (T) {
                e = {error: T}
            } finally {
                try {
                    l && !l.done && (r = s.return) && r.call(s)
                } finally {
                    if (e) throw e.error
                }
            } else o.remove(this);
            var d = this.initialTeardown;
            if (Wo(d)) try {
                d()
            } catch (T) {
                a = T instanceof $j ? T.errors : [T]
            }
            var p = this._finalizers;
            if (p) {
                this._finalizers = null;
                try {
                    for (var g = iS(p), b = g.next(); !b.done; b = g.next()) {
                        var S = b.value;
                        try {
                            yse(S)
                        } catch (T) {
                            a = a ?? [], T instanceof $j ? a = aS(aS([], Xy(a)), Xy(T.errors)) : a.push(T)
                        }
                    }
                } catch (T) {
                    n = {error: T}
                } finally {
                    try {
                        b && !b.done && (i = g.return) && i.call(g)
                    } finally {
                        if (n) throw n.error
                    }
                }
            }
            if (a) throw new $j(a)
        }
    }, t.prototype.add = function (e) {
        var r;
        if (e && e !== this) if (this.closed) yse(e); else {
            if (e instanceof t) {
                if (e.closed || e._hasParent(this)) return;
                e._addParent(this)
            }
            (this._finalizers = (r = this._finalizers) !== null && r !== void 0 ? r : []).push(e)
        }
    }, t.prototype._hasParent = function (e) {
        var r = this._parentage;
        return r === e || Array.isArray(r) && r.includes(e)
    }, t.prototype._addParent = function (e) {
        var r = this._parentage;
        this._parentage = Array.isArray(r) ? (r.push(e), r) : r ? [r, e] : e
    }, t.prototype._removeParent = function (e) {
        var r = this._parentage;
        r === e ? this._parentage = null : Array.isArray(r) && zM(r, e)
    }, t.prototype.remove = function (e) {
        var r = this._finalizers;
        r && zM(r, e), e instanceof t && e._removeParent(this)
    }, t.EMPTY = function () {
        var e = new t;
        return e.closed = !0, e
    }(), t
}(), uye = g8.EMPTY;

function fye(t) {
    return t instanceof g8 || t && "closed" in t && Wo(t.remove) && Wo(t.add) && Wo(t.unsubscribe)
}

function yse(t) {
    Wo(t) ? t() : t.unsubscribe()
}

var dye = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1
}, hye = {
    setTimeout: function (t, e) {
        for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
        return setTimeout.apply(void 0, aS([t, e], Xy(r)))
    }, clearTimeout: function (t) {
        var e = hye.delegate;
        return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(t)
    }, delegate: void 0
};

function pye(t) {
    hye.setTimeout(function () {
        throw t
    })
}

function YW() {
}

function gD(t) {
    t()
}

var bX = function (t) {
    yp(e, t);

    function e(r) {
        var n = t.call(this) || this;
        return n.isStopped = !1, r ? (n.destination = r, fye(r) && r.add(n)) : n.destination = kHe, n
    }

    return e.create = function (r, n, i) {
        return new A4(r, n, i)
    }, e.prototype.next = function (r) {
        this.isStopped || this._next(r)
    }, e.prototype.error = function (r) {
        this.isStopped || (this.isStopped = !0, this._error(r))
    }, e.prototype.complete = function () {
        this.isStopped || (this.isStopped = !0, this._complete())
    }, e.prototype.unsubscribe = function () {
        this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null)
    }, e.prototype._next = function (r) {
        this.destination.next(r)
    }, e.prototype._error = function (r) {
        try {
            this.destination.error(r)
        } finally {
            this.unsubscribe()
        }
    }, e.prototype._complete = function () {
        try {
            this.destination.complete()
        } finally {
            this.unsubscribe()
        }
    }, e
}(g8), CHe = Function.prototype.bind;

function Fj(t, e) {
    return CHe.call(t, e)
}

var AHe = function () {
    function t(e) {
        this.partialObserver = e
    }

    return t.prototype.next = function (e) {
        var r = this.partialObserver;
        if (r.next) try {
            r.next(e)
        } catch (n) {
            Q9(n)
        }
    }, t.prototype.error = function (e) {
        var r = this.partialObserver;
        if (r.error) try {
            r.error(e)
        } catch (n) {
            Q9(n)
        } else Q9(e)
    }, t.prototype.complete = function () {
        var e = this.partialObserver;
        if (e.complete) try {
            e.complete()
        } catch (r) {
            Q9(r)
        }
    }, t
}(), A4 = function (t) {
    yp(e, t);

    function e(r, n, i) {
        var a = t.call(this) || this, o;
        if (Wo(r) || !r) o = {next: r ?? void 0, error: n ?? void 0, complete: i ?? void 0}; else {
            var s;
            a && dye.useDeprecatedNextContext ? (s = Object.create(r), s.unsubscribe = function () {
                return a.unsubscribe()
            }, o = {
                next: r.next && Fj(r.next, s),
                error: r.error && Fj(r.error, s),
                complete: r.complete && Fj(r.complete, s)
            }) : o = r
        }
        return a.destination = new AHe(o), a
    }

    return e
}(bX);

function Q9(t) {
    pye(t)
}

function IHe(t) {
    throw t
}

var kHe = {closed: !0, next: YW, error: IHe, complete: YW}, wX = function () {
    return typeof Symbol == "function" && Symbol.observable || "@@observable"
}();

function MS(t) {
    return t
}

function RHe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return mye(t)
}

function mye(t) {
    return t.length === 0 ? MS : t.length === 1 ? t[0] : function (r) {
        return t.reduce(function (n, i) {
            return i(n)
        }, r)
    }
}

var ia = function () {
    function t(e) {
        e && (this._subscribe = e)
    }

    return t.prototype.lift = function (e) {
        var r = new t;
        return r.source = this, r.operator = e, r
    }, t.prototype.subscribe = function (e, r, n) {
        var i = this, a = MHe(e) ? e : new A4(e, r, n);
        return gD(function () {
            var o = i, s = o.operator, l = o.source;
            a.add(s ? s.call(a, l) : l ? i._subscribe(a) : i._trySubscribe(a))
        }), a
    }, t.prototype._trySubscribe = function (e) {
        try {
            return this._subscribe(e)
        } catch (r) {
            e.error(r)
        }
    }, t.prototype.forEach = function (e, r) {
        var n = this;
        return r = bse(r), new r(function (i, a) {
            var o = new A4({
                next: function (s) {
                    try {
                        e(s)
                    } catch (l) {
                        a(l), o.unsubscribe()
                    }
                }, error: a, complete: i
            });
            n.subscribe(o)
        })
    }, t.prototype._subscribe = function (e) {
        var r;
        return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(e)
    }, t.prototype[wX] = function () {
        return this
    }, t.prototype.pipe = function () {
        for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
        return mye(e)(this)
    }, t.prototype.toPromise = function (e) {
        var r = this;
        return e = bse(e), new e(function (n, i) {
            var a;
            r.subscribe(function (o) {
                return a = o
            }, function (o) {
                return i(o)
            }, function () {
                return n(a)
            })
        })
    }, t.create = function (e) {
        return new t(e)
    }, t
}();

function bse(t) {
    var e;
    return (e = t ?? dye.Promise) !== null && e !== void 0 ? e : Promise
}

function DHe(t) {
    return t && Wo(t.next) && Wo(t.error) && Wo(t.complete)
}

function MHe(t) {
    return t && t instanceof bX || DHe(t) && fye(t)
}

function OHe(t) {
    return Wo(t == null ? void 0 : t.lift)
}

function yu(t) {
    return function (e) {
        if (OHe(e)) return e.lift(function (r) {
            try {
                return t(r, this)
            } catch (n) {
                this.error(n)
            }
        });
        throw new TypeError("Unable to lift unknown Observable type")
    }
}

function hu(t, e, r, n, i) {
    return new PHe(t, e, r, n, i)
}

var PHe = function (t) {
    yp(e, t);

    function e(r, n, i, a, o, s) {
        var l = t.call(this, r) || this;
        return l.onFinalize = o, l.shouldUnsubscribe = s, l._next = n ? function (f) {
            try {
                n(f)
            } catch (d) {
                r.error(d)
            }
        } : t.prototype._next, l._error = a ? function (f) {
            try {
                a(f)
            } catch (d) {
                r.error(d)
            } finally {
                this.unsubscribe()
            }
        } : t.prototype._error, l._complete = i ? function () {
            try {
                i()
            } catch (f) {
                r.error(f)
            } finally {
                this.unsubscribe()
            }
        } : t.prototype._complete, l
    }

    return e.prototype.unsubscribe = function () {
        var r;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var n = this.closed;
            t.prototype.unsubscribe.call(this), !n && ((r = this.onFinalize) === null || r === void 0 || r.call(this))
        }
    }, e
}(bX), NHe = yX(function (t) {
    return function () {
        t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
    }
}), Mv = function (t) {
    yp(e, t);

    function e() {
        var r = t.call(this) || this;
        return r.closed = !1, r.currentObservers = null, r.observers = [], r.isStopped = !1, r.hasError = !1, r.thrownError = null, r
    }

    return e.prototype.lift = function (r) {
        var n = new wse(this, this);
        return n.operator = r, n
    }, e.prototype._throwIfClosed = function () {
        if (this.closed) throw new NHe
    }, e.prototype.next = function (r) {
        var n = this;
        gD(function () {
            var i, a;
            if (n._throwIfClosed(), !n.isStopped) {
                n.currentObservers || (n.currentObservers = Array.from(n.observers));
                try {
                    for (var o = iS(n.currentObservers), s = o.next(); !s.done; s = o.next()) {
                        var l = s.value;
                        l.next(r)
                    }
                } catch (f) {
                    i = {error: f}
                } finally {
                    try {
                        s && !s.done && (a = o.return) && a.call(o)
                    } finally {
                        if (i) throw i.error
                    }
                }
            }
        })
    }, e.prototype.error = function (r) {
        var n = this;
        gD(function () {
            if (n._throwIfClosed(), !n.isStopped) {
                n.hasError = n.isStopped = !0, n.thrownError = r;
                for (var i = n.observers; i.length;) i.shift().error(r)
            }
        })
    }, e.prototype.complete = function () {
        var r = this;
        gD(function () {
            if (r._throwIfClosed(), !r.isStopped) {
                r.isStopped = !0;
                for (var n = r.observers; n.length;) n.shift().complete()
            }
        })
    }, e.prototype.unsubscribe = function () {
        this.isStopped = this.closed = !0, this.observers = this.currentObservers = null
    }, Object.defineProperty(e.prototype, "observed", {
        get: function () {
            var r;
            return ((r = this.observers) === null || r === void 0 ? void 0 : r.length) > 0
        }, enumerable: !1, configurable: !0
    }), e.prototype._trySubscribe = function (r) {
        return this._throwIfClosed(), t.prototype._trySubscribe.call(this, r)
    }, e.prototype._subscribe = function (r) {
        return this._throwIfClosed(), this._checkFinalizedStatuses(r), this._innerSubscribe(r)
    }, e.prototype._innerSubscribe = function (r) {
        var n = this, i = this, a = i.hasError, o = i.isStopped, s = i.observers;
        return a || o ? uye : (this.currentObservers = null, s.push(r), new g8(function () {
            n.currentObservers = null, zM(s, r)
        }))
    }, e.prototype._checkFinalizedStatuses = function (r) {
        var n = this, i = n.hasError, a = n.thrownError, o = n.isStopped;
        i ? r.error(a) : o && r.complete()
    }, e.prototype.asObservable = function () {
        var r = new ia;
        return r.source = this, r
    }, e.create = function (r, n) {
        return new wse(r, n)
    }, e
}(ia), wse = function (t) {
    yp(e, t);

    function e(r, n) {
        var i = t.call(this) || this;
        return i.destination = r, i.source = n, i
    }

    return e.prototype.next = function (r) {
        var n, i;
        (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, r)
    }, e.prototype.error = function (r) {
        var n, i;
        (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, r)
    }, e.prototype.complete = function () {
        var r, n;
        (n = (r = this.destination) === null || r === void 0 ? void 0 : r.complete) === null || n === void 0 || n.call(r)
    }, e.prototype._subscribe = function (r) {
        var n, i;
        return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(r)) !== null && i !== void 0 ? i : uye
    }, e
}(Mv), SX = function (t) {
    yp(e, t);

    function e(r) {
        var n = t.call(this) || this;
        return n._value = r, n
    }

    return Object.defineProperty(e.prototype, "value", {
        get: function () {
            return this.getValue()
        }, enumerable: !1, configurable: !0
    }), e.prototype._subscribe = function (r) {
        var n = t.prototype._subscribe.call(this, r);
        return !n.closed && r.next(this._value), n
    }, e.prototype.getValue = function () {
        var r = this, n = r.hasError, i = r.thrownError, a = r._value;
        if (n) throw i;
        return this._throwIfClosed(), a
    }, e.prototype.next = function (r) {
        t.prototype.next.call(this, this._value = r)
    }, e
}(Mv), _X = {
    now: function () {
        return (_X.delegate || Date).now()
    }, delegate: void 0
}, I4 = function (t) {
    yp(e, t);

    function e(r, n, i) {
        r === void 0 && (r = 1 / 0), n === void 0 && (n = 1 / 0), i === void 0 && (i = _X);
        var a = t.call(this) || this;
        return a._bufferSize = r, a._windowTime = n, a._timestampProvider = i, a._buffer = [], a._infiniteTimeWindow = !0, a._infiniteTimeWindow = n === 1 / 0, a._bufferSize = Math.max(1, r), a._windowTime = Math.max(1, n), a
    }

    return e.prototype.next = function (r) {
        var n = this, i = n.isStopped, a = n._buffer, o = n._infiniteTimeWindow, s = n._timestampProvider,
            l = n._windowTime;
        i || (a.push(r), !o && a.push(s.now() + l)), this._trimBuffer(), t.prototype.next.call(this, r)
    }, e.prototype._subscribe = function (r) {
        this._throwIfClosed(), this._trimBuffer();
        for (var n = this._innerSubscribe(r), i = this, a = i._infiniteTimeWindow, o = i._buffer, s = o.slice(), l = 0; l < s.length && !r.closed; l += a ? 1 : 2) r.next(s[l]);
        return this._checkFinalizedStatuses(r), n
    }, e.prototype._trimBuffer = function () {
        var r = this, n = r._bufferSize, i = r._timestampProvider, a = r._buffer, o = r._infiniteTimeWindow,
            s = (o ? 1 : 2) * n;
        if (n < 1 / 0 && s < a.length && a.splice(0, a.length - s), !o) {
            for (var l = i.now(), f = 0, d = 1; d < a.length && a[d] <= l; d += 2) f = d;
            f && a.splice(0, f + 1)
        }
    }, e
}(Mv), LHe = function (t) {
    yp(e, t);

    function e(r, n) {
        return t.call(this) || this
    }

    return e.prototype.schedule = function (r, n) {
        return this
    }, e
}(g8), XW = {
    setInterval: function (t, e) {
        for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
        return setInterval.apply(void 0, aS([t, e], Xy(r)))
    }, clearInterval: function (t) {
        var e = XW.delegate;
        return ((e == null ? void 0 : e.clearInterval) || clearInterval)(t)
    }, delegate: void 0
}, BHe = function (t) {
    yp(e, t);

    function e(r, n) {
        var i = t.call(this, r, n) || this;
        return i.scheduler = r, i.work = n, i.pending = !1, i
    }

    return e.prototype.schedule = function (r, n) {
        var i;
        if (n === void 0 && (n = 0), this.closed) return this;
        this.state = r;
        var a = this.id, o = this.scheduler;
        return a != null && (this.id = this.recycleAsyncId(o, a, n)), this.pending = !0, this.delay = n, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(o, this.id, n), this
    }, e.prototype.requestAsyncId = function (r, n, i) {
        return i === void 0 && (i = 0), XW.setInterval(r.flush.bind(r, this), i)
    }, e.prototype.recycleAsyncId = function (r, n, i) {
        if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1) return n;
        n != null && XW.clearInterval(n)
    }, e.prototype.execute = function (r, n) {
        if (this.closed) return new Error("executing a cancelled action");
        this.pending = !1;
        var i = this._execute(r, n);
        if (i) return i;
        this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
    }, e.prototype._execute = function (r, n) {
        var i = !1, a;
        try {
            this.work(r)
        } catch (o) {
            i = !0, a = o || new Error("Scheduled action threw falsy error")
        }
        if (i) return this.unsubscribe(), a
    }, e.prototype.unsubscribe = function () {
        if (!this.closed) {
            var r = this, n = r.id, i = r.scheduler, a = i.actions;
            this.work = this.state = this.scheduler = null, this.pending = !1, zM(a, this), n != null && (this.id = this.recycleAsyncId(i, n, null)), this.delay = null, t.prototype.unsubscribe.call(this)
        }
    }, e
}(LHe), Sse = function () {
    function t(e, r) {
        r === void 0 && (r = t.now), this.schedulerActionCtor = e, this.now = r
    }

    return t.prototype.schedule = function (e, r, n) {
        return r === void 0 && (r = 0), new this.schedulerActionCtor(this, e).schedule(n, r)
    }, t.now = _X.now, t
}(), $He = function (t) {
    yp(e, t);

    function e(r, n) {
        n === void 0 && (n = Sse.now);
        var i = t.call(this, r, n) || this;
        return i.actions = [], i._active = !1, i
    }

    return e.prototype.flush = function (r) {
        var n = this.actions;
        if (this._active) {
            n.push(r);
            return
        }
        var i;
        this._active = !0;
        do if (i = r.execute(r.state, r.delay)) break; while (r = n.shift());
        if (this._active = !1, i) {
            for (; r = n.shift();) r.unsubscribe();
            throw i
        }
    }, e
}(Sse), xX = new $He(BHe), FHe = xX, vye = new ia(function (t) {
    return t.complete()
});

function gye(t) {
    return t && Wo(t.schedule)
}

function EX(t) {
    return t[t.length - 1]
}

function UHe(t) {
    return Wo(EX(t)) ? t.pop() : void 0
}

function TX(t) {
    return gye(EX(t)) ? t.pop() : void 0
}

function jHe(t, e) {
    return typeof EX(t) == "number" ? t.pop() : e
}

var yye = function (t) {
    return t && typeof t.length == "number" && typeof t != "function"
};

function bye(t) {
    return Wo(t == null ? void 0 : t.then)
}

function wye(t) {
    return Wo(t[wX])
}

function Sye(t) {
    return Symbol.asyncIterator && Wo(t == null ? void 0 : t[Symbol.asyncIterator])
}

function _ye(t) {
    return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")
}

function zHe() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator
}

var xye = zHe();

function Eye(t) {
    return Wo(t == null ? void 0 : t[xye])
}

function Tye(t) {
    return cye(this, arguments, function () {
        var r, n, i, a;
        return vX(this, function (o) {
            switch (o.label) {
                case 0:
                    r = t.getReader(), o.label = 1;
                case 1:
                    o.trys.push([1, , 9, 10]), o.label = 2;
                case 2:
                    return [4, Ny(r.read())];
                case 3:
                    return n = o.sent(), i = n.value, a = n.done, a ? [4, Ny(void 0)] : [3, 5];
                case 4:
                    return [2, o.sent()];
                case 5:
                    return [4, Ny(i)];
                case 6:
                    return [4, o.sent()];
                case 7:
                    return o.sent(), [3, 2];
                case 8:
                    return [3, 10];
                case 9:
                    return r.releaseLock(), [7];
                case 10:
                    return [2]
            }
        })
    })
}

function Cye(t) {
    return Wo(t == null ? void 0 : t.getReader)
}

function Xv(t) {
    if (t instanceof ia) return t;
    if (t != null) {
        if (wye(t)) return VHe(t);
        if (yye(t)) return HHe(t);
        if (bye(t)) return WHe(t);
        if (Sye(t)) return Aye(t);
        if (Eye(t)) return qHe(t);
        if (Cye(t)) return GHe(t)
    }
    throw _ye(t)
}

function VHe(t) {
    return new ia(function (e) {
        var r = t[wX]();
        if (Wo(r.subscribe)) return r.subscribe(e);
        throw new TypeError("Provided object does not correctly implement Symbol.observable")
    })
}

function HHe(t) {
    return new ia(function (e) {
        for (var r = 0; r < t.length && !e.closed; r++) e.next(t[r]);
        e.complete()
    })
}

function WHe(t) {
    return new ia(function (e) {
        t.then(function (r) {
            e.closed || (e.next(r), e.complete())
        }, function (r) {
            return e.error(r)
        }).then(null, pye)
    })
}

function qHe(t) {
    return new ia(function (e) {
        var r, n;
        try {
            for (var i = iS(t), a = i.next(); !a.done; a = i.next()) {
                var o = a.value;
                if (e.next(o), e.closed) return
            }
        } catch (s) {
            r = {error: s}
        } finally {
            try {
                a && !a.done && (n = i.return) && n.call(i)
            } finally {
                if (r) throw r.error
            }
        }
        e.complete()
    })
}

function Aye(t) {
    return new ia(function (e) {
        KHe(t, e).catch(function (r) {
            return e.error(r)
        })
    })
}

function GHe(t) {
    return Aye(Tye(t))
}

function KHe(t, e) {
    var r, n, i, a;
    return sye(this, void 0, void 0, function () {
        var o, s;
        return vX(this, function (l) {
            switch (l.label) {
                case 0:
                    l.trys.push([0, 5, 6, 11]), r = lye(t), l.label = 1;
                case 1:
                    return [4, r.next()];
                case 2:
                    if (n = l.sent(), !!n.done) return [3, 4];
                    if (o = n.value, e.next(o), e.closed) return [2];
                    l.label = 3;
                case 3:
                    return [3, 1];
                case 4:
                    return [3, 11];
                case 5:
                    return s = l.sent(), i = {error: s}, [3, 11];
                case 6:
                    return l.trys.push([6, , 9, 10]), n && !n.done && (a = r.return) ? [4, a.call(r)] : [3, 8];
                case 7:
                    l.sent(), l.label = 8;
                case 8:
                    return [3, 10];
                case 9:
                    if (i) throw i.error;
                    return [7];
                case 10:
                    return [7];
                case 11:
                    return e.complete(), [2]
            }
        })
    })
}

function bv(t, e, r, n, i) {
    n === void 0 && (n = 0), i === void 0 && (i = !1);
    var a = e.schedule(function () {
        r(), i ? t.add(this.schedule(null, n)) : this.unsubscribe()
    }, n);
    if (t.add(a), !i) return a
}

function Iye(t, e) {
    return e === void 0 && (e = 0), yu(function (r, n) {
        r.subscribe(hu(n, function (i) {
            return bv(n, t, function () {
                return n.next(i)
            }, e)
        }, function () {
            return bv(n, t, function () {
                return n.complete()
            }, e)
        }, function (i) {
            return bv(n, t, function () {
                return n.error(i)
            }, e)
        }))
    })
}

function kye(t, e) {
    return e === void 0 && (e = 0), yu(function (r, n) {
        n.add(t.schedule(function () {
            return r.subscribe(n)
        }, e))
    })
}

function YHe(t, e) {
    return Xv(t).pipe(kye(e), Iye(e))
}

function XHe(t, e) {
    return Xv(t).pipe(kye(e), Iye(e))
}

function QHe(t, e) {
    return new ia(function (r) {
        var n = 0;
        return e.schedule(function () {
            n === t.length ? r.complete() : (r.next(t[n++]), r.closed || this.schedule())
        })
    })
}

function ZHe(t, e) {
    return new ia(function (r) {
        var n;
        return bv(r, e, function () {
            n = t[xye](), bv(r, e, function () {
                var i, a, o;
                try {
                    i = n.next(), a = i.value, o = i.done
                } catch (s) {
                    r.error(s);
                    return
                }
                o ? r.complete() : r.next(a)
            }, 0, !0)
        }), function () {
            return Wo(n == null ? void 0 : n.return) && n.return()
        }
    })
}

function Rye(t, e) {
    if (!t) throw new Error("Iterable cannot be null");
    return new ia(function (r) {
        bv(r, e, function () {
            var n = t[Symbol.asyncIterator]();
            bv(r, e, function () {
                n.next().then(function (i) {
                    i.done ? r.complete() : r.next(i.value)
                })
            }, 0, !0)
        })
    })
}

function JHe(t, e) {
    return Rye(Tye(t), e)
}

function eWe(t, e) {
    if (t != null) {
        if (wye(t)) return YHe(t, e);
        if (yye(t)) return QHe(t, e);
        if (bye(t)) return XHe(t, e);
        if (Sye(t)) return Rye(t, e);
        if (Eye(t)) return ZHe(t, e);
        if (Cye(t)) return JHe(t, e)
    }
    throw _ye(t)
}

function Ju(t, e) {
    return e ? eWe(t, e) : Xv(t)
}

function Hd() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var r = TX(t);
    return Ju(t, r)
}

var CX = yX(function (t) {
    return function () {
        t(this), this.name = "EmptyError", this.message = "no elements in sequence"
    }
});

function _l(t, e) {
    var r = typeof e == "object";
    return new Promise(function (n, i) {
        var a = new A4({
            next: function (o) {
                n(o), a.unsubscribe()
            }, error: i, complete: function () {
                r ? n(e.defaultValue) : i(new CX)
            }
        });
        t.subscribe(a)
    })
}

function tWe(t) {
    return t instanceof Date && !isNaN(t)
}

function zn(t, e) {
    return yu(function (r, n) {
        var i = 0;
        r.subscribe(hu(n, function (a) {
            n.next(t.call(e, a, i++))
        }))
    })
}

var rWe = Array.isArray;

function nWe(t, e) {
    return rWe(e) ? t.apply(void 0, aS([], Xy(e))) : t(e)
}

function iWe(t) {
    return zn(function (e) {
        return nWe(t, e)
    })
}

var aWe = Array.isArray, oWe = Object.getPrototypeOf, sWe = Object.prototype, cWe = Object.keys;

function lWe(t) {
    if (t.length === 1) {
        var e = t[0];
        if (aWe(e)) return {args: e, keys: null};
        if (uWe(e)) {
            var r = cWe(e);
            return {
                args: r.map(function (n) {
                    return e[n]
                }), keys: r
            }
        }
    }
    return {args: t, keys: null}
}

function uWe(t) {
    return t && typeof t == "object" && oWe(t) === sWe
}

function fWe(t, e) {
    return t.reduce(function (r, n, i) {
        return r[n] = e[i], r
    }, {})
}

function Qy() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var r = TX(t), n = UHe(t), i = lWe(t), a = i.args, o = i.keys;
    if (a.length === 0) return Ju([], r);
    var s = new ia(dWe(a, r, o ? function (l) {
        return fWe(o, l)
    } : MS));
    return n ? s.pipe(iWe(n)) : s
}

function dWe(t, e, r) {
    return r === void 0 && (r = MS), function (n) {
        _se(e, function () {
            for (var i = t.length, a = new Array(i), o = i, s = i, l = function (d) {
                _se(e, function () {
                    var p = Ju(t[d], e), g = !1;
                    p.subscribe(hu(n, function (b) {
                        a[d] = b, g || (g = !0, s--), s || n.next(r(a.slice()))
                    }, function () {
                        --o || n.complete()
                    }))
                }, n)
            }, f = 0; f < i; f++) l(f)
        }, n)
    }
}

function _se(t, e, r) {
    t ? bv(r, t, e) : e()
}

function hWe(t, e, r, n, i, a, o, s) {
    var l = [], f = 0, d = 0, p = !1, g = function () {
        p && !l.length && !f && e.complete()
    }, b = function (T) {
        return f < n ? S(T) : l.push(T)
    }, S = function (T) {
        a && e.next(T), f++;
        var I = !1;
        Xv(r(T, d++)).subscribe(hu(e, function (N) {
            i == null || i(N), a ? b(N) : e.next(N)
        }, function () {
            I = !0
        }, void 0, function () {
            if (I) try {
                f--;
                for (var N = function () {
                    var P = l.shift();
                    o ? bv(e, o, function () {
                        return S(P)
                    }) : S(P)
                }; l.length && f < n;) N();
                g()
            } catch (P) {
                e.error(P)
            }
        }))
    };
    return t.subscribe(hu(e, b, function () {
        p = !0, g()
    })), function () {
        s == null || s()
    }
}

function AX(t, e, r) {
    return r === void 0 && (r = 1 / 0), Wo(e) ? AX(function (n, i) {
        return zn(function (a, o) {
            return e(n, a, i, o)
        })(Xv(t(n, i)))
    }, r) : (typeof e == "number" && (r = e), yu(function (n, i) {
        return hWe(n, i, t, r)
    }))
}

function pWe(t) {
    return t === void 0 && (t = 1 / 0), AX(MS, t)
}

function QW(t, e, r) {
    t === void 0 && (t = 0), r === void 0 && (r = FHe);
    var n = -1;
    return e != null && (gye(e) ? r = e : n = e), new ia(function (i) {
        var a = tWe(t) ? +t - r.now() : t;
        a < 0 && (a = 0);
        var o = 0;
        return r.schedule(function () {
            i.closed || (i.next(o++), 0 <= n ? this.schedule(void 0, n) : i.complete())
        }, a)
    })
}

function ZW() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var r = TX(t), n = jHe(t, 1 / 0), i = t;
    return i.length ? i.length === 1 ? Xv(i[0]) : pWe(n)(Ju(i, r)) : vye
}

var Dye = new ia(YW);

function j0(t, e) {
    return yu(function (r, n) {
        var i = 0;
        r.subscribe(hu(n, function (a) {
            return t.call(e, a, i++) && n.next(a)
        }))
    })
}

function mWe(t, e, r, n, i) {
    return function (a, o) {
        var s = r, l = e, f = 0;
        a.subscribe(hu(o, function (d) {
            var p = f++;
            l = s ? t(l, d, p) : (s = !0, d), n && o.next(l)
        }, i && function () {
            s && o.next(l), o.complete()
        }))
    }
}

function vWe(t, e) {
    return e === void 0 && (e = xX), yu(function (r, n) {
        var i = null, a = null, o = null, s = function () {
            if (i) {
                i.unsubscribe(), i = null;
                var f = a;
                a = null, n.next(f)
            }
        };

        function l() {
            var f = o + t, d = e.now();
            if (d < f) {
                i = this.schedule(void 0, f - d), n.add(i);
                return
            }
            s()
        }

        r.subscribe(hu(n, function (f) {
            a = f, o = e.now(), i || (i = e.schedule(l, t), n.add(i))
        }, function () {
            s(), n.complete()
        }, void 0, function () {
            a = i = null
        }))
    })
}

function gWe(t) {
    return yu(function (e, r) {
        var n = !1;
        e.subscribe(hu(r, function (i) {
            n = !0, r.next(i)
        }, function () {
            n || r.next(t), r.complete()
        }))
    })
}

function Mye(t) {
    return t <= 0 ? function () {
        return vye
    } : yu(function (e, r) {
        var n = 0;
        e.subscribe(hu(r, function (i) {
            ++n <= t && (r.next(i), t <= n && r.complete())
        }))
    })
}

function PE(t, e) {
    return e === void 0 && (e = MS), t = t ?? yWe, yu(function (r, n) {
        var i, a = !0;
        r.subscribe(hu(n, function (o) {
            var s = e(o);
            (a || !t(i, s)) && (a = !1, i = s, n.next(o))
        }))
    })
}

function yWe(t, e) {
    return t === e
}

function bWe(t) {
    return t === void 0 && (t = wWe), yu(function (e, r) {
        var n = !1;
        e.subscribe(hu(r, function (i) {
            n = !0, r.next(i)
        }, function () {
            return n ? r.complete() : r.error(t())
        }))
    })
}

function wWe() {
    return new CX
}

function SWe(t) {
    return yu(function (e, r) {
        try {
            e.subscribe(r)
        } finally {
            r.add(t)
        }
    })
}

function _We(t, e) {
    var r = arguments.length >= 2;
    return function (n) {
        return n.pipe(t ? j0(function (i, a) {
            return t(i, a, n)
        }) : MS, Mye(1), r ? gWe(e) : bWe(function () {
            return new CX
        }))
    }
}

function xWe(t, e) {
    return yu(mWe(t, e, arguments.length >= 2, !0))
}

function IX(t) {
    t === void 0 && (t = {});
    var e = t.connector, r = e === void 0 ? function () {
            return new Mv
        } : e, n = t.resetOnError, i = n === void 0 ? !0 : n, a = t.resetOnComplete, o = a === void 0 ? !0 : a,
        s = t.resetOnRefCountZero, l = s === void 0 ? !0 : s;
    return function (f) {
        var d, p, g, b = 0, S = !1, T = !1, I = function () {
            p == null || p.unsubscribe(), p = void 0
        }, N = function () {
            I(), d = g = void 0, S = T = !1
        }, P = function () {
            var F = d;
            N(), F == null || F.unsubscribe()
        };
        return yu(function (F, V) {
            b++, !T && !S && I();
            var Y = g = g ?? r();
            V.add(function () {
                b--, b === 0 && !T && !S && (p = Uj(P, l))
            }), Y.subscribe(V), !d && b > 0 && (d = new A4({
                next: function (ee) {
                    return Y.next(ee)
                }, error: function (ee) {
                    T = !0, I(), p = Uj(N, i, ee), Y.error(ee)
                }, complete: function () {
                    S = !0, I(), p = Uj(N, o), Y.complete()
                }
            }), Xv(F).subscribe(d))
        })(f)
    }
}

function Uj(t, e) {
    for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
    if (e === !0) {
        t();
        return
    }
    if (e !== !1) {
        var i = new A4({
            next: function () {
                i.unsubscribe(), t()
            }
        });
        return Xv(e.apply(void 0, aS([], Xy(r)))).subscribe(i)
    }
}

function EWe(t, e, r) {
    var n, i, a, o, s = !1;
    return t && typeof t == "object" ? (n = t.bufferSize, o = n === void 0 ? 1 / 0 : n, i = t.windowTime, e = i === void 0 ? 1 / 0 : i, a = t.refCount, s = a === void 0 ? !1 : a, r = t.scheduler) : o = t ?? 1 / 0, IX({
        connector: function () {
            return new I4(o, e, r)
        }, resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: s
    })
}

function TWe(t) {
    return j0(function (e, r) {
        return t <= r
    })
}

function uo(t, e) {
    return yu(function (r, n) {
        var i = null, a = 0, o = !1, s = function () {
            return o && !i && n.complete()
        };
        r.subscribe(hu(n, function (l) {
            i == null || i.unsubscribe();
            var f = 0, d = a++;
            Xv(t(l, d)).subscribe(i = hu(n, function (p) {
                return n.next(e ? e(l, p, d, f++) : p)
            }, function () {
                i = null, s()
            }))
        }, function () {
            o = !0, s()
        }))
    })
}

function Zy(t, e, r) {
    var n = Wo(t) || e || r ? {next: t, error: e, complete: r} : t;
    return n ? yu(function (i, a) {
        var o;
        (o = n.subscribe) === null || o === void 0 || o.call(n);
        var s = !0;
        i.subscribe(hu(a, function (l) {
            var f;
            (f = n.next) === null || f === void 0 || f.call(n, l), a.next(l)
        }, function () {
            var l;
            s = !1, (l = n.complete) === null || l === void 0 || l.call(n), a.complete()
        }, function (l) {
            var f;
            s = !1, (f = n.error) === null || f === void 0 || f.call(n, l), a.error(l)
        }, function () {
            var l, f;
            s && ((l = n.unsubscribe) === null || l === void 0 || l.call(n)), (f = n.finalize) === null || f === void 0 || f.call(n)
        }))
    }) : MS
}

const CWe = t => e => new ia(r => {
    const n = [];
    let i = !0;
    const a = () => {
        n.splice(0, n.length).forEach(l => r.next(l))
    }, o = e.subscribe({
        next: l => {
            if (!i) {
                r.next(l);
                return
            }
            n.push(l)
        }, error: l => r.error(l), complete: () => {
            a(), r.complete()
        }
    }), s = t.subscribe({
        next: l => {
            i = !l, l && a()
        }, error: l => r.error(l), complete: ZC
    });
    return () => {
        o.unsubscribe(), s.unsubscribe()
    }
});
var AWe = function () {
    var t = function (e, r) {
        return t = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (n, i) {
            n.__proto__ = i
        } || function (n, i) {
            for (var a in i) i.hasOwnProperty(a) && (n[a] = i[a])
        }, t(e, r)
    };
    return function (e, r) {
        t(e, r);

        function n() {
            this.constructor = e
        }

        e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n)
    }
}(), IWe = Object.prototype.hasOwnProperty;

function JW(t, e) {
    return IWe.call(t, e)
}

function eq(t) {
    if (Array.isArray(t)) {
        for (var e = new Array(t.length), r = 0; r < e.length; r++) e[r] = "" + r;
        return e
    }
    if (Object.keys) return Object.keys(t);
    var n = [];
    for (var i in t) JW(t, i) && n.push(i);
    return n
}

function Lf(t) {
    switch (typeof t) {
        case"object":
            return JSON.parse(JSON.stringify(t));
        case"undefined":
            return null;
        default:
            return t
    }
}

function tq(t) {
    for (var e = 0, r = t.length, n; e < r;) {
        if (n = t.charCodeAt(e), n >= 48 && n <= 57) {
            e++;
            continue
        }
        return !1
    }
    return !0
}

function ew(t) {
    return t.indexOf("/") === -1 && t.indexOf("~") === -1 ? t : t.replace(/~/g, "~0").replace(/\//g, "~1")
}

function Oye(t) {
    return t.replace(/~1/g, "/").replace(/~0/g, "~")
}

function rq(t) {
    if (t === void 0) return !0;
    if (t) {
        if (Array.isArray(t)) {
            for (var e = 0, r = t.length; e < r; e++) if (rq(t[e])) return !0
        } else if (typeof t == "object") {
            for (var n = eq(t), i = n.length, a = 0; a < i; a++) if (rq(t[n[a]])) return !0
        }
    }
    return !1
}

function xse(t, e) {
    var r = [t];
    for (var n in e) {
        var i = typeof e[n] == "object" ? JSON.stringify(e[n], null, 2) : e[n];
        typeof i < "u" && r.push(n + ": " + i)
    }
    return r.join(`
`)
}

var Pye = function (t) {
    AWe(e, t);

    function e(r, n, i, a, o) {
        var s = this.constructor, l = t.call(this, xse(r, {name: n, index: i, operation: a, tree: o})) || this;
        return l.name = n, l.index = i, l.operation = a, l.tree = o, Object.setPrototypeOf(l, s.prototype), l.message = xse(r, {
            name: n,
            index: i,
            operation: a,
            tree: o
        }), l
    }

    return e
}(Error), Eo = Pye, kWe = Lf, xx = {
    add: function (t, e, r) {
        return t[e] = this.value, {newDocument: r}
    }, remove: function (t, e, r) {
        var n = t[e];
        return delete t[e], {newDocument: r, removed: n}
    }, replace: function (t, e, r) {
        var n = t[e];
        return t[e] = this.value, {newDocument: r, removed: n}
    }, move: function (t, e, r) {
        var n = VM(r, this.path);
        n && (n = Lf(n));
        var i = Fw(r, {op: "remove", path: this.from}).removed;
        return Fw(r, {op: "add", path: this.path, value: i}), {newDocument: r, removed: n}
    }, copy: function (t, e, r) {
        var n = VM(r, this.from);
        return Fw(r, {op: "add", path: this.path, value: Lf(n)}), {newDocument: r}
    }, test: function (t, e, r) {
        return {newDocument: r, test: eA(t[e], this.value)}
    }, _get: function (t, e, r) {
        return this.value = t[e], {newDocument: r}
    }
}, RWe = {
    add: function (t, e, r) {
        return tq(e) ? t.splice(e, 0, this.value) : t[e] = this.value, {newDocument: r, index: e}
    }, remove: function (t, e, r) {
        var n = t.splice(e, 1);
        return {newDocument: r, removed: n[0]}
    }, replace: function (t, e, r) {
        var n = t[e];
        return t[e] = this.value, {newDocument: r, removed: n}
    }, move: xx.move, copy: xx.copy, test: xx.test, _get: xx._get
};

function VM(t, e) {
    if (e == "") return t;
    var r = {op: "_get", path: e};
    return Fw(t, r), r.value
}

function Fw(t, e, r, n, i, a) {
    if (r === void 0 && (r = !1), n === void 0 && (n = !0), i === void 0 && (i = !0), a === void 0 && (a = 0), r && (typeof r == "function" ? r(e, 0, t, e.path) : HM(e, 0)), e.path === "") {
        var o = {newDocument: t};
        if (e.op === "add") return o.newDocument = e.value, o;
        if (e.op === "replace") return o.newDocument = e.value, o.removed = t, o;
        if (e.op === "move" || e.op === "copy") return o.newDocument = VM(t, e.from), e.op === "move" && (o.removed = t), o;
        if (e.op === "test") {
            if (o.test = eA(t, e.value), o.test === !1) throw new Eo("Test operation failed", "TEST_OPERATION_FAILED", a, e, t);
            return o.newDocument = t, o
        } else {
            if (e.op === "remove") return o.removed = t, o.newDocument = null, o;
            if (e.op === "_get") return e.value = t, o;
            if (r) throw new Eo("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", a, e, t);
            return o
        }
    } else {
        n || (t = Lf(t));
        var s = e.path || "", l = s.split("/"), f = t, d = 1, p = l.length, g = void 0, b = void 0, S = void 0;
        for (typeof r == "function" ? S = r : S = HM; ;) {
            if (b = l[d], b && b.indexOf("~") != -1 && (b = Oye(b)), i && (b == "__proto__" || b == "prototype" && d > 0 && l[d - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
            if (r && g === void 0 && (f[b] === void 0 ? g = l.slice(0, d).join("/") : d == p - 1 && (g = e.path), g !== void 0 && S(e, 0, t, g)), d++, Array.isArray(f)) {
                if (b === "-") b = f.length; else {
                    if (r && !tq(b)) throw new Eo("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", a, e, t);
                    tq(b) && (b = ~~b)
                }
                if (d >= p) {
                    if (r && e.op === "add" && b > f.length) throw new Eo("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", a, e, t);
                    var o = RWe[e.op].call(e, f, b, t);
                    if (o.test === !1) throw new Eo("Test operation failed", "TEST_OPERATION_FAILED", a, e, t);
                    return o
                }
            } else if (d >= p) {
                var o = xx[e.op].call(e, f, b, t);
                if (o.test === !1) throw new Eo("Test operation failed", "TEST_OPERATION_FAILED", a, e, t);
                return o
            }
            if (f = f[b], r && d < p && (!f || typeof f != "object")) throw new Eo("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", a, e, t)
        }
    }
}

function kX(t, e, r, n, i) {
    if (n === void 0 && (n = !0), i === void 0 && (i = !0), r && !Array.isArray(e)) throw new Eo("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    n || (t = Lf(t));
    for (var a = new Array(e.length), o = 0, s = e.length; o < s; o++) a[o] = Fw(t, e[o], r, !0, i, o), t = a[o].newDocument;
    return a.newDocument = t, a
}

function DWe(t, e, r) {
    var n = Fw(t, e);
    if (n.test === !1) throw new Eo("Test operation failed", "TEST_OPERATION_FAILED", r, e, t);
    return n.newDocument
}

function HM(t, e, r, n) {
    if (typeof t != "object" || t === null || Array.isArray(t)) throw new Eo("Operation is not an object", "OPERATION_NOT_AN_OBJECT", e, t, r);
    if (xx[t.op]) {
        if (typeof t.path != "string") throw new Eo("Operation `path` property is not a string", "OPERATION_PATH_INVALID", e, t, r);
        if (t.path.indexOf("/") !== 0 && t.path.length > 0) throw new Eo('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", e, t, r);
        if ((t.op === "move" || t.op === "copy") && typeof t.from != "string") throw new Eo("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", e, t, r);
        if ((t.op === "add" || t.op === "replace" || t.op === "test") && t.value === void 0) throw new Eo("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", e, t, r);
        if ((t.op === "add" || t.op === "replace" || t.op === "test") && rq(t.value)) throw new Eo("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", e, t, r);
        if (r) {
            if (t.op == "add") {
                var i = t.path.split("/").length, a = n.split("/").length;
                if (i !== a + 1 && i !== a) throw new Eo("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", e, t, r)
            } else if (t.op === "replace" || t.op === "remove" || t.op === "_get") {
                if (t.path !== n) throw new Eo("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", e, t, r)
            } else if (t.op === "move" || t.op === "copy") {
                var o = {op: "_get", path: t.from, value: void 0}, s = Nye([o], r);
                if (s && s.name === "OPERATION_PATH_UNRESOLVABLE") throw new Eo("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", e, t, r)
            }
        }
    } else throw new Eo("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", e, t, r)
}

function Nye(t, e, r) {
    try {
        if (!Array.isArray(t)) throw new Eo("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
        if (e) kX(Lf(e), Lf(t), r || !0); else {
            r = r || HM;
            for (var n = 0; n < t.length; n++) r(t[n], n, e, void 0)
        }
    } catch (i) {
        if (i instanceof Eo) return i;
        throw i
    }
}

function eA(t, e) {
    if (t === e) return !0;
    if (t && e && typeof t == "object" && typeof e == "object") {
        var r = Array.isArray(t), n = Array.isArray(e), i, a, o;
        if (r && n) {
            if (a = t.length, a != e.length) return !1;
            for (i = a; i-- !== 0;) if (!eA(t[i], e[i])) return !1;
            return !0
        }
        if (r != n) return !1;
        var s = Object.keys(t);
        if (a = s.length, a !== Object.keys(e).length) return !1;
        for (i = a; i-- !== 0;) if (!e.hasOwnProperty(s[i])) return !1;
        for (i = a; i-- !== 0;) if (o = s[i], !eA(t[o], e[o])) return !1;
        return !0
    }
    return t !== t && e !== e
}

const MWe = Object.freeze(Object.defineProperty({
    __proto__: null,
    JsonPatchError: Eo,
    _areEquals: eA,
    applyOperation: Fw,
    applyPatch: kX,
    applyReducer: DWe,
    deepClone: kWe,
    getValueByPointer: VM,
    validate: Nye,
    validator: HM
}, Symbol.toStringTag, {value: "Module"}));
var RX = new WeakMap, OWe = function () {
    function t(e) {
        this.observers = new Map, this.obj = e
    }

    return t
}(), PWe = function () {
    function t(e, r) {
        this.callback = e, this.observer = r
    }

    return t
}();

function NWe(t) {
    return RX.get(t)
}

function LWe(t, e) {
    return t.observers.get(e)
}

function BWe(t, e) {
    t.observers.delete(e.callback)
}

function $We(t, e) {
    e.unobserve()
}

function FWe(t, e) {
    var r = [], n, i = NWe(t);
    if (!i) i = new OWe(t), RX.set(t, i); else {
        var a = LWe(i, e);
        n = a && a.observer
    }
    if (n) return n;
    if (n = {}, i.value = Lf(t), e) {
        n.callback = e, n.next = null;
        var o = function () {
            nq(n)
        }, s = function () {
            clearTimeout(n.next), n.next = setTimeout(o)
        };
        typeof window < "u" && (window.addEventListener("mouseup", s), window.addEventListener("keyup", s), window.addEventListener("mousedown", s), window.addEventListener("keydown", s), window.addEventListener("change", s))
    }
    return n.patches = r, n.object = t, n.unobserve = function () {
        nq(n), clearTimeout(n.next), BWe(i, n), typeof window < "u" && (window.removeEventListener("mouseup", s), window.removeEventListener("keyup", s), window.removeEventListener("mousedown", s), window.removeEventListener("keydown", s), window.removeEventListener("change", s))
    }, i.observers.set(e, new PWe(e, n)), n
}

function nq(t, e) {
    e === void 0 && (e = !1);
    var r = RX.get(t.object);
    DX(r.value, t.object, t.patches, "", e), t.patches.length && kX(r.value, t.patches);
    var n = t.patches;
    return n.length > 0 && (t.patches = [], t.callback && t.callback(n)), n
}

function DX(t, e, r, n, i) {
    if (e !== t) {
        typeof e.toJSON == "function" && (e = e.toJSON());
        for (var a = eq(e), o = eq(t), s = !1, l = o.length - 1; l >= 0; l--) {
            var f = o[l], d = t[f];
            if (JW(e, f) && !(e[f] === void 0 && d !== void 0 && Array.isArray(e) === !1)) {
                var p = e[f];
                typeof d == "object" && d != null && typeof p == "object" && p != null && Array.isArray(d) === Array.isArray(p) ? DX(d, p, r, n + "/" + ew(f), i) : d !== p && (i && r.push({
                    op: "test",
                    path: n + "/" + ew(f),
                    value: Lf(d)
                }), r.push({op: "replace", path: n + "/" + ew(f), value: Lf(p)}))
            } else Array.isArray(t) === Array.isArray(e) ? (i && r.push({
                op: "test",
                path: n + "/" + ew(f),
                value: Lf(d)
            }), r.push({op: "remove", path: n + "/" + ew(f)}), s = !0) : (i && r.push({
                op: "test",
                path: n,
                value: t
            }), r.push({op: "replace", path: n, value: e}))
        }
        if (!(!s && a.length == o.length)) for (var l = 0; l < a.length; l++) {
            var f = a[l];
            !JW(t, f) && e[f] !== void 0 && r.push({op: "add", path: n + "/" + ew(f), value: Lf(e[f])})
        }
    }
}

function UWe(t, e, r) {
    r === void 0 && (r = !1);
    var n = [];
    return DX(t, e, n, "", r), n
}

const jWe = Object.freeze(Object.defineProperty({
    __proto__: null,
    compare: UWe,
    generate: nq,
    observe: FWe,
    unobserve: $We
}, Symbol.toStringTag, {value: "Module"})), zWe = Object.assign({}, MWe, jWe, {
    JsonPatchError: Pye,
    deepClone: Lf,
    escapePathComponent: ew,
    unescapePathComponent: Oye
});

function Fc(t) {
    for (var e = arguments.length, r = Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];
    if (Ve.env.NODE_ENV !== "production") {
        var i = XWe[t], a = i ? typeof i == "function" ? i.apply(null, r) : i : "unknown error nr: " + t;
        throw Error("[Immer] " + a)
    }
    throw Error("[Immer] minified error nr: " + t + (r.length ? " " + r.map(function (o) {
        return "'" + o + "'"
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
}

function k4(t) {
    return !!t && !!t[Hf]
}

function oS(t) {
    return !!t && (function (e) {
        if (!e || typeof e != "object") return !1;
        var r = Object.getPrototypeOf(e);
        if (r === null) return !0;
        var n = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
        return n === Object || typeof n == "function" && Function.toString.call(n) === QWe
    }(t) || Array.isArray(t) || !!t[Dse] || !!t.constructor[Dse] || MX(t) || OX(t))
}

function tA(t, e, r) {
    r === void 0 && (r = !1), NE(t) === 0 ? (r ? Object.keys : $X)(t).forEach(function (n) {
        r && typeof n == "symbol" || e(n, t[n], t)
    }) : t.forEach(function (n, i) {
        return e(i, n, t)
    })
}

function NE(t) {
    var e = t[Hf];
    return e ? e.i > 3 ? e.i - 4 : e.i : Array.isArray(t) ? 1 : MX(t) ? 2 : OX(t) ? 3 : 0
}

function iq(t, e) {
    return NE(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e)
}

function VWe(t, e) {
    return NE(t) === 2 ? t.get(e) : t[e]
}

function Lye(t, e, r) {
    var n = NE(t);
    n === 2 ? t.set(e, r) : n === 3 ? (t.delete(e), t.add(r)) : t[e] = r
}

function HWe(t, e) {
    return t === e ? t !== 0 || 1 / t == 1 / e : t != t && e != e
}

function MX(t) {
    return KWe && t instanceof Map
}

function OX(t) {
    return YWe && t instanceof Set
}

function tw(t) {
    return t.o || t.t
}

function PX(t) {
    if (Array.isArray(t)) return Array.prototype.slice.call(t);
    var e = ZWe(t);
    delete e[Hf];
    for (var r = $X(e), n = 0; n < r.length; n++) {
        var i = r[n], a = e[i];
        a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (e[i] = {
            configurable: !0,
            writable: !0,
            enumerable: a.enumerable,
            value: t[i]
        })
    }
    return Object.create(Object.getPrototypeOf(t), e)
}

function NX(t, e) {
    return e === void 0 && (e = !1), LX(t) || k4(t) || !oS(t) || (NE(t) > 1 && (t.set = t.add = t.clear = t.delete = WWe), Object.freeze(t), e && tA(t, function (r, n) {
        return NX(n, !0)
    }, !0)), t
}

function WWe() {
    Fc(2)
}

function LX(t) {
    return t == null || typeof t != "object" || Object.isFrozen(t)
}

function k0(t) {
    var e = JWe[t];
    return e || Fc(18, t), e
}

function Ese() {
    return Ve.env.NODE_ENV === "production" || R4 || Fc(0), R4
}

function jj(t, e) {
    e && (k0("Patches"), t.u = [], t.s = [], t.v = e)
}

function WM(t) {
    aq(t), t.p.forEach(qWe), t.p = null
}

function aq(t) {
    t === R4 && (R4 = t.l)
}

function Tse(t) {
    return R4 = {p: [], l: R4, h: t, m: !0, _: 0}
}

function qWe(t) {
    var e = t[Hf];
    e.i === 0 || e.i === 1 ? e.j() : e.O = !0
}

function zj(t, e) {
    e._ = e.p.length;
    var r = e.p[0], n = t !== void 0 && t !== r;
    return e.h.g || k0("ES5").S(e, t, n), n ? (r[Hf].P && (WM(e), Fc(4)), oS(t) && (t = qM(e, t), e.l || GM(e, t)), e.u && k0("Patches").M(r[Hf].t, t, e.u, e.s)) : t = qM(e, r, []), WM(e), e.u && e.v(e.u, e.s), t !== Bye ? t : void 0
}

function qM(t, e, r) {
    if (LX(e)) return e;
    var n = e[Hf];
    if (!n) return tA(e, function (a, o) {
        return Cse(t, n, e, a, o, r)
    }, !0), e;
    if (n.A !== t) return e;
    if (!n.P) return GM(t, n.t, !0), n.t;
    if (!n.I) {
        n.I = !0, n.A._--;
        var i = n.i === 4 || n.i === 5 ? n.o = PX(n.k) : n.o;
        tA(n.i === 3 ? new Set(i) : i, function (a, o) {
            return Cse(t, n, i, a, o, r)
        }), GM(t, i, !1), r && t.u && k0("Patches").R(n, r, t.u, t.s)
    }
    return n.o
}

function Cse(t, e, r, n, i, a) {
    if (Ve.env.NODE_ENV !== "production" && i === r && Fc(5), k4(i)) {
        var o = qM(t, i, a && e && e.i !== 3 && !iq(e.D, n) ? a.concat(n) : void 0);
        if (Lye(r, n, o), !k4(o)) return;
        t.m = !1
    }
    if (oS(i) && !LX(i)) {
        if (!t.h.F && t._ < 1) return;
        qM(t, i), e && e.A.l || GM(t, i)
    }
}

function GM(t, e, r) {
    r === void 0 && (r = !1), t.h.F && t.m && NX(e, r)
}

function Vj(t, e) {
    var r = t[Hf];
    return (r ? tw(r) : t)[e]
}

function Ase(t, e) {
    if (e in t) for (var r = Object.getPrototypeOf(t); r;) {
        var n = Object.getOwnPropertyDescriptor(r, e);
        if (n) return n;
        r = Object.getPrototypeOf(r)
    }
}

function oq(t) {
    t.P || (t.P = !0, t.l && oq(t.l))
}

function Hj(t) {
    t.o || (t.o = PX(t.t))
}

function sq(t, e, r) {
    var n = MX(e) ? k0("MapSet").N(e, r) : OX(e) ? k0("MapSet").T(e, r) : t.g ? function (i, a) {
        var o = Array.isArray(i),
            s = {i: o ? 1 : 0, A: a ? a.A : Ese(), P: !1, I: !1, D: {}, l: a, t: i, k: null, o: null, j: null, C: !1},
            l = s, f = cq;
        o && (l = [s], f = _T);
        var d = Proxy.revocable(l, f), p = d.revoke, g = d.proxy;
        return s.k = g, s.j = p, g
    }(e, r) : k0("ES5").J(e, r);
    return (r ? r.A : Ese()).p.push(n), n
}

function GWe(t) {
    return k4(t) || Fc(22, t), function e(r) {
        if (!oS(r)) return r;
        var n, i = r[Hf], a = NE(r);
        if (i) {
            if (!i.P && (i.i < 4 || !k0("ES5").K(i))) return i.t;
            i.I = !0, n = Ise(r, a), i.I = !1
        } else n = Ise(r, a);
        return tA(n, function (o, s) {
            i && VWe(i.t, o) === s || Lye(n, o, e(s))
        }), a === 3 ? new Set(n) : n
    }(t)
}

function Ise(t, e) {
    switch (e) {
        case 2:
            return new Map(t);
        case 3:
            return Array.from(t)
    }
    return PX(t)
}

var kse, R4, BX = typeof Symbol < "u" && typeof Symbol("x") == "symbol", KWe = typeof Map < "u", YWe = typeof Set < "u",
    Rse = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
    Bye = BX ? Symbol.for("immer-nothing") : ((kse = {})["immer-nothing"] = !0, kse),
    Dse = BX ? Symbol.for("immer-draftable") : "__$immer_draftable",
    Hf = BX ? Symbol.for("immer-state") : "__$immer_state", XWe = {
        0: "Illegal state",
        1: "Immer drafts cannot have computed properties",
        2: "This object has been frozen and should not be mutated",
        3: function (t) {
            return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t
        },
        4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
        5: "Immer forbids circular references",
        6: "The first or second argument to `produce` must be a function",
        7: "The third argument to `produce` must be a function or undefined",
        8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
        9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
        10: "The given draft is already finalized",
        11: "Object.defineProperty() cannot be used on an Immer draft",
        12: "Object.setPrototypeOf() cannot be used on an Immer draft",
        13: "Immer only supports deleting array indices",
        14: "Immer only supports setting array indices and the 'length' property",
        15: function (t) {
            return "Cannot apply patch, path doesn't resolve: " + t
        },
        16: 'Sets cannot have "replace" patches.',
        17: function (t) {
            return "Unsupported patch operation: " + t
        },
        18: function (t) {
            return "The plugin for '" + t + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + t + "()` when initializing your application."
        },
        20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
        21: function (t) {
            return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + t + "'"
        },
        22: function (t) {
            return "'current' expects a draft, got: " + t
        },
        23: function (t) {
            return "'original' expects a draft, got: " + t
        },
        24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    }, QWe = "" + Object.prototype.constructor,
    $X = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function (t) {
        return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
    } : Object.getOwnPropertyNames, ZWe = Object.getOwnPropertyDescriptors || function (t) {
        var e = {};
        return $X(t).forEach(function (r) {
            e[r] = Object.getOwnPropertyDescriptor(t, r)
        }), e
    }, JWe = {}, cq = {
        get: function (t, e) {
            if (e === Hf) return t;
            var r = tw(t);
            if (!iq(r, e)) return function (i, a, o) {
                var s, l = Ase(a, o);
                return l ? "value" in l ? l.value : (s = l.get) === null || s === void 0 ? void 0 : s.call(i.k) : void 0
            }(t, r, e);
            var n = r[e];
            return t.I || !oS(n) ? n : n === Vj(t.t, e) ? (Hj(t), t.o[e] = sq(t.A.h, n, t)) : n
        }, has: function (t, e) {
            return e in tw(t)
        }, ownKeys: function (t) {
            return Reflect.ownKeys(tw(t))
        }, set: function (t, e, r) {
            var n = Ase(tw(t), e);
            if (n != null && n.set) return n.set.call(t.k, r), !0;
            if (!t.P) {
                var i = Vj(tw(t), e), a = i == null ? void 0 : i[Hf];
                if (a && a.t === r) return t.o[e] = r, t.D[e] = !1, !0;
                if (HWe(r, i) && (r !== void 0 || iq(t.t, e))) return !0;
                Hj(t), oq(t)
            }
            return t.o[e] === r && typeof r != "number" && (r !== void 0 || e in t.o) || (t.o[e] = r, t.D[e] = !0, !0)
        }, deleteProperty: function (t, e) {
            return Vj(t.t, e) !== void 0 || e in t.t ? (t.D[e] = !1, Hj(t), oq(t)) : delete t.D[e], t.o && delete t.o[e], !0
        }, getOwnPropertyDescriptor: function (t, e) {
            var r = tw(t), n = Reflect.getOwnPropertyDescriptor(r, e);
            return n && {writable: !0, configurable: t.i !== 1 || e !== "length", enumerable: n.enumerable, value: r[e]}
        }, defineProperty: function () {
            Fc(11)
        }, getPrototypeOf: function (t) {
            return Object.getPrototypeOf(t.t)
        }, setPrototypeOf: function () {
            Fc(12)
        }
    }, _T = {};
tA(cq, function (t, e) {
    _T[t] = function () {
        return arguments[0] = arguments[0][0], e.apply(this, arguments)
    }
}), _T.deleteProperty = function (t, e) {
    return Ve.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && Fc(13), _T.set.call(this, t, e, void 0)
}, _T.set = function (t, e, r) {
    return Ve.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && Fc(14), cq.set.call(this, t[0], e, r, t[0])
};
var eqe = function () {
    function t(r) {
        var n = this;
        this.g = Rse, this.F = !0, this.produce = function (i, a, o) {
            if (typeof i == "function" && typeof a != "function") {
                var s = a;
                a = i;
                var l = n;
                return function (T) {
                    var I = this;
                    T === void 0 && (T = s);
                    for (var N = arguments.length, P = Array(N > 1 ? N - 1 : 0), F = 1; F < N; F++) P[F - 1] = arguments[F];
                    return l.produce(T, function (V) {
                        var Y;
                        return (Y = a).call.apply(Y, [I, V].concat(P))
                    })
                }
            }
            var f;
            if (typeof a != "function" && Fc(6), o !== void 0 && typeof o != "function" && Fc(7), oS(i)) {
                var d = Tse(n), p = sq(n, i, void 0), g = !0;
                try {
                    f = a(p), g = !1
                } finally {
                    g ? WM(d) : aq(d)
                }
                return typeof Promise < "u" && f instanceof Promise ? f.then(function (T) {
                    return jj(d, o), zj(T, d)
                }, function (T) {
                    throw WM(d), T
                }) : (jj(d, o), zj(f, d))
            }
            if (!i || typeof i != "object") {
                if ((f = a(i)) === void 0 && (f = i), f === Bye && (f = void 0), n.F && NX(f, !0), o) {
                    var b = [], S = [];
                    k0("Patches").M(i, f, b, S), o(b, S)
                }
                return f
            }
            Fc(21, i)
        }, this.produceWithPatches = function (i, a) {
            if (typeof i == "function") return function (f) {
                for (var d = arguments.length, p = Array(d > 1 ? d - 1 : 0), g = 1; g < d; g++) p[g - 1] = arguments[g];
                return n.produceWithPatches(f, function (b) {
                    return i.apply(void 0, [b].concat(p))
                })
            };
            var o, s, l = n.produce(i, a, function (f, d) {
                o = f, s = d
            });
            return typeof Promise < "u" && l instanceof Promise ? l.then(function (f) {
                return [f, o, s]
            }) : [l, o, s]
        }, typeof (r == null ? void 0 : r.useProxies) == "boolean" && this.setUseProxies(r.useProxies), typeof (r == null ? void 0 : r.autoFreeze) == "boolean" && this.setAutoFreeze(r.autoFreeze)
    }

    var e = t.prototype;
    return e.createDraft = function (r) {
        oS(r) || Fc(8), k4(r) && (r = GWe(r));
        var n = Tse(this), i = sq(this, r, void 0);
        return i[Hf].C = !0, aq(n), i
    }, e.finishDraft = function (r, n) {
        var i = r && r[Hf];
        Ve.env.NODE_ENV !== "production" && (i && i.C || Fc(9), i.I && Fc(10));
        var a = i.A;
        return jj(a, n), zj(void 0, a)
    }, e.setAutoFreeze = function (r) {
        this.F = r
    }, e.setUseProxies = function (r) {
        r && !Rse && Fc(20), this.g = r
    }, e.applyPatches = function (r, n) {
        var i;
        for (i = n.length - 1; i >= 0; i--) {
            var a = n[i];
            if (a.path.length === 0 && a.op === "replace") {
                r = a.value;
                break
            }
        }
        i > -1 && (n = n.slice(i + 1));
        var o = k0("Patches").$;
        return k4(r) ? o(r, n) : this.produce(r, function (s) {
            return o(s, n)
        })
    }, t
}(), Wf = new eqe, $ye = Wf.produce;
Wf.produceWithPatches.bind(Wf);
Wf.setAutoFreeze.bind(Wf);
Wf.setUseProxies.bind(Wf);
Wf.applyPatches.bind(Wf);
Wf.createDraft.bind(Wf);
Wf.finishDraft.bind(Wf);

class tqe {
    constructor(e) {
        this.selfOptions = e || {}, this.pipes = {}
    }

    options(e) {
        return e && (this.selfOptions = e), this.selfOptions
    }

    pipe(e, r) {
        let n = r;
        if (typeof e == "string") {
            if (typeof n > "u") return this.pipes[e];
            this.pipes[e] = n
        }
        if (e && e.name) {
            if (n = e, n.processor === this) return n;
            this.pipes[n.name] = n
        }
        return n.processor = this, n
    }

    process(e, r) {
        let n = e;
        n.options = this.options();
        let i = r || e.pipe || "default", a;
        for (; i;) typeof n.nextAfterChildren < "u" && (n.next = n.nextAfterChildren, n.nextAfterChildren = null), typeof i == "string" && (i = this.pipe(i)), i.process(n), a = i, i = null, n && n.next && (n = n.next, i = n.pipe || a);
        return n.hasResult ? n.result : void 0
    }
}

class Wj {
    constructor(e) {
        this.name = e, this.filters = []
    }

    process(e) {
        if (!this.processor) throw new Error("add this pipe to a processor before using it");
        const r = this.debug, n = this.filters.length, i = e;
        for (let a = 0; a < n; a++) {
            const o = this.filters[a];
            if (r && this.log(`filter: ${o.filterName}`), o(i), typeof i == "object" && i.exiting) {
                i.exiting = !1;
                break
            }
        }
        !i.next && this.resultCheck && this.resultCheck(i)
    }

    log(e) {
        console.log(`[jsondiffpatch] ${this.name} pipe, ${e}`)
    }

    append(...e) {
        return this.filters.push(...e), this
    }

    prepend(...e) {
        return this.filters.unshift(...e), this
    }

    indexOf(e) {
        if (!e) throw new Error("a filter name is required");
        for (let r = 0; r < this.filters.length; r++) if (this.filters[r].filterName === e) return r;
        throw new Error(`filter not found: ${e}`)
    }

    list() {
        return this.filters.map(e => e.filterName)
    }

    after(e, ...r) {
        const n = this.indexOf(e);
        return this.filters.splice(n + 1, 0, ...r), this
    }

    before(e, ...r) {
        const n = this.indexOf(e);
        return this.filters.splice(n, 0, ...r), this
    }

    replace(e, ...r) {
        const n = this.indexOf(e);
        return this.filters.splice(n, 1, ...r), this
    }

    remove(e) {
        const r = this.indexOf(e);
        return this.filters.splice(r, 1), this
    }

    clear() {
        return this.filters.length = 0, this
    }

    shouldHaveResult(e) {
        if (e === !1) {
            this.resultCheck = null;
            return
        }
        if (!this.resultCheck) return this.resultCheck = r => {
            if (!r.hasResult) {
                console.log(r);
                const n = new Error(`${this.name} failed`);
                throw n.noResult = !0, n
            }
        }, this
    }
}

let FX = class {
    setResult(e) {
        return this.result = e, this.hasResult = !0, this
    }

    exit() {
        return this.exiting = !0, this
    }

    push(e, r) {
        return e.parent = this, typeof r < "u" && (e.childName = r), e.root = this.root || this, e.options = e.options || this.options, this.children ? (this.children[this.children.length - 1].next = e, this.children.push(e)) : (this.children = [e], this.nextAfterChildren = this.next || null, this.next = e), e.next = this, this
    }
};

function rqe(t) {
    const e = /^\/(.*)\/([gimyu]*)$/.exec(t.toString());
    return new RegExp(e[1], e[2])
}

function KM(t) {
    if (typeof t != "object") return t;
    if (t === null) return null;
    if (Array.isArray(t)) return t.map(KM);
    if (t instanceof Date) return new Date(t.getTime());
    if (t instanceof RegExp) return rqe(t);
    const e = {};
    for (const r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = KM(t[r]));
    return e
}

class Sw extends FX {
    constructor(e, r) {
        super(), this.left = e, this.right = r, this.pipe = "diff"
    }

    setResult(e) {
        if (this.options.cloneDiffValues && typeof e == "object") {
            const r = typeof this.options.cloneDiffValues == "function" ? this.options.cloneDiffValues : KM;
            typeof e[0] == "object" && (e[0] = r(e[0])), typeof e[1] == "object" && (e[1] = r(e[1]))
        }
        return super.setResult(e)
    }
}

class UX extends FX {
    constructor(e, r) {
        super(), this.left = e, this.delta = r, this.pipe = "patch"
    }
}

class jX extends FX {
    constructor(e) {
        super(), this.delta = e, this.pipe = "reverse"
    }
}

const Fye = function (e) {
    if (e.left === e.right) {
        e.setResult(void 0).exit();
        return
    }
    if (typeof e.left > "u") {
        if (typeof e.right == "function") throw new Error("functions are not supported");
        e.setResult([e.right]).exit();
        return
    }
    if (typeof e.right > "u") {
        e.setResult([e.left, 0, 0]).exit();
        return
    }
    if (typeof e.left == "function" || typeof e.right == "function") throw new Error("functions are not supported");
    if (e.leftType = e.left === null ? "null" : typeof e.left, e.rightType = e.right === null ? "null" : typeof e.right, e.leftType !== e.rightType) {
        e.setResult([e.left, e.right]).exit();
        return
    }
    if (e.leftType === "boolean" || e.leftType === "number") {
        e.setResult([e.left, e.right]).exit();
        return
    }
    if (e.leftType === "object" && (e.leftIsArray = Array.isArray(e.left)), e.rightType === "object" && (e.rightIsArray = Array.isArray(e.right)), e.leftIsArray !== e.rightIsArray) {
        e.setResult([e.left, e.right]).exit();
        return
    }
    e.left instanceof RegExp && (e.right instanceof RegExp ? e.setResult([e.left.toString(), e.right.toString()]).exit() : e.setResult([e.left, e.right]).exit())
};
Fye.filterName = "trivial";
const Uye = function (e) {
    if (typeof e.delta > "u") {
        e.setResult(e.left).exit();
        return
    }
    if (e.nested = !Array.isArray(e.delta), e.nested) return;
    const r = e.delta;
    if (r.length === 1) {
        e.setResult(r[0]).exit();
        return
    }
    if (r.length === 2) {
        if (e.left instanceof RegExp) {
            const n = /^\/(.*)\/([gimyu]+)$/.exec(r[1]);
            if (n) {
                e.setResult(new RegExp(n[1], n[2])).exit();
                return
            }
        }
        e.setResult(r[1]).exit();
        return
    }
    r.length === 3 && r[2] === 0 && e.setResult(void 0).exit()
};
Uye.filterName = "trivial";
const jye = function (e) {
    if (typeof e.delta > "u") {
        e.setResult(e.delta).exit();
        return
    }
    if (e.nested = !Array.isArray(e.delta), e.nested) return;
    const r = e.delta;
    if (r.length === 1) {
        e.setResult([r[0], 0, 0]).exit();
        return
    }
    if (r.length === 2) {
        e.setResult([r[1], r[0]]).exit();
        return
    }
    r.length === 3 && r[2] === 0 && e.setResult([r[0]]).exit()
};
jye.filterName = "trivial";
const zye = t => {
    if (!t || !t.children) return;
    const e = t.children.length;
    let r, n = t.result;
    for (let i = 0; i < e; i++) r = t.children[i], !(typeof r.result > "u") && (n = n || {}, n[r.childName] = r.result);
    n && t.leftIsArray && (n._t = "a"), t.setResult(n).exit()
};
zye.filterName = "collectChildren";
const Vye = t => {
    if (t.leftIsArray || t.leftType !== "object") return;
    const e = t.left, r = t.right;
    let n, i;
    const a = t.options.propertyFilter;
    for (n in e) Object.prototype.hasOwnProperty.call(e, n) && (a && !a(n, t) || (i = new Sw(e[n], r[n]), t.push(i, n)));
    for (n in r) Object.prototype.hasOwnProperty.call(r, n) && (a && !a(n, t) || typeof e[n] > "u" && (i = new Sw(void 0, r[n]), t.push(i, n)));
    if (!t.children || t.children.length === 0) {
        t.setResult(void 0).exit();
        return
    }
    t.exit()
};
Vye.filterName = "objects";
const Hye = function (e) {
    if (!e.nested) return;
    const r = e.delta;
    if (r._t) return;
    const n = r;
    let i, a;
    for (i in n) a = new UX(e.left[i], n[i]), e.push(a, i);
    e.exit()
};
Hye.filterName = "objects";
const Wye = function (e) {
    if (!e || !e.children || e.delta._t) return;
    const n = e.left, i = e.children.length;
    let a;
    for (let o = 0; o < i; o++) {
        a = e.children[o];
        const s = a.childName;
        Object.prototype.hasOwnProperty.call(e.left, s) && a.result === void 0 ? delete n[s] : n[s] !== a.result && (n[s] = a.result)
    }
    e.setResult(n).exit()
};
Wye.filterName = "collectChildren";
const qye = function (e) {
    if (!e.nested || e.delta._t) return;
    const n = e.delta;
    let i, a;
    for (i in n) a = new jX(n[i]), e.push(a, i);
    e.exit()
};
qye.filterName = "objects";
const Gye = t => {
    if (!t || !t.children || t.delta._t) return;
    const r = t.children.length;
    let n;
    const i = {};
    for (let a = 0; a < r; a++) {
        n = t.children[a];
        const o = n.childName;
        i[o] !== n.result && (i[o] = n.result)
    }
    t.setResult(i).exit()
};
Gye.filterName = "collectChildren";
const nqe = function (t, e, r, n) {
    return t[r] === e[n]
}, iqe = function (t, e, r, n) {
    const i = t.length, a = e.length;
    let o, s;
    const l = new Array(i + 1);
    for (o = 0; o < i + 1; o++) for (l[o] = new Array(a + 1), s = 0; s < a + 1; s++) l[o][s] = 0;
    for (l.match = r, o = 1; o < i + 1; o++) for (s = 1; s < a + 1; s++) r(t, e, o - 1, s - 1, n) ? l[o][s] = l[o - 1][s - 1] + 1 : l[o][s] = Math.max(l[o - 1][s], l[o][s - 1]);
    return l
}, aqe = function (t, e, r, n) {
    let i = e.length, a = r.length;
    const o = {sequence: [], indices1: [], indices2: []};
    for (; i !== 0 && a !== 0;) if (t.match(e, r, i - 1, a - 1, n)) o.sequence.unshift(e[i - 1]), o.indices1.unshift(i - 1), o.indices2.unshift(a - 1), --i, --a; else {
        const l = t[i][a - 1], f = t[i - 1][a];
        l > f ? --a : --i
    }
    return o
}, oqe = function (t, e, r, n) {
    const i = n || {}, a = iqe(t, e, r || nqe, i);
    return aqe(a, t, e, i)
}, sqe = {get: oqe}, D4 = 3;

function cqe(t, e, r, n) {
    for (let i = 0; i < r; i++) {
        const a = t[i];
        for (let o = 0; o < n; o++) {
            const s = e[o];
            if (i !== o && a === s) return !0
        }
    }
}

function Z9(t, e, r, n, i) {
    const a = t[r], o = e[n];
    if (a === o) return !0;
    if (typeof a != "object" || typeof o != "object") return !1;
    const s = i.objectHash;
    if (!s) return i.matchByPosition && r === n;
    i.hashCache1 = i.hashCache1 || [];
    let l = i.hashCache1[r];
    if (typeof l > "u" && (i.hashCache1[r] = l = s(a, r)), typeof l > "u") return !1;
    i.hashCache2 = i.hashCache2 || [];
    let f = i.hashCache2[n];
    return typeof f > "u" && (i.hashCache2[n] = f = s(o, n)), typeof f > "u" ? !1 : l === f
}

const Kye = function (e) {
    if (!e.leftIsArray) return;
    const r = {objectHash: e.options && e.options.objectHash, matchByPosition: e.options && e.options.matchByPosition};
    let n = 0, i = 0, a, o, s;
    const l = e.left, f = e.right, d = l.length, p = f.length;
    let g;
    for (d > 0 && p > 0 && !r.objectHash && typeof r.matchByPosition != "boolean" && (r.matchByPosition = !cqe(l, f, d, p)); n < d && n < p && Z9(l, f, n, n, r);) a = n, g = new Sw(l[a], f[a]), e.push(g, a), n++;
    for (; i + n < d && i + n < p && Z9(l, f, d - 1 - i, p - 1 - i, r);) o = d - 1 - i, s = p - 1 - i, g = new Sw(l[o], f[s]), e.push(g, s), i++;
    let b;
    if (n + i === d) {
        if (d === p) {
            e.setResult(void 0).exit();
            return
        }
        for (b = b || {_t: "a"}, a = n; a < p - i; a++) b[a] = [f[a]];
        e.setResult(b).exit();
        return
    }
    if (n + i === p) {
        for (b = b || {_t: "a"}, a = n; a < d - i; a++) b[`_${a}`] = [l[a], 0, 0];
        e.setResult(b).exit();
        return
    }
    delete r.hashCache1, delete r.hashCache2;
    const S = l.slice(n, d - i), T = f.slice(n, p - i), I = sqe.get(S, T, Z9, r), N = [];
    for (b = b || {_t: "a"}, a = n; a < d - i; a++) I.indices1.indexOf(a - n) < 0 && (b[`_${a}`] = [l[a], 0, 0], N.push(a));
    let P = !0;
    e.options && e.options.arrays && e.options.arrays.detectMove === !1 && (P = !1);
    let F = !1;
    e.options && e.options.arrays && e.options.arrays.includeValueOnMove && (F = !0);
    const V = N.length;
    for (a = n; a < p - i; a++) {
        const Y = I.indices2.indexOf(a - n);
        if (Y < 0) {
            let ee = !1;
            if (P && V > 0) {
                for (let oe = 0; oe < V; oe++) if (o = N[oe], Z9(S, T, o - n, a - n, r)) {
                    b[`_${o}`].splice(1, 2, a, D4), F || (b[`_${o}`][0] = ""), s = a, g = new Sw(l[o], f[s]), e.push(g, s), N.splice(oe, 1), ee = !0;
                    break
                }
            }
            ee || (b[a] = [f[a]])
        } else o = I.indices1[Y] + n, s = I.indices2[Y] + n, g = new Sw(l[o], f[s]), e.push(g, s)
    }
    e.setResult(b).exit()
};
Kye.filterName = "arrays";
const Mse = {
    numerically(t, e) {
        return t - e
    }, numericallyBy(t) {
        return (e, r) => e[t] - r[t]
    }
}, Yye = function (e) {
    if (!e.nested) return;
    const r = e.delta;
    if (r._t !== "a") return;
    let n, i;
    const a = r, o = e.left;
    let s = [], l = [];
    const f = [];
    for (n in a) if (n !== "_t") if (n[0] === "_") {
        const b = n;
        if (a[b][2] === 0 || a[b][2] === D4) s.push(parseInt(n.slice(1), 10)); else throw new Error(`only removal or move can be applied at original array indices, invalid diff type: ${a[b][2]}`)
    } else {
        const b = n;
        a[b].length === 1 ? l.push({index: parseInt(b, 10), value: a[b][0]}) : f.push({
            index: parseInt(b, 10),
            delta: a[b]
        })
    }
    for (s = s.sort(Mse.numerically), n = s.length - 1; n >= 0; n--) {
        i = s[n];
        const b = a[`_${i}`], S = o.splice(i, 1)[0];
        b[2] === D4 && l.push({index: b[1], value: S})
    }
    l = l.sort(Mse.numericallyBy("index"));
    const d = l.length;
    for (n = 0; n < d; n++) {
        const b = l[n];
        o.splice(b.index, 0, b.value)
    }
    const p = f.length;
    let g;
    if (p > 0) for (n = 0; n < p; n++) {
        const b = f[n];
        g = new UX(o[b.index], b.delta), e.push(g, b.index)
    }
    if (!e.children) {
        e.setResult(o).exit();
        return
    }
    e.exit()
};
Yye.filterName = "arrays";
const Xye = function (e) {
    if (!e || !e.children || e.delta._t !== "a") return;
    const n = e.left, i = e.children.length;
    let a;
    for (let o = 0; o < i; o++) {
        a = e.children[o];
        const s = a.childName;
        n[s] = a.result
    }
    e.setResult(n).exit()
};
Xye.filterName = "arraysCollectChildren";
const Qye = function (e) {
    if (!e.nested) {
        const o = e.delta;
        if (o[2] === D4) {
            const s = o;
            e.newName = `_${s[1]}`, e.setResult([s[0], parseInt(e.childName.substring(1), 10), D4]).exit()
        }
        return
    }
    const r = e.delta;
    if (r._t !== "a") return;
    const n = r;
    let i, a;
    for (i in n) i !== "_t" && (a = new jX(n[i]), e.push(a, i));
    e.exit()
};
Qye.filterName = "arrays";
const lqe = (t, e, r) => {
    if (typeof e == "string" && e[0] === "_") return parseInt(e.substring(1), 10);
    if (Array.isArray(r) && r[2] === 0) return `_${e}`;
    let n = +e;
    for (const i in t) {
        const a = t[i];
        if (Array.isArray(a)) if (a[2] === D4) {
            const o = parseInt(i.substring(1), 10), s = a[1];
            if (s === +e) return o;
            o <= n && s > n ? n++ : o >= n && s < n && n--
        } else a[2] === 0 ? parseInt(i.substring(1), 10) <= n && n++ : a.length === 1 && parseInt(i, 10) <= n && n--
    }
    return n
}, Zye = t => {
    if (!t || !t.children) return;
    const e = t.delta;
    if (e._t !== "a") return;
    const r = e, n = t.children.length;
    let i;
    const a = {_t: "a"};
    for (let o = 0; o < n; o++) {
        i = t.children[o];
        let s = i.newName;
        typeof s > "u" && (s = lqe(r, i.childName, i.result)), a[s] !== i.result && (a[s] = i.result)
    }
    t.setResult(a).exit()
};
Zye.filterName = "arraysCollectChildren";
const Jye = function (e) {
    e.left instanceof Date ? (e.right instanceof Date ? e.left.getTime() !== e.right.getTime() ? e.setResult([e.left, e.right]) : e.setResult(void 0) : e.setResult([e.left, e.right]), e.exit()) : e.right instanceof Date && e.setResult([e.left, e.right]).exit()
};
Jye.filterName = "dates";
const YM = 2, uqe = 60;
let qj = null;

function e1e(t, e) {
    var r;
    if (!qj) {
        let n;
        if (!((r = t == null ? void 0 : t.textDiff) === null || r === void 0) && r.diffMatchPatch) n = new t.textDiff.diffMatchPatch; else {
            if (!e) return null;
            const i = new Error("The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.");
            throw i.diff_match_patch_not_found = !0, i
        }
        qj = {
            diff: function (i, a) {
                return n.patch_toText(n.patch_make(i, a))
            }, patch: function (i, a) {
                const o = n.patch_apply(n.patch_fromText(a), i);
                for (let s = 0; s < o[1].length; s++) if (!o[1][s]) {
                    const l = new Error("text patch failed");
                    l.textPatchFailed = !0
                }
                return o[0]
            }
        }
    }
    return qj
}

const t1e = function (e) {
    if (e.leftType !== "string") return;
    const r = e.left, n = e.right, i = e.options && e.options.textDiff && e.options.textDiff.minLength || uqe;
    if (r.length < i || n.length < i) {
        e.setResult([r, n]).exit();
        return
    }
    const a = e1e(e.options);
    if (!a) {
        e.setResult([r, n]).exit();
        return
    }
    const o = a.diff;
    e.setResult([o(r, n), 0, YM]).exit()
};
t1e.filterName = "texts";
const r1e = function (e) {
    if (e.nested) return;
    const r = e.delta;
    if (r[2] !== YM) return;
    const n = r, i = e1e(e.options, !0).patch;
    e.setResult(i(e.left, n[0])).exit()
};
r1e.filterName = "texts";
const fqe = function (t) {
    let e, r, n, i, a = null;
    const o = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
    let s;
    const l = t.split(`
`);
    for (e = 0, r = l.length; e < r; e++) {
        n = l[e];
        const f = n.slice(0, 1);
        f === "@" ? (a = o.exec(n), s = e, l[s] = "@@ -" + a[3] + "," + a[4] + " +" + a[1] + "," + a[2] + " @@") : f === "+" ? (l[e] = "-" + l[e].slice(1), l[e - 1].slice(0, 1) === "+" && (i = l[e], l[e] = l[e - 1], l[e - 1] = i)) : f === "-" && (l[e] = "+" + l[e].slice(1))
    }
    return l.join(`
`)
}, n1e = function (e) {
    if (e.nested) return;
    const r = e.delta;
    if (r[2] !== YM) return;
    const n = r;
    e.setResult([fqe(n[0]), 0, YM]).exit()
};
n1e.filterName = "texts";

class i1e {
    constructor(e) {
        this.processor = new tqe(e), this.processor.pipe(new Wj("diff").append(zye, Fye, Jye, t1e, Vye, Kye).shouldHaveResult()), this.processor.pipe(new Wj("patch").append(Wye, Xye, Uye, r1e, Hye, Yye).shouldHaveResult()), this.processor.pipe(new Wj("reverse").append(Gye, Zye, jye, n1e, qye, Qye).shouldHaveResult())
    }

    options(e) {
        return this.processor.options(e)
    }

    diff(e, r) {
        return this.processor.process(new Sw(e, r))
    }

    patch(e, r) {
        return this.processor.process(new UX(e, r))
    }

    reverse(e) {
        return this.processor.process(new jX(e))
    }

    unpatch(e, r) {
        return this.patch(e, this.reverse(r))
    }

    clone(e) {
        return KM(e)
    }
}

let Yx;

function a1e(t, e) {
    return Yx || (Yx = new i1e), Yx.diff(t, e)
}

function dqe(t, e) {
    return Yx || (Yx = new i1e), Yx.patch(t, e)
}

const {applyPatch: hqe, compare: o1e} = zWe, s1e = (t, e) => $ye(r => {
    dqe(r, e)
})(t), rJt = () => t => {
    let e;
    return t.pipe(zn(r => r && (e ? (e = s1e(e, a1e(e, r)), e) : (e = r, r))), PE())
}, c1e = (t, e) => $ye(r => {
    hqe(r, e.slice(), !1, !0)
})(t), nJt = (t, e) => s1e(t, a1e(t, e)), iJt = (t, e) => c1e(t, o1e(t, e)), op = () => t => {
    let e;
    return t.pipe(zn(r => r && (e ? (e = c1e(e, o1e(e, r)), e) : (e = r, r))), PE())
}, Ly = t => new ia(e => {
    const r = new AbortController, n = Ju(t({signal: r.signal})).subscribe(e);
    return () => {
        n.unsubscribe(), r.abort()
    }
}), Xa = RHe(PE(), EWe({bufferSize: 1, refCount: !0}));

function pqe() {
    const t = new Mv;
    return [e => t.next(e), t]
}

class l1e extends SX {
    next(e) {
        e !== this.getValue() && super.next(e)
    }
}

var u1e = typeof Os == "object" && Os && Os.Object === Object && Os,
    mqe = typeof self == "object" && self && self.Object === Object && self,
    bp = u1e || mqe || Function("return this")(), Yd = bp.Symbol, f1e = Object.prototype, vqe = f1e.hasOwnProperty,
    gqe = f1e.toString, U5 = Yd ? Yd.toStringTag : void 0;

function yqe(t) {
    var e = vqe.call(t, U5), r = t[U5];
    try {
        t[U5] = void 0;
        var n = !0
    } catch {
    }
    var i = gqe.call(t);
    return n && (e ? t[U5] = r : delete t[U5]), i
}

var bqe = Object.prototype, wqe = bqe.toString;

function Sqe(t) {
    return wqe.call(t)
}

var _qe = "[object Null]", xqe = "[object Undefined]", Ose = Yd ? Yd.toStringTag : void 0;

function g1(t) {
    return t == null ? t === void 0 ? xqe : _qe : Ose && Ose in Object(t) ? yqe(t) : Sqe(t)
}

function dp(t) {
    return t != null && typeof t == "object"
}

var Eqe = "[object Symbol]";

function M4(t) {
    return typeof t == "symbol" || dp(t) && g1(t) == Eqe
}

function QT(t, e) {
    for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n;) i[r] = e(t[r], r, t);
    return i
}

var Rl = Array.isArray, Tqe = 1 / 0, Pse = Yd ? Yd.prototype : void 0, Nse = Pse ? Pse.toString : void 0;

function XM(t) {
    if (typeof t == "string") return t;
    if (Rl(t)) return QT(t, XM) + "";
    if (M4(t)) return Nse ? Nse.call(t) : "";
    var e = t + "";
    return e == "0" && 1 / t == -Tqe ? "-0" : e
}

var Cqe = /\s/;

function Aqe(t) {
    for (var e = t.length; e-- && Cqe.test(t.charAt(e));) ;
    return e
}

var Iqe = /^\s+/;

function kqe(t) {
    return t && t.slice(0, Aqe(t) + 1).replace(Iqe, "")
}

function pu(t) {
    var e = typeof t;
    return t != null && (e == "object" || e == "function")
}

var Lse = NaN, Rqe = /^[-+]0x[0-9a-f]+$/i, Dqe = /^0b[01]+$/i, Mqe = /^0o[0-7]+$/i, Oqe = parseInt;

function lq(t) {
    if (typeof t == "number") return t;
    if (M4(t)) return Lse;
    if (pu(t)) {
        var e = typeof t.valueOf == "function" ? t.valueOf() : t;
        t = pu(e) ? e + "" : e
    }
    if (typeof t != "string") return t === 0 ? t : +t;
    t = kqe(t);
    var r = Dqe.test(t);
    return r || Mqe.test(t) ? Oqe(t.slice(2), r ? 2 : 8) : Rqe.test(t) ? Lse : +t
}

var Bse = 1 / 0, Pqe = 17976931348623157e292;

function uq(t) {
    if (!t) return t === 0 ? t : 0;
    if (t = lq(t), t === Bse || t === -Bse) {
        var e = t < 0 ? -1 : 1;
        return e * Pqe
    }
    return t === t ? t : 0
}

function Nqe(t) {
    var e = uq(t), r = e % 1;
    return e === e ? r ? e - r : e : 0
}

function HP(t) {
    return t
}

var Lqe = "[object AsyncFunction]", Bqe = "[object Function]", $qe = "[object GeneratorFunction]",
    Fqe = "[object Proxy]";

function zX(t) {
    if (!pu(t)) return !1;
    var e = g1(t);
    return e == Bqe || e == $qe || e == Lqe || e == Fqe
}

var Gj = bp["__core-js_shared__"], $se = function () {
    var t = /[^.]+$/.exec(Gj && Gj.keys && Gj.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : ""
}();

function Uqe(t) {
    return !!$se && $se in t
}

var jqe = Function.prototype, zqe = jqe.toString;

function OS(t) {
    if (t != null) {
        try {
            return zqe.call(t)
        } catch {
        }
        try {
            return t + ""
        } catch {
        }
    }
    return ""
}

var Vqe = /[\\^$.*+?()[\]{}|]/g, Hqe = /^\[object .+?Constructor\]$/, Wqe = Function.prototype, qqe = Object.prototype,
    Gqe = Wqe.toString, Kqe = qqe.hasOwnProperty,
    Yqe = RegExp("^" + Gqe.call(Kqe).replace(Vqe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function Xqe(t) {
    if (!pu(t) || Uqe(t)) return !1;
    var e = zX(t) ? Yqe : Hqe;
    return e.test(OS(t))
}

function Qqe(t, e) {
    return t == null ? void 0 : t[e]
}

function PS(t, e) {
    var r = Qqe(t, e);
    return Xqe(r) ? r : void 0
}

var fq = PS(bp, "WeakMap"), Fse = Object.create, Zqe = function () {
    function t() {
    }

    return function (e) {
        if (!pu(e)) return {};
        if (Fse) return Fse(e);
        t.prototype = e;
        var r = new t;
        return t.prototype = void 0, r
    }
}();

function Jqe(t, e, r) {
    switch (r.length) {
        case 0:
            return t.call(e);
        case 1:
            return t.call(e, r[0]);
        case 2:
            return t.call(e, r[0], r[1]);
        case 3:
            return t.call(e, r[0], r[1], r[2])
    }
    return t.apply(e, r)
}

function eGe() {
}

function d1e(t, e) {
    var r = -1, n = t.length;
    for (e || (e = Array(n)); ++r < n;) e[r] = t[r];
    return e
}

var tGe = 800, rGe = 16, nGe = Date.now;

function iGe(t) {
    var e = 0, r = 0;
    return function () {
        var n = nGe(), i = rGe - (n - r);
        if (r = n, i > 0) {
            if (++e >= tGe) return arguments[0]
        } else e = 0;
        return t.apply(void 0, arguments)
    }
}

function aGe(t) {
    return function () {
        return t
    }
}

var QM = function () {
    try {
        var t = PS(Object, "defineProperty");
        return t({}, "", {}), t
    } catch {
    }
}(), oGe = QM ? function (t, e) {
    return QM(t, "toString", {configurable: !0, enumerable: !1, value: aGe(e), writable: !0})
} : HP;
const sGe = oGe;
var h1e = iGe(sGe);

function cGe(t, e) {
    for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1;) ;
    return t
}

function lGe(t, e, r, n) {
    for (var i = t.length, a = r + (n ? 1 : -1); n ? a-- : ++a < i;) if (e(t[a], a, t)) return a;
    return -1
}

function uGe(t) {
    return t !== t
}

function fGe(t, e, r) {
    for (var n = r - 1, i = t.length; ++n < i;) if (t[n] === e) return n;
    return -1
}

function dGe(t, e, r) {
    return e === e ? fGe(t, e, r) : lGe(t, uGe, r)
}

function hGe(t, e) {
    var r = t == null ? 0 : t.length;
    return !!r && dGe(t, e, 0) > -1
}

var pGe = 9007199254740991, mGe = /^(?:0|[1-9]\d*)$/;

function WP(t, e) {
    var r = typeof t;
    return e = e ?? pGe, !!e && (r == "number" || r != "symbol" && mGe.test(t)) && t > -1 && t % 1 == 0 && t < e
}

function VX(t, e, r) {
    e == "__proto__" && QM ? QM(t, e, {configurable: !0, enumerable: !0, value: r, writable: !0}) : t[e] = r
}

function y8(t, e) {
    return t === e || t !== t && e !== e
}

var vGe = Object.prototype, gGe = vGe.hasOwnProperty;

function HX(t, e, r) {
    var n = t[e];
    (!(gGe.call(t, e) && y8(n, r)) || r === void 0 && !(e in t)) && VX(t, e, r)
}

function LE(t, e, r, n) {
    var i = !r;
    r || (r = {});
    for (var a = -1, o = e.length; ++a < o;) {
        var s = e[a], l = n ? n(r[s], t[s], s, r, t) : void 0;
        l === void 0 && (l = t[s]), i ? VX(r, s, l) : HX(r, s, l)
    }
    return r
}

var Use = Math.max;

function p1e(t, e, r) {
    return e = Use(e === void 0 ? t.length - 1 : e, 0), function () {
        for (var n = arguments, i = -1, a = Use(n.length - e, 0), o = Array(a); ++i < a;) o[i] = n[e + i];
        i = -1;
        for (var s = Array(e + 1); ++i < e;) s[i] = n[i];
        return s[e] = r(o), Jqe(t, this, s)
    }
}

function yGe(t, e) {
    return h1e(p1e(t, e, HP), t + "")
}

var bGe = 9007199254740991;

function WX(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= bGe
}

function BE(t) {
    return t != null && WX(t.length) && !zX(t)
}

function m1e(t, e, r) {
    if (!pu(r)) return !1;
    var n = typeof e;
    return (n == "number" ? BE(r) && WP(e, r.length) : n == "string" && e in r) ? y8(r[e], t) : !1
}

function wGe(t) {
    return yGe(function (e, r) {
        var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, o = i > 2 ? r[2] : void 0;
        for (a = t.length > 3 && typeof a == "function" ? (i--, a) : void 0, o && m1e(r[0], r[1], o) && (a = i < 3 ? void 0 : a, i = 1), e = Object(e); ++n < i;) {
            var s = r[n];
            s && t(e, s, n, a)
        }
        return e
    })
}

var SGe = Object.prototype;

function qX(t) {
    var e = t && t.constructor, r = typeof e == "function" && e.prototype || SGe;
    return t === r
}

function _Ge(t, e) {
    for (var r = -1, n = Array(t); ++r < t;) n[r] = e(r);
    return n
}

var xGe = "[object Arguments]";

function jse(t) {
    return dp(t) && g1(t) == xGe
}

var v1e = Object.prototype, EGe = v1e.hasOwnProperty, TGe = v1e.propertyIsEnumerable, rA = jse(function () {
    return arguments
}()) ? jse : function (t) {
    return dp(t) && EGe.call(t, "callee") && !TGe.call(t, "callee")
};

function CGe() {
    return !1
}

var g1e = typeof exports == "object" && exports && !exports.nodeType && exports,
    zse = g1e && typeof module == "object" && module && !module.nodeType && module, AGe = zse && zse.exports === g1e,
    Vse = AGe ? bp.Buffer : void 0, IGe = Vse ? Vse.isBuffer : void 0, nA = IGe || CGe, kGe = "[object Arguments]",
    RGe = "[object Array]", DGe = "[object Boolean]", MGe = "[object Date]", OGe = "[object Error]",
    PGe = "[object Function]", NGe = "[object Map]", LGe = "[object Number]", BGe = "[object Object]",
    $Ge = "[object RegExp]", FGe = "[object Set]", UGe = "[object String]", jGe = "[object WeakMap]",
    zGe = "[object ArrayBuffer]", VGe = "[object DataView]", HGe = "[object Float32Array]",
    WGe = "[object Float64Array]", qGe = "[object Int8Array]", GGe = "[object Int16Array]", KGe = "[object Int32Array]",
    YGe = "[object Uint8Array]", XGe = "[object Uint8ClampedArray]", QGe = "[object Uint16Array]",
    ZGe = "[object Uint32Array]", Ua = {};
Ua[HGe] = Ua[WGe] = Ua[qGe] = Ua[GGe] = Ua[KGe] = Ua[YGe] = Ua[XGe] = Ua[QGe] = Ua[ZGe] = !0;
Ua[kGe] = Ua[RGe] = Ua[zGe] = Ua[DGe] = Ua[VGe] = Ua[MGe] = Ua[OGe] = Ua[PGe] = Ua[NGe] = Ua[LGe] = Ua[BGe] = Ua[$Ge] = Ua[FGe] = Ua[UGe] = Ua[jGe] = !1;

function JGe(t) {
    return dp(t) && WX(t.length) && !!Ua[g1(t)]
}

function b8(t) {
    return function (e) {
        return t(e)
    }
}

var y1e = typeof exports == "object" && exports && !exports.nodeType && exports,
    ZT = y1e && typeof module == "object" && module && !module.nodeType && module, eKe = ZT && ZT.exports === y1e,
    Kj = eKe && u1e.process, Jy = function () {
        try {
            var t = ZT && ZT.require && ZT.require("util").types;
            return t || Kj && Kj.binding && Kj.binding("util")
        } catch {
        }
    }(), Hse = Jy && Jy.isTypedArray, GX = Hse ? b8(Hse) : JGe, tKe = Object.prototype, rKe = tKe.hasOwnProperty;

function b1e(t, e) {
    var r = Rl(t), n = !r && rA(t), i = !r && !n && nA(t), a = !r && !n && !i && GX(t), o = r || n || i || a,
        s = o ? _Ge(t.length, String) : [], l = s.length;
    for (var f in t) (e || rKe.call(t, f)) && !(o && (f == "length" || i && (f == "offset" || f == "parent") || a && (f == "buffer" || f == "byteLength" || f == "byteOffset") || WP(f, l))) && s.push(f);
    return s
}

function w1e(t, e) {
    return function (r) {
        return t(e(r))
    }
}

var nKe = w1e(Object.keys, Object), iKe = Object.prototype, aKe = iKe.hasOwnProperty;

function oKe(t) {
    if (!qX(t)) return nKe(t);
    var e = [];
    for (var r in Object(t)) aKe.call(t, r) && r != "constructor" && e.push(r);
    return e
}

function w8(t) {
    return BE(t) ? b1e(t) : oKe(t)
}

function sKe(t) {
    var e = [];
    if (t != null) for (var r in Object(t)) e.push(r);
    return e
}

var cKe = Object.prototype, lKe = cKe.hasOwnProperty;

function uKe(t) {
    if (!pu(t)) return sKe(t);
    var e = qX(t), r = [];
    for (var n in t) n == "constructor" && (e || !lKe.call(t, n)) || r.push(n);
    return r
}

function S8(t) {
    return BE(t) ? b1e(t, !0) : uKe(t)
}

var fKe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, dKe = /^\w*$/;

function KX(t, e) {
    if (Rl(t)) return !1;
    var r = typeof t;
    return r == "number" || r == "symbol" || r == "boolean" || t == null || M4(t) ? !0 : dKe.test(t) || !fKe.test(t) || e != null && t in Object(e)
}

var iA = PS(Object, "create");

function hKe() {
    this.__data__ = iA ? iA(null) : {}, this.size = 0
}

function pKe(t) {
    var e = this.has(t) && delete this.__data__[t];
    return this.size -= e ? 1 : 0, e
}

var mKe = "__lodash_hash_undefined__", vKe = Object.prototype, gKe = vKe.hasOwnProperty;

function yKe(t) {
    var e = this.__data__;
    if (iA) {
        var r = e[t];
        return r === mKe ? void 0 : r
    }
    return gKe.call(e, t) ? e[t] : void 0
}

var bKe = Object.prototype, wKe = bKe.hasOwnProperty;

function SKe(t) {
    var e = this.__data__;
    return iA ? e[t] !== void 0 : wKe.call(e, t)
}

var _Ke = "__lodash_hash_undefined__";

function xKe(t, e) {
    var r = this.__data__;
    return this.size += this.has(t) ? 0 : 1, r[t] = iA && e === void 0 ? _Ke : e, this
}

function sS(t) {
    var e = -1, r = t == null ? 0 : t.length;
    for (this.clear(); ++e < r;) {
        var n = t[e];
        this.set(n[0], n[1])
    }
}

sS.prototype.clear = hKe;
sS.prototype.delete = pKe;
sS.prototype.get = yKe;
sS.prototype.has = SKe;
sS.prototype.set = xKe;

function EKe() {
    this.__data__ = [], this.size = 0
}

function qP(t, e) {
    for (var r = t.length; r--;) if (y8(t[r][0], e)) return r;
    return -1
}

var TKe = Array.prototype, CKe = TKe.splice;

function AKe(t) {
    var e = this.__data__, r = qP(e, t);
    if (r < 0) return !1;
    var n = e.length - 1;
    return r == n ? e.pop() : CKe.call(e, r, 1), --this.size, !0
}

function IKe(t) {
    var e = this.__data__, r = qP(e, t);
    return r < 0 ? void 0 : e[r][1]
}

function kKe(t) {
    return qP(this.__data__, t) > -1
}

function RKe(t, e) {
    var r = this.__data__, n = qP(r, t);
    return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this
}

function Qv(t) {
    var e = -1, r = t == null ? 0 : t.length;
    for (this.clear(); ++e < r;) {
        var n = t[e];
        this.set(n[0], n[1])
    }
}

Qv.prototype.clear = EKe;
Qv.prototype.delete = AKe;
Qv.prototype.get = IKe;
Qv.prototype.has = kKe;
Qv.prototype.set = RKe;
var aA = PS(bp, "Map");

function DKe() {
    this.size = 0, this.__data__ = {hash: new sS, map: new (aA || Qv), string: new sS}
}

function MKe(t) {
    var e = typeof t;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
}

function GP(t, e) {
    var r = t.__data__;
    return MKe(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map
}

function OKe(t) {
    var e = GP(this, t).delete(t);
    return this.size -= e ? 1 : 0, e
}

function PKe(t) {
    return GP(this, t).get(t)
}

function NKe(t) {
    return GP(this, t).has(t)
}

function LKe(t, e) {
    var r = GP(this, t), n = r.size;
    return r.set(t, e), this.size += r.size == n ? 0 : 1, this
}

function Zv(t) {
    var e = -1, r = t == null ? 0 : t.length;
    for (this.clear(); ++e < r;) {
        var n = t[e];
        this.set(n[0], n[1])
    }
}

Zv.prototype.clear = DKe;
Zv.prototype.delete = OKe;
Zv.prototype.get = PKe;
Zv.prototype.has = NKe;
Zv.prototype.set = LKe;
var BKe = "Expected a function";

function YX(t, e) {
    if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(BKe);
    var r = function () {
        var n = arguments, i = e ? e.apply(this, n) : n[0], a = r.cache;
        if (a.has(i)) return a.get(i);
        var o = t.apply(this, n);
        return r.cache = a.set(i, o) || a, o
    };
    return r.cache = new (YX.Cache || Zv), r
}

YX.Cache = Zv;
var $Ke = 500;

function FKe(t) {
    var e = YX(t, function (n) {
        return r.size === $Ke && r.clear(), n
    }), r = e.cache;
    return e
}

var UKe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    jKe = /\\(\\)?/g, zKe = FKe(function (t) {
        var e = [];
        return t.charCodeAt(0) === 46 && e.push(""), t.replace(UKe, function (r, n, i, a) {
            e.push(i ? a.replace(jKe, "$1") : n || r)
        }), e
    });

function dq(t) {
    return t == null ? "" : XM(t)
}

function _8(t, e) {
    return Rl(t) ? t : KX(t, e) ? [t] : zKe(dq(t))
}

var VKe = 1 / 0;

function $E(t) {
    if (typeof t == "string" || M4(t)) return t;
    var e = t + "";
    return e == "0" && 1 / t == -VKe ? "-0" : e
}

function KP(t, e) {
    e = _8(e, t);
    for (var r = 0, n = e.length; t != null && r < n;) t = t[$E(e[r++])];
    return r && r == n ? t : void 0
}

function HKe(t, e, r) {
    var n = t == null ? void 0 : KP(t, e);
    return n === void 0 ? r : n
}

function XX(t, e) {
    for (var r = -1, n = e.length, i = t.length; ++r < n;) t[i + r] = e[r];
    return t
}

var Wse = Yd ? Yd.isConcatSpreadable : void 0;

function WKe(t) {
    return Rl(t) || rA(t) || !!(Wse && t && t[Wse])
}

function S1e(t, e, r, n, i) {
    var a = -1, o = t.length;
    for (r || (r = WKe), i || (i = []); ++a < o;) {
        var s = t[a];
        e > 0 && r(s) ? e > 1 ? S1e(s, e - 1, r, n, i) : XX(i, s) : n || (i[i.length] = s)
    }
    return i
}

function qKe(t) {
    var e = t == null ? 0 : t.length;
    return e ? S1e(t, 1) : []
}

function GKe(t) {
    return h1e(p1e(t, void 0, qKe), t + "")
}

var QX = w1e(Object.getPrototypeOf, Object), KKe = "[object Object]", YKe = Function.prototype, XKe = Object.prototype,
    _1e = YKe.toString, QKe = XKe.hasOwnProperty, ZKe = _1e.call(Object);

function x1e(t) {
    if (!dp(t) || g1(t) != KKe) return !1;
    var e = QX(t);
    if (e === null) return !0;
    var r = QKe.call(e, "constructor") && e.constructor;
    return typeof r == "function" && r instanceof r && _1e.call(r) == ZKe
}

function E1e(t, e, r) {
    var n = -1, i = t.length;
    e < 0 && (e = -e > i ? 0 : i + e), r = r > i ? i : r, r < 0 && (r += i), i = e > r ? 0 : r - e >>> 0, e >>>= 0;
    for (var a = Array(i); ++n < i;) a[n] = t[n + e];
    return a
}

function JKe(t, e, r) {
    var n = t.length;
    return r = r === void 0 ? n : r, !e && r >= n ? t : E1e(t, e, r)
}

var eYe = "\\ud800-\\udfff", tYe = "\\u0300-\\u036f", rYe = "\\ufe20-\\ufe2f", nYe = "\\u20d0-\\u20ff",
    iYe = tYe + rYe + nYe, aYe = "\\ufe0e\\ufe0f", oYe = "\\u200d", sYe = RegExp("[" + oYe + eYe + iYe + aYe + "]");

function ZX(t) {
    return sYe.test(t)
}

function cYe(t) {
    return t.split("")
}

var T1e = "\\ud800-\\udfff", lYe = "\\u0300-\\u036f", uYe = "\\ufe20-\\ufe2f", fYe = "\\u20d0-\\u20ff",
    dYe = lYe + uYe + fYe, hYe = "\\ufe0e\\ufe0f", pYe = "[" + T1e + "]", hq = "[" + dYe + "]",
    pq = "\\ud83c[\\udffb-\\udfff]", mYe = "(?:" + hq + "|" + pq + ")", C1e = "[^" + T1e + "]",
    A1e = "(?:\\ud83c[\\udde6-\\uddff]){2}", I1e = "[\\ud800-\\udbff][\\udc00-\\udfff]", vYe = "\\u200d",
    k1e = mYe + "?", R1e = "[" + hYe + "]?",
    gYe = "(?:" + vYe + "(?:" + [C1e, A1e, I1e].join("|") + ")" + R1e + k1e + ")*", yYe = R1e + k1e + gYe,
    bYe = "(?:" + [C1e + hq + "?", hq, A1e, I1e, pYe].join("|") + ")",
    wYe = RegExp(pq + "(?=" + pq + ")|" + bYe + yYe, "g");

function SYe(t) {
    return t.match(wYe) || []
}

function _Ye(t) {
    return ZX(t) ? SYe(t) : cYe(t)
}

function xYe() {
    this.__data__ = new Qv, this.size = 0
}

function EYe(t) {
    var e = this.__data__, r = e.delete(t);
    return this.size = e.size, r
}

function TYe(t) {
    return this.__data__.get(t)
}

function CYe(t) {
    return this.__data__.has(t)
}

var AYe = 200;

function IYe(t, e) {
    var r = this.__data__;
    if (r instanceof Qv) {
        var n = r.__data__;
        if (!aA || n.length < AYe - 1) return n.push([t, e]), this.size = ++r.size, this;
        r = this.__data__ = new Zv(n)
    }
    return r.set(t, e), this.size = r.size, this
}

function sp(t) {
    var e = this.__data__ = new Qv(t);
    this.size = e.size
}

sp.prototype.clear = xYe;
sp.prototype.delete = EYe;
sp.prototype.get = TYe;
sp.prototype.has = CYe;
sp.prototype.set = IYe;

function kYe(t, e) {
    return t && LE(e, w8(e), t)
}

function RYe(t, e) {
    return t && LE(e, S8(e), t)
}

var D1e = typeof exports == "object" && exports && !exports.nodeType && exports,
    qse = D1e && typeof module == "object" && module && !module.nodeType && module, DYe = qse && qse.exports === D1e,
    Gse = DYe ? bp.Buffer : void 0, Kse = Gse ? Gse.allocUnsafe : void 0;

function M1e(t, e) {
    if (e) return t.slice();
    var r = t.length, n = Kse ? Kse(r) : new t.constructor(r);
    return t.copy(n), n
}

function MYe(t, e) {
    for (var r = -1, n = t == null ? 0 : t.length, i = 0, a = []; ++r < n;) {
        var o = t[r];
        e(o, r, t) && (a[i++] = o)
    }
    return a
}

function O1e() {
    return []
}

var OYe = Object.prototype, PYe = OYe.propertyIsEnumerable, Yse = Object.getOwnPropertySymbols,
    NYe = Yse ? function (t) {
        return t == null ? [] : (t = Object(t), MYe(Yse(t), function (e) {
            return PYe.call(t, e)
        }))
    } : O1e;
const JX = NYe;

function LYe(t, e) {
    return LE(t, JX(t), e)
}

var BYe = Object.getOwnPropertySymbols, $Ye = BYe ? function (t) {
    for (var e = []; t;) XX(e, JX(t)), t = QX(t);
    return e
} : O1e;
const P1e = $Ye;

function FYe(t, e) {
    return LE(t, P1e(t), e)
}

function N1e(t, e, r) {
    var n = e(t);
    return Rl(t) ? n : XX(n, r(t))
}

function mq(t) {
    return N1e(t, w8, JX)
}

function L1e(t) {
    return N1e(t, S8, P1e)
}

var vq = PS(bp, "DataView"), gq = PS(bp, "Promise"), Xx = PS(bp, "Set"), Xse = "[object Map]", UYe = "[object Object]",
    Qse = "[object Promise]", Zse = "[object Set]", Jse = "[object WeakMap]", ece = "[object DataView]", jYe = OS(vq),
    zYe = OS(aA), VYe = OS(gq), HYe = OS(Xx), WYe = OS(fq), rw = g1;
(vq && rw(new vq(new ArrayBuffer(1))) != ece || aA && rw(new aA) != Xse || gq && rw(gq.resolve()) != Qse || Xx && rw(new Xx) != Zse || fq && rw(new fq) != Jse) && (rw = function (t) {
    var e = g1(t), r = e == UYe ? t.constructor : void 0, n = r ? OS(r) : "";
    if (n) switch (n) {
        case jYe:
            return ece;
        case zYe:
            return Xse;
        case VYe:
            return Qse;
        case HYe:
            return Zse;
        case WYe:
            return Jse
    }
    return e
});
const oA = rw;
var qYe = Object.prototype, GYe = qYe.hasOwnProperty;

function KYe(t) {
    var e = t.length, r = new t.constructor(e);
    return e && typeof t[0] == "string" && GYe.call(t, "index") && (r.index = t.index, r.input = t.input), r
}

var ZM = bp.Uint8Array;

function eQ(t) {
    var e = new t.constructor(t.byteLength);
    return new ZM(e).set(new ZM(t)), e
}

function YYe(t, e) {
    var r = e ? eQ(t.buffer) : t.buffer;
    return new t.constructor(r, t.byteOffset, t.byteLength)
}

var XYe = /\w*$/;

function QYe(t) {
    var e = new t.constructor(t.source, XYe.exec(t));
    return e.lastIndex = t.lastIndex, e
}

var tce = Yd ? Yd.prototype : void 0, rce = tce ? tce.valueOf : void 0;

function ZYe(t) {
    return rce ? Object(rce.call(t)) : {}
}

function B1e(t, e) {
    var r = e ? eQ(t.buffer) : t.buffer;
    return new t.constructor(r, t.byteOffset, t.length)
}

var JYe = "[object Boolean]", eXe = "[object Date]", tXe = "[object Map]", rXe = "[object Number]",
    nXe = "[object RegExp]", iXe = "[object Set]", aXe = "[object String]", oXe = "[object Symbol]",
    sXe = "[object ArrayBuffer]", cXe = "[object DataView]", lXe = "[object Float32Array]",
    uXe = "[object Float64Array]", fXe = "[object Int8Array]", dXe = "[object Int16Array]", hXe = "[object Int32Array]",
    pXe = "[object Uint8Array]", mXe = "[object Uint8ClampedArray]", vXe = "[object Uint16Array]",
    gXe = "[object Uint32Array]";

function yXe(t, e, r) {
    var n = t.constructor;
    switch (e) {
        case sXe:
            return eQ(t);
        case JYe:
        case eXe:
            return new n(+t);
        case cXe:
            return YYe(t, r);
        case lXe:
        case uXe:
        case fXe:
        case dXe:
        case hXe:
        case pXe:
        case mXe:
        case vXe:
        case gXe:
            return B1e(t, r);
        case tXe:
            return new n;
        case rXe:
        case aXe:
            return new n(t);
        case nXe:
            return QYe(t);
        case iXe:
            return new n;
        case oXe:
            return ZYe(t)
    }
}

function $1e(t) {
    return typeof t.constructor == "function" && !qX(t) ? Zqe(QX(t)) : {}
}

var bXe = "[object Map]";

function wXe(t) {
    return dp(t) && oA(t) == bXe
}

var nce = Jy && Jy.isMap, SXe = nce ? b8(nce) : wXe, _Xe = "[object Set]";

function xXe(t) {
    return dp(t) && oA(t) == _Xe
}

var ice = Jy && Jy.isSet, EXe = ice ? b8(ice) : xXe, TXe = 1, CXe = 2, AXe = 4, F1e = "[object Arguments]",
    IXe = "[object Array]", kXe = "[object Boolean]", RXe = "[object Date]", DXe = "[object Error]",
    U1e = "[object Function]", MXe = "[object GeneratorFunction]", OXe = "[object Map]", PXe = "[object Number]",
    j1e = "[object Object]", NXe = "[object RegExp]", LXe = "[object Set]", BXe = "[object String]",
    $Xe = "[object Symbol]", FXe = "[object WeakMap]", UXe = "[object ArrayBuffer]", jXe = "[object DataView]",
    zXe = "[object Float32Array]", VXe = "[object Float64Array]", HXe = "[object Int8Array]",
    WXe = "[object Int16Array]", qXe = "[object Int32Array]", GXe = "[object Uint8Array]",
    KXe = "[object Uint8ClampedArray]", YXe = "[object Uint16Array]", XXe = "[object Uint32Array]", Ea = {};
Ea[F1e] = Ea[IXe] = Ea[UXe] = Ea[jXe] = Ea[kXe] = Ea[RXe] = Ea[zXe] = Ea[VXe] = Ea[HXe] = Ea[WXe] = Ea[qXe] = Ea[OXe] = Ea[PXe] = Ea[j1e] = Ea[NXe] = Ea[LXe] = Ea[BXe] = Ea[$Xe] = Ea[GXe] = Ea[KXe] = Ea[YXe] = Ea[XXe] = !0;
Ea[DXe] = Ea[U1e] = Ea[FXe] = !1;

function yD(t, e, r, n, i, a) {
    var o, s = e & TXe, l = e & CXe, f = e & AXe;
    if (r && (o = i ? r(t, n, i, a) : r(t)), o !== void 0) return o;
    if (!pu(t)) return t;
    var d = Rl(t);
    if (d) {
        if (o = KYe(t), !s) return d1e(t, o)
    } else {
        var p = oA(t), g = p == U1e || p == MXe;
        if (nA(t)) return M1e(t, s);
        if (p == j1e || p == F1e || g && !i) {
            if (o = l || g ? {} : $1e(t), !s) return l ? FYe(t, RYe(o, t)) : LYe(t, kYe(o, t))
        } else {
            if (!Ea[p]) return i ? t : {};
            o = yXe(t, p, s)
        }
    }
    a || (a = new sp);
    var b = a.get(t);
    if (b) return b;
    a.set(t, o), EXe(t) ? t.forEach(function (I) {
        o.add(yD(I, e, r, I, t, a))
    }) : SXe(t) && t.forEach(function (I, N) {
        o.set(N, yD(I, e, r, N, t, a))
    });
    var S = f ? l ? L1e : mq : l ? S8 : w8, T = d ? void 0 : S(t);
    return cGe(T || t, function (I, N) {
        T && (N = I, I = t[N]), HX(o, N, yD(I, e, r, N, t, a))
    }), o
}

var QXe = "__lodash_hash_undefined__";

function ZXe(t) {
    return this.__data__.set(t, QXe), this
}

function JXe(t) {
    return this.__data__.has(t)
}

function sA(t) {
    var e = -1, r = t == null ? 0 : t.length;
    for (this.__data__ = new Zv; ++e < r;) this.add(t[e])
}

sA.prototype.add = sA.prototype.push = ZXe;
sA.prototype.has = JXe;

function eQe(t, e) {
    for (var r = -1, n = t == null ? 0 : t.length; ++r < n;) if (e(t[r], r, t)) return !0;
    return !1
}

function z1e(t, e) {
    return t.has(e)
}

var tQe = 1, rQe = 2;

function V1e(t, e, r, n, i, a) {
    var o = r & tQe, s = t.length, l = e.length;
    if (s != l && !(o && l > s)) return !1;
    var f = a.get(t), d = a.get(e);
    if (f && d) return f == e && d == t;
    var p = -1, g = !0, b = r & rQe ? new sA : void 0;
    for (a.set(t, e), a.set(e, t); ++p < s;) {
        var S = t[p], T = e[p];
        if (n) var I = o ? n(T, S, p, e, t, a) : n(S, T, p, t, e, a);
        if (I !== void 0) {
            if (I) continue;
            g = !1;
            break
        }
        if (b) {
            if (!eQe(e, function (N, P) {
                if (!z1e(b, P) && (S === N || i(S, N, r, n, a))) return b.push(P)
            })) {
                g = !1;
                break
            }
        } else if (!(S === T || i(S, T, r, n, a))) {
            g = !1;
            break
        }
    }
    return a.delete(t), a.delete(e), g
}

function nQe(t) {
    var e = -1, r = Array(t.size);
    return t.forEach(function (n, i) {
        r[++e] = [i, n]
    }), r
}

function tQ(t) {
    var e = -1, r = Array(t.size);
    return t.forEach(function (n) {
        r[++e] = n
    }), r
}

var iQe = 1, aQe = 2, oQe = "[object Boolean]", sQe = "[object Date]", cQe = "[object Error]", lQe = "[object Map]",
    uQe = "[object Number]", fQe = "[object RegExp]", dQe = "[object Set]", hQe = "[object String]",
    pQe = "[object Symbol]", mQe = "[object ArrayBuffer]", vQe = "[object DataView]", ace = Yd ? Yd.prototype : void 0,
    Yj = ace ? ace.valueOf : void 0;

function gQe(t, e, r, n, i, a, o) {
    switch (r) {
        case vQe:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
            t = t.buffer, e = e.buffer;
        case mQe:
            return !(t.byteLength != e.byteLength || !a(new ZM(t), new ZM(e)));
        case oQe:
        case sQe:
        case uQe:
            return y8(+t, +e);
        case cQe:
            return t.name == e.name && t.message == e.message;
        case fQe:
        case hQe:
            return t == e + "";
        case lQe:
            var s = nQe;
        case dQe:
            var l = n & iQe;
            if (s || (s = tQ), t.size != e.size && !l) return !1;
            var f = o.get(t);
            if (f) return f == e;
            n |= aQe, o.set(t, e);
            var d = V1e(s(t), s(e), n, i, a, o);
            return o.delete(t), d;
        case pQe:
            if (Yj) return Yj.call(t) == Yj.call(e)
    }
    return !1
}

var yQe = 1, bQe = Object.prototype, wQe = bQe.hasOwnProperty;

function SQe(t, e, r, n, i, a) {
    var o = r & yQe, s = mq(t), l = s.length, f = mq(e), d = f.length;
    if (l != d && !o) return !1;
    for (var p = l; p--;) {
        var g = s[p];
        if (!(o ? g in e : wQe.call(e, g))) return !1
    }
    var b = a.get(t), S = a.get(e);
    if (b && S) return b == e && S == t;
    var T = !0;
    a.set(t, e), a.set(e, t);
    for (var I = o; ++p < l;) {
        g = s[p];
        var N = t[g], P = e[g];
        if (n) var F = o ? n(P, N, g, e, t, a) : n(N, P, g, t, e, a);
        if (!(F === void 0 ? N === P || i(N, P, r, n, a) : F)) {
            T = !1;
            break
        }
        I || (I = g == "constructor")
    }
    if (T && !I) {
        var V = t.constructor, Y = e.constructor;
        V != Y && "constructor" in t && "constructor" in e && !(typeof V == "function" && V instanceof V && typeof Y == "function" && Y instanceof Y) && (T = !1)
    }
    return a.delete(t), a.delete(e), T
}

var _Qe = 1, oce = "[object Arguments]", sce = "[object Array]", J9 = "[object Object]", xQe = Object.prototype,
    cce = xQe.hasOwnProperty;

function EQe(t, e, r, n, i, a) {
    var o = Rl(t), s = Rl(e), l = o ? sce : oA(t), f = s ? sce : oA(e);
    l = l == oce ? J9 : l, f = f == oce ? J9 : f;
    var d = l == J9, p = f == J9, g = l == f;
    if (g && nA(t)) {
        if (!nA(e)) return !1;
        o = !0, d = !1
    }
    if (g && !d) return a || (a = new sp), o || GX(t) ? V1e(t, e, r, n, i, a) : gQe(t, e, l, r, n, i, a);
    if (!(r & _Qe)) {
        var b = d && cce.call(t, "__wrapped__"), S = p && cce.call(e, "__wrapped__");
        if (b || S) {
            var T = b ? t.value() : t, I = S ? e.value() : e;
            return a || (a = new sp), i(T, I, r, n, a)
        }
    }
    return g ? (a || (a = new sp), SQe(t, e, r, n, i, a)) : !1
}

function YP(t, e, r, n, i) {
    return t === e ? !0 : t == null || e == null || !dp(t) && !dp(e) ? t !== t && e !== e : EQe(t, e, r, n, YP, i)
}

var TQe = 1, CQe = 2;

function AQe(t, e, r, n) {
    var i = r.length, a = i, o = !n;
    if (t == null) return !a;
    for (t = Object(t); i--;) {
        var s = r[i];
        if (o && s[2] ? s[1] !== t[s[0]] : !(s[0] in t)) return !1
    }
    for (; ++i < a;) {
        s = r[i];
        var l = s[0], f = t[l], d = s[1];
        if (o && s[2]) {
            if (f === void 0 && !(l in t)) return !1
        } else {
            var p = new sp;
            if (n) var g = n(f, d, l, t, e, p);
            if (!(g === void 0 ? YP(d, f, TQe | CQe, n, p) : g)) return !1
        }
    }
    return !0
}

function H1e(t) {
    return t === t && !pu(t)
}

function IQe(t) {
    for (var e = w8(t), r = e.length; r--;) {
        var n = e[r], i = t[n];
        e[r] = [n, i, H1e(i)]
    }
    return e
}

function W1e(t, e) {
    return function (r) {
        return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r))
    }
}

function kQe(t) {
    var e = IQe(t);
    return e.length == 1 && e[0][2] ? W1e(e[0][0], e[0][1]) : function (r) {
        return r === t || AQe(r, t, e)
    }
}

function RQe(t, e) {
    return t != null && e in Object(t)
}

function DQe(t, e, r) {
    e = _8(e, t);
    for (var n = -1, i = e.length, a = !1; ++n < i;) {
        var o = $E(e[n]);
        if (!(a = t != null && r(t, o))) break;
        t = t[o]
    }
    return a || ++n != i ? a : (i = t == null ? 0 : t.length, !!i && WX(i) && WP(o, i) && (Rl(t) || rA(t)))
}

function MQe(t, e) {
    return t != null && DQe(t, e, RQe)
}

var OQe = 1, PQe = 2;

function NQe(t, e) {
    return KX(t) && H1e(e) ? W1e($E(t), e) : function (r) {
        var n = HKe(r, t);
        return n === void 0 && n === e ? MQe(r, t) : YP(e, n, OQe | PQe)
    }
}

function q1e(t) {
    return function (e) {
        return e == null ? void 0 : e[t]
    }
}

function LQe(t) {
    return function (e) {
        return KP(e, t)
    }
}

function BQe(t) {
    return KX(t) ? q1e($E(t)) : LQe(t)
}

function $Qe(t) {
    return typeof t == "function" ? t : t == null ? HP : typeof t == "object" ? Rl(t) ? NQe(t[0], t[1]) : kQe(t) : BQe(t)
}

function FQe(t) {
    return function (e, r, n) {
        for (var i = -1, a = Object(e), o = n(e), s = o.length; s--;) {
            var l = o[t ? s : ++i];
            if (r(a[l], l, a) === !1) break
        }
        return e
    }
}

var G1e = FQe();

function UQe(t, e) {
    return t && G1e(t, e, w8)
}

function jQe(t, e) {
    return function (r, n) {
        if (r == null) return r;
        if (!BE(r)) return t(r, n);
        for (var i = r.length, a = e ? i : -1, o = Object(r); (e ? a-- : ++a < i) && n(o[a], a, o) !== !1;) ;
        return r
    }
}

var zQe = jQe(UQe), Xj = function () {
    return bp.Date.now()
}, VQe = "Expected a function", HQe = Math.max, WQe = Math.min;

function K1e(t, e, r) {
    var n, i, a, o, s, l, f = 0, d = !1, p = !1, g = !0;
    if (typeof t != "function") throw new TypeError(VQe);
    e = lq(e) || 0, pu(r) && (d = !!r.leading, p = "maxWait" in r, a = p ? HQe(lq(r.maxWait) || 0, e) : a, g = "trailing" in r ? !!r.trailing : g);

    function b(ee) {
        var oe = n, G = i;
        return n = i = void 0, f = ee, o = t.apply(G, oe), o
    }

    function S(ee) {
        return f = ee, s = setTimeout(N, e), d ? b(ee) : o
    }

    function T(ee) {
        var oe = ee - l, G = ee - f, J = e - oe;
        return p ? WQe(J, a - G) : J
    }

    function I(ee) {
        var oe = ee - l, G = ee - f;
        return l === void 0 || oe >= e || oe < 0 || p && G >= a
    }

    function N() {
        var ee = Xj();
        if (I(ee)) return P(ee);
        s = setTimeout(N, T(ee))
    }

    function P(ee) {
        return s = void 0, g && n ? b(ee) : (n = i = void 0, o)
    }

    function F() {
        s !== void 0 && clearTimeout(s), f = 0, n = l = i = s = void 0
    }

    function V() {
        return s === void 0 ? o : P(Xj())
    }

    function Y() {
        var ee = Xj(), oe = I(ee);
        if (n = arguments, i = this, l = ee, oe) {
            if (s === void 0) return S(l);
            if (p) return clearTimeout(s), s = setTimeout(N, e), b(l)
        }
        return s === void 0 && (s = setTimeout(N, e)), o
    }

    return Y.cancel = F, Y.flush = V, Y
}

function yq(t, e, r) {
    (r !== void 0 && !y8(t[e], r) || r === void 0 && !(e in t)) && VX(t, e, r)
}

function qQe(t) {
    return dp(t) && BE(t)
}

function bq(t, e) {
    if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__") return t[e]
}

function GQe(t) {
    return LE(t, S8(t))
}

function KQe(t, e, r, n, i, a, o) {
    var s = bq(t, r), l = bq(e, r), f = o.get(l);
    if (f) {
        yq(t, r, f);
        return
    }
    var d = a ? a(s, l, r + "", t, e, o) : void 0, p = d === void 0;
    if (p) {
        var g = Rl(l), b = !g && nA(l), S = !g && !b && GX(l);
        d = l, g || b || S ? Rl(s) ? d = s : qQe(s) ? d = d1e(s) : b ? (p = !1, d = M1e(l, !0)) : S ? (p = !1, d = B1e(l, !0)) : d = [] : x1e(l) || rA(l) ? (d = s, rA(s) ? d = GQe(s) : (!pu(s) || zX(s)) && (d = $1e(l))) : p = !1
    }
    p && (o.set(l, d), i(d, l, n, a, o), o.delete(l)), yq(t, r, d)
}

function Y1e(t, e, r, n, i) {
    t !== e && G1e(e, function (a, o) {
        if (i || (i = new sp), pu(a)) KQe(t, e, o, r, Y1e, n, i); else {
            var s = n ? n(bq(t, o), a, o + "", t, e, i) : void 0;
            s === void 0 && (s = a), yq(t, o, s)
        }
    }, S8)
}

function YQe(t, e, r) {
    for (var n = -1, i = t == null ? 0 : t.length; ++n < i;) if (r(e, t[n])) return !0;
    return !1
}

function XQe(t) {
    var e = t == null ? 0 : t.length;
    return e ? t[e - 1] : void 0
}

function QQe(t, e) {
    var r = -1, n = BE(t) ? Array(t.length) : [];
    return zQe(t, function (i, a, o) {
        n[++r] = e(i, a, o)
    }), n
}

function ZQe(t, e) {
    return e.length < 2 ? t : KP(t, E1e(e, 0, -1))
}

function X1e(t, e) {
    return YP(t, e)
}

var JQe = "[object RegExp]";

function eZe(t) {
    return dp(t) && g1(t) == JQe
}

var lce = Jy && Jy.isRegExp, tZe = lce ? b8(lce) : eZe, rZe = wGe(function (t, e, r) {
    Y1e(t, e, r)
});

function nZe(t, e) {
    return e = _8(e, t), t = ZQe(t, e), t == null || delete t[$E(XQe(e))]
}

function iZe(t) {
    return x1e(t) ? void 0 : t
}

var aZe = 1, oZe = 2, sZe = 4, cZe = GKe(function (t, e) {
    var r = {};
    if (t == null) return r;
    var n = !1;
    e = QT(e, function (a) {
        return a = _8(a, t), n || (n = a.length > 1), a
    }), LE(t, L1e(t), r), n && (r = yD(r, aZe | oZe | sZe, iZe));
    for (var i = e.length; i--;) nZe(r, e[i]);
    return r
});
const XP = cZe;

function lZe(t, e, r, n) {
    if (!pu(t)) return t;
    e = _8(e, t);
    for (var i = -1, a = e.length, o = a - 1, s = t; s != null && ++i < a;) {
        var l = $E(e[i]), f = r;
        if (l === "__proto__" || l === "constructor" || l === "prototype") return t;
        if (i != o) {
            var d = s[l];
            f = n ? n(d, l, s) : void 0, f === void 0 && (f = pu(d) ? d : WP(e[i + 1]) ? [] : {})
        }
        HX(s, l, f), s = s[l]
    }
    return t
}

function uZe(t, e) {
    var r = t.length;
    for (t.sort(e); r--;) t[r] = t[r].value;
    return t
}

function fZe(t, e) {
    if (t !== e) {
        var r = t !== void 0, n = t === null, i = t === t, a = M4(t), o = e !== void 0, s = e === null, l = e === e,
            f = M4(e);
        if (!s && !f && !a && t > e || a && o && l && !s && !f || n && o && l || !r && l || !i) return 1;
        if (!n && !a && !f && t < e || f && r && i && !n && !a || s && r && i || !o && i || !l) return -1
    }
    return 0
}

function dZe(t, e, r) {
    for (var n = -1, i = t.criteria, a = e.criteria, o = i.length, s = r.length; ++n < o;) {
        var l = fZe(i[n], a[n]);
        if (l) {
            if (n >= s) return l;
            var f = r[n];
            return l * (f == "desc" ? -1 : 1)
        }
    }
    return t.index - e.index
}

function hZe(t, e, r) {
    e.length ? e = QT(e, function (a) {
        return Rl(a) ? function (o) {
            return KP(o, a.length === 1 ? a[0] : a)
        } : a
    }) : e = [HP];
    var n = -1;
    e = QT(e, b8($Qe));
    var i = QQe(t, function (a, o, s) {
        var l = QT(e, function (f) {
            return f(a)
        });
        return {criteria: l, index: ++n, value: a}
    });
    return uZe(i, function (a, o) {
        return dZe(a, o, r)
    })
}

function bD(t, e, r, n) {
    return t == null ? [] : (Rl(e) || (e = e == null ? [] : [e]), r = n ? void 0 : r, Rl(r) || (r = r == null ? [] : [r]), hZe(t, e, r))
}

var pZe = q1e("length"), Q1e = "\\ud800-\\udfff", mZe = "\\u0300-\\u036f", vZe = "\\ufe20-\\ufe2f",
    gZe = "\\u20d0-\\u20ff", yZe = mZe + vZe + gZe, bZe = "\\ufe0e\\ufe0f", wZe = "[" + Q1e + "]", wq = "[" + yZe + "]",
    Sq = "\\ud83c[\\udffb-\\udfff]", SZe = "(?:" + wq + "|" + Sq + ")", Z1e = "[^" + Q1e + "]",
    J1e = "(?:\\ud83c[\\udde6-\\uddff]){2}", ebe = "[\\ud800-\\udbff][\\udc00-\\udfff]", _Ze = "\\u200d",
    tbe = SZe + "?", rbe = "[" + bZe + "]?",
    xZe = "(?:" + _Ze + "(?:" + [Z1e, J1e, ebe].join("|") + ")" + rbe + tbe + ")*", EZe = rbe + tbe + xZe,
    TZe = "(?:" + [Z1e + wq + "?", wq, J1e, ebe, wZe].join("|") + ")",
    uce = RegExp(Sq + "(?=" + Sq + ")|" + TZe + EZe, "g");

function CZe(t) {
    for (var e = uce.lastIndex = 0; uce.test(t);) ++e;
    return e
}

function AZe(t) {
    return ZX(t) ? CZe(t) : pZe(t)
}

var IZe = Math.floor, kZe = Math.random;

function RZe(t, e) {
    return t + IZe(kZe() * (e - t + 1))
}

var DZe = parseFloat, MZe = Math.min, OZe = Math.random;

function PZe(t, e, r) {
    if (r && typeof r != "boolean" && m1e(t, e, r) && (e = r = void 0), r === void 0 && (typeof e == "boolean" ? (r = e, e = void 0) : typeof t == "boolean" && (r = t, t = void 0)), t === void 0 && e === void 0 ? (t = 0, e = 1) : (t = uq(t), e === void 0 ? (e = t, t = 0) : e = uq(e)), t > e) {
        var n = t;
        t = e, e = n
    }
    if (r || t % 1 || e % 1) {
        var i = OZe();
        return MZe(t + i * (e - t + DZe("1e-" + ((i + "").length - 1))), e)
    }
    return RZe(t, e)
}

function Wr(t, e, r) {
    return t == null ? t : lZe(t, e, r)
}

var NZe = 30, LZe = "...", BZe = /\w*$/;

function nbe(t, e) {
    var r = NZe, n = LZe;
    if (pu(e)) {
        var i = "separator" in e ? e.separator : i;
        r = "length" in e ? Nqe(e.length) : r, n = "omission" in e ? XM(e.omission) : n
    }
    t = dq(t);
    var a = t.length;
    if (ZX(t)) {
        var o = _Ye(t);
        a = o.length
    }
    if (r >= a) return t;
    var s = r - AZe(n);
    if (s < 1) return n;
    var l = o ? JKe(o, 0, s).join("") : t.slice(0, s);
    if (i === void 0) return l + n;
    if (o && (s += l.length - s), tZe(i)) {
        if (t.slice(s).search(i)) {
            var f, d = l;
            for (i.global || (i = RegExp(i.source, dq(BZe.exec(i)) + "g")), i.lastIndex = 0; f = i.exec(d);) var p = f.index;
            l = l.slice(0, p === void 0 ? s : p)
        }
    } else if (t.indexOf(XM(i), s) != s) {
        var g = l.lastIndexOf(i);
        g > -1 && (l = l.slice(0, g))
    }
    return l + n
}

var $Ze = 1 / 0, FZe = Xx && 1 / tQ(new Xx([, -0]))[1] == $Ze ? function (t) {
    return new Xx(t)
} : eGe, UZe = 200;

function jZe(t, e, r) {
    var n = -1, i = hGe, a = t.length, o = !0, s = [], l = s;
    if (r) o = !1, i = YQe; else if (a >= UZe) {
        var f = e ? null : FZe(t);
        if (f) return tQ(f);
        o = !1, i = z1e, l = new sA
    } else l = e ? [] : s;
    e:for (; ++n < a;) {
        var d = t[n], p = e ? e(d) : d;
        if (d = r || d !== 0 ? d : 0, o && p === p) {
            for (var g = l.length; g--;) if (l[g] === p) continue e;
            e && l.push(p), s.push(d)
        } else i(l, p, r) || (l !== s && l.push(p), s.push(d))
    }
    return s
}

function zZe(t, e) {
    return e = typeof e == "function" ? e : void 0, t && t.length ? jZe(t, void 0, e) : []
}

const VZe = (t, e, r) => {
        const n = e !== 0 ? t.slice(0, e).trim() : "", i = r !== 0 ? t.slice(-r).trim() : "";
        return `${n}...${i}`
    }, aJt = t => Math.abs(t.value) === 1 ? t.single : t.zeroOrMany,
    oJt = t => t[0] ? t[0].toLocaleUpperCase() + t.slice(1) : "",
    sJt = (t, e, r) => t && nbe(t, {length: e, omission: "…", ...r}), HZe = t => new Blob([t]).size;
var On = {}, _q = {exports: {}}, xq = {exports: {}};
(function (t, e) {
    var r = qr, n = r.Buffer;

    function i(o, s) {
        for (var l in o) s[l] = o[l]
    }

    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = a);

    function a(o, s, l) {
        return n(o, s, l)
    }

    a.prototype = Object.create(n.prototype), i(n, a), a.from = function (o, s, l) {
        if (typeof o == "number") throw new TypeError("Argument must not be a number");
        return n(o, s, l)
    }, a.alloc = function (o, s, l) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        var f = n(o);
        return s !== void 0 ? typeof l == "string" ? f.fill(s, l) : f.fill(s) : f.fill(0), f
    }, a.allocUnsafe = function (o) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        return n(o)
    }, a.allocUnsafeSlow = function (o) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        return r.SlowBuffer(o)
    }
})(xq, xq.exports);
var Vn = xq.exports, Qj = 65536, WZe = 4294967295;

function qZe() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
}

var GZe = Vn.Buffer, JM = tn.crypto || tn.msCrypto;
JM && JM.getRandomValues ? _q.exports = KZe : _q.exports = qZe;

function KZe(t, e) {
    if (t > WZe) throw new RangeError("requested too many random bytes");
    var r = GZe.allocUnsafe(t);
    if (t > 0) if (t > Qj) for (var n = 0; n < t; n += Qj) JM.getRandomValues(r.slice(n, n + Qj)); else JM.getRandomValues(r);
    return typeof e == "function" ? Ve.nextTick(function () {
        e(null, r)
    }) : r
}

var FE = _q.exports, Eq = {exports: {}};
typeof Object.create == "function" ? Eq.exports = function (e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : Eq.exports = function (e, r) {
    if (r) {
        e.super_ = r;
        var n = function () {
        };
        n.prototype = r.prototype, e.prototype = new n, e.prototype.constructor = e
    }
};
var Xn = Eq.exports, Tq = {exports: {}}, rQ = {exports: {}}, Qx = typeof Reflect == "object" ? Reflect : null,
    fce = Qx && typeof Qx.apply == "function" ? Qx.apply : function (e, r, n) {
        return Function.prototype.apply.call(e, r, n)
    }, wD;
Qx && typeof Qx.ownKeys == "function" ? wD = Qx.ownKeys : Object.getOwnPropertySymbols ? wD = function (e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
} : wD = function (e) {
    return Object.getOwnPropertyNames(e)
};

function YZe(t) {
    console && console.warn && console.warn(t)
}

var ibe = Number.isNaN || function (e) {
    return e !== e
};

function da() {
    da.init.call(this)
}

rQ.exports = da;
rQ.exports.once = JZe;
da.EventEmitter = da;
da.prototype._events = void 0;
da.prototype._eventsCount = 0;
da.prototype._maxListeners = void 0;
var dce = 10;

function QP(t) {
    if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
}

Object.defineProperty(da, "defaultMaxListeners", {
    enumerable: !0, get: function () {
        return dce
    }, set: function (t) {
        if (typeof t != "number" || t < 0 || ibe(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
        dce = t
    }
});
da.init = function () {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
};
da.prototype.setMaxListeners = function (e) {
    if (typeof e != "number" || e < 0 || ibe(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this
};

function abe(t) {
    return t._maxListeners === void 0 ? da.defaultMaxListeners : t._maxListeners
}

da.prototype.getMaxListeners = function () {
    return abe(this)
};
da.prototype.emit = function (e) {
    for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
    var i = e === "error", a = this._events;
    if (a !== void 0) i = i && a.error === void 0; else if (!i) return !1;
    if (i) {
        var o;
        if (r.length > 0 && (o = r[0]), o instanceof Error) throw o;
        var s = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw s.context = o, s
    }
    var l = a[e];
    if (l === void 0) return !1;
    if (typeof l == "function") fce(l, this, r); else for (var f = l.length, d = ube(l, f), n = 0; n < f; ++n) fce(d[n], this, r);
    return !0
};

function obe(t, e, r, n) {
    var i, a, o;
    if (QP(r), a = t._events, a === void 0 ? (a = t._events = Object.create(null), t._eventsCount = 0) : (a.newListener !== void 0 && (t.emit("newListener", e, r.listener ? r.listener : r), a = t._events), o = a[e]), o === void 0) o = a[e] = r, ++t._eventsCount; else if (typeof o == "function" ? o = a[e] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), i = abe(t), i > 0 && o.length > i && !o.warned) {
        o.warned = !0;
        var s = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s.name = "MaxListenersExceededWarning", s.emitter = t, s.type = e, s.count = o.length, YZe(s)
    }
    return t
}

da.prototype.addListener = function (e, r) {
    return obe(this, e, r, !1)
};
da.prototype.on = da.prototype.addListener;
da.prototype.prependListener = function (e, r) {
    return obe(this, e, r, !0)
};

function XZe() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}

function sbe(t, e, r) {
    var n = {fired: !1, wrapFn: void 0, target: t, type: e, listener: r}, i = XZe.bind(n);
    return i.listener = r, n.wrapFn = i, i
}

da.prototype.once = function (e, r) {
    return QP(r), this.on(e, sbe(this, e, r)), this
};
da.prototype.prependOnceListener = function (e, r) {
    return QP(r), this.prependListener(e, sbe(this, e, r)), this
};
da.prototype.removeListener = function (e, r) {
    var n, i, a, o, s;
    if (QP(r), i = this._events, i === void 0) return this;
    if (n = i[e], n === void 0) return this;
    if (n === r || n.listener === r) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r)); else if (typeof n != "function") {
        for (a = -1, o = n.length - 1; o >= 0; o--) if (n[o] === r || n[o].listener === r) {
            s = n[o].listener, a = o;
            break
        }
        if (a < 0) return this;
        a === 0 ? n.shift() : QZe(n, a), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, s || r)
    }
    return this
};
da.prototype.off = da.prototype.removeListener;
da.prototype.removeAllListeners = function (e) {
    var r, n, i;
    if (n = this._events, n === void 0) return this;
    if (n.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[e]), this;
    if (arguments.length === 0) {
        var a = Object.keys(n), o;
        for (i = 0; i < a.length; ++i) o = a[i], o !== "removeListener" && this.removeAllListeners(o);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
    }
    if (r = n[e], typeof r == "function") this.removeListener(e, r); else if (r !== void 0) for (i = r.length - 1; i >= 0; i--) this.removeListener(e, r[i]);
    return this
};

function cbe(t, e, r) {
    var n = t._events;
    if (n === void 0) return [];
    var i = n[e];
    return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ZZe(i) : ube(i, i.length)
}

da.prototype.listeners = function (e) {
    return cbe(this, e, !0)
};
da.prototype.rawListeners = function (e) {
    return cbe(this, e, !1)
};
da.listenerCount = function (t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : lbe.call(t, e)
};
da.prototype.listenerCount = lbe;

function lbe(t) {
    var e = this._events;
    if (e !== void 0) {
        var r = e[t];
        if (typeof r == "function") return 1;
        if (r !== void 0) return r.length
    }
    return 0
}

da.prototype.eventNames = function () {
    return this._eventsCount > 0 ? wD(this._events) : []
};

function ube(t, e) {
    for (var r = new Array(e), n = 0; n < e; ++n) r[n] = t[n];
    return r
}

function QZe(t, e) {
    for (; e + 1 < t.length; e++) t[e] = t[e + 1];
    t.pop()
}

function ZZe(t) {
    for (var e = new Array(t.length), r = 0; r < e.length; ++r) e[r] = t[r].listener || t[r];
    return e
}

function JZe(t, e) {
    return new Promise(function (r, n) {
        function i(o) {
            t.removeListener(e, a), n(o)
        }

        function a() {
            typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments))
        }

        fbe(t, e, a, {once: !0}), e !== "error" && eJe(t, i, {once: !0})
    })
}

function eJe(t, e, r) {
    typeof t.on == "function" && fbe(t, "error", e, r)
}

function fbe(t, e, r, n) {
    if (typeof t.on == "function") n.once ? t.once(e, r) : t.on(e, r); else if (typeof t.addEventListener == "function") t.addEventListener(e, function i(a) {
        n.once && t.removeEventListener(e, i), r(a)
    }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t)
}

var dbe = rQ.exports;
const cJt = za(dbe);
var hbe = dbe.EventEmitter, Zj, hce;

function tJe() {
    if (hce) return Zj;
    hce = 1;

    function t(S, T) {
        var I = Object.keys(S);
        if (Object.getOwnPropertySymbols) {
            var N = Object.getOwnPropertySymbols(S);
            T && (N = N.filter(function (P) {
                return Object.getOwnPropertyDescriptor(S, P).enumerable
            })), I.push.apply(I, N)
        }
        return I
    }

    function e(S) {
        for (var T = 1; T < arguments.length; T++) {
            var I = arguments[T] != null ? arguments[T] : {};
            T % 2 ? t(Object(I), !0).forEach(function (N) {
                r(S, N, I[N])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(I)) : t(Object(I)).forEach(function (N) {
                Object.defineProperty(S, N, Object.getOwnPropertyDescriptor(I, N))
            })
        }
        return S
    }

    function r(S, T, I) {
        return T = o(T), T in S ? Object.defineProperty(S, T, {
            value: I,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : S[T] = I, S
    }

    function n(S, T) {
        if (!(S instanceof T)) throw new TypeError("Cannot call a class as a function")
    }

    function i(S, T) {
        for (var I = 0; I < T.length; I++) {
            var N = T[I];
            N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(S, o(N.key), N)
        }
    }

    function a(S, T, I) {
        return T && i(S.prototype, T), I && i(S, I), Object.defineProperty(S, "prototype", {writable: !1}), S
    }

    function o(S) {
        var T = s(S, "string");
        return typeof T == "symbol" ? T : String(T)
    }

    function s(S, T) {
        if (typeof S != "object" || S === null) return S;
        var I = S[Symbol.toPrimitive];
        if (I !== void 0) {
            var N = I.call(S, T || "default");
            if (typeof N != "object") return N;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (T === "string" ? String : Number)(S)
    }

    var l = qr, f = l.Buffer, d = ME, p = d.inspect, g = p && p.custom || "inspect";

    function b(S, T, I) {
        f.prototype.copy.call(S, T, I)
    }

    return Zj = function () {
        function S() {
            n(this, S), this.head = null, this.tail = null, this.length = 0
        }

        return a(S, [{
            key: "push", value: function (I) {
                var N = {data: I, next: null};
                this.length > 0 ? this.tail.next = N : this.head = N, this.tail = N, ++this.length
            }
        }, {
            key: "unshift", value: function (I) {
                var N = {data: I, next: this.head};
                this.length === 0 && (this.tail = N), this.head = N, ++this.length
            }
        }, {
            key: "shift", value: function () {
                if (this.length !== 0) {
                    var I = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, I
                }
            }
        }, {
            key: "clear", value: function () {
                this.head = this.tail = null, this.length = 0
            }
        }, {
            key: "join", value: function (I) {
                if (this.length === 0) return "";
                for (var N = this.head, P = "" + N.data; N = N.next;) P += I + N.data;
                return P
            }
        }, {
            key: "concat", value: function (I) {
                if (this.length === 0) return f.alloc(0);
                for (var N = f.allocUnsafe(I >>> 0), P = this.head, F = 0; P;) b(P.data, N, F), F += P.data.length, P = P.next;
                return N
            }
        }, {
            key: "consume", value: function (I, N) {
                var P;
                return I < this.head.data.length ? (P = this.head.data.slice(0, I), this.head.data = this.head.data.slice(I)) : I === this.head.data.length ? P = this.shift() : P = N ? this._getString(I) : this._getBuffer(I), P
            }
        }, {
            key: "first", value: function () {
                return this.head.data
            }
        }, {
            key: "_getString", value: function (I) {
                var N = this.head, P = 1, F = N.data;
                for (I -= F.length; N = N.next;) {
                    var V = N.data, Y = I > V.length ? V.length : I;
                    if (Y === V.length ? F += V : F += V.slice(0, I), I -= Y, I === 0) {
                        Y === V.length ? (++P, N.next ? this.head = N.next : this.head = this.tail = null) : (this.head = N, N.data = V.slice(Y));
                        break
                    }
                    ++P
                }
                return this.length -= P, F
            }
        }, {
            key: "_getBuffer", value: function (I) {
                var N = f.allocUnsafe(I), P = this.head, F = 1;
                for (P.data.copy(N), I -= P.data.length; P = P.next;) {
                    var V = P.data, Y = I > V.length ? V.length : I;
                    if (V.copy(N, N.length - I, 0, Y), I -= Y, I === 0) {
                        Y === V.length ? (++F, P.next ? this.head = P.next : this.head = this.tail = null) : (this.head = P, P.data = V.slice(Y));
                        break
                    }
                    ++F
                }
                return this.length -= F, N
            }
        }, {
            key: g, value: function (I, N) {
                return p(this, e(e({}, N), {}, {depth: 0, customInspect: !1}))
            }
        }]), S
    }(), Zj
}

function rJe(t, e) {
    var r = this, n = this._readableState && this._readableState.destroyed,
        i = this._writableState && this._writableState.destroyed;
    return n || i ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ve.nextTick(Cq, this, t)) : Ve.nextTick(Cq, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function (a) {
        !e && a ? r._writableState ? r._writableState.errorEmitted ? Ve.nextTick(SD, r) : (r._writableState.errorEmitted = !0, Ve.nextTick(pce, r, a)) : Ve.nextTick(pce, r, a) : e ? (Ve.nextTick(SD, r), e(a)) : Ve.nextTick(SD, r)
    }), this)
}

function pce(t, e) {
    Cq(t, e), SD(t)
}

function SD(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close")
}

function nJe() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
}

function Cq(t, e) {
    t.emit("error", e)
}

function iJe(t, e) {
    var r = t._readableState, n = t._writableState;
    r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e)
}

var pbe = {destroy: rJe, undestroy: nJe, errorOrDestroy: iJe}, NS = {};

function aJe(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
}

var mbe = {};

function rh(t, e, r) {
    r || (r = Error);

    function n(a, o, s) {
        return typeof e == "string" ? e : e(a, o, s)
    }

    var i = function (a) {
        aJe(o, a);

        function o(s, l, f) {
            return a.call(this, n(s, l, f)) || this
        }

        return o
    }(r);
    i.prototype.name = r.name, i.prototype.code = t, mbe[t] = i
}

function mce(t, e) {
    if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function (n) {
            return String(n)
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0])
    } else return "of ".concat(e, " ").concat(String(t))
}

function oJe(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e
}

function sJe(t, e, r) {
    return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e
}

function cJe(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? !1 : t.indexOf(e, r) !== -1
}

rh("ERR_INVALID_OPT_VALUE", function (t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"'
}, TypeError);
rh("ERR_INVALID_ARG_TYPE", function (t, e, r) {
    var n;
    typeof e == "string" && oJe(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
    var i;
    if (sJe(t, " argument")) i = "The ".concat(t, " ").concat(n, " ").concat(mce(e, "type")); else {
        var a = cJe(t, ".") ? "property" : "argument";
        i = 'The "'.concat(t, '" ').concat(a, " ").concat(n, " ").concat(mce(e, "type"))
    }
    return i += ". Received type ".concat(typeof r), i
}, TypeError);
rh("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
rh("ERR_METHOD_NOT_IMPLEMENTED", function (t) {
    return "The " + t + " method is not implemented"
});
rh("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
rh("ERR_STREAM_DESTROYED", function (t) {
    return "Cannot call " + t + " after a stream was destroyed"
});
rh("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
rh("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
rh("ERR_STREAM_WRITE_AFTER_END", "write after end");
rh("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
rh("ERR_UNKNOWN_ENCODING", function (t) {
    return "Unknown encoding: " + t
}, TypeError);
rh("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
NS.codes = mbe;
var lJe = NS.codes.ERR_INVALID_OPT_VALUE;

function uJe(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null
}

function fJe(t, e, r, n) {
    var i = uJe(e, n, r);
    if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
            var a = n ? r : "highWaterMark";
            throw new lJe(a, i)
        }
        return Math.floor(i)
    }
    return t.objectMode ? 16 : 16 * 1024
}

var vbe = {getHighWaterMark: fJe}, dJe = hJe;

function hJe(t, e) {
    if (Jj("noDeprecation")) return t;
    var r = !1;

    function n() {
        if (!r) {
            if (Jj("throwDeprecation")) throw new Error(e);
            Jj("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0
        }
        return t.apply(this, arguments)
    }

    return n
}

function Jj(t) {
    try {
        if (!tn.localStorage) return !1
    } catch {
        return !1
    }
    var e = tn.localStorage[t];
    return e == null ? !1 : String(e).toLowerCase() === "true"
}

var ez, vce;

function gbe() {
    if (vce) return ez;
    vce = 1, ez = G;

    function t(ue) {
        var me = this;
        this.next = null, this.entry = null, this.finish = function () {
            ye(me, ue)
        }
    }

    var e;
    G.WritableState = ee;
    var r = {deprecate: dJe}, n = hbe, i = qr.Buffer,
        a = (typeof tn < "u" ? tn : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function () {
        };

    function o(ue) {
        return i.from(ue)
    }

    function s(ue) {
        return i.isBuffer(ue) || ue instanceof a
    }

    var l = pbe, f = vbe, d = f.getHighWaterMark, p = NS.codes, g = p.ERR_INVALID_ARG_TYPE,
        b = p.ERR_METHOD_NOT_IMPLEMENTED, S = p.ERR_MULTIPLE_CALLBACK, T = p.ERR_STREAM_CANNOT_PIPE,
        I = p.ERR_STREAM_DESTROYED, N = p.ERR_STREAM_NULL_VALUES, P = p.ERR_STREAM_WRITE_AFTER_END,
        F = p.ERR_UNKNOWN_ENCODING, V = l.errorOrDestroy;
    Xn(G, n);

    function Y() {
    }

    function ee(ue, me, Se) {
        e = e || O4(), ue = ue || {}, typeof Se != "boolean" && (Se = me instanceof e), this.objectMode = !!ue.objectMode, Se && (this.objectMode = this.objectMode || !!ue.writableObjectMode), this.highWaterMark = d(this, ue, "writableHighWaterMark", Se), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var Ce = ue.decodeStrings === !1;
        this.decodeStrings = !Ce, this.defaultEncoding = ue.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (Me) {
            B(me, Me)
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ue.emitClose !== !1, this.autoDestroy = !!ue.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this)
    }

    ee.prototype.getBuffer = function () {
        for (var me = this.bufferedRequest, Se = []; me;) Se.push(me), me = me.next;
        return Se
    }, function () {
        try {
            Object.defineProperty(ee.prototype, "buffer", {
                get: r.deprecate(function () {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {
        }
    }();
    var oe;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (oe = Function.prototype[Symbol.hasInstance], Object.defineProperty(G, Symbol.hasInstance, {
        value: function (me) {
            return oe.call(this, me) ? !0 : this !== G ? !1 : me && me._writableState instanceof ee
        }
    })) : oe = function (me) {
        return me instanceof this
    };

    function G(ue) {
        e = e || O4();
        var me = this instanceof e;
        if (!me && !oe.call(G, this)) return new G(ue);
        this._writableState = new ee(ue, this, me), this.writable = !0, ue && (typeof ue.write == "function" && (this._write = ue.write), typeof ue.writev == "function" && (this._writev = ue.writev), typeof ue.destroy == "function" && (this._destroy = ue.destroy), typeof ue.final == "function" && (this._final = ue.final)), n.call(this)
    }

    G.prototype.pipe = function () {
        V(this, new T)
    };

    function J(ue, me) {
        var Se = new P;
        V(ue, Se), Ve.nextTick(me, Se)
    }

    function ce(ue, me, Se, Ce) {
        var Me;
        return Se === null ? Me = new N : typeof Se != "string" && !me.objectMode && (Me = new g("chunk", ["string", "Buffer"], Se)), Me ? (V(ue, Me), Ve.nextTick(Ce, Me), !1) : !0
    }

    G.prototype.write = function (ue, me, Se) {
        var Ce = this._writableState, Me = !1, ve = !Ce.objectMode && s(ue);
        return ve && !i.isBuffer(ue) && (ue = o(ue)), typeof me == "function" && (Se = me, me = null), ve ? me = "buffer" : me || (me = Ce.defaultEncoding), typeof Se != "function" && (Se = Y), Ce.ending ? J(this, Se) : (ve || ce(this, Ce, ue, Se)) && (Ce.pendingcb++, Me = M(this, Ce, ve, ue, me, Se)), Me
    }, G.prototype.cork = function () {
        this._writableState.corked++
    }, G.prototype.uncork = function () {
        var ue = this._writableState;
        ue.corked && (ue.corked--, !ue.writing && !ue.corked && !ue.bufferProcessing && ue.bufferedRequest && $(this, ue))
    }, G.prototype.setDefaultEncoding = function (me) {
        if (typeof me == "string" && (me = me.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((me + "").toLowerCase()) > -1)) throw new F(me);
        return this._writableState.defaultEncoding = me, this
    }, Object.defineProperty(G.prototype, "writableBuffer", {
        enumerable: !1, get: function () {
            return this._writableState && this._writableState.getBuffer()
        }
    });

    function re(ue, me, Se) {
        return !ue.objectMode && ue.decodeStrings !== !1 && typeof me == "string" && (me = i.from(me, Se)), me
    }

    Object.defineProperty(G.prototype, "writableHighWaterMark", {
        enumerable: !1, get: function () {
            return this._writableState.highWaterMark
        }
    });

    function M(ue, me, Se, Ce, Me, ve) {
        if (!Se) {
            var ne = re(me, Ce, Me);
            Ce !== ne && (Se = !0, Me = "buffer", Ce = ne)
        }
        var be = me.objectMode ? 1 : Ce.length;
        me.length += be;
        var Ee = me.length < me.highWaterMark;
        if (Ee || (me.needDrain = !0), me.writing || me.corked) {
            var Oe = me.lastBufferedRequest;
            me.lastBufferedRequest = {
                chunk: Ce,
                encoding: Me,
                isBuf: Se,
                callback: ve,
                next: null
            }, Oe ? Oe.next = me.lastBufferedRequest : me.bufferedRequest = me.lastBufferedRequest, me.bufferedRequestCount += 1
        } else D(ue, me, !1, be, Ce, Me, ve);
        return Ee
    }

    function D(ue, me, Se, Ce, Me, ve, ne) {
        me.writelen = Ce, me.writecb = ne, me.writing = !0, me.sync = !0, me.destroyed ? me.onwrite(new I("write")) : Se ? ue._writev(Me, me.onwrite) : ue._write(Me, ve, me.onwrite), me.sync = !1
    }

    function x(ue, me, Se, Ce, Me) {
        --me.pendingcb, Se ? (Ve.nextTick(Me, Ce), Ve.nextTick(Q, ue, me), ue._writableState.errorEmitted = !0, V(ue, Ce)) : (Me(Ce), ue._writableState.errorEmitted = !0, V(ue, Ce), Q(ue, me))
    }

    function A(ue) {
        ue.writing = !1, ue.writecb = null, ue.length -= ue.writelen, ue.writelen = 0
    }

    function B(ue, me) {
        var Se = ue._writableState, Ce = Se.sync, Me = Se.writecb;
        if (typeof Me != "function") throw new S;
        if (A(Se), me) x(ue, Se, Ce, me, Me); else {
            var ve = C(Se) || ue.destroyed;
            !ve && !Se.corked && !Se.bufferProcessing && Se.bufferedRequest && $(ue, Se), Ce ? Ve.nextTick(z, ue, Se, ve, Me) : z(ue, Se, ve, Me)
        }
    }

    function z(ue, me, Se, Ce) {
        Se || j(ue, me), me.pendingcb--, Ce(), Q(ue, me)
    }

    function j(ue, me) {
        me.length === 0 && me.needDrain && (me.needDrain = !1, ue.emit("drain"))
    }

    function $(ue, me) {
        me.bufferProcessing = !0;
        var Se = me.bufferedRequest;
        if (ue._writev && Se && Se.next) {
            var Ce = me.bufferedRequestCount, Me = new Array(Ce), ve = me.corkedRequestsFree;
            ve.entry = Se;
            for (var ne = 0, be = !0; Se;) Me[ne] = Se, Se.isBuf || (be = !1), Se = Se.next, ne += 1;
            Me.allBuffers = be, D(ue, me, !0, me.length, Me, "", ve.finish), me.pendingcb++, me.lastBufferedRequest = null, ve.next ? (me.corkedRequestsFree = ve.next, ve.next = null) : me.corkedRequestsFree = new t(me), me.bufferedRequestCount = 0
        } else {
            for (; Se;) {
                var Ee = Se.chunk, Oe = Se.encoding, ze = Se.callback, Be = me.objectMode ? 1 : Ee.length;
                if (D(ue, me, !1, Be, Ee, Oe, ze), Se = Se.next, me.bufferedRequestCount--, me.writing) break
            }
            Se === null && (me.lastBufferedRequest = null)
        }
        me.bufferedRequest = Se, me.bufferProcessing = !1
    }

    G.prototype._write = function (ue, me, Se) {
        Se(new b("_write()"))
    }, G.prototype._writev = null, G.prototype.end = function (ue, me, Se) {
        var Ce = this._writableState;
        return typeof ue == "function" ? (Se = ue, ue = null, me = null) : typeof me == "function" && (Se = me, me = null), ue != null && this.write(ue, me), Ce.corked && (Ce.corked = 1, this.uncork()), Ce.ending || fe(this, Ce, Se), this
    }, Object.defineProperty(G.prototype, "writableLength", {
        enumerable: !1, get: function () {
            return this._writableState.length
        }
    });

    function C(ue) {
        return ue.ending && ue.length === 0 && ue.bufferedRequest === null && !ue.finished && !ue.writing
    }

    function R(ue, me) {
        ue._final(function (Se) {
            me.pendingcb--, Se && V(ue, Se), me.prefinished = !0, ue.emit("prefinish"), Q(ue, me)
        })
    }

    function k(ue, me) {
        !me.prefinished && !me.finalCalled && (typeof ue._final == "function" && !me.destroyed ? (me.pendingcb++, me.finalCalled = !0, Ve.nextTick(R, ue, me)) : (me.prefinished = !0, ue.emit("prefinish")))
    }

    function Q(ue, me) {
        var Se = C(me);
        if (Se && (k(ue, me), me.pendingcb === 0 && (me.finished = !0, ue.emit("finish"), me.autoDestroy))) {
            var Ce = ue._readableState;
            (!Ce || Ce.autoDestroy && Ce.endEmitted) && ue.destroy()
        }
        return Se
    }

    function fe(ue, me, Se) {
        me.ending = !0, Q(ue, me), Se && (me.finished ? Ve.nextTick(Se) : ue.once("finish", Se)), me.ended = !0, ue.writable = !1
    }

    function ye(ue, me, Se) {
        var Ce = ue.entry;
        for (ue.entry = null; Ce;) {
            var Me = Ce.callback;
            me.pendingcb--, Me(Se), Ce = Ce.next
        }
        me.corkedRequestsFree.next = ue
    }

    return Object.defineProperty(G.prototype, "destroyed", {
        enumerable: !1, get: function () {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        }, set: function (me) {
            this._writableState && (this._writableState.destroyed = me)
        }
    }), G.prototype.destroy = l.destroy, G.prototype._undestroy = l.undestroy, G.prototype._destroy = function (ue, me) {
        me(ue)
    }, ez
}

var tz, gce;

function O4() {
    if (gce) return tz;
    gce = 1;
    var t = Object.keys || function (f) {
        var d = [];
        for (var p in f) d.push(p);
        return d
    };
    tz = o;
    var e = bbe(), r = gbe();
    Xn(o, e);
    for (var n = t(r.prototype), i = 0; i < n.length; i++) {
        var a = n[i];
        o.prototype[a] || (o.prototype[a] = r.prototype[a])
    }

    function o(f) {
        if (!(this instanceof o)) return new o(f);
        e.call(this, f), r.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", s)))
    }

    Object.defineProperty(o.prototype, "writableHighWaterMark", {
        enumerable: !1, get: function () {
            return this._writableState.highWaterMark
        }
    }), Object.defineProperty(o.prototype, "writableBuffer", {
        enumerable: !1, get: function () {
            return this._writableState && this._writableState.getBuffer()
        }
    }), Object.defineProperty(o.prototype, "writableLength", {
        enumerable: !1, get: function () {
            return this._writableState.length
        }
    });

    function s() {
        this._writableState.ended || Ve.nextTick(l, this)
    }

    function l(f) {
        f.end()
    }

    return Object.defineProperty(o.prototype, "destroyed", {
        enumerable: !1, get: function () {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        }, set: function (d) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d)
        }
    }), tz
}

var eO = {}, nQ = Vn.Buffer, yce = nQ.isEncoding || function (t) {
    switch (t = "" + t, t && t.toLowerCase()) {
        case"hex":
        case"utf8":
        case"utf-8":
        case"ascii":
        case"binary":
        case"base64":
        case"ucs2":
        case"ucs-2":
        case"utf16le":
        case"utf-16le":
        case"raw":
            return !0;
        default:
            return !1
    }
};

function pJe(t) {
    if (!t) return "utf8";
    for (var e; ;) switch (t) {
        case"utf8":
        case"utf-8":
            return "utf8";
        case"ucs2":
        case"ucs-2":
        case"utf16le":
        case"utf-16le":
            return "utf16le";
        case"latin1":
        case"binary":
            return "latin1";
        case"base64":
        case"ascii":
        case"hex":
            return t;
        default:
            if (e) return;
            t = ("" + t).toLowerCase(), e = !0
    }
}

function mJe(t) {
    var e = pJe(t);
    if (typeof e != "string" && (nQ.isEncoding === yce || !yce(t))) throw new Error("Unknown encoding: " + t);
    return e || t
}

eO.StringDecoder = x8;

function x8(t) {
    this.encoding = mJe(t);
    var e;
    switch (this.encoding) {
        case"utf16le":
            this.text = SJe, this.end = _Je, e = 4;
            break;
        case"utf8":
            this.fillLast = yJe, e = 4;
            break;
        case"base64":
            this.text = xJe, this.end = EJe, e = 3;
            break;
        default:
            this.write = TJe, this.end = CJe;
            return
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = nQ.allocUnsafe(e)
}

x8.prototype.write = function (t) {
    if (t.length === 0) return "";
    var e, r;
    if (this.lastNeed) {
        if (e = this.fillLast(t), e === void 0) return "";
        r = this.lastNeed, this.lastNeed = 0
    } else r = 0;
    return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || ""
};
x8.prototype.end = wJe;
x8.prototype.text = bJe;
x8.prototype.fillLast = function (t) {
    if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length
};

function rz(t) {
    return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2
}

function vJe(t, e, r) {
    var n = e.length - 1;
    if (n < r) return 0;
    var i = rz(e[n]);
    return i >= 0 ? (i > 0 && (t.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = rz(e[n]), i >= 0 ? (i > 0 && (t.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = rz(e[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : t.lastNeed = i - 3), i) : 0))
}

function gJe(t, e, r) {
    if ((e[0] & 192) !== 128) return t.lastNeed = 0, "�";
    if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128) return t.lastNeed = 1, "�";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128) return t.lastNeed = 2, "�"
    }
}

function yJe(t) {
    var e = this.lastTotal - this.lastNeed, r = gJe(this, t);
    if (r !== void 0) return r;
    if (this.lastNeed <= t.length) return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length
}

function bJe(t, e) {
    var r = vJe(this, t, e);
    if (!this.lastNeed) return t.toString("utf8", e);
    this.lastTotal = r;
    var n = t.length - (r - this.lastNeed);
    return t.copy(this.lastChar, 0, n), t.toString("utf8", e, n)
}

function wJe(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + "�" : e
}

function SJe(t, e) {
    if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
            var n = r.charCodeAt(r.length - 1);
            if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1)
        }
        return r
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1)
}

function _Je(t) {
    var e = t && t.length ? this.write(t) : "";
    if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r)
    }
    return e
}

function xJe(t, e) {
    var r = (t.length - e) % 3;
    return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r))
}

function EJe(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e
}

function TJe(t) {
    return t.toString(this.encoding)
}

function CJe(t) {
    return t && t.length ? this.write(t) : ""
}

var bce = NS.codes.ERR_STREAM_PREMATURE_CLOSE;

function AJe(t) {
    var e = !1;
    return function () {
        if (!e) {
            e = !0;
            for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
            t.apply(this, n)
        }
    }
}

function IJe() {
}

function kJe(t) {
    return t.setHeader && typeof t.abort == "function"
}

function ybe(t, e, r) {
    if (typeof e == "function") return ybe(t, null, e);
    e || (e = {}), r = AJe(r || IJe);
    var n = e.readable || e.readable !== !1 && t.readable, i = e.writable || e.writable !== !1 && t.writable,
        a = function () {
            t.writable || s()
        }, o = t._writableState && t._writableState.finished, s = function () {
            i = !1, o = !0, n || r.call(t)
        }, l = t._readableState && t._readableState.endEmitted, f = function () {
            n = !1, l = !0, i || r.call(t)
        }, d = function (S) {
            r.call(t, S)
        }, p = function () {
            var S;
            if (n && !l) return (!t._readableState || !t._readableState.ended) && (S = new bce), r.call(t, S);
            if (i && !o) return (!t._writableState || !t._writableState.ended) && (S = new bce), r.call(t, S)
        }, g = function () {
            t.req.on("finish", s)
        };
    return kJe(t) ? (t.on("complete", s), t.on("abort", p), t.req ? g() : t.on("request", g)) : i && !t._writableState && (t.on("end", a), t.on("close", a)), t.on("end", f), t.on("finish", s), e.error !== !1 && t.on("error", d), t.on("close", p), function () {
        t.removeListener("complete", s), t.removeListener("abort", p), t.removeListener("request", g), t.req && t.req.removeListener("finish", s), t.removeListener("end", a), t.removeListener("close", a), t.removeListener("finish", s), t.removeListener("end", f), t.removeListener("error", d), t.removeListener("close", p)
    }
}

var iQ = ybe, nz, wce;

function RJe() {
    if (wce) return nz;
    wce = 1;
    var t;

    function e(F, V, Y) {
        return V = r(V), V in F ? Object.defineProperty(F, V, {
            value: Y,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : F[V] = Y, F
    }

    function r(F) {
        var V = n(F, "string");
        return typeof V == "symbol" ? V : String(V)
    }

    function n(F, V) {
        if (typeof F != "object" || F === null) return F;
        var Y = F[Symbol.toPrimitive];
        if (Y !== void 0) {
            var ee = Y.call(F, V || "default");
            if (typeof ee != "object") return ee;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (V === "string" ? String : Number)(F)
    }

    var i = iQ, a = Symbol("lastResolve"), o = Symbol("lastReject"), s = Symbol("error"), l = Symbol("ended"),
        f = Symbol("lastPromise"), d = Symbol("handlePromise"), p = Symbol("stream");

    function g(F, V) {
        return {value: F, done: V}
    }

    function b(F) {
        var V = F[a];
        if (V !== null) {
            var Y = F[p].read();
            Y !== null && (F[f] = null, F[a] = null, F[o] = null, V(g(Y, !1)))
        }
    }

    function S(F) {
        Ve.nextTick(b, F)
    }

    function T(F, V) {
        return function (Y, ee) {
            F.then(function () {
                if (V[l]) {
                    Y(g(void 0, !0));
                    return
                }
                V[d](Y, ee)
            }, ee)
        }
    }

    var I = Object.getPrototypeOf(function () {
    }), N = Object.setPrototypeOf((t = {
        get stream() {
            return this[p]
        }, next: function () {
            var V = this, Y = this[s];
            if (Y !== null) return Promise.reject(Y);
            if (this[l]) return Promise.resolve(g(void 0, !0));
            if (this[p].destroyed) return new Promise(function (J, ce) {
                Ve.nextTick(function () {
                    V[s] ? ce(V[s]) : J(g(void 0, !0))
                })
            });
            var ee = this[f], oe;
            if (ee) oe = new Promise(T(ee, this)); else {
                var G = this[p].read();
                if (G !== null) return Promise.resolve(g(G, !1));
                oe = new Promise(this[d])
            }
            return this[f] = oe, oe
        }
    }, e(t, Symbol.asyncIterator, function () {
        return this
    }), e(t, "return", function () {
        var V = this;
        return new Promise(function (Y, ee) {
            V[p].destroy(null, function (oe) {
                if (oe) {
                    ee(oe);
                    return
                }
                Y(g(void 0, !0))
            })
        })
    }), t), I), P = function (V) {
        var Y, ee = Object.create(N, (Y = {}, e(Y, p, {value: V, writable: !0}), e(Y, a, {
            value: null,
            writable: !0
        }), e(Y, o, {value: null, writable: !0}), e(Y, s, {
            value: null,
            writable: !0
        }), e(Y, l, {value: V._readableState.endEmitted, writable: !0}), e(Y, d, {
            value: function (G, J) {
                var ce = ee[p].read();
                ce ? (ee[f] = null, ee[a] = null, ee[o] = null, G(g(ce, !1))) : (ee[a] = G, ee[o] = J)
            }, writable: !0
        }), Y));
        return ee[f] = null, i(V, function (oe) {
            if (oe && oe.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var G = ee[o];
                G !== null && (ee[f] = null, ee[a] = null, ee[o] = null, G(oe)), ee[s] = oe;
                return
            }
            var J = ee[a];
            J !== null && (ee[f] = null, ee[a] = null, ee[o] = null, J(g(void 0, !0))), ee[l] = !0
        }), V.on("readable", S.bind(null, ee)), ee
    };
    return nz = P, nz
}

var iz, Sce;

function DJe() {
    return Sce || (Sce = 1, iz = function () {
        throw new Error("Readable.from is not available in the browser")
    }), iz
}

var az, _ce;

function bbe() {
    if (_ce) return az;
    _ce = 1, az = J;
    var t;
    J.ReadableState = G;
    var e = function (ne, be) {
            return ne.listeners(be).length
        }, r = hbe, n = qr.Buffer,
        i = (typeof tn < "u" ? tn : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function () {
        };

    function a(ve) {
        return n.from(ve)
    }

    function o(ve) {
        return n.isBuffer(ve) || ve instanceof i
    }

    var s = ME, l;
    s && s.debuglog ? l = s.debuglog("stream") : l = function () {
    };
    var f = tJe(), d = pbe, p = vbe, g = p.getHighWaterMark, b = NS.codes, S = b.ERR_INVALID_ARG_TYPE,
        T = b.ERR_STREAM_PUSH_AFTER_EOF, I = b.ERR_METHOD_NOT_IMPLEMENTED, N = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, P,
        F, V;
    Xn(J, r);
    var Y = d.errorOrDestroy, ee = ["error", "close", "destroy", "pause", "resume"];

    function oe(ve, ne, be) {
        if (typeof ve.prependListener == "function") return ve.prependListener(ne, be);
        !ve._events || !ve._events[ne] ? ve.on(ne, be) : Array.isArray(ve._events[ne]) ? ve._events[ne].unshift(be) : ve._events[ne] = [be, ve._events[ne]]
    }

    function G(ve, ne, be) {
        t = t || O4(), ve = ve || {}, typeof be != "boolean" && (be = ne instanceof t), this.objectMode = !!ve.objectMode, be && (this.objectMode = this.objectMode || !!ve.readableObjectMode), this.highWaterMark = g(this, ve, "readableHighWaterMark", be), this.buffer = new f, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ve.emitClose !== !1, this.autoDestroy = !!ve.autoDestroy, this.destroyed = !1, this.defaultEncoding = ve.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ve.encoding && (P || (P = eO.StringDecoder), this.decoder = new P(ve.encoding), this.encoding = ve.encoding)
    }

    function J(ve) {
        if (t = t || O4(), !(this instanceof J)) return new J(ve);
        var ne = this instanceof t;
        this._readableState = new G(ve, this, ne), this.readable = !0, ve && (typeof ve.read == "function" && (this._read = ve.read), typeof ve.destroy == "function" && (this._destroy = ve.destroy)), r.call(this)
    }

    Object.defineProperty(J.prototype, "destroyed", {
        enumerable: !1, get: function () {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        }, set: function (ne) {
            this._readableState && (this._readableState.destroyed = ne)
        }
    }), J.prototype.destroy = d.destroy, J.prototype._undestroy = d.undestroy, J.prototype._destroy = function (ve, ne) {
        ne(ve)
    }, J.prototype.push = function (ve, ne) {
        var be = this._readableState, Ee;
        return be.objectMode ? Ee = !0 : typeof ve == "string" && (ne = ne || be.defaultEncoding, ne !== be.encoding && (ve = n.from(ve, ne), ne = ""), Ee = !0), ce(this, ve, ne, !1, Ee)
    }, J.prototype.unshift = function (ve) {
        return ce(this, ve, null, !0, !1)
    };

    function ce(ve, ne, be, Ee, Oe) {
        l("readableAddChunk", ne);
        var ze = ve._readableState;
        if (ne === null) ze.reading = !1, B(ve, ze); else {
            var Be;
            if (Oe || (Be = M(ze, ne)), Be) Y(ve, Be); else if (ze.objectMode || ne && ne.length > 0) if (typeof ne != "string" && !ze.objectMode && Object.getPrototypeOf(ne) !== n.prototype && (ne = a(ne)), Ee) ze.endEmitted ? Y(ve, new N) : re(ve, ze, ne, !0); else if (ze.ended) Y(ve, new T); else {
                if (ze.destroyed) return !1;
                ze.reading = !1, ze.decoder && !be ? (ne = ze.decoder.write(ne), ze.objectMode || ne.length !== 0 ? re(ve, ze, ne, !1) : $(ve, ze)) : re(ve, ze, ne, !1)
            } else Ee || (ze.reading = !1, $(ve, ze))
        }
        return !ze.ended && (ze.length < ze.highWaterMark || ze.length === 0)
    }

    function re(ve, ne, be, Ee) {
        ne.flowing && ne.length === 0 && !ne.sync ? (ne.awaitDrain = 0, ve.emit("data", be)) : (ne.length += ne.objectMode ? 1 : be.length, Ee ? ne.buffer.unshift(be) : ne.buffer.push(be), ne.needReadable && z(ve)), $(ve, ne)
    }

    function M(ve, ne) {
        var be;
        return !o(ne) && typeof ne != "string" && ne !== void 0 && !ve.objectMode && (be = new S("chunk", ["string", "Buffer", "Uint8Array"], ne)), be
    }

    J.prototype.isPaused = function () {
        return this._readableState.flowing === !1
    }, J.prototype.setEncoding = function (ve) {
        P || (P = eO.StringDecoder);
        var ne = new P(ve);
        this._readableState.decoder = ne, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var be = this._readableState.buffer.head, Ee = ""; be !== null;) Ee += ne.write(be.data), be = be.next;
        return this._readableState.buffer.clear(), Ee !== "" && this._readableState.buffer.push(Ee), this._readableState.length = Ee.length, this
    };
    var D = 1073741824;

    function x(ve) {
        return ve >= D ? ve = D : (ve--, ve |= ve >>> 1, ve |= ve >>> 2, ve |= ve >>> 4, ve |= ve >>> 8, ve |= ve >>> 16, ve++), ve
    }

    function A(ve, ne) {
        return ve <= 0 || ne.length === 0 && ne.ended ? 0 : ne.objectMode ? 1 : ve !== ve ? ne.flowing && ne.length ? ne.buffer.head.data.length : ne.length : (ve > ne.highWaterMark && (ne.highWaterMark = x(ve)), ve <= ne.length ? ve : ne.ended ? ne.length : (ne.needReadable = !0, 0))
    }

    J.prototype.read = function (ve) {
        l("read", ve), ve = parseInt(ve, 10);
        var ne = this._readableState, be = ve;
        if (ve !== 0 && (ne.emittedReadable = !1), ve === 0 && ne.needReadable && ((ne.highWaterMark !== 0 ? ne.length >= ne.highWaterMark : ne.length > 0) || ne.ended)) return l("read: emitReadable", ne.length, ne.ended), ne.length === 0 && ne.ended ? Se(this) : z(this), null;
        if (ve = A(ve, ne), ve === 0 && ne.ended) return ne.length === 0 && Se(this), null;
        var Ee = ne.needReadable;
        l("need readable", Ee), (ne.length === 0 || ne.length - ve < ne.highWaterMark) && (Ee = !0, l("length less than watermark", Ee)), ne.ended || ne.reading ? (Ee = !1, l("reading or ended", Ee)) : Ee && (l("do read"), ne.reading = !0, ne.sync = !0, ne.length === 0 && (ne.needReadable = !0), this._read(ne.highWaterMark), ne.sync = !1, ne.reading || (ve = A(be, ne)));
        var Oe;
        return ve > 0 ? Oe = me(ve, ne) : Oe = null, Oe === null ? (ne.needReadable = ne.length <= ne.highWaterMark, ve = 0) : (ne.length -= ve, ne.awaitDrain = 0), ne.length === 0 && (ne.ended || (ne.needReadable = !0), be !== ve && ne.ended && Se(this)), Oe !== null && this.emit("data", Oe), Oe
    };

    function B(ve, ne) {
        if (l("onEofChunk"), !ne.ended) {
            if (ne.decoder) {
                var be = ne.decoder.end();
                be && be.length && (ne.buffer.push(be), ne.length += ne.objectMode ? 1 : be.length)
            }
            ne.ended = !0, ne.sync ? z(ve) : (ne.needReadable = !1, ne.emittedReadable || (ne.emittedReadable = !0, j(ve)))
        }
    }

    function z(ve) {
        var ne = ve._readableState;
        l("emitReadable", ne.needReadable, ne.emittedReadable), ne.needReadable = !1, ne.emittedReadable || (l("emitReadable", ne.flowing), ne.emittedReadable = !0, Ve.nextTick(j, ve))
    }

    function j(ve) {
        var ne = ve._readableState;
        l("emitReadable_", ne.destroyed, ne.length, ne.ended), !ne.destroyed && (ne.length || ne.ended) && (ve.emit("readable"), ne.emittedReadable = !1), ne.needReadable = !ne.flowing && !ne.ended && ne.length <= ne.highWaterMark, ue(ve)
    }

    function $(ve, ne) {
        ne.readingMore || (ne.readingMore = !0, Ve.nextTick(C, ve, ne))
    }

    function C(ve, ne) {
        for (; !ne.reading && !ne.ended && (ne.length < ne.highWaterMark || ne.flowing && ne.length === 0);) {
            var be = ne.length;
            if (l("maybeReadMore read 0"), ve.read(0), be === ne.length) break
        }
        ne.readingMore = !1
    }

    J.prototype._read = function (ve) {
        Y(this, new I("_read()"))
    }, J.prototype.pipe = function (ve, ne) {
        var be = this, Ee = this._readableState;
        switch (Ee.pipesCount) {
            case 0:
                Ee.pipes = ve;
                break;
            case 1:
                Ee.pipes = [Ee.pipes, ve];
                break;
            default:
                Ee.pipes.push(ve);
                break
        }
        Ee.pipesCount += 1, l("pipe count=%d opts=%j", Ee.pipesCount, ne);
        var Oe = (!ne || ne.end !== !1) && ve !== Ve.stdout && ve !== Ve.stderr, ze = Oe ? it : rr;
        Ee.endEmitted ? Ve.nextTick(ze) : be.once("end", ze), ve.on("unpipe", Be);

        function Be(pe, te) {
            l("onunpipe"), pe === be && te && te.hasUnpiped === !1 && (te.hasUnpiped = !0, gt())
        }

        function it() {
            l("onend"), ve.end()
        }

        var Ue = R(be);
        ve.on("drain", Ue);
        var bt = !1;

        function gt() {
            l("cleanup"), ve.removeListener("close", _t), ve.removeListener("finish", Dt), ve.removeListener("drain", Ue), ve.removeListener("error", zt), ve.removeListener("unpipe", Be), be.removeListener("end", it), be.removeListener("end", rr), be.removeListener("data", Ot), bt = !0, Ee.awaitDrain && (!ve._writableState || ve._writableState.needDrain) && Ue()
        }

        be.on("data", Ot);

        function Ot(pe) {
            l("ondata");
            var te = ve.write(pe);
            l("dest.write", te), te === !1 && ((Ee.pipesCount === 1 && Ee.pipes === ve || Ee.pipesCount > 1 && Me(Ee.pipes, ve) !== -1) && !bt && (l("false write response, pause", Ee.awaitDrain), Ee.awaitDrain++), be.pause())
        }

        function zt(pe) {
            l("onerror", pe), rr(), ve.removeListener("error", zt), e(ve, "error") === 0 && Y(ve, pe)
        }

        oe(ve, "error", zt);

        function _t() {
            ve.removeListener("finish", Dt), rr()
        }

        ve.once("close", _t);

        function Dt() {
            l("onfinish"), ve.removeListener("close", _t), rr()
        }

        ve.once("finish", Dt);

        function rr() {
            l("unpipe"), be.unpipe(ve)
        }

        return ve.emit("pipe", be), Ee.flowing || (l("pipe resume"), be.resume()), ve
    };

    function R(ve) {
        return function () {
            var be = ve._readableState;
            l("pipeOnDrain", be.awaitDrain), be.awaitDrain && be.awaitDrain--, be.awaitDrain === 0 && e(ve, "data") && (be.flowing = !0, ue(ve))
        }
    }

    J.prototype.unpipe = function (ve) {
        var ne = this._readableState, be = {hasUnpiped: !1};
        if (ne.pipesCount === 0) return this;
        if (ne.pipesCount === 1) return ve && ve !== ne.pipes ? this : (ve || (ve = ne.pipes), ne.pipes = null, ne.pipesCount = 0, ne.flowing = !1, ve && ve.emit("unpipe", this, be), this);
        if (!ve) {
            var Ee = ne.pipes, Oe = ne.pipesCount;
            ne.pipes = null, ne.pipesCount = 0, ne.flowing = !1;
            for (var ze = 0; ze < Oe; ze++) Ee[ze].emit("unpipe", this, {hasUnpiped: !1});
            return this
        }
        var Be = Me(ne.pipes, ve);
        return Be === -1 ? this : (ne.pipes.splice(Be, 1), ne.pipesCount -= 1, ne.pipesCount === 1 && (ne.pipes = ne.pipes[0]), ve.emit("unpipe", this, be), this)
    }, J.prototype.on = function (ve, ne) {
        var be = r.prototype.on.call(this, ve, ne), Ee = this._readableState;
        return ve === "data" ? (Ee.readableListening = this.listenerCount("readable") > 0, Ee.flowing !== !1 && this.resume()) : ve === "readable" && !Ee.endEmitted && !Ee.readableListening && (Ee.readableListening = Ee.needReadable = !0, Ee.flowing = !1, Ee.emittedReadable = !1, l("on readable", Ee.length, Ee.reading), Ee.length ? z(this) : Ee.reading || Ve.nextTick(Q, this)), be
    }, J.prototype.addListener = J.prototype.on, J.prototype.removeListener = function (ve, ne) {
        var be = r.prototype.removeListener.call(this, ve, ne);
        return ve === "readable" && Ve.nextTick(k, this), be
    }, J.prototype.removeAllListeners = function (ve) {
        var ne = r.prototype.removeAllListeners.apply(this, arguments);
        return (ve === "readable" || ve === void 0) && Ve.nextTick(k, this), ne
    };

    function k(ve) {
        var ne = ve._readableState;
        ne.readableListening = ve.listenerCount("readable") > 0, ne.resumeScheduled && !ne.paused ? ne.flowing = !0 : ve.listenerCount("data") > 0 && ve.resume()
    }

    function Q(ve) {
        l("readable nexttick read 0"), ve.read(0)
    }

    J.prototype.resume = function () {
        var ve = this._readableState;
        return ve.flowing || (l("resume"), ve.flowing = !ve.readableListening, fe(this, ve)), ve.paused = !1, this
    };

    function fe(ve, ne) {
        ne.resumeScheduled || (ne.resumeScheduled = !0, Ve.nextTick(ye, ve, ne))
    }

    function ye(ve, ne) {
        l("resume", ne.reading), ne.reading || ve.read(0), ne.resumeScheduled = !1, ve.emit("resume"), ue(ve), ne.flowing && !ne.reading && ve.read(0)
    }

    J.prototype.pause = function () {
        return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
    };

    function ue(ve) {
        var ne = ve._readableState;
        for (l("flow", ne.flowing); ne.flowing && ve.read() !== null;) ;
    }

    J.prototype.wrap = function (ve) {
        var ne = this, be = this._readableState, Ee = !1;
        ve.on("end", function () {
            if (l("wrapped end"), be.decoder && !be.ended) {
                var Be = be.decoder.end();
                Be && Be.length && ne.push(Be)
            }
            ne.push(null)
        }), ve.on("data", function (Be) {
            if (l("wrapped data"), be.decoder && (Be = be.decoder.write(Be)), !(be.objectMode && Be == null) && !(!be.objectMode && (!Be || !Be.length))) {
                var it = ne.push(Be);
                it || (Ee = !0, ve.pause())
            }
        });
        for (var Oe in ve) this[Oe] === void 0 && typeof ve[Oe] == "function" && (this[Oe] = function (it) {
            return function () {
                return ve[it].apply(ve, arguments)
            }
        }(Oe));
        for (var ze = 0; ze < ee.length; ze++) ve.on(ee[ze], this.emit.bind(this, ee[ze]));
        return this._read = function (Be) {
            l("wrapped _read", Be), Ee && (Ee = !1, ve.resume())
        }, this
    }, typeof Symbol == "function" && (J.prototype[Symbol.asyncIterator] = function () {
        return F === void 0 && (F = RJe()), F(this)
    }), Object.defineProperty(J.prototype, "readableHighWaterMark", {
        enumerable: !1, get: function () {
            return this._readableState.highWaterMark
        }
    }), Object.defineProperty(J.prototype, "readableBuffer", {
        enumerable: !1, get: function () {
            return this._readableState && this._readableState.buffer
        }
    }), Object.defineProperty(J.prototype, "readableFlowing", {
        enumerable: !1, get: function () {
            return this._readableState.flowing
        }, set: function (ne) {
            this._readableState && (this._readableState.flowing = ne)
        }
    }), J._fromList = me, Object.defineProperty(J.prototype, "readableLength", {
        enumerable: !1, get: function () {
            return this._readableState.length
        }
    });

    function me(ve, ne) {
        if (ne.length === 0) return null;
        var be;
        return ne.objectMode ? be = ne.buffer.shift() : !ve || ve >= ne.length ? (ne.decoder ? be = ne.buffer.join("") : ne.buffer.length === 1 ? be = ne.buffer.first() : be = ne.buffer.concat(ne.length), ne.buffer.clear()) : be = ne.buffer.consume(ve, ne.decoder), be
    }

    function Se(ve) {
        var ne = ve._readableState;
        l("endReadable", ne.endEmitted), ne.endEmitted || (ne.ended = !0, Ve.nextTick(Ce, ne, ve))
    }

    function Ce(ve, ne) {
        if (l("endReadableNT", ve.endEmitted, ve.length), !ve.endEmitted && ve.length === 0 && (ve.endEmitted = !0, ne.readable = !1, ne.emit("end"), ve.autoDestroy)) {
            var be = ne._writableState;
            (!be || be.autoDestroy && be.finished) && ne.destroy()
        }
    }

    typeof Symbol == "function" && (J.from = function (ve, ne) {
        return V === void 0 && (V = DJe()), V(J, ve, ne)
    });

    function Me(ve, ne) {
        for (var be = 0, Ee = ve.length; be < Ee; be++) if (ve[be] === ne) return be;
        return -1
    }

    return az
}

var wbe = Ov, ZP = NS.codes, MJe = ZP.ERR_METHOD_NOT_IMPLEMENTED, OJe = ZP.ERR_MULTIPLE_CALLBACK,
    PJe = ZP.ERR_TRANSFORM_ALREADY_TRANSFORMING, NJe = ZP.ERR_TRANSFORM_WITH_LENGTH_0, JP = O4();
Xn(Ov, JP);

function LJe(t, e) {
    var r = this._transformState;
    r.transforming = !1;
    var n = r.writecb;
    if (n === null) return this.emit("error", new OJe);
    r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t);
    var i = this._readableState;
    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
}

function Ov(t) {
    if (!(this instanceof Ov)) return new Ov(t);
    JP.call(this, t), this._transformState = {
        afterTransform: LJe.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", BJe)
}

function BJe() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function (e, r) {
        xce(t, e, r)
    }) : xce(this, null, null)
}

Ov.prototype.push = function (t, e) {
    return this._transformState.needTransform = !1, JP.prototype.push.call(this, t, e)
};
Ov.prototype._transform = function (t, e, r) {
    r(new MJe("_transform()"))
};
Ov.prototype._write = function (t, e, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
    }
};
Ov.prototype._read = function (t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0
};
Ov.prototype._destroy = function (t, e) {
    JP.prototype._destroy.call(this, t, function (r) {
        e(r)
    })
};

function xce(t, e, r) {
    if (e) return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length) throw new NJe;
    if (t._transformState.transforming) throw new PJe;
    return t.push(null)
}

var $Je = cA, Sbe = wbe;
Xn(cA, Sbe);

function cA(t) {
    if (!(this instanceof cA)) return new cA(t);
    Sbe.call(this, t)
}

cA.prototype._transform = function (t, e, r) {
    r(null, t)
};
var oz;

function FJe(t) {
    var e = !1;
    return function () {
        e || (e = !0, t.apply(void 0, arguments))
    }
}

var _be = NS.codes, UJe = _be.ERR_MISSING_ARGS, jJe = _be.ERR_STREAM_DESTROYED;

function Ece(t) {
    if (t) throw t
}

function zJe(t) {
    return t.setHeader && typeof t.abort == "function"
}

function VJe(t, e, r, n) {
    n = FJe(n);
    var i = !1;
    t.on("close", function () {
        i = !0
    }), oz === void 0 && (oz = iQ), oz(t, {readable: e, writable: r}, function (o) {
        if (o) return n(o);
        i = !0, n()
    });
    var a = !1;
    return function (o) {
        if (!i && !a) {
            if (a = !0, zJe(t)) return t.abort();
            if (typeof t.destroy == "function") return t.destroy();
            n(o || new jJe("pipe"))
        }
    }
}

function Tce(t) {
    t()
}

function HJe(t, e) {
    return t.pipe(e)
}

function WJe(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? Ece : t.pop()
}

function qJe() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
    var n = WJe(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new UJe("streams");
    var i, a = e.map(function (o, s) {
        var l = s < e.length - 1, f = s > 0;
        return VJe(o, l, f, function (d) {
            i || (i = d), d && a.forEach(Tce), !l && (a.forEach(Tce), n(i))
        })
    });
    return e.reduce(HJe)
}

var GJe = qJe;
(function (t, e) {
    e = t.exports = bbe(), e.Stream = e, e.Readable = e, e.Writable = gbe(), e.Duplex = O4(), e.Transform = wbe, e.PassThrough = $Je, e.finished = iQ, e.pipeline = GJe
})(Tq, Tq.exports);
var xbe = Tq.exports, tO = Vn.Buffer, Ebe = xbe.Transform, KJe = Xn;

function YJe(t, e) {
    if (!tO.isBuffer(t) && typeof t != "string") throw new TypeError(e + " must be a string or a buffer")
}

function y1(t) {
    Ebe.call(this), this._block = tO.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1
}

KJe(y1, Ebe);
y1.prototype._transform = function (t, e, r) {
    var n = null;
    try {
        this.update(t, e)
    } catch (i) {
        n = i
    }
    r(n)
};
y1.prototype._flush = function (t) {
    var e = null;
    try {
        this.push(this.digest())
    } catch (r) {
        e = r
    }
    t(e)
};
y1.prototype.update = function (t, e) {
    if (YJe(t, "Data"), this._finalized) throw new Error("Digest already called");
    tO.isBuffer(t) || (t = tO.from(t, e));
    for (var r = this._block, n = 0; this._blockOffset + t.length - n >= this._blockSize;) {
        for (var i = this._blockOffset; i < this._blockSize;) r[i++] = t[n++];
        this._update(), this._blockOffset = 0
    }
    for (; n < t.length;) r[this._blockOffset++] = t[n++];
    for (var a = 0, o = t.length * 8; o > 0; ++a) this._length[a] += o, o = this._length[a] / 4294967296 | 0, o > 0 && (this._length[a] -= 4294967296 * o);
    return this
};
y1.prototype._update = function () {
    throw new Error("_update is not implemented")
};
y1.prototype.digest = function (t) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var e = this._digest();
    t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r = 0; r < 4; ++r) this._length[r] = 0;
    return e
};
y1.prototype._digest = function () {
    throw new Error("_digest is not implemented")
};
var Tbe = y1, XJe = Xn, Cbe = Tbe, QJe = Vn.Buffer, ZJe = new Array(16);

function eN() {
    Cbe.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878
}

XJe(eN, Cbe);
eN.prototype._update = function () {
    for (var t = ZJe, e = 0; e < 16; ++e) t[e] = this._block.readInt32LE(e * 4);
    var r = this._a, n = this._b, i = this._c, a = this._d;
    r = fl(r, n, i, a, t[0], 3614090360, 7), a = fl(a, r, n, i, t[1], 3905402710, 12), i = fl(i, a, r, n, t[2], 606105819, 17), n = fl(n, i, a, r, t[3], 3250441966, 22), r = fl(r, n, i, a, t[4], 4118548399, 7), a = fl(a, r, n, i, t[5], 1200080426, 12), i = fl(i, a, r, n, t[6], 2821735955, 17), n = fl(n, i, a, r, t[7], 4249261313, 22), r = fl(r, n, i, a, t[8], 1770035416, 7), a = fl(a, r, n, i, t[9], 2336552879, 12), i = fl(i, a, r, n, t[10], 4294925233, 17), n = fl(n, i, a, r, t[11], 2304563134, 22), r = fl(r, n, i, a, t[12], 1804603682, 7), a = fl(a, r, n, i, t[13], 4254626195, 12), i = fl(i, a, r, n, t[14], 2792965006, 17), n = fl(n, i, a, r, t[15], 1236535329, 22), r = dl(r, n, i, a, t[1], 4129170786, 5), a = dl(a, r, n, i, t[6], 3225465664, 9), i = dl(i, a, r, n, t[11], 643717713, 14), n = dl(n, i, a, r, t[0], 3921069994, 20), r = dl(r, n, i, a, t[5], 3593408605, 5), a = dl(a, r, n, i, t[10], 38016083, 9), i = dl(i, a, r, n, t[15], 3634488961, 14), n = dl(n, i, a, r, t[4], 3889429448, 20), r = dl(r, n, i, a, t[9], 568446438, 5), a = dl(a, r, n, i, t[14], 3275163606, 9), i = dl(i, a, r, n, t[3], 4107603335, 14), n = dl(n, i, a, r, t[8], 1163531501, 20), r = dl(r, n, i, a, t[13], 2850285829, 5), a = dl(a, r, n, i, t[2], 4243563512, 9), i = dl(i, a, r, n, t[7], 1735328473, 14), n = dl(n, i, a, r, t[12], 2368359562, 20), r = hl(r, n, i, a, t[5], 4294588738, 4), a = hl(a, r, n, i, t[8], 2272392833, 11), i = hl(i, a, r, n, t[11], 1839030562, 16), n = hl(n, i, a, r, t[14], 4259657740, 23), r = hl(r, n, i, a, t[1], 2763975236, 4), a = hl(a, r, n, i, t[4], 1272893353, 11), i = hl(i, a, r, n, t[7], 4139469664, 16), n = hl(n, i, a, r, t[10], 3200236656, 23), r = hl(r, n, i, a, t[13], 681279174, 4), a = hl(a, r, n, i, t[0], 3936430074, 11), i = hl(i, a, r, n, t[3], 3572445317, 16), n = hl(n, i, a, r, t[6], 76029189, 23), r = hl(r, n, i, a, t[9], 3654602809, 4), a = hl(a, r, n, i, t[12], 3873151461, 11), i = hl(i, a, r, n, t[15], 530742520, 16), n = hl(n, i, a, r, t[2], 3299628645, 23), r = pl(r, n, i, a, t[0], 4096336452, 6), a = pl(a, r, n, i, t[7], 1126891415, 10), i = pl(i, a, r, n, t[14], 2878612391, 15), n = pl(n, i, a, r, t[5], 4237533241, 21), r = pl(r, n, i, a, t[12], 1700485571, 6), a = pl(a, r, n, i, t[3], 2399980690, 10), i = pl(i, a, r, n, t[10], 4293915773, 15), n = pl(n, i, a, r, t[1], 2240044497, 21), r = pl(r, n, i, a, t[8], 1873313359, 6), a = pl(a, r, n, i, t[15], 4264355552, 10), i = pl(i, a, r, n, t[6], 2734768916, 15), n = pl(n, i, a, r, t[13], 1309151649, 21), r = pl(r, n, i, a, t[4], 4149444226, 6), a = pl(a, r, n, i, t[11], 3174756917, 10), i = pl(i, a, r, n, t[2], 718787259, 15), n = pl(n, i, a, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + n | 0, this._c = this._c + i | 0, this._d = this._d + a | 0
};
eN.prototype._digest = function () {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = QJe.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t
};

function tN(t, e) {
    return t << e | t >>> 32 - e
}

function fl(t, e, r, n, i, a, o) {
    return tN(t + (e & r | ~e & n) + i + a | 0, o) + e | 0
}

function dl(t, e, r, n, i, a, o) {
    return tN(t + (e & n | r & ~n) + i + a | 0, o) + e | 0
}

function hl(t, e, r, n, i, a, o) {
    return tN(t + (e ^ r ^ n) + i + a | 0, o) + e | 0
}

function pl(t, e, r, n, i, a, o) {
    return tN(t + (r ^ (e | ~n)) + i + a | 0, o) + e | 0
}

var aQ = eN, sz = qr.Buffer, JJe = Xn, Abe = Tbe, eet = new Array(16),
    j5 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    z5 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
    V5 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
    H5 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
    W5 = [0, 1518500249, 1859775393, 2400959708, 2840853838], q5 = [1352829926, 1548603684, 1836072691, 2053994217, 0];

function rN() {
    Abe.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520
}

JJe(rN, Abe);
rN.prototype._update = function () {
    for (var t = eet, e = 0; e < 16; ++e) t[e] = this._block.readInt32LE(e * 4);
    for (var r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, o = this._e | 0, s = this._a | 0, l = this._b | 0, f = this._c | 0, d = this._d | 0, p = this._e | 0, g = 0; g < 80; g += 1) {
        var b, S;
        g < 16 ? (b = Cce(r, n, i, a, o, t[j5[g]], W5[0], V5[g]), S = Rce(s, l, f, d, p, t[z5[g]], q5[0], H5[g])) : g < 32 ? (b = Ace(r, n, i, a, o, t[j5[g]], W5[1], V5[g]), S = kce(s, l, f, d, p, t[z5[g]], q5[1], H5[g])) : g < 48 ? (b = Ice(r, n, i, a, o, t[j5[g]], W5[2], V5[g]), S = Ice(s, l, f, d, p, t[z5[g]], q5[2], H5[g])) : g < 64 ? (b = kce(r, n, i, a, o, t[j5[g]], W5[3], V5[g]), S = Ace(s, l, f, d, p, t[z5[g]], q5[3], H5[g])) : (b = Rce(r, n, i, a, o, t[j5[g]], W5[4], V5[g]), S = Cce(s, l, f, d, p, t[z5[g]], q5[4], H5[g])), r = o, o = a, a = cS(i, 10), i = n, n = b, s = p, p = d, d = cS(f, 10), f = l, l = S
    }
    var T = this._b + i + d | 0;
    this._b = this._c + a + p | 0, this._c = this._d + o + s | 0, this._d = this._e + r + l | 0, this._e = this._a + n + f | 0, this._a = T
};
rN.prototype._digest = function () {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = sz.alloc ? sz.alloc(20) : new sz(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t
};

function cS(t, e) {
    return t << e | t >>> 32 - e
}

function Cce(t, e, r, n, i, a, o, s) {
    return cS(t + (e ^ r ^ n) + a + o | 0, s) + i | 0
}

function Ace(t, e, r, n, i, a, o, s) {
    return cS(t + (e & r | ~e & n) + a + o | 0, s) + i | 0
}

function Ice(t, e, r, n, i, a, o, s) {
    return cS(t + ((e | ~r) ^ n) + a + o | 0, s) + i | 0
}

function kce(t, e, r, n, i, a, o, s) {
    return cS(t + (e & n | r & ~n) + a + o | 0, s) + i | 0
}

function Rce(t, e, r, n, i, a, o, s) {
    return cS(t + (e ^ (r | ~n)) + a + o | 0, s) + i | 0
}

var oQ = rN, Ibe = {exports: {}}, kbe = Vn.Buffer;

function nN(t, e) {
    this._block = kbe.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0
}

nN.prototype.update = function (t, e) {
    typeof t == "string" && (e = e || "utf8", t = kbe.from(t, e));
    for (var r = this._block, n = this._blockSize, i = t.length, a = this._len, o = 0; o < i;) {
        for (var s = a % n, l = Math.min(i - o, n - s), f = 0; f < l; f++) r[s + f] = t[o + f];
        a += l, o += l, a % n === 0 && this._update(r)
    }
    return this._len += i, this
};
nN.prototype.digest = function (t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r = this._len * 8;
    if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4); else {
        var n = (r & 4294967295) >>> 0, i = (r - n) / 4294967296;
        this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4)
    }
    this._update(this._block);
    var a = this._hash();
    return t ? a.toString(t) : a
};
nN.prototype._update = function () {
    throw new Error("_update must be implemented by subclass")
};
var UE = nN, tet = Xn, Rbe = UE, ret = Vn.Buffer, net = [1518500249, 1859775393, -1894007588, -899497514],
    iet = new Array(80);

function E8() {
    this.init(), this._w = iet, Rbe.call(this, 64, 56)
}

tet(E8, Rbe);
E8.prototype.init = function () {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
};

function aet(t) {
    return t << 5 | t >>> 27
}

function oet(t) {
    return t << 30 | t >>> 2
}

function set(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n
}

E8.prototype._update = function (t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, o = this._e | 0, s = 0; s < 16; ++s) e[s] = t.readInt32BE(s * 4);
    for (; s < 80; ++s) e[s] = e[s - 3] ^ e[s - 8] ^ e[s - 14] ^ e[s - 16];
    for (var l = 0; l < 80; ++l) {
        var f = ~~(l / 20), d = aet(r) + set(f, n, i, a) + o + e[l] + net[f] | 0;
        o = a, a = i, i = oet(n), n = r, r = d
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0
};
E8.prototype._hash = function () {
    var t = ret.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t
};
var cet = E8, uet = Xn, Dbe = UE, fet = Vn.Buffer, det = [1518500249, 1859775393, -1894007588, -899497514],
    het = new Array(80);

function T8() {
    this.init(), this._w = het, Dbe.call(this, 64, 56)
}

uet(T8, Dbe);
T8.prototype.init = function () {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
};

function pet(t) {
    return t << 1 | t >>> 31
}

function met(t) {
    return t << 5 | t >>> 27
}

function vet(t) {
    return t << 30 | t >>> 2
}

function get(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n
}

T8.prototype._update = function (t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, o = this._e | 0, s = 0; s < 16; ++s) e[s] = t.readInt32BE(s * 4);
    for (; s < 80; ++s) e[s] = pet(e[s - 3] ^ e[s - 8] ^ e[s - 14] ^ e[s - 16]);
    for (var l = 0; l < 80; ++l) {
        var f = ~~(l / 20), d = met(r) + get(f, n, i, a) + o + e[l] + det[f] | 0;
        o = a, a = i, i = vet(n), n = r, r = d
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0
};
T8.prototype._hash = function () {
    var t = fet.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t
};
var yet = T8, bet = Xn, Mbe = UE, wet = Vn.Buffer,
    _et = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
    xet = new Array(64);

function C8() {
    this.init(), this._w = xet, Mbe.call(this, 64, 56)
}

bet(C8, Mbe);
C8.prototype.init = function () {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this
};

function Eet(t, e, r) {
    return r ^ t & (e ^ r)
}

function Tet(t, e, r) {
    return t & e | r & (t | e)
}

function Cet(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10)
}

function Aet(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7)
}

function Iet(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3
}

function ket(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10
}

C8.prototype._update = function (t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, o = this._e | 0, s = this._f | 0, l = this._g | 0, f = this._h | 0, d = 0; d < 16; ++d) e[d] = t.readInt32BE(d * 4);
    for (; d < 64; ++d) e[d] = ket(e[d - 2]) + e[d - 7] + Iet(e[d - 15]) + e[d - 16] | 0;
    for (var p = 0; p < 64; ++p) {
        var g = f + Aet(o) + Eet(o, s, l) + _et[p] + e[p] | 0, b = Cet(r) + Tet(r, n, i) | 0;
        f = l, l = s, s = o, o = a + g | 0, a = i, i = n, n = r, r = g + b | 0
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = a + this._d | 0, this._e = o + this._e | 0, this._f = s + this._f | 0, this._g = l + this._g | 0, this._h = f + this._h | 0
};
C8.prototype._hash = function () {
    var t = wet.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t
};
var Obe = C8, Ret = Xn, Det = Obe, Met = UE, Oet = Vn.Buffer, Pet = new Array(64);

function iN() {
    this.init(), this._w = Pet, Met.call(this, 64, 56)
}

Ret(iN, Det);
iN.prototype.init = function () {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this
};
iN.prototype._hash = function () {
    var t = Oet.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t
};
var Net = iN, Let = Xn, Pbe = UE, Bet = Vn.Buffer,
    Dce = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
    $et = new Array(160);

function A8() {
    this.init(), this._w = $et, Pbe.call(this, 128, 112)
}

Let(A8, Pbe);
A8.prototype.init = function () {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this
};

function Mce(t, e, r) {
    return r ^ t & (e ^ r)
}

function Oce(t, e, r) {
    return t & e | r & (t | e)
}

function Pce(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25)
}

function Nce(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23)
}

function Fet(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7
}

function Uet(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25)
}

function jet(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6
}

function zet(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26)
}

function Gs(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0
}

A8.prototype._update = function (t) {
    for (var e = this._w, r = this._ah | 0, n = this._bh | 0, i = this._ch | 0, a = this._dh | 0, o = this._eh | 0, s = this._fh | 0, l = this._gh | 0, f = this._hh | 0, d = this._al | 0, p = this._bl | 0, g = this._cl | 0, b = this._dl | 0, S = this._el | 0, T = this._fl | 0, I = this._gl | 0, N = this._hl | 0, P = 0; P < 32; P += 2) e[P] = t.readInt32BE(P * 4), e[P + 1] = t.readInt32BE(P * 4 + 4);
    for (; P < 160; P += 2) {
        var F = e[P - 30], V = e[P - 15 * 2 + 1], Y = Fet(F, V), ee = Uet(V, F);
        F = e[P - 2 * 2], V = e[P - 2 * 2 + 1];
        var oe = jet(F, V), G = zet(V, F), J = e[P - 7 * 2], ce = e[P - 7 * 2 + 1], re = e[P - 16 * 2],
            M = e[P - 16 * 2 + 1], D = ee + ce | 0, x = Y + J + Gs(D, ee) | 0;
        D = D + G | 0, x = x + oe + Gs(D, G) | 0, D = D + M | 0, x = x + re + Gs(D, M) | 0, e[P] = x, e[P + 1] = D
    }
    for (var A = 0; A < 160; A += 2) {
        x = e[A], D = e[A + 1];
        var B = Oce(r, n, i), z = Oce(d, p, g), j = Pce(r, d), $ = Pce(d, r), C = Nce(o, S), R = Nce(S, o), k = Dce[A],
            Q = Dce[A + 1], fe = Mce(o, s, l), ye = Mce(S, T, I), ue = N + R | 0, me = f + C + Gs(ue, N) | 0;
        ue = ue + ye | 0, me = me + fe + Gs(ue, ye) | 0, ue = ue + Q | 0, me = me + k + Gs(ue, Q) | 0, ue = ue + D | 0, me = me + x + Gs(ue, D) | 0;
        var Se = $ + z | 0, Ce = j + B + Gs(Se, $) | 0;
        f = l, N = I, l = s, I = T, s = o, T = S, S = b + ue | 0, o = a + me + Gs(S, b) | 0, a = i, b = g, i = n, g = p, n = r, p = d, d = ue + Se | 0, r = me + Ce + Gs(d, ue) | 0
    }
    this._al = this._al + d | 0, this._bl = this._bl + p | 0, this._cl = this._cl + g | 0, this._dl = this._dl + b | 0, this._el = this._el + S | 0, this._fl = this._fl + T | 0, this._gl = this._gl + I | 0, this._hl = this._hl + N | 0, this._ah = this._ah + r + Gs(this._al, d) | 0, this._bh = this._bh + n + Gs(this._bl, p) | 0, this._ch = this._ch + i + Gs(this._cl, g) | 0, this._dh = this._dh + a + Gs(this._dl, b) | 0, this._eh = this._eh + o + Gs(this._el, S) | 0, this._fh = this._fh + s + Gs(this._fl, T) | 0, this._gh = this._gh + l + Gs(this._gl, I) | 0, this._hh = this._hh + f + Gs(this._hl, N) | 0
};
A8.prototype._hash = function () {
    var t = Bet.allocUnsafe(64);

    function e(r, n, i) {
        t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4)
    }

    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t
};
var Nbe = A8, Vet = Xn, Het = Nbe, Wet = UE, qet = Vn.Buffer, Get = new Array(160);

function aN() {
    this.init(), this._w = Get, Wet.call(this, 128, 112)
}

Vet(aN, Het);
aN.prototype.init = function () {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this
};
aN.prototype._hash = function () {
    var t = qet.allocUnsafe(48);

    function e(r, n, i) {
        t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4)
    }

    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t
};
var Ket = aN, LS = Ibe.exports = function (e) {
    e = e.toLowerCase();
    var r = LS[e];
    if (!r) throw new Error(e + " is not supported (we accept pull requests)");
    return new r
};
LS.sha = cet;
LS.sha1 = yet;
LS.sha224 = Net;
LS.sha256 = Obe;
LS.sha384 = Ket;
LS.sha512 = Nbe;
var sQ = Ibe.exports, Lbe = Vn.Buffer, Bbe = ME.Transform, Yet = eO.StringDecoder, Xet = Xn;

function wp(t) {
    Bbe.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null
}

Xet(wp, Bbe);
wp.prototype.update = function (t, e, r) {
    typeof t == "string" && (t = Lbe.from(t, e));
    var n = this._update(t);
    return this.hashMode ? this : (r && (n = this._toString(n, r)), n)
};
wp.prototype.setAutoPadding = function () {
};
wp.prototype.getAuthTag = function () {
    throw new Error("trying to get auth tag in unsupported state")
};
wp.prototype.setAuthTag = function () {
    throw new Error("trying to set auth tag in unsupported state")
};
wp.prototype.setAAD = function () {
    throw new Error("trying to set aad in unsupported state")
};
wp.prototype._transform = function (t, e, r) {
    var n;
    try {
        this.hashMode ? this._update(t) : this.push(this._update(t))
    } catch (i) {
        n = i
    } finally {
        r(n)
    }
};
wp.prototype._flush = function (t) {
    var e;
    try {
        this.push(this.__final())
    } catch (r) {
        e = r
    }
    t(e)
};
wp.prototype._finalOrDigest = function (t) {
    var e = this.__final() || Lbe.alloc(0);
    return t && (e = this._toString(e, t, !0)), e
};
wp.prototype._toString = function (t, e, r) {
    if (this._decoder || (this._decoder = new Yet(e), this._encoding = e), this._encoding !== e) throw new Error("can't switch encodings");
    var n = this._decoder.write(t);
    return r && (n += this._decoder.end()), n
};
var b1 = wp, Qet = Xn, Zet = aQ, Jet = oQ, ett = sQ, $be = b1;

function oN(t) {
    $be.call(this, "digest"), this._hash = t
}

Qet(oN, $be);
oN.prototype._update = function (t) {
    this._hash.update(t)
};
oN.prototype._final = function () {
    return this._hash.digest()
};
var I8 = function (e) {
    return e = e.toLowerCase(), e === "md5" ? new Zet : e === "rmd160" || e === "ripemd160" ? new Jet : new oN(ett(e))
}, ttt = Xn, _w = Vn.Buffer, Fbe = b1, rtt = _w.alloc(128), Y_ = 64;

function sN(t, e) {
    Fbe.call(this, "digest"), typeof e == "string" && (e = _w.from(e)), this._alg = t, this._key = e, e.length > Y_ ? e = t(e) : e.length < Y_ && (e = _w.concat([e, rtt], Y_));
    for (var r = this._ipad = _w.allocUnsafe(Y_), n = this._opad = _w.allocUnsafe(Y_), i = 0; i < Y_; i++) r[i] = e[i] ^ 54, n[i] = e[i] ^ 92;
    this._hash = [r]
}

ttt(sN, Fbe);
sN.prototype._update = function (t) {
    this._hash.push(t)
};
sN.prototype._final = function () {
    var t = this._alg(_w.concat(this._hash));
    return this._alg(_w.concat([this._opad, t]))
};
var ntt = sN, itt = aQ, Ube = function (t) {
    return new itt().update(t).digest()
}, att = Xn, ott = ntt, jbe = b1, xT = Vn.Buffer, stt = Ube, Aq = oQ, Iq = sQ, ctt = xT.alloc(128);

function lA(t, e) {
    jbe.call(this, "digest"), typeof e == "string" && (e = xT.from(e));
    var r = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r) {
        var n = t === "rmd160" ? new Aq : Iq(t);
        e = n.update(e).digest()
    } else e.length < r && (e = xT.concat([e, ctt], r));
    for (var i = this._ipad = xT.allocUnsafe(r), a = this._opad = xT.allocUnsafe(r), o = 0; o < r; o++) i[o] = e[o] ^ 54, a[o] = e[o] ^ 92;
    this._hash = t === "rmd160" ? new Aq : Iq(t), this._hash.update(i)
}

att(lA, jbe);
lA.prototype._update = function (t) {
    this._hash.update(t)
};
lA.prototype._final = function () {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new Aq : Iq(this._alg);
    return e.update(this._opad).update(t).digest()
};
var zbe = function (e, r) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new lA("rmd160", r) : e === "md5" ? new ott(stt, r) : new lA(e, r)
};
const ltt = {sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c"},
    utt = {sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420"},
    ftt = {sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430"},
    dtt = {sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440"},
    htt = {sign: "ecdsa", hash: "sha256", id: ""}, ptt = {sign: "ecdsa", hash: "sha224", id: ""},
    mtt = {sign: "ecdsa", hash: "sha384", id: ""}, vtt = {sign: "ecdsa", hash: "sha512", id: ""},
    gtt = {sign: "dsa", hash: "sha1", id: ""},
    ytt = {sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414"},
    btt = {sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410"}, Vbe = {
        sha224WithRSAEncryption: ltt,
        "RSA-SHA224": {sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c"},
        sha256WithRSAEncryption: utt,
        "RSA-SHA256": {sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420"},
        sha384WithRSAEncryption: ftt,
        "RSA-SHA384": {sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430"},
        sha512WithRSAEncryption: dtt,
        "RSA-SHA512": {sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440"},
        "RSA-SHA1": {sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414"},
        "ecdsa-with-SHA1": {sign: "ecdsa", hash: "sha1", id: ""},
        sha256: htt,
        sha224: ptt,
        sha384: mtt,
        sha512: vtt,
        "DSA-SHA": {sign: "dsa", hash: "sha1", id: ""},
        "DSA-SHA1": {sign: "dsa", hash: "sha1", id: ""},
        DSA: gtt,
        "DSA-WITH-SHA224": {sign: "dsa", hash: "sha224", id: ""},
        "DSA-SHA224": {sign: "dsa", hash: "sha224", id: ""},
        "DSA-WITH-SHA256": {sign: "dsa", hash: "sha256", id: ""},
        "DSA-SHA256": {sign: "dsa", hash: "sha256", id: ""},
        "DSA-WITH-SHA384": {sign: "dsa", hash: "sha384", id: ""},
        "DSA-SHA384": {sign: "dsa", hash: "sha384", id: ""},
        "DSA-WITH-SHA512": {sign: "dsa", hash: "sha512", id: ""},
        "DSA-SHA512": {sign: "dsa", hash: "sha512", id: ""},
        "DSA-RIPEMD160": {sign: "dsa", hash: "rmd160", id: ""},
        ripemd160WithRSA: ytt,
        "RSA-RIPEMD160": {sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414"},
        md5WithRSAEncryption: btt,
        "RSA-MD5": {sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410"}
    };
var wtt = Vbe, cN = {}, Stt = Math.pow(2, 30) - 1, Hbe = function (t, e) {
    if (typeof t != "number") throw new TypeError("Iterations not a number");
    if (t < 0) throw new TypeError("Bad iterations");
    if (typeof e != "number") throw new TypeError("Key length not a number");
    if (e < 0 || e > Stt || e !== e) throw new TypeError("Bad key length")
}, _D;
if (tn.process && tn.process.browser) _D = "utf-8"; else if (tn.process && tn.process.version) {
    var _tt = parseInt(Ve.version.split(".")[0].slice(1), 10);
    _D = _tt >= 6 ? "utf-8" : "binary"
} else _D = "utf-8";
var Wbe = _D, cz = Vn.Buffer, qbe = function (t, e, r) {
        if (cz.isBuffer(t)) return t;
        if (typeof t == "string") return cz.from(t, e);
        if (ArrayBuffer.isView(t)) return cz.from(t.buffer);
        throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView")
    }, xtt = Ube, Ett = oQ, Ttt = sQ, xw = Vn.Buffer, Ctt = Hbe, Lce = Wbe, Bce = qbe, Att = xw.alloc(128),
    xD = {md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20};

function Gbe(t, e, r) {
    var n = Itt(t), i = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > i ? e = n(e) : e.length < i && (e = xw.concat([e, Att], i));
    for (var a = xw.allocUnsafe(i + xD[t]), o = xw.allocUnsafe(i + xD[t]), s = 0; s < i; s++) a[s] = e[s] ^ 54, o[s] = e[s] ^ 92;
    var l = xw.allocUnsafe(i + r + 4);
    a.copy(l, 0, 0, i), this.ipad1 = l, this.ipad2 = a, this.opad = o, this.alg = t, this.blocksize = i, this.hash = n, this.size = xD[t]
}

Gbe.prototype.run = function (t, e) {
    t.copy(e, this.blocksize);
    var r = this.hash(e);
    return r.copy(this.opad, this.blocksize), this.hash(this.opad)
};

function Itt(t) {
    function e(n) {
        return Ttt(t).update(n).digest()
    }

    function r(n) {
        return new Ett().update(n).digest()
    }

    return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? xtt : e
}

function ktt(t, e, r, n, i) {
    Ctt(r, n), t = Bce(t, Lce, "Password"), e = Bce(e, Lce, "Salt"), i = i || "sha1";
    var a = new Gbe(i, t, e.length), o = xw.allocUnsafe(n), s = xw.allocUnsafe(e.length + 4);
    e.copy(s, 0, 0, e.length);
    for (var l = 0, f = xD[i], d = Math.ceil(n / f), p = 1; p <= d; p++) {
        s.writeUInt32BE(p, e.length);
        for (var g = a.run(s, a.ipad1), b = g, S = 1; S < r; S++) {
            b = a.run(b, a.ipad2);
            for (var T = 0; T < f; T++) g[T] ^= b[T]
        }
        g.copy(o, l), l += f
    }
    return o
}

var Kbe = ktt, Ybe = Vn.Buffer, Rtt = Hbe, $ce = Wbe, Fce = Kbe, Uce = qbe, e7, JT = tn.crypto && tn.crypto.subtle,
    Dtt = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, lz = [];

function Mtt(t) {
    if (tn.process && !tn.process.browser || !JT || !JT.importKey || !JT.deriveBits) return Promise.resolve(!1);
    if (lz[t] !== void 0) return lz[t];
    e7 = e7 || Ybe.alloc(8);
    var e = Xbe(e7, e7, 10, 128, t).then(function () {
        return !0
    }).catch(function () {
        return !1
    });
    return lz[t] = e, e
}

var qb;

function kq() {
    return qb || (tn.process && tn.process.nextTick ? qb = tn.process.nextTick : tn.queueMicrotask ? qb = tn.queueMicrotask : tn.setImmediate ? qb = tn.setImmediate : qb = tn.setTimeout, qb)
}

function Xbe(t, e, r, n, i) {
    return JT.importKey("raw", t, {name: "PBKDF2"}, !1, ["deriveBits"]).then(function (a) {
        return JT.deriveBits({name: "PBKDF2", salt: e, iterations: r, hash: {name: i}}, a, n << 3)
    }).then(function (a) {
        return Ybe.from(a)
    })
}

function Ott(t, e) {
    t.then(function (r) {
        kq()(function () {
            e(null, r)
        })
    }, function (r) {
        kq()(function () {
            e(r)
        })
    })
}

var Ptt = function (t, e, r, n, i, a) {
    typeof i == "function" && (a = i, i = void 0), i = i || "sha1";
    var o = Dtt[i.toLowerCase()];
    if (!o || typeof tn.Promise != "function") {
        kq()(function () {
            var s;
            try {
                s = Fce(t, e, r, n, i)
            } catch (l) {
                return a(l)
            }
            a(null, s)
        });
        return
    }
    if (Rtt(r, n), t = Uce(t, $ce, "Password"), e = Uce(e, $ce, "Salt"), typeof a != "function") throw new Error("No callback provided to pbkdf2");
    Ott(Mtt(o).then(function (s) {
        return s ? Xbe(t, e, r, n, o) : Fce(t, e, r, n, i)
    }), a)
};
cN.pbkdf2 = Ptt;
cN.pbkdf2Sync = Kbe;
var hp = {}, jE = {}, Zf = {};
Zf.readUInt32BE = function (e, r) {
    var n = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
    return n >>> 0
};
Zf.writeUInt32BE = function (e, r, n) {
    e[0 + n] = r >>> 24, e[1 + n] = r >>> 16 & 255, e[2 + n] = r >>> 8 & 255, e[3 + n] = r & 255
};
Zf.ip = function (e, r, n, i) {
    for (var a = 0, o = 0, s = 6; s >= 0; s -= 2) {
        for (var l = 0; l <= 24; l += 8) a <<= 1, a |= r >>> l + s & 1;
        for (var l = 0; l <= 24; l += 8) a <<= 1, a |= e >>> l + s & 1
    }
    for (var s = 6; s >= 0; s -= 2) {
        for (var l = 1; l <= 25; l += 8) o <<= 1, o |= r >>> l + s & 1;
        for (var l = 1; l <= 25; l += 8) o <<= 1, o |= e >>> l + s & 1
    }
    n[i + 0] = a >>> 0, n[i + 1] = o >>> 0
};
Zf.rip = function (e, r, n, i) {
    for (var a = 0, o = 0, s = 0; s < 4; s++) for (var l = 24; l >= 0; l -= 8) a <<= 1, a |= r >>> l + s & 1, a <<= 1, a |= e >>> l + s & 1;
    for (var s = 4; s < 8; s++) for (var l = 24; l >= 0; l -= 8) o <<= 1, o |= r >>> l + s & 1, o <<= 1, o |= e >>> l + s & 1;
    n[i + 0] = a >>> 0, n[i + 1] = o >>> 0
};
Zf.pc1 = function (e, r, n, i) {
    for (var a = 0, o = 0, s = 7; s >= 5; s--) {
        for (var l = 0; l <= 24; l += 8) a <<= 1, a |= r >> l + s & 1;
        for (var l = 0; l <= 24; l += 8) a <<= 1, a |= e >> l + s & 1
    }
    for (var l = 0; l <= 24; l += 8) a <<= 1, a |= r >> l + s & 1;
    for (var s = 1; s <= 3; s++) {
        for (var l = 0; l <= 24; l += 8) o <<= 1, o |= r >> l + s & 1;
        for (var l = 0; l <= 24; l += 8) o <<= 1, o |= e >> l + s & 1
    }
    for (var l = 0; l <= 24; l += 8) o <<= 1, o |= e >> l + s & 1;
    n[i + 0] = a >>> 0, n[i + 1] = o >>> 0
};
Zf.r28shl = function (e, r) {
    return e << r & 268435455 | e >>> 28 - r
};
var t7 = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
Zf.pc2 = function (e, r, n, i) {
    for (var a = 0, o = 0, s = t7.length >>> 1, l = 0; l < s; l++) a <<= 1, a |= e >>> t7[l] & 1;
    for (var l = s; l < t7.length; l++) o <<= 1, o |= r >>> t7[l] & 1;
    n[i + 0] = a >>> 0, n[i + 1] = o >>> 0
};
Zf.expand = function (e, r, n) {
    var i = 0, a = 0;
    i = (e & 1) << 5 | e >>> 27;
    for (var o = 23; o >= 15; o -= 4) i <<= 6, i |= e >>> o & 63;
    for (var o = 11; o >= 3; o -= 4) a |= e >>> o & 63, a <<= 6;
    a |= (e & 31) << 1 | e >>> 31, r[n + 0] = i >>> 0, r[n + 1] = a >>> 0
};
var jce = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
Zf.substitute = function (e, r) {
    for (var n = 0, i = 0; i < 4; i++) {
        var a = e >>> 18 - i * 6 & 63, o = jce[i * 64 + a];
        n <<= 4, n |= o
    }
    for (var i = 0; i < 4; i++) {
        var a = r >>> 18 - i * 6 & 63, o = jce[4 * 64 + i * 64 + a];
        n <<= 4, n |= o
    }
    return n >>> 0
};
var zce = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
Zf.permute = function (e) {
    for (var r = 0, n = 0; n < zce.length; n++) r <<= 1, r |= e >>> zce[n] & 1;
    return r >>> 0
};
Zf.padSplit = function (e, r, n) {
    for (var i = e.toString(2); i.length < r;) i = "0" + i;
    for (var a = [], o = 0; o < r; o += n) a.push(i.slice(o, o + n));
    return a.join(" ")
};
var nh = Qbe;

function Qbe(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}

Qbe.equal = function (e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var Ntt = nh;

function ih(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== !1
}

var cQ = ih;
ih.prototype._init = function () {
};
ih.prototype.update = function (e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e)
};
ih.prototype._buffer = function (e, r) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, e.length - r), i = 0; i < n; i++) this.buffer[this.bufferOff + i] = e[r + i];
    return this.bufferOff += n, n
};
ih.prototype._flushBuffer = function (e, r) {
    return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize
};
ih.prototype._updateEncrypt = function (e) {
    var r = 0, n = 0, i = (this.bufferOff + e.length) / this.blockSize | 0, a = new Array(i * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (n += this._flushBuffer(a, n)));
    for (var o = e.length - (e.length - r) % this.blockSize; r < o; r += this.blockSize) this._update(e, r, a, n), n += this.blockSize;
    for (; r < e.length; r++, this.bufferOff++) this.buffer[this.bufferOff] = e[r];
    return a
};
ih.prototype._updateDecrypt = function (e) {
    for (var r = 0, n = 0, i = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, a = new Array(i * this.blockSize); i > 0; i--) r += this._buffer(e, r), n += this._flushBuffer(a, n);
    return r += this._buffer(e, r), a
};
ih.prototype.final = function (e) {
    var r;
    e && (r = this.update(e));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), r ? r.concat(n) : n
};
ih.prototype._pad = function (e, r) {
    if (r === 0) return !1;
    for (; r < e.length;) e[r++] = 0;
    return !0
};
ih.prototype._finalEncrypt = function () {
    if (!this._pad(this.buffer, this.bufferOff)) return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e
};
ih.prototype._unpad = function (e) {
    return e
};
ih.prototype._finalDecrypt = function () {
    Ntt.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e)
};
var Zbe = nh, Ltt = Xn, Rs = Zf, Jbe = cQ;

function Btt() {
    this.tmp = new Array(2), this.keys = null
}

function z0(t) {
    Jbe.call(this, t);
    var e = new Btt;
    this._desState = e, this.deriveKeys(e, t.key)
}

Ltt(z0, Jbe);
var ewe = z0;
z0.create = function (e) {
    return new z0(e)
};
var $tt = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
z0.prototype.deriveKeys = function (e, r) {
    e.keys = new Array(16 * 2), Zbe.equal(r.length, this.blockSize, "Invalid key length");
    var n = Rs.readUInt32BE(r, 0), i = Rs.readUInt32BE(r, 4);
    Rs.pc1(n, i, e.tmp, 0), n = e.tmp[0], i = e.tmp[1];
    for (var a = 0; a < e.keys.length; a += 2) {
        var o = $tt[a >>> 1];
        n = Rs.r28shl(n, o), i = Rs.r28shl(i, o), Rs.pc2(n, i, e.keys, a)
    }
};
z0.prototype._update = function (e, r, n, i) {
    var a = this._desState, o = Rs.readUInt32BE(e, r), s = Rs.readUInt32BE(e, r + 4);
    Rs.ip(o, s, a.tmp, 0), o = a.tmp[0], s = a.tmp[1], this.type === "encrypt" ? this._encrypt(a, o, s, a.tmp, 0) : this._decrypt(a, o, s, a.tmp, 0), o = a.tmp[0], s = a.tmp[1], Rs.writeUInt32BE(n, o, i), Rs.writeUInt32BE(n, s, i + 4)
};
z0.prototype._pad = function (e, r) {
    if (this.padding === !1) return !1;
    for (var n = e.length - r, i = r; i < e.length; i++) e[i] = n;
    return !0
};
z0.prototype._unpad = function (e) {
    if (this.padding === !1) return e;
    for (var r = e[e.length - 1], n = e.length - r; n < e.length; n++) Zbe.equal(e[n], r);
    return e.slice(0, e.length - r)
};
z0.prototype._encrypt = function (e, r, n, i, a) {
    for (var o = r, s = n, l = 0; l < e.keys.length; l += 2) {
        var f = e.keys[l], d = e.keys[l + 1];
        Rs.expand(s, e.tmp, 0), f ^= e.tmp[0], d ^= e.tmp[1];
        var p = Rs.substitute(f, d), g = Rs.permute(p), b = s;
        s = (o ^ g) >>> 0, o = b
    }
    Rs.rip(s, o, i, a)
};
z0.prototype._decrypt = function (e, r, n, i, a) {
    for (var o = n, s = r, l = e.keys.length - 2; l >= 0; l -= 2) {
        var f = e.keys[l], d = e.keys[l + 1];
        Rs.expand(o, e.tmp, 0), f ^= e.tmp[0], d ^= e.tmp[1];
        var p = Rs.substitute(f, d), g = Rs.permute(p), b = o;
        o = (s ^ g) >>> 0, s = b
    }
    Rs.rip(o, s, i, a)
};
var twe = {}, Ftt = nh, Utt = Xn, rO = {};

function jtt(t) {
    Ftt.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0; e < this.iv.length; e++) this.iv[e] = t[e]
}

function ztt(t) {
    function e(a) {
        t.call(this, a), this._cbcInit()
    }

    Utt(e, t);
    for (var r = Object.keys(rO), n = 0; n < r.length; n++) {
        var i = r[n];
        e.prototype[i] = rO[i]
    }
    return e.create = function (o) {
        return new e(o)
    }, e
}

twe.instantiate = ztt;
rO._cbcInit = function () {
    var e = new jtt(this.options.iv);
    this._cbcState = e
};
rO._update = function (e, r, n, i) {
    var a = this._cbcState, o = this.constructor.super_.prototype, s = a.iv;
    if (this.type === "encrypt") {
        for (var l = 0; l < this.blockSize; l++) s[l] ^= e[r + l];
        o._update.call(this, s, 0, n, i);
        for (var l = 0; l < this.blockSize; l++) s[l] = n[i + l]
    } else {
        o._update.call(this, e, r, n, i);
        for (var l = 0; l < this.blockSize; l++) n[i + l] ^= s[l];
        for (var l = 0; l < this.blockSize; l++) s[l] = e[r + l]
    }
};
var Vtt = nh, Htt = Xn, rwe = cQ, gy = ewe;

function Wtt(t, e) {
    Vtt.equal(e.length, 24, "Invalid key length");
    var r = e.slice(0, 8), n = e.slice(8, 16), i = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [gy.create({type: "encrypt", key: r}), gy.create({
        type: "decrypt",
        key: n
    }), gy.create({type: "encrypt", key: i})] : this.ciphers = [gy.create({
        type: "decrypt",
        key: i
    }), gy.create({type: "encrypt", key: n}), gy.create({type: "decrypt", key: r})]
}

function lS(t) {
    rwe.call(this, t);
    var e = new Wtt(this.type, this.options.key);
    this._edeState = e
}

Htt(lS, rwe);
var qtt = lS;
lS.create = function (e) {
    return new lS(e)
};
lS.prototype._update = function (e, r, n, i) {
    var a = this._edeState;
    a.ciphers[0]._update(e, r, n, i), a.ciphers[1]._update(n, i, n, i), a.ciphers[2]._update(n, i, n, i)
};
lS.prototype._pad = gy.prototype._pad;
lS.prototype._unpad = gy.prototype._unpad;
jE.utils = Zf;
jE.Cipher = cQ;
jE.DES = ewe;
jE.CBC = twe;
jE.EDE = qtt;
var nwe = b1, Zm = jE, Gtt = Xn, fw = Vn.Buffer, uA = {
    "des-ede3-cbc": Zm.CBC.instantiate(Zm.EDE),
    "des-ede3": Zm.EDE,
    "des-ede-cbc": Zm.CBC.instantiate(Zm.EDE),
    "des-ede": Zm.EDE,
    "des-cbc": Zm.CBC.instantiate(Zm.DES),
    "des-ecb": Zm.DES
};
uA.des = uA["des-cbc"];
uA.des3 = uA["des-ede3-cbc"];
var Ktt = lN;
Gtt(lN, nwe);

function lN(t) {
    nwe.call(this);
    var e = t.mode.toLowerCase(), r = uA[e], n;
    t.decrypt ? n = "decrypt" : n = "encrypt";
    var i = t.key;
    fw.isBuffer(i) || (i = fw.from(i)), (e === "des-ede" || e === "des-ede-cbc") && (i = fw.concat([i, i.slice(0, 8)]));
    var a = t.iv;
    fw.isBuffer(a) || (a = fw.from(a)), this._des = r.create({key: i, iv: a, type: n})
}

lN.prototype._update = function (t) {
    return fw.from(this._des.update(t))
};
lN.prototype._final = function () {
    return fw.from(this._des.final())
};
var qf = {}, lQ = {}, uQ = {};
uQ.encrypt = function (t, e) {
    return t._cipher.encryptBlock(e)
};
uQ.decrypt = function (t, e) {
    return t._cipher.decryptBlock(e)
};
var fQ = {}, iwe = {}, uN = {};
uN.byteLength = Qtt;
uN.toByteArray = Jtt;
uN.fromByteArray = rrt;
var w0 = [], Bd = [], Ytt = typeof Uint8Array < "u" ? Uint8Array : Array,
    uz = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var X_ = 0, Xtt = uz.length; X_ < Xtt; ++X_) w0[X_] = uz[X_], Bd[uz.charCodeAt(X_)] = X_;
Bd[45] = 62;
Bd[95] = 63;

function awe(t) {
    var e = t.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t.indexOf("=");
    r === -1 && (r = e);
    var n = r === e ? 0 : 4 - r % 4;
    return [r, n]
}

function Qtt(t) {
    var e = awe(t), r = e[0], n = e[1];
    return (r + n) * 3 / 4 - n
}

function Ztt(t, e, r) {
    return (e + r) * 3 / 4 - r
}

function Jtt(t) {
    var e, r = awe(t), n = r[0], i = r[1], a = new Ytt(Ztt(t, n, i)), o = 0, s = i > 0 ? n - 4 : n, l;
    for (l = 0; l < s; l += 4) e = Bd[t.charCodeAt(l)] << 18 | Bd[t.charCodeAt(l + 1)] << 12 | Bd[t.charCodeAt(l + 2)] << 6 | Bd[t.charCodeAt(l + 3)], a[o++] = e >> 16 & 255, a[o++] = e >> 8 & 255, a[o++] = e & 255;
    return i === 2 && (e = Bd[t.charCodeAt(l)] << 2 | Bd[t.charCodeAt(l + 1)] >> 4, a[o++] = e & 255), i === 1 && (e = Bd[t.charCodeAt(l)] << 10 | Bd[t.charCodeAt(l + 1)] << 4 | Bd[t.charCodeAt(l + 2)] >> 2, a[o++] = e >> 8 & 255, a[o++] = e & 255), a
}

function ert(t) {
    return w0[t >> 18 & 63] + w0[t >> 12 & 63] + w0[t >> 6 & 63] + w0[t & 63]
}

function trt(t, e, r) {
    for (var n, i = [], a = e; a < r; a += 3) n = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (t[a + 2] & 255), i.push(ert(n));
    return i.join("")
}

function rrt(t) {
    for (var e, r = t.length, n = r % 3, i = [], a = 16383, o = 0, s = r - n; o < s; o += a) i.push(trt(t, o, o + a > s ? s : o + a));
    return n === 1 ? (e = t[r - 1], i.push(w0[e >> 2] + w0[e << 4 & 63] + "==")) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(w0[e >> 10] + w0[e >> 4 & 63] + w0[e << 2 & 63] + "=")), i.join("")
}

var dQ = {};
dQ.read = function (t, e, r, n, i) {
    var a, o, s = i * 8 - n - 1, l = (1 << s) - 1, f = l >> 1, d = -7, p = r ? i - 1 : 0, g = r ? -1 : 1, b = t[e + p];
    for (p += g, a = b & (1 << -d) - 1, b >>= -d, d += s; d > 0; a = a * 256 + t[e + p], p += g, d -= 8) ;
    for (o = a & (1 << -d) - 1, a >>= -d, d += n; d > 0; o = o * 256 + t[e + p], p += g, d -= 8) ;
    if (a === 0) a = 1 - f; else {
        if (a === l) return o ? NaN : (b ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, n), a = a - f
    }
    return (b ? -1 : 1) * o * Math.pow(2, a - n)
};
dQ.write = function (t, e, r, n, i, a) {
    var o, s, l, f = a * 8 - i - 1, d = (1 << f) - 1, p = d >> 1,
        g = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, b = n ? 0 : a - 1, S = n ? 1 : -1,
        T = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = d) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + p >= 1 ? e += g / l : e += g * Math.pow(2, 1 - p), e * l >= 2 && (o++, l /= 2), o + p >= d ? (s = 0, o = d) : o + p >= 1 ? (s = (e * l - 1) * Math.pow(2, i), o = o + p) : (s = e * Math.pow(2, p - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + b] = s & 255, b += S, s /= 256, i -= 8) ;
    for (o = o << i | s, f += i; f > 0; t[r + b] = o & 255, b += S, o /= 256, f -= 8) ;
    t[r + b - S] |= T * 128
};
(function (t) {
    const e = uN, r = dQ,
        n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = d, t.SlowBuffer = Y, t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i;
    const {Uint8Array: a, ArrayBuffer: o, SharedArrayBuffer: s} = globalThis;
    d.TYPED_ARRAY_SUPPORT = l(), !d.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function l() {
        try {
            const H = new a(1), U = {
                foo: function () {
                    return 42
                }
            };
            return Object.setPrototypeOf(U, a.prototype), Object.setPrototypeOf(H, U), H.foo() === 42
        } catch {
            return !1
        }
    }

    Object.defineProperty(d.prototype, "parent", {
        enumerable: !0, get: function () {
            if (d.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(d.prototype, "offset", {
        enumerable: !0, get: function () {
            if (d.isBuffer(this)) return this.byteOffset
        }
    });

    function f(H) {
        if (H > i) throw new RangeError('The value "' + H + '" is invalid for option "size"');
        const U = new a(H);
        return Object.setPrototypeOf(U, d.prototype), U
    }

    function d(H, U, q) {
        if (typeof H == "number") {
            if (typeof U == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return S(H)
        }
        return p(H, U, q)
    }

    d.poolSize = 8192;

    function p(H, U, q) {
        if (typeof H == "string") return T(H, U);
        if (o.isView(H)) return N(H);
        if (H == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof H);
        if (Dt(H, o) || H && Dt(H.buffer, o) || typeof s < "u" && (Dt(H, s) || H && Dt(H.buffer, s))) return P(H, U, q);
        if (typeof H == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const le = H.valueOf && H.valueOf();
        if (le != null && le !== H) return d.from(le, U, q);
        const xe = F(H);
        if (xe) return xe;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof H[Symbol.toPrimitive] == "function") return d.from(H[Symbol.toPrimitive]("string"), U, q);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof H)
    }

    d.from = function (H, U, q) {
        return p(H, U, q)
    }, Object.setPrototypeOf(d.prototype, a.prototype), Object.setPrototypeOf(d, a);

    function g(H) {
        if (typeof H != "number") throw new TypeError('"size" argument must be of type number');
        if (H < 0) throw new RangeError('The value "' + H + '" is invalid for option "size"')
    }

    function b(H, U, q) {
        return g(H), H <= 0 ? f(H) : U !== void 0 ? typeof q == "string" ? f(H).fill(U, q) : f(H).fill(U) : f(H)
    }

    d.alloc = function (H, U, q) {
        return b(H, U, q)
    };

    function S(H) {
        return g(H), f(H < 0 ? 0 : V(H) | 0)
    }

    d.allocUnsafe = function (H) {
        return S(H)
    }, d.allocUnsafeSlow = function (H) {
        return S(H)
    };

    function T(H, U) {
        if ((typeof U != "string" || U === "") && (U = "utf8"), !d.isEncoding(U)) throw new TypeError("Unknown encoding: " + U);
        const q = ee(H, U) | 0;
        let le = f(q);
        const xe = le.write(H, U);
        return xe !== q && (le = le.slice(0, xe)), le
    }

    function I(H) {
        const U = H.length < 0 ? 0 : V(H.length) | 0, q = f(U);
        for (let le = 0; le < U; le += 1) q[le] = H[le] & 255;
        return q
    }

    function N(H) {
        if (Dt(H, a)) {
            const U = new a(H);
            return P(U.buffer, U.byteOffset, U.byteLength)
        }
        return I(H)
    }

    function P(H, U, q) {
        if (U < 0 || H.byteLength < U) throw new RangeError('"offset" is outside of buffer bounds');
        if (H.byteLength < U + (q || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let le;
        return U === void 0 && q === void 0 ? le = new a(H) : q === void 0 ? le = new a(H, U) : le = new a(H, U, q), Object.setPrototypeOf(le, d.prototype), le
    }

    function F(H) {
        if (d.isBuffer(H)) {
            const U = V(H.length) | 0, q = f(U);
            return q.length === 0 || H.copy(q, 0, 0, U), q
        }
        if (H.length !== void 0) return typeof H.length != "number" || rr(H.length) ? f(0) : I(H);
        if (H.type === "Buffer" && Array.isArray(H.data)) return I(H.data)
    }

    function V(H) {
        if (H >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return H | 0
    }

    function Y(H) {
        return +H != H && (H = 0), d.alloc(+H)
    }

    d.isBuffer = function (U) {
        return U != null && U._isBuffer === !0 && U !== d.prototype
    }, d.compare = function (U, q) {
        if (Dt(U, a) && (U = d.from(U, U.offset, U.byteLength)), Dt(q, a) && (q = d.from(q, q.offset, q.byteLength)), !d.isBuffer(U) || !d.isBuffer(q)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (U === q) return 0;
        let le = U.length, xe = q.length;
        for (let Ae = 0, De = Math.min(le, xe); Ae < De; ++Ae) if (U[Ae] !== q[Ae]) {
            le = U[Ae], xe = q[Ae];
            break
        }
        return le < xe ? -1 : xe < le ? 1 : 0
    }, d.isEncoding = function (U) {
        switch (String(U).toLowerCase()) {
            case"hex":
            case"utf8":
            case"utf-8":
            case"ascii":
            case"latin1":
            case"binary":
            case"base64":
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return !0;
            default:
                return !1
        }
    }, d.concat = function (U, q) {
        if (!Array.isArray(U)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (U.length === 0) return d.alloc(0);
        let le;
        if (q === void 0) for (q = 0, le = 0; le < U.length; ++le) q += U[le].length;
        const xe = d.allocUnsafe(q);
        let Ae = 0;
        for (le = 0; le < U.length; ++le) {
            let De = U[le];
            if (Dt(De, a)) Ae + De.length > xe.length ? (d.isBuffer(De) || (De = d.from(De)), De.copy(xe, Ae)) : a.prototype.set.call(xe, De, Ae); else if (d.isBuffer(De)) De.copy(xe, Ae); else throw new TypeError('"list" argument must be an Array of Buffers');
            Ae += De.length
        }
        return xe
    };

    function ee(H, U) {
        if (d.isBuffer(H)) return H.length;
        if (o.isView(H) || Dt(H, o)) return H.byteLength;
        if (typeof H != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof H);
        const q = H.length, le = arguments.length > 2 && arguments[2] === !0;
        if (!le && q === 0) return 0;
        let xe = !1;
        for (; ;) switch (U) {
            case"ascii":
            case"latin1":
            case"binary":
                return q;
            case"utf8":
            case"utf-8":
                return bt(H).length;
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return q * 2;
            case"hex":
                return q >>> 1;
            case"base64":
                return zt(H).length;
            default:
                if (xe) return le ? -1 : bt(H).length;
                U = ("" + U).toLowerCase(), xe = !0
        }
    }

    d.byteLength = ee;

    function oe(H, U, q) {
        let le = !1;
        if ((U === void 0 || U < 0) && (U = 0), U > this.length || ((q === void 0 || q > this.length) && (q = this.length), q <= 0) || (q >>>= 0, U >>>= 0, q <= U)) return "";
        for (H || (H = "utf8"); ;) switch (H) {
            case"hex":
                return k(this, U, q);
            case"utf8":
            case"utf-8":
                return z(this, U, q);
            case"ascii":
                return C(this, U, q);
            case"latin1":
            case"binary":
                return R(this, U, q);
            case"base64":
                return B(this, U, q);
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return Q(this, U, q);
            default:
                if (le) throw new TypeError("Unknown encoding: " + H);
                H = (H + "").toLowerCase(), le = !0
        }
    }

    d.prototype._isBuffer = !0;

    function G(H, U, q) {
        const le = H[U];
        H[U] = H[q], H[q] = le
    }

    d.prototype.swap16 = function () {
        const U = this.length;
        if (U % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let q = 0; q < U; q += 2) G(this, q, q + 1);
        return this
    }, d.prototype.swap32 = function () {
        const U = this.length;
        if (U % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let q = 0; q < U; q += 4) G(this, q, q + 3), G(this, q + 1, q + 2);
        return this
    }, d.prototype.swap64 = function () {
        const U = this.length;
        if (U % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let q = 0; q < U; q += 8) G(this, q, q + 7), G(this, q + 1, q + 6), G(this, q + 2, q + 5), G(this, q + 3, q + 4);
        return this
    }, d.prototype.toString = function () {
        const U = this.length;
        return U === 0 ? "" : arguments.length === 0 ? z(this, 0, U) : oe.apply(this, arguments)
    }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function (U) {
        if (!d.isBuffer(U)) throw new TypeError("Argument must be a Buffer");
        return this === U ? !0 : d.compare(this, U) === 0
    }, d.prototype.inspect = function () {
        let U = "";
        const q = t.INSPECT_MAX_BYTES;
        return U = this.toString("hex", 0, q).replace(/(.{2})/g, "$1 ").trim(), this.length > q && (U += " ... "), "<Buffer " + U + ">"
    }, n && (d.prototype[n] = d.prototype.inspect), d.prototype.compare = function (U, q, le, xe, Ae) {
        if (Dt(U, a) && (U = d.from(U, U.offset, U.byteLength)), !d.isBuffer(U)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof U);
        if (q === void 0 && (q = 0), le === void 0 && (le = U ? U.length : 0), xe === void 0 && (xe = 0), Ae === void 0 && (Ae = this.length), q < 0 || le > U.length || xe < 0 || Ae > this.length) throw new RangeError("out of range index");
        if (xe >= Ae && q >= le) return 0;
        if (xe >= Ae) return -1;
        if (q >= le) return 1;
        if (q >>>= 0, le >>>= 0, xe >>>= 0, Ae >>>= 0, this === U) return 0;
        let De = Ae - xe, Ze = le - q;
        const ft = Math.min(De, Ze), ht = this.slice(xe, Ae), cr = U.slice(q, le);
        for (let Rt = 0; Rt < ft; ++Rt) if (ht[Rt] !== cr[Rt]) {
            De = ht[Rt], Ze = cr[Rt];
            break
        }
        return De < Ze ? -1 : Ze < De ? 1 : 0
    };

    function J(H, U, q, le, xe) {
        if (H.length === 0) return -1;
        if (typeof q == "string" ? (le = q, q = 0) : q > 2147483647 ? q = 2147483647 : q < -2147483648 && (q = -2147483648), q = +q, rr(q) && (q = xe ? 0 : H.length - 1), q < 0 && (q = H.length + q), q >= H.length) {
            if (xe) return -1;
            q = H.length - 1
        } else if (q < 0) if (xe) q = 0; else return -1;
        if (typeof U == "string" && (U = d.from(U, le)), d.isBuffer(U)) return U.length === 0 ? -1 : ce(H, U, q, le, xe);
        if (typeof U == "number") return U = U & 255, typeof a.prototype.indexOf == "function" ? xe ? a.prototype.indexOf.call(H, U, q) : a.prototype.lastIndexOf.call(H, U, q) : ce(H, [U], q, le, xe);
        throw new TypeError("val must be string, number or Buffer")
    }

    function ce(H, U, q, le, xe) {
        let Ae = 1, De = H.length, Ze = U.length;
        if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
            if (H.length < 2 || U.length < 2) return -1;
            Ae = 2, De /= 2, Ze /= 2, q /= 2
        }

        function ft(cr, Rt) {
            return Ae === 1 ? cr[Rt] : cr.readUInt16BE(Rt * Ae)
        }

        let ht;
        if (xe) {
            let cr = -1;
            for (ht = q; ht < De; ht++) if (ft(H, ht) === ft(U, cr === -1 ? 0 : ht - cr)) {
                if (cr === -1 && (cr = ht), ht - cr + 1 === Ze) return cr * Ae
            } else cr !== -1 && (ht -= ht - cr), cr = -1
        } else for (q + Ze > De && (q = De - Ze), ht = q; ht >= 0; ht--) {
            let cr = !0;
            for (let Rt = 0; Rt < Ze; Rt++) if (ft(H, ht + Rt) !== ft(U, Rt)) {
                cr = !1;
                break
            }
            if (cr) return ht
        }
        return -1
    }

    d.prototype.includes = function (U, q, le) {
        return this.indexOf(U, q, le) !== -1
    }, d.prototype.indexOf = function (U, q, le) {
        return J(this, U, q, le, !0)
    }, d.prototype.lastIndexOf = function (U, q, le) {
        return J(this, U, q, le, !1)
    };

    function re(H, U, q, le) {
        q = Number(q) || 0;
        const xe = H.length - q;
        le ? (le = Number(le), le > xe && (le = xe)) : le = xe;
        const Ae = U.length;
        le > Ae / 2 && (le = Ae / 2);
        let De;
        for (De = 0; De < le; ++De) {
            const Ze = parseInt(U.substr(De * 2, 2), 16);
            if (rr(Ze)) return De;
            H[q + De] = Ze
        }
        return De
    }

    function M(H, U, q, le) {
        return _t(bt(U, H.length - q), H, q, le)
    }

    function D(H, U, q, le) {
        return _t(gt(U), H, q, le)
    }

    function x(H, U, q, le) {
        return _t(zt(U), H, q, le)
    }

    function A(H, U, q, le) {
        return _t(Ot(U, H.length - q), H, q, le)
    }

    d.prototype.write = function (U, q, le, xe) {
        if (q === void 0) xe = "utf8", le = this.length, q = 0; else if (le === void 0 && typeof q == "string") xe = q, le = this.length, q = 0; else if (isFinite(q)) q = q >>> 0, isFinite(le) ? (le = le >>> 0, xe === void 0 && (xe = "utf8")) : (xe = le, le = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Ae = this.length - q;
        if ((le === void 0 || le > Ae) && (le = Ae), U.length > 0 && (le < 0 || q < 0) || q > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        xe || (xe = "utf8");
        let De = !1;
        for (; ;) switch (xe) {
            case"hex":
                return re(this, U, q, le);
            case"utf8":
            case"utf-8":
                return M(this, U, q, le);
            case"ascii":
            case"latin1":
            case"binary":
                return D(this, U, q, le);
            case"base64":
                return x(this, U, q, le);
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
                return A(this, U, q, le);
            default:
                if (De) throw new TypeError("Unknown encoding: " + xe);
                xe = ("" + xe).toLowerCase(), De = !0
        }
    }, d.prototype.toJSON = function () {
        return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
    };

    function B(H, U, q) {
        return U === 0 && q === H.length ? e.fromByteArray(H) : e.fromByteArray(H.slice(U, q))
    }

    function z(H, U, q) {
        q = Math.min(H.length, q);
        const le = [];
        let xe = U;
        for (; xe < q;) {
            const Ae = H[xe];
            let De = null, Ze = Ae > 239 ? 4 : Ae > 223 ? 3 : Ae > 191 ? 2 : 1;
            if (xe + Ze <= q) {
                let ft, ht, cr, Rt;
                switch (Ze) {
                    case 1:
                        Ae < 128 && (De = Ae);
                        break;
                    case 2:
                        ft = H[xe + 1], (ft & 192) === 128 && (Rt = (Ae & 31) << 6 | ft & 63, Rt > 127 && (De = Rt));
                        break;
                    case 3:
                        ft = H[xe + 1], ht = H[xe + 2], (ft & 192) === 128 && (ht & 192) === 128 && (Rt = (Ae & 15) << 12 | (ft & 63) << 6 | ht & 63, Rt > 2047 && (Rt < 55296 || Rt > 57343) && (De = Rt));
                        break;
                    case 4:
                        ft = H[xe + 1], ht = H[xe + 2], cr = H[xe + 3], (ft & 192) === 128 && (ht & 192) === 128 && (cr & 192) === 128 && (Rt = (Ae & 15) << 18 | (ft & 63) << 12 | (ht & 63) << 6 | cr & 63, Rt > 65535 && Rt < 1114112 && (De = Rt))
                }
            }
            De === null ? (De = 65533, Ze = 1) : De > 65535 && (De -= 65536, le.push(De >>> 10 & 1023 | 55296), De = 56320 | De & 1023), le.push(De), xe += Ze
        }
        return $(le)
    }

    const j = 4096;

    function $(H) {
        const U = H.length;
        if (U <= j) return String.fromCharCode.apply(String, H);
        let q = "", le = 0;
        for (; le < U;) q += String.fromCharCode.apply(String, H.slice(le, le += j));
        return q
    }

    function C(H, U, q) {
        let le = "";
        q = Math.min(H.length, q);
        for (let xe = U; xe < q; ++xe) le += String.fromCharCode(H[xe] & 127);
        return le
    }

    function R(H, U, q) {
        let le = "";
        q = Math.min(H.length, q);
        for (let xe = U; xe < q; ++xe) le += String.fromCharCode(H[xe]);
        return le
    }

    function k(H, U, q) {
        const le = H.length;
        (!U || U < 0) && (U = 0), (!q || q < 0 || q > le) && (q = le);
        let xe = "";
        for (let Ae = U; Ae < q; ++Ae) xe += pe[H[Ae]];
        return xe
    }

    function Q(H, U, q) {
        const le = H.slice(U, q);
        let xe = "";
        for (let Ae = 0; Ae < le.length - 1; Ae += 2) xe += String.fromCharCode(le[Ae] + le[Ae + 1] * 256);
        return xe
    }

    d.prototype.slice = function (U, q) {
        const le = this.length;
        U = ~~U, q = q === void 0 ? le : ~~q, U < 0 ? (U += le, U < 0 && (U = 0)) : U > le && (U = le), q < 0 ? (q += le, q < 0 && (q = 0)) : q > le && (q = le), q < U && (q = U);
        const xe = this.subarray(U, q);
        return Object.setPrototypeOf(xe, d.prototype), xe
    };

    function fe(H, U, q) {
        if (H % 1 !== 0 || H < 0) throw new RangeError("offset is not uint");
        if (H + U > q) throw new RangeError("Trying to access beyond buffer length")
    }

    d.prototype.readUintLE = d.prototype.readUIntLE = function (U, q, le) {
        U = U >>> 0, q = q >>> 0, le || fe(U, q, this.length);
        let xe = this[U], Ae = 1, De = 0;
        for (; ++De < q && (Ae *= 256);) xe += this[U + De] * Ae;
        return xe
    }, d.prototype.readUintBE = d.prototype.readUIntBE = function (U, q, le) {
        U = U >>> 0, q = q >>> 0, le || fe(U, q, this.length);
        let xe = this[U + --q], Ae = 1;
        for (; q > 0 && (Ae *= 256);) xe += this[U + --q] * Ae;
        return xe
    }, d.prototype.readUint8 = d.prototype.readUInt8 = function (U, q) {
        return U = U >>> 0, q || fe(U, 1, this.length), this[U]
    }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function (U, q) {
        return U = U >>> 0, q || fe(U, 2, this.length), this[U] | this[U + 1] << 8
    }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function (U, q) {
        return U = U >>> 0, q || fe(U, 2, this.length), this[U] << 8 | this[U + 1]
    }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function (U, q) {
        return U = U >>> 0, q || fe(U, 4, this.length), (this[U] | this[U + 1] << 8 | this[U + 2] << 16) + this[U + 3] * 16777216
    }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function (U, q) {
        return U = U >>> 0, q || fe(U, 4, this.length), this[U] * 16777216 + (this[U + 1] << 16 | this[U + 2] << 8 | this[U + 3])
    }, d.prototype.readBigUInt64LE = te(function (U) {
        U = U >>> 0, ze(U, "offset");
        const q = this[U], le = this[U + 7];
        (q === void 0 || le === void 0) && Be(U, this.length - 8);
        const xe = q + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + this[++U] * 2 ** 24,
            Ae = this[++U] + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + le * 2 ** 24;
        return BigInt(xe) + (BigInt(Ae) << BigInt(32))
    }), d.prototype.readBigUInt64BE = te(function (U) {
        U = U >>> 0, ze(U, "offset");
        const q = this[U], le = this[U + 7];
        (q === void 0 || le === void 0) && Be(U, this.length - 8);
        const xe = q * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + this[++U],
            Ae = this[++U] * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + le;
        return (BigInt(xe) << BigInt(32)) + BigInt(Ae)
    }), d.prototype.readIntLE = function (U, q, le) {
        U = U >>> 0, q = q >>> 0, le || fe(U, q, this.length);
        let xe = this[U], Ae = 1, De = 0;
        for (; ++De < q && (Ae *= 256);) xe += this[U + De] * Ae;
        return Ae *= 128, xe >= Ae && (xe -= Math.pow(2, 8 * q)), xe
    }, d.prototype.readIntBE = function (U, q, le) {
        U = U >>> 0, q = q >>> 0, le || fe(U, q, this.length);
        let xe = q, Ae = 1, De = this[U + --xe];
        for (; xe > 0 && (Ae *= 256);) De += this[U + --xe] * Ae;
        return Ae *= 128, De >= Ae && (De -= Math.pow(2, 8 * q)), De
    }, d.prototype.readInt8 = function (U, q) {
        return U = U >>> 0, q || fe(U, 1, this.length), this[U] & 128 ? (255 - this[U] + 1) * -1 : this[U]
    }, d.prototype.readInt16LE = function (U, q) {
        U = U >>> 0, q || fe(U, 2, this.length);
        const le = this[U] | this[U + 1] << 8;
        return le & 32768 ? le | 4294901760 : le
    }, d.prototype.readInt16BE = function (U, q) {
        U = U >>> 0, q || fe(U, 2, this.length);
        const le = this[U + 1] | this[U] << 8;
        return le & 32768 ? le | 4294901760 : le
    }, d.prototype.readInt32LE = function (U, q) {
        return U = U >>> 0, q || fe(U, 4, this.length), this[U] | this[U + 1] << 8 | this[U + 2] << 16 | this[U + 3] << 24
    }, d.prototype.readInt32BE = function (U, q) {
        return U = U >>> 0, q || fe(U, 4, this.length), this[U] << 24 | this[U + 1] << 16 | this[U + 2] << 8 | this[U + 3]
    }, d.prototype.readBigInt64LE = te(function (U) {
        U = U >>> 0, ze(U, "offset");
        const q = this[U], le = this[U + 7];
        (q === void 0 || le === void 0) && Be(U, this.length - 8);
        const xe = this[U + 4] + this[U + 5] * 2 ** 8 + this[U + 6] * 2 ** 16 + (le << 24);
        return (BigInt(xe) << BigInt(32)) + BigInt(q + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + this[++U] * 2 ** 24)
    }), d.prototype.readBigInt64BE = te(function (U) {
        U = U >>> 0, ze(U, "offset");
        const q = this[U], le = this[U + 7];
        (q === void 0 || le === void 0) && Be(U, this.length - 8);
        const xe = (q << 24) + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + this[++U];
        return (BigInt(xe) << BigInt(32)) + BigInt(this[++U] * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + le)
    }), d.prototype.readFloatLE = function (U, q) {
        return U = U >>> 0, q || fe(U, 4, this.length), r.read(this, U, !0, 23, 4)
    }, d.prototype.readFloatBE = function (U, q) {
        return U = U >>> 0, q || fe(U, 4, this.length), r.read(this, U, !1, 23, 4)
    }, d.prototype.readDoubleLE = function (U, q) {
        return U = U >>> 0, q || fe(U, 8, this.length), r.read(this, U, !0, 52, 8)
    }, d.prototype.readDoubleBE = function (U, q) {
        return U = U >>> 0, q || fe(U, 8, this.length), r.read(this, U, !1, 52, 8)
    };

    function ye(H, U, q, le, xe, Ae) {
        if (!d.isBuffer(H)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (U > xe || U < Ae) throw new RangeError('"value" argument is out of bounds');
        if (q + le > H.length) throw new RangeError("Index out of range")
    }

    d.prototype.writeUintLE = d.prototype.writeUIntLE = function (U, q, le, xe) {
        if (U = +U, q = q >>> 0, le = le >>> 0, !xe) {
            const Ze = Math.pow(2, 8 * le) - 1;
            ye(this, U, q, le, Ze, 0)
        }
        let Ae = 1, De = 0;
        for (this[q] = U & 255; ++De < le && (Ae *= 256);) this[q + De] = U / Ae & 255;
        return q + le
    }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function (U, q, le, xe) {
        if (U = +U, q = q >>> 0, le = le >>> 0, !xe) {
            const Ze = Math.pow(2, 8 * le) - 1;
            ye(this, U, q, le, Ze, 0)
        }
        let Ae = le - 1, De = 1;
        for (this[q + Ae] = U & 255; --Ae >= 0 && (De *= 256);) this[q + Ae] = U / De & 255;
        return q + le
    }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 1, 255, 0), this[q] = U & 255, q + 1
    }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 2, 65535, 0), this[q] = U & 255, this[q + 1] = U >>> 8, q + 2
    }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 2, 65535, 0), this[q] = U >>> 8, this[q + 1] = U & 255, q + 2
    }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 4, 4294967295, 0), this[q + 3] = U >>> 24, this[q + 2] = U >>> 16, this[q + 1] = U >>> 8, this[q] = U & 255, q + 4
    }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 4, 4294967295, 0), this[q] = U >>> 24, this[q + 1] = U >>> 16, this[q + 2] = U >>> 8, this[q + 3] = U & 255, q + 4
    };

    function ue(H, U, q, le, xe) {
        Oe(U, le, xe, H, q, 7);
        let Ae = Number(U & BigInt(4294967295));
        H[q++] = Ae, Ae = Ae >> 8, H[q++] = Ae, Ae = Ae >> 8, H[q++] = Ae, Ae = Ae >> 8, H[q++] = Ae;
        let De = Number(U >> BigInt(32) & BigInt(4294967295));
        return H[q++] = De, De = De >> 8, H[q++] = De, De = De >> 8, H[q++] = De, De = De >> 8, H[q++] = De, q
    }

    function me(H, U, q, le, xe) {
        Oe(U, le, xe, H, q, 7);
        let Ae = Number(U & BigInt(4294967295));
        H[q + 7] = Ae, Ae = Ae >> 8, H[q + 6] = Ae, Ae = Ae >> 8, H[q + 5] = Ae, Ae = Ae >> 8, H[q + 4] = Ae;
        let De = Number(U >> BigInt(32) & BigInt(4294967295));
        return H[q + 3] = De, De = De >> 8, H[q + 2] = De, De = De >> 8, H[q + 1] = De, De = De >> 8, H[q] = De, q + 8
    }

    d.prototype.writeBigUInt64LE = te(function (U, q = 0) {
        return ue(this, U, q, BigInt(0), BigInt("0xffffffffffffffff"))
    }), d.prototype.writeBigUInt64BE = te(function (U, q = 0) {
        return me(this, U, q, BigInt(0), BigInt("0xffffffffffffffff"))
    }), d.prototype.writeIntLE = function (U, q, le, xe) {
        if (U = +U, q = q >>> 0, !xe) {
            const ft = Math.pow(2, 8 * le - 1);
            ye(this, U, q, le, ft - 1, -ft)
        }
        let Ae = 0, De = 1, Ze = 0;
        for (this[q] = U & 255; ++Ae < le && (De *= 256);) U < 0 && Ze === 0 && this[q + Ae - 1] !== 0 && (Ze = 1), this[q + Ae] = (U / De >> 0) - Ze & 255;
        return q + le
    }, d.prototype.writeIntBE = function (U, q, le, xe) {
        if (U = +U, q = q >>> 0, !xe) {
            const ft = Math.pow(2, 8 * le - 1);
            ye(this, U, q, le, ft - 1, -ft)
        }
        let Ae = le - 1, De = 1, Ze = 0;
        for (this[q + Ae] = U & 255; --Ae >= 0 && (De *= 256);) U < 0 && Ze === 0 && this[q + Ae + 1] !== 0 && (Ze = 1), this[q + Ae] = (U / De >> 0) - Ze & 255;
        return q + le
    }, d.prototype.writeInt8 = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 1, 127, -128), U < 0 && (U = 255 + U + 1), this[q] = U & 255, q + 1
    }, d.prototype.writeInt16LE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 2, 32767, -32768), this[q] = U & 255, this[q + 1] = U >>> 8, q + 2
    }, d.prototype.writeInt16BE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 2, 32767, -32768), this[q] = U >>> 8, this[q + 1] = U & 255, q + 2
    }, d.prototype.writeInt32LE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 4, 2147483647, -2147483648), this[q] = U & 255, this[q + 1] = U >>> 8, this[q + 2] = U >>> 16, this[q + 3] = U >>> 24, q + 4
    }, d.prototype.writeInt32BE = function (U, q, le) {
        return U = +U, q = q >>> 0, le || ye(this, U, q, 4, 2147483647, -2147483648), U < 0 && (U = 4294967295 + U + 1), this[q] = U >>> 24, this[q + 1] = U >>> 16, this[q + 2] = U >>> 8, this[q + 3] = U & 255, q + 4
    }, d.prototype.writeBigInt64LE = te(function (U, q = 0) {
        return ue(this, U, q, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), d.prototype.writeBigInt64BE = te(function (U, q = 0) {
        return me(this, U, q, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function Se(H, U, q, le, xe, Ae) {
        if (q + le > H.length) throw new RangeError("Index out of range");
        if (q < 0) throw new RangeError("Index out of range")
    }

    function Ce(H, U, q, le, xe) {
        return U = +U, q = q >>> 0, xe || Se(H, U, q, 4), r.write(H, U, q, le, 23, 4), q + 4
    }

    d.prototype.writeFloatLE = function (U, q, le) {
        return Ce(this, U, q, !0, le)
    }, d.prototype.writeFloatBE = function (U, q, le) {
        return Ce(this, U, q, !1, le)
    };

    function Me(H, U, q, le, xe) {
        return U = +U, q = q >>> 0, xe || Se(H, U, q, 8), r.write(H, U, q, le, 52, 8), q + 8
    }

    d.prototype.writeDoubleLE = function (U, q, le) {
        return Me(this, U, q, !0, le)
    }, d.prototype.writeDoubleBE = function (U, q, le) {
        return Me(this, U, q, !1, le)
    }, d.prototype.copy = function (U, q, le, xe) {
        if (!d.isBuffer(U)) throw new TypeError("argument should be a Buffer");
        if (le || (le = 0), !xe && xe !== 0 && (xe = this.length), q >= U.length && (q = U.length), q || (q = 0), xe > 0 && xe < le && (xe = le), xe === le || U.length === 0 || this.length === 0) return 0;
        if (q < 0) throw new RangeError("targetStart out of bounds");
        if (le < 0 || le >= this.length) throw new RangeError("Index out of range");
        if (xe < 0) throw new RangeError("sourceEnd out of bounds");
        xe > this.length && (xe = this.length), U.length - q < xe - le && (xe = U.length - q + le);
        const Ae = xe - le;
        return this === U && typeof a.prototype.copyWithin == "function" ? this.copyWithin(q, le, xe) : a.prototype.set.call(U, this.subarray(le, xe), q), Ae
    }, d.prototype.fill = function (U, q, le, xe) {
        if (typeof U == "string") {
            if (typeof q == "string" ? (xe = q, q = 0, le = this.length) : typeof le == "string" && (xe = le, le = this.length), xe !== void 0 && typeof xe != "string") throw new TypeError("encoding must be a string");
            if (typeof xe == "string" && !d.isEncoding(xe)) throw new TypeError("Unknown encoding: " + xe);
            if (U.length === 1) {
                const De = U.charCodeAt(0);
                (xe === "utf8" && De < 128 || xe === "latin1") && (U = De)
            }
        } else typeof U == "number" ? U = U & 255 : typeof U == "boolean" && (U = Number(U));
        if (q < 0 || this.length < q || this.length < le) throw new RangeError("Out of range index");
        if (le <= q) return this;
        q = q >>> 0, le = le === void 0 ? this.length : le >>> 0, U || (U = 0);
        let Ae;
        if (typeof U == "number") for (Ae = q; Ae < le; ++Ae) this[Ae] = U; else {
            const De = d.isBuffer(U) ? U : d.from(U, xe), Ze = De.length;
            if (Ze === 0) throw new TypeError('The value "' + U + '" is invalid for argument "value"');
            for (Ae = 0; Ae < le - q; ++Ae) this[Ae + q] = De[Ae % Ze]
        }
        return this
    };
    const ve = {};

    function ne(H, U, q) {
        ve[H] = class extends q {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: U.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${H}]`, delete this.name
            }

            get code() {
                return H
            }

            set code(xe) {
                Object.defineProperty(this, "code", {configurable: !0, enumerable: !0, value: xe, writable: !0})
            }

            toString() {
                return `${this.name} [${H}]: ${this.message}`
            }
        }
    }

    ne("ERR_BUFFER_OUT_OF_BOUNDS", function (H) {
        return H ? `${H} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), ne("ERR_INVALID_ARG_TYPE", function (H, U) {
        return `The "${H}" argument must be of type number. Received type ${typeof U}`
    }, TypeError), ne("ERR_OUT_OF_RANGE", function (H, U, q) {
        let le = `The value of "${H}" is out of range.`, xe = q;
        return Number.isInteger(q) && Math.abs(q) > 2 ** 32 ? xe = be(String(q)) : typeof q == "bigint" && (xe = String(q), (q > BigInt(2) ** BigInt(32) || q < -(BigInt(2) ** BigInt(32))) && (xe = be(xe)), xe += "n"), le += ` It must be ${U}. Received ${xe}`, le
    }, RangeError);

    function be(H) {
        let U = "", q = H.length;
        const le = H[0] === "-" ? 1 : 0;
        for (; q >= le + 4; q -= 3) U = `_${H.slice(q - 3, q)}${U}`;
        return `${H.slice(0, q)}${U}`
    }

    function Ee(H, U, q) {
        ze(U, "offset"), (H[U] === void 0 || H[U + q] === void 0) && Be(U, H.length - (q + 1))
    }

    function Oe(H, U, q, le, xe, Ae) {
        if (H > q || H < U) {
            const De = typeof U == "bigint" ? "n" : "";
            let Ze;
            throw Ae > 3 ? U === 0 || U === BigInt(0) ? Ze = `>= 0${De} and < 2${De} ** ${(Ae + 1) * 8}${De}` : Ze = `>= -(2${De} ** ${(Ae + 1) * 8 - 1}${De}) and < 2 ** ${(Ae + 1) * 8 - 1}${De}` : Ze = `>= ${U}${De} and <= ${q}${De}`, new ve.ERR_OUT_OF_RANGE("value", Ze, H)
        }
        Ee(le, xe, Ae)
    }

    function ze(H, U) {
        if (typeof H != "number") throw new ve.ERR_INVALID_ARG_TYPE(U, "number", H)
    }

    function Be(H, U, q) {
        throw Math.floor(H) !== H ? (ze(H, q), new ve.ERR_OUT_OF_RANGE(q || "offset", "an integer", H)) : U < 0 ? new ve.ERR_BUFFER_OUT_OF_BOUNDS : new ve.ERR_OUT_OF_RANGE(q || "offset", `>= ${q ? 1 : 0} and <= ${U}`, H)
    }

    const it = /[^+/0-9A-Za-z-_]/g;

    function Ue(H) {
        if (H = H.split("=")[0], H = H.trim().replace(it, ""), H.length < 2) return "";
        for (; H.length % 4 !== 0;) H = H + "=";
        return H
    }

    function bt(H, U) {
        U = U || 1 / 0;
        let q;
        const le = H.length;
        let xe = null;
        const Ae = [];
        for (let De = 0; De < le; ++De) {
            if (q = H.charCodeAt(De), q > 55295 && q < 57344) {
                if (!xe) {
                    if (q > 56319) {
                        (U -= 3) > -1 && Ae.push(239, 191, 189);
                        continue
                    } else if (De + 1 === le) {
                        (U -= 3) > -1 && Ae.push(239, 191, 189);
                        continue
                    }
                    xe = q;
                    continue
                }
                if (q < 56320) {
                    (U -= 3) > -1 && Ae.push(239, 191, 189), xe = q;
                    continue
                }
                q = (xe - 55296 << 10 | q - 56320) + 65536
            } else xe && (U -= 3) > -1 && Ae.push(239, 191, 189);
            if (xe = null, q < 128) {
                if ((U -= 1) < 0) break;
                Ae.push(q)
            } else if (q < 2048) {
                if ((U -= 2) < 0) break;
                Ae.push(q >> 6 | 192, q & 63 | 128)
            } else if (q < 65536) {
                if ((U -= 3) < 0) break;
                Ae.push(q >> 12 | 224, q >> 6 & 63 | 128, q & 63 | 128)
            } else if (q < 1114112) {
                if ((U -= 4) < 0) break;
                Ae.push(q >> 18 | 240, q >> 12 & 63 | 128, q >> 6 & 63 | 128, q & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return Ae
    }

    function gt(H) {
        const U = [];
        for (let q = 0; q < H.length; ++q) U.push(H.charCodeAt(q) & 255);
        return U
    }

    function Ot(H, U) {
        let q, le, xe;
        const Ae = [];
        for (let De = 0; De < H.length && !((U -= 2) < 0); ++De) q = H.charCodeAt(De), le = q >> 8, xe = q % 256, Ae.push(xe), Ae.push(le);
        return Ae
    }

    function zt(H) {
        return e.toByteArray(Ue(H))
    }

    function _t(H, U, q, le) {
        let xe;
        for (xe = 0; xe < le && !(xe + q >= U.length || xe >= H.length); ++xe) U[xe + q] = H[xe];
        return xe
    }

    function Dt(H, U) {
        return H instanceof U || H != null && H.constructor != null && H.constructor.name != null && H.constructor.name === U.name
    }

    function rr(H) {
        return H !== H
    }

    const pe = function () {
        const H = "0123456789abcdef", U = new Array(256);
        for (let q = 0; q < 16; ++q) {
            const le = q * 16;
            for (let xe = 0; xe < 16; ++xe) U[le + xe] = H[q] + H[xe]
        }
        return U
    }();

    function te(H) {
        return typeof BigInt > "u" ? X : H
    }

    function X() {
        throw new Error("BigInt not supported")
    }
})(iwe);
const kr = iwe.Buffer;
var k8 = function (e, r) {
    for (var n = Math.min(e.length, r.length), i = new kr(n), a = 0; a < n; ++a) i[a] = e[a] ^ r[a];
    return i
}, owe = k8;
fQ.encrypt = function (t, e) {
    var r = owe(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev
};
fQ.decrypt = function (t, e) {
    var r = t._prev;
    t._prev = e;
    var n = t._cipher.decryptBlock(e);
    return owe(n, r)
};
var swe = {}, ET = Vn.Buffer, nrt = k8;

function Vce(t, e, r) {
    var n = e.length, i = nrt(e, t._cache);
    return t._cache = t._cache.slice(n), t._prev = ET.concat([t._prev, r ? e : i]), i
}

swe.encrypt = function (t, e, r) {
    for (var n = ET.allocUnsafe(0), i; e.length;) if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = ET.allocUnsafe(0)), t._cache.length <= e.length) i = t._cache.length, n = ET.concat([n, Vce(t, e.slice(0, i), r)]), e = e.slice(i); else {
        n = ET.concat([n, Vce(t, e, r)]);
        break
    }
    return n
};
var cwe = {}, Rq = Vn.Buffer;

function irt(t, e, r) {
    var n = t._cipher.encryptBlock(t._prev), i = n[0] ^ e;
    return t._prev = Rq.concat([t._prev.slice(1), Rq.from([r ? e : i])]), i
}

cwe.encrypt = function (t, e, r) {
    for (var n = e.length, i = Rq.allocUnsafe(n), a = -1; ++a < n;) i[a] = irt(t, e[a], r);
    return i
};
var lwe = {}, ED = Vn.Buffer;

function art(t, e, r) {
    for (var n, i = -1, a = 8, o = 0, s, l; ++i < a;) n = t._cipher.encryptBlock(t._prev), s = e & 1 << 7 - i ? 128 : 0, l = n[0] ^ s, o += (l & 128) >> i % 8, t._prev = ort(t._prev, r ? s : l);
    return o
}

function ort(t, e) {
    var r = t.length, n = -1, i = ED.allocUnsafe(t.length);
    for (t = ED.concat([t, ED.from([e])]); ++n < r;) i[n] = t[n] << 1 | t[n + 1] >> 7;
    return i
}

lwe.encrypt = function (t, e, r) {
    for (var n = e.length, i = ED.allocUnsafe(n), a = -1; ++a < n;) i[a] = art(t, e[a], r);
    return i
};
var uwe = {}, srt = k8;

function crt(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev
}

uwe.encrypt = function (t, e) {
    for (; t._cache.length < e.length;) t._cache = kr.concat([t._cache, crt(t)]);
    var r = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), srt(e, r)
};
var Dq = {};

function lrt(t) {
    for (var e = t.length, r; e--;) if (r = t.readUInt8(e), r === 255) t.writeUInt8(0, e); else {
        r++, t.writeUInt8(r, e);
        break
    }
}

var fwe = lrt, urt = k8, Hce = Vn.Buffer, frt = fwe;

function drt(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return frt(t._prev), e
}

var fz = 16;
Dq.encrypt = function (t, e) {
    var r = Math.ceil(e.length / fz), n = t._cache.length;
    t._cache = Hce.concat([t._cache, Hce.allocUnsafe(r * fz)]);
    for (var i = 0; i < r; i++) {
        var a = drt(t), o = n + i * fz;
        t._cache.writeUInt32BE(a[0], o + 0), t._cache.writeUInt32BE(a[1], o + 4), t._cache.writeUInt32BE(a[2], o + 8), t._cache.writeUInt32BE(a[3], o + 12)
    }
    var s = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), urt(e, s)
};
const hrt = {cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block"},
    prt = {cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block"},
    mrt = {cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block"}, dwe = {
        "aes-128-ecb": {cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block"},
        "aes-192-ecb": {cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block"},
        "aes-256-ecb": {cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block"},
        "aes-128-cbc": {cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block"},
        "aes-192-cbc": {cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block"},
        "aes-256-cbc": {cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block"},
        aes128: hrt,
        aes192: prt,
        aes256: mrt,
        "aes-128-cfb": {cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream"},
        "aes-192-cfb": {cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream"},
        "aes-256-cfb": {cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream"},
        "aes-128-cfb8": {cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream"},
        "aes-192-cfb8": {cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream"},
        "aes-256-cfb8": {cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream"},
        "aes-128-cfb1": {cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream"},
        "aes-192-cfb1": {cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream"},
        "aes-256-cfb1": {cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream"},
        "aes-128-ofb": {cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream"},
        "aes-192-ofb": {cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream"},
        "aes-256-ofb": {cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream"},
        "aes-128-ctr": {cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream"},
        "aes-192-ctr": {cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream"},
        "aes-256-ctr": {cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream"},
        "aes-128-gcm": {cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth"},
        "aes-192-gcm": {cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth"},
        "aes-256-gcm": {cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth"}
    };
var vrt = {ECB: uQ, CBC: fQ, CFB: swe, CFB8: cwe, CFB1: lwe, OFB: uwe, CTR: Dq, GCM: Dq}, TD = dwe;
for (var Wce in TD) TD[Wce].module = vrt[TD[Wce].mode];
var hQ = TD, R8 = {}, nO = Vn.Buffer;

function pQ(t) {
    nO.isBuffer(t) || (t = nO.from(t));
    for (var e = t.length / 4 | 0, r = new Array(e), n = 0; n < e; n++) r[n] = t.readUInt32BE(n * 4);
    return r
}

function dz(t) {
    for (var e = 0; e < t.length; t++) t[e] = 0
}

function hwe(t, e, r, n, i) {
    for (var a = r[0], o = r[1], s = r[2], l = r[3], f = t[0] ^ e[0], d = t[1] ^ e[1], p = t[2] ^ e[2], g = t[3] ^ e[3], b, S, T, I, N = 4, P = 1; P < i; P++) b = a[f >>> 24] ^ o[d >>> 16 & 255] ^ s[p >>> 8 & 255] ^ l[g & 255] ^ e[N++], S = a[d >>> 24] ^ o[p >>> 16 & 255] ^ s[g >>> 8 & 255] ^ l[f & 255] ^ e[N++], T = a[p >>> 24] ^ o[g >>> 16 & 255] ^ s[f >>> 8 & 255] ^ l[d & 255] ^ e[N++], I = a[g >>> 24] ^ o[f >>> 16 & 255] ^ s[d >>> 8 & 255] ^ l[p & 255] ^ e[N++], f = b, d = S, p = T, g = I;
    return b = (n[f >>> 24] << 24 | n[d >>> 16 & 255] << 16 | n[p >>> 8 & 255] << 8 | n[g & 255]) ^ e[N++], S = (n[d >>> 24] << 24 | n[p >>> 16 & 255] << 16 | n[g >>> 8 & 255] << 8 | n[f & 255]) ^ e[N++], T = (n[p >>> 24] << 24 | n[g >>> 16 & 255] << 16 | n[f >>> 8 & 255] << 8 | n[d & 255]) ^ e[N++], I = (n[g >>> 24] << 24 | n[f >>> 16 & 255] << 16 | n[d >>> 8 & 255] << 8 | n[p & 255]) ^ e[N++], b = b >>> 0, S = S >>> 0, T = T >>> 0, I = I >>> 0, [b, S, T, I]
}

var grt = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], rs = function () {
    for (var t = new Array(256), e = 0; e < 256; e++) e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r = [], n = [], i = [[], [], [], []], a = [[], [], [], []], o = 0, s = 0, l = 0; l < 256; ++l) {
        var f = s ^ s << 1 ^ s << 2 ^ s << 3 ^ s << 4;
        f = f >>> 8 ^ f & 255 ^ 99, r[o] = f, n[f] = o;
        var d = t[o], p = t[d], g = t[p], b = t[f] * 257 ^ f * 16843008;
        i[0][o] = b << 24 | b >>> 8, i[1][o] = b << 16 | b >>> 16, i[2][o] = b << 8 | b >>> 24, i[3][o] = b, b = g * 16843009 ^ p * 65537 ^ d * 257 ^ o * 16843008, a[0][f] = b << 24 | b >>> 8, a[1][f] = b << 16 | b >>> 16, a[2][f] = b << 8 | b >>> 24, a[3][f] = b, o === 0 ? o = s = 1 : (o = d ^ t[t[t[g ^ d]]], s ^= t[t[s]])
    }
    return {SBOX: r, INV_SBOX: n, SUB_MIX: i, INV_SUB_MIX: a}
}();

function Xd(t) {
    this._key = pQ(t), this._reset()
}

Xd.blockSize = 4 * 4;
Xd.keySize = 256 / 8;
Xd.prototype.blockSize = Xd.blockSize;
Xd.prototype.keySize = Xd.keySize;
Xd.prototype._reset = function () {
    for (var t = this._key, e = t.length, r = e + 6, n = (r + 1) * 4, i = [], a = 0; a < e; a++) i[a] = t[a];
    for (a = e; a < n; a++) {
        var o = i[a - 1];
        a % e === 0 ? (o = o << 8 | o >>> 24, o = rs.SBOX[o >>> 24] << 24 | rs.SBOX[o >>> 16 & 255] << 16 | rs.SBOX[o >>> 8 & 255] << 8 | rs.SBOX[o & 255], o ^= grt[a / e | 0] << 24) : e > 6 && a % e === 4 && (o = rs.SBOX[o >>> 24] << 24 | rs.SBOX[o >>> 16 & 255] << 16 | rs.SBOX[o >>> 8 & 255] << 8 | rs.SBOX[o & 255]), i[a] = i[a - e] ^ o
    }
    for (var s = [], l = 0; l < n; l++) {
        var f = n - l, d = i[f - (l % 4 ? 0 : 4)];
        l < 4 || f <= 4 ? s[l] = d : s[l] = rs.INV_SUB_MIX[0][rs.SBOX[d >>> 24]] ^ rs.INV_SUB_MIX[1][rs.SBOX[d >>> 16 & 255]] ^ rs.INV_SUB_MIX[2][rs.SBOX[d >>> 8 & 255]] ^ rs.INV_SUB_MIX[3][rs.SBOX[d & 255]]
    }
    this._nRounds = r, this._keySchedule = i, this._invKeySchedule = s
};
Xd.prototype.encryptBlockRaw = function (t) {
    return t = pQ(t), hwe(t, this._keySchedule, rs.SUB_MIX, rs.SBOX, this._nRounds)
};
Xd.prototype.encryptBlock = function (t) {
    var e = this.encryptBlockRaw(t), r = nO.allocUnsafe(16);
    return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r
};
Xd.prototype.decryptBlock = function (t) {
    t = pQ(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r = hwe(t, this._invKeySchedule, rs.INV_SUB_MIX, rs.INV_SBOX, this._nRounds), n = nO.allocUnsafe(16);
    return n.writeUInt32BE(r[0], 0), n.writeUInt32BE(r[3], 4), n.writeUInt32BE(r[2], 8), n.writeUInt32BE(r[1], 12), n
};
Xd.prototype.scrub = function () {
    dz(this._keySchedule), dz(this._invKeySchedule), dz(this._key)
};
R8.AES = Xd;
var P4 = Vn.Buffer, yrt = P4.alloc(16, 0);

function brt(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)]
}

function pwe(t) {
    var e = P4.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e
}

function D8(t) {
    this.h = t, this.state = P4.alloc(16, 0), this.cache = P4.allocUnsafe(0)
}

D8.prototype.ghash = function (t) {
    for (var e = -1; ++e < t.length;) this.state[e] ^= t[e];
    this._multiply()
};
D8.prototype._multiply = function () {
    for (var t = brt(this.h), e = [0, 0, 0, 0], r, n, i, a = -1; ++a < 128;) {
        for (n = (this.state[~~(a / 8)] & 1 << 7 - a % 8) !== 0, n && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), i = (t[3] & 1) !== 0, r = 3; r > 0; r--) t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, i && (t[0] = t[0] ^ 225 << 24)
    }
    this.state = pwe(e)
};
D8.prototype.update = function (t) {
    this.cache = P4.concat([this.cache, t]);
    for (var e; this.cache.length >= 16;) e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e)
};
D8.prototype.final = function (t, e) {
    return this.cache.length && this.ghash(P4.concat([this.cache, yrt], 16)), this.ghash(pwe([0, t, 0, e])), this.state
};
var wrt = D8, Srt = R8, Hu = Vn.Buffer, mwe = b1, _rt = Xn, vwe = wrt, xrt = k8, Ert = fwe;

function Trt(t, e) {
    var r = 0;
    t.length !== e.length && r++;
    for (var n = Math.min(t.length, e.length), i = 0; i < n; ++i) r += t[i] ^ e[i];
    return r
}

function Crt(t, e, r) {
    if (e.length === 12) return t._finID = Hu.concat([e, Hu.from([0, 0, 0, 1])]), Hu.concat([e, Hu.from([0, 0, 0, 2])]);
    var n = new vwe(r), i = e.length, a = i % 16;
    n.update(e), a && (a = 16 - a, n.update(Hu.alloc(a, 0))), n.update(Hu.alloc(8, 0));
    var o = i * 8, s = Hu.alloc(8);
    s.writeUIntBE(o, 0, 8), n.update(s), t._finID = n.state;
    var l = Hu.from(t._finID);
    return Ert(l), l
}

function BS(t, e, r, n) {
    mwe.call(this);
    var i = Hu.alloc(4, 0);
    this._cipher = new Srt.AES(e);
    var a = this._cipher.encryptBlock(i);
    this._ghash = new vwe(a), r = Crt(this, r, a), this._prev = Hu.from(r), this._cache = Hu.allocUnsafe(0), this._secCache = Hu.allocUnsafe(0), this._decrypt = n, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = !1
}

_rt(BS, mwe);
BS.prototype._update = function (t) {
    if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = Hu.alloc(e, 0), this._ghash.update(e))
    }
    this._called = !0;
    var r = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r
};
BS.prototype._final = function () {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var t = xrt(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && Trt(t, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub()
};
BS.prototype.getAuthTag = function () {
    if (this._decrypt || !Hu.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag
};
BS.prototype.setAuthTag = function (e) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e
};
BS.prototype.setAAD = function (e) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length
};
var gwe = BS, Art = R8, hz = Vn.Buffer, ywe = b1, Irt = Xn;

function fN(t, e, r, n) {
    ywe.call(this), this._cipher = new Art.AES(e), this._prev = hz.from(r), this._cache = hz.allocUnsafe(0), this._secCache = hz.allocUnsafe(0), this._decrypt = n, this._mode = t
}

Irt(fN, ywe);
fN.prototype._update = function (t) {
    return this._mode.encrypt(this, t, this._decrypt)
};
fN.prototype._final = function () {
    this._cipher.scrub()
};
var bwe = fN, Gb = Vn.Buffer, krt = aQ;

function Rrt(t, e, r, n) {
    if (Gb.isBuffer(t) || (t = Gb.from(t, "binary")), e && (Gb.isBuffer(e) || (e = Gb.from(e, "binary")), e.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
    for (var i = r / 8, a = Gb.alloc(i), o = Gb.alloc(n || 0), s = Gb.alloc(0); i > 0 || n > 0;) {
        var l = new krt;
        l.update(s), l.update(t), e && l.update(e), s = l.digest();
        var f = 0;
        if (i > 0) {
            var d = a.length - i;
            f = Math.min(i, s.length), s.copy(a, d, 0, f), i -= f
        }
        if (f < s.length && n > 0) {
            var p = o.length - n, g = Math.min(n, s.length - f);
            s.copy(o, p, f, f + g), n -= g
        }
    }
    return s.fill(0), {key: a, iv: o}
}

var dN = Rrt, wwe = hQ, Drt = gwe, Pv = Vn.Buffer, Mrt = bwe, Swe = b1, Ort = R8, Prt = dN, Nrt = Xn;

function M8(t, e, r) {
    Swe.call(this), this._cache = new hN, this._cipher = new Ort.AES(e), this._prev = Pv.from(r), this._mode = t, this._autopadding = !0
}

Nrt(M8, Swe);
M8.prototype._update = function (t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get();) r = this._mode.encrypt(this, e), n.push(r);
    return Pv.concat(n)
};
var Lrt = Pv.alloc(16, 16);
M8.prototype._final = function () {
    var t = this._cache.flush();
    if (this._autopadding) return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(Lrt)) throw this._cipher.scrub(), new Error("data not multiple of block length")
};
M8.prototype.setAutoPadding = function (t) {
    return this._autopadding = !!t, this
};

function hN() {
    this.cache = Pv.allocUnsafe(0)
}

hN.prototype.add = function (t) {
    this.cache = Pv.concat([this.cache, t])
};
hN.prototype.get = function () {
    if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t
    }
    return null
};
hN.prototype.flush = function () {
    for (var t = 16 - this.cache.length, e = Pv.allocUnsafe(t), r = -1; ++r < t;) e.writeUInt8(t, r);
    return Pv.concat([this.cache, e])
};

function _we(t, e, r) {
    var n = wwe[t.toLowerCase()];
    if (!n) throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = Pv.from(e)), e.length !== n.key / 8) throw new TypeError("invalid key length " + e.length);
    if (typeof r == "string" && (r = Pv.from(r)), n.mode !== "GCM" && r.length !== n.iv) throw new TypeError("invalid iv length " + r.length);
    return n.type === "stream" ? new Mrt(n.module, e, r) : n.type === "auth" ? new Drt(n.module, e, r) : new M8(n.module, e, r)
}

function Brt(t, e) {
    var r = wwe[t.toLowerCase()];
    if (!r) throw new TypeError("invalid suite type");
    var n = Prt(e, !1, r.key, r.iv);
    return _we(t, n.key, n.iv)
}

lQ.createCipheriv = _we;
lQ.createCipher = Brt;
var mQ = {}, $rt = gwe, N4 = Vn.Buffer, xwe = hQ, Frt = bwe, Ewe = b1, Urt = R8, jrt = dN, zrt = Xn;

function O8(t, e, r) {
    Ewe.call(this), this._cache = new pN, this._last = void 0, this._cipher = new Urt.AES(e), this._prev = N4.from(r), this._mode = t, this._autopadding = !0
}

zrt(O8, Ewe);
O8.prototype._update = function (t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(this._autopadding);) r = this._mode.decrypt(this, e), n.push(r);
    return N4.concat(n)
};
O8.prototype._final = function () {
    var t = this._cache.flush();
    if (this._autopadding) return Vrt(this._mode.decrypt(this, t));
    if (t) throw new Error("data not multiple of block length")
};
O8.prototype.setAutoPadding = function (t) {
    return this._autopadding = !!t, this
};

function pN() {
    this.cache = N4.allocUnsafe(0)
}

pN.prototype.add = function (t) {
    this.cache = N4.concat([this.cache, t])
};
pN.prototype.get = function (t) {
    var e;
    if (t) {
        if (this.cache.length > 16) return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e
    } else if (this.cache.length >= 16) return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null
};
pN.prototype.flush = function () {
    if (this.cache.length) return this.cache
};

function Vrt(t) {
    var e = t[15];
    if (e < 1 || e > 16) throw new Error("unable to decrypt data");
    for (var r = -1; ++r < e;) if (t[r + (16 - e)] !== e) throw new Error("unable to decrypt data");
    if (e !== 16) return t.slice(0, 16 - e)
}

function Twe(t, e, r) {
    var n = xwe[t.toLowerCase()];
    if (!n) throw new TypeError("invalid suite type");
    if (typeof r == "string" && (r = N4.from(r)), n.mode !== "GCM" && r.length !== n.iv) throw new TypeError("invalid iv length " + r.length);
    if (typeof e == "string" && (e = N4.from(e)), e.length !== n.key / 8) throw new TypeError("invalid key length " + e.length);
    return n.type === "stream" ? new Frt(n.module, e, r, !0) : n.type === "auth" ? new $rt(n.module, e, r, !0) : new O8(n.module, e, r)
}

function Hrt(t, e) {
    var r = xwe[t.toLowerCase()];
    if (!r) throw new TypeError("invalid suite type");
    var n = jrt(e, !1, r.key, r.iv);
    return Twe(t, n.key, n.iv)
}

mQ.createDecipher = Hrt;
mQ.createDecipheriv = Twe;
var Cwe = lQ, Awe = mQ, Wrt = dwe;

function qrt() {
    return Object.keys(Wrt)
}

qf.createCipher = qf.Cipher = Cwe.createCipher;
qf.createCipheriv = qf.Cipheriv = Cwe.createCipheriv;
qf.createDecipher = qf.Decipher = Awe.createDecipher;
qf.createDecipheriv = qf.Decipheriv = Awe.createDecipheriv;
qf.listCiphers = qf.getCiphers = qrt;
var Iwe = {};
(function (t) {
    t["des-ecb"] = {key: 8, iv: 0}, t["des-cbc"] = t.des = {key: 8, iv: 8}, t["des-ede3-cbc"] = t.des3 = {
        key: 24,
        iv: 8
    }, t["des-ede3"] = {key: 24, iv: 0}, t["des-ede-cbc"] = {key: 16, iv: 8}, t["des-ede"] = {key: 16, iv: 0}
})(Iwe);
var kwe = Ktt, vQ = qf, By = hQ, wv = Iwe, Rwe = dN;

function Grt(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (By[t]) r = By[t].key, n = By[t].iv; else if (wv[t]) r = wv[t].key * 8, n = wv[t].iv; else throw new TypeError("invalid suite type");
    var i = Rwe(e, !1, r, n);
    return Dwe(t, i.key, i.iv)
}

function Krt(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (By[t]) r = By[t].key, n = By[t].iv; else if (wv[t]) r = wv[t].key * 8, n = wv[t].iv; else throw new TypeError("invalid suite type");
    var i = Rwe(e, !1, r, n);
    return Mwe(t, i.key, i.iv)
}

function Dwe(t, e, r) {
    if (t = t.toLowerCase(), By[t]) return vQ.createCipheriv(t, e, r);
    if (wv[t]) return new kwe({key: e, iv: r, mode: t});
    throw new TypeError("invalid suite type")
}

function Mwe(t, e, r) {
    if (t = t.toLowerCase(), By[t]) return vQ.createDecipheriv(t, e, r);
    if (wv[t]) return new kwe({key: e, iv: r, mode: t, decrypt: !0});
    throw new TypeError("invalid suite type")
}

function Yrt() {
    return Object.keys(wv).concat(vQ.getCiphers())
}

hp.createCipher = hp.Cipher = Grt;
hp.createCipheriv = hp.Cipheriv = Dwe;
hp.createDecipher = hp.Decipher = Krt;
hp.createDecipheriv = hp.Decipheriv = Mwe;
hp.listCiphers = hp.getCiphers = Yrt;
var Kb = {}, Owe = {exports: {}};
(function (t) {
    (function (e, r) {
        function n(re, M) {
            if (!re) throw new Error(M || "Assertion failed")
        }

        function i(re, M) {
            re.super_ = M;
            var D = function () {
            };
            D.prototype = M.prototype, re.prototype = new D, re.prototype.constructor = re
        }

        function a(re, M, D) {
            if (a.isBN(re)) return re;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, re !== null && ((M === "le" || M === "be") && (D = M, M = 10), this._init(re || 0, M || 10, D || "be"))
        }

        typeof e == "object" ? e.exports = a : r.BN = a, a.BN = a, a.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = ME.Buffer
        } catch {
        }
        a.isBN = function (M) {
            return M instanceof a ? !0 : M !== null && typeof M == "object" && M.constructor.wordSize === a.wordSize && Array.isArray(M.words)
        }, a.max = function (M, D) {
            return M.cmp(D) > 0 ? M : D
        }, a.min = function (M, D) {
            return M.cmp(D) < 0 ? M : D
        }, a.prototype._init = function (M, D, x) {
            if (typeof M == "number") return this._initNumber(M, D, x);
            if (typeof M == "object") return this._initArray(M, D, x);
            D === "hex" && (D = 16), n(D === (D | 0) && D >= 2 && D <= 36), M = M.toString().replace(/\s+/g, "");
            var A = 0;
            M[0] === "-" && (A++, this.negative = 1), A < M.length && (D === 16 ? this._parseHex(M, A, x) : (this._parseBase(M, D, A), x === "le" && this._initArray(this.toArray(), D, x)))
        }, a.prototype._initNumber = function (M, D, x) {
            M < 0 && (this.negative = 1, M = -M), M < 67108864 ? (this.words = [M & 67108863], this.length = 1) : M < 4503599627370496 ? (this.words = [M & 67108863, M / 67108864 & 67108863], this.length = 2) : (n(M < 9007199254740992), this.words = [M & 67108863, M / 67108864 & 67108863, 1], this.length = 3), x === "le" && this._initArray(this.toArray(), D, x)
        }, a.prototype._initArray = function (M, D, x) {
            if (n(typeof M.length == "number"), M.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(M.length / 3), this.words = new Array(this.length);
            for (var A = 0; A < this.length; A++) this.words[A] = 0;
            var B, z, j = 0;
            if (x === "be") for (A = M.length - 1, B = 0; A >= 0; A -= 3) z = M[A] | M[A - 1] << 8 | M[A - 2] << 16, this.words[B] |= z << j & 67108863, this.words[B + 1] = z >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, B++); else if (x === "le") for (A = 0, B = 0; A < M.length; A += 3) z = M[A] | M[A + 1] << 8 | M[A + 2] << 16, this.words[B] |= z << j & 67108863, this.words[B + 1] = z >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, B++);
            return this.strip()
        };

        function s(re, M) {
            var D = re.charCodeAt(M);
            return D >= 65 && D <= 70 ? D - 55 : D >= 97 && D <= 102 ? D - 87 : D - 48 & 15
        }

        function l(re, M, D) {
            var x = s(re, D);
            return D - 1 >= M && (x |= s(re, D - 1) << 4), x
        }

        a.prototype._parseHex = function (M, D, x) {
            this.length = Math.ceil((M.length - D) / 6), this.words = new Array(this.length);
            for (var A = 0; A < this.length; A++) this.words[A] = 0;
            var B = 0, z = 0, j;
            if (x === "be") for (A = M.length - 1; A >= D; A -= 2) j = l(M, D, A) << B, this.words[z] |= j & 67108863, B >= 18 ? (B -= 18, z += 1, this.words[z] |= j >>> 26) : B += 8; else {
                var $ = M.length - D;
                for (A = $ % 2 === 0 ? D + 1 : D; A < M.length; A += 2) j = l(M, D, A) << B, this.words[z] |= j & 67108863, B >= 18 ? (B -= 18, z += 1, this.words[z] |= j >>> 26) : B += 8
            }
            this.strip()
        };

        function f(re, M, D, x) {
            for (var A = 0, B = Math.min(re.length, D), z = M; z < B; z++) {
                var j = re.charCodeAt(z) - 48;
                A *= x, j >= 49 ? A += j - 49 + 10 : j >= 17 ? A += j - 17 + 10 : A += j
            }
            return A
        }

        a.prototype._parseBase = function (M, D, x) {
            this.words = [0], this.length = 1;
            for (var A = 0, B = 1; B <= 67108863; B *= D) A++;
            A--, B = B / D | 0;
            for (var z = M.length - x, j = z % A, $ = Math.min(z, z - j) + x, C = 0, R = x; R < $; R += A) C = f(M, R, R + A, D), this.imuln(B), this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C);
            if (j !== 0) {
                var k = 1;
                for (C = f(M, R, M.length, D), R = 0; R < j; R++) k *= D;
                this.imuln(k), this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C)
            }
            this.strip()
        }, a.prototype.copy = function (M) {
            M.words = new Array(this.length);
            for (var D = 0; D < this.length; D++) M.words[D] = this.words[D];
            M.length = this.length, M.negative = this.negative, M.red = this.red
        }, a.prototype.clone = function () {
            var M = new a(null);
            return this.copy(M), M
        }, a.prototype._expand = function (M) {
            for (; this.length < M;) this.words[this.length++] = 0;
            return this
        }, a.prototype.strip = function () {
            for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
            return this._normSign()
        }, a.prototype._normSign = function () {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        }, a.prototype.inspect = function () {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        };
        var d = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            p = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            g = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        a.prototype.toString = function (M, D) {
            M = M || 10, D = D | 0 || 1;
            var x;
            if (M === 16 || M === "hex") {
                x = "";
                for (var A = 0, B = 0, z = 0; z < this.length; z++) {
                    var j = this.words[z], $ = ((j << A | B) & 16777215).toString(16);
                    B = j >>> 24 - A & 16777215, B !== 0 || z !== this.length - 1 ? x = d[6 - $.length] + $ + x : x = $ + x, A += 2, A >= 26 && (A -= 26, z--)
                }
                for (B !== 0 && (x = B.toString(16) + x); x.length % D !== 0;) x = "0" + x;
                return this.negative !== 0 && (x = "-" + x), x
            }
            if (M === (M | 0) && M >= 2 && M <= 36) {
                var C = p[M], R = g[M];
                x = "";
                var k = this.clone();
                for (k.negative = 0; !k.isZero();) {
                    var Q = k.modn(R).toString(M);
                    k = k.idivn(R), k.isZero() ? x = Q + x : x = d[C - Q.length] + Q + x
                }
                for (this.isZero() && (x = "0" + x); x.length % D !== 0;) x = "0" + x;
                return this.negative !== 0 && (x = "-" + x), x
            }
            n(!1, "Base should be between 2 and 36")
        }, a.prototype.toNumber = function () {
            var M = this.words[0];
            return this.length === 2 ? M += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? M += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -M : M
        }, a.prototype.toJSON = function () {
            return this.toString(16)
        }, a.prototype.toBuffer = function (M, D) {
            return n(typeof o < "u"), this.toArrayLike(o, M, D)
        }, a.prototype.toArray = function (M, D) {
            return this.toArrayLike(Array, M, D)
        }, a.prototype.toArrayLike = function (M, D, x) {
            var A = this.byteLength(), B = x || Math.max(1, A);
            n(A <= B, "byte array longer than desired length"), n(B > 0, "Requested array length <= 0"), this.strip();
            var z = D === "le", j = new M(B), $, C, R = this.clone();
            if (z) {
                for (C = 0; !R.isZero(); C++) $ = R.andln(255), R.iushrn(8), j[C] = $;
                for (; C < B; C++) j[C] = 0
            } else {
                for (C = 0; C < B - A; C++) j[C] = 0;
                for (C = 0; !R.isZero(); C++) $ = R.andln(255), R.iushrn(8), j[B - C - 1] = $
            }
            return j
        }, Math.clz32 ? a.prototype._countBits = function (M) {
            return 32 - Math.clz32(M)
        } : a.prototype._countBits = function (M) {
            var D = M, x = 0;
            return D >= 4096 && (x += 13, D >>>= 13), D >= 64 && (x += 7, D >>>= 7), D >= 8 && (x += 4, D >>>= 4), D >= 2 && (x += 2, D >>>= 2), x + D
        }, a.prototype._zeroBits = function (M) {
            if (M === 0) return 26;
            var D = M, x = 0;
            return D & 8191 || (x += 13, D >>>= 13), D & 127 || (x += 7, D >>>= 7), D & 15 || (x += 4, D >>>= 4), D & 3 || (x += 2, D >>>= 2), D & 1 || x++, x
        }, a.prototype.bitLength = function () {
            var M = this.words[this.length - 1], D = this._countBits(M);
            return (this.length - 1) * 26 + D
        };

        function b(re) {
            for (var M = new Array(re.bitLength()), D = 0; D < M.length; D++) {
                var x = D / 26 | 0, A = D % 26;
                M[D] = (re.words[x] & 1 << A) >>> A
            }
            return M
        }

        a.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var M = 0, D = 0; D < this.length; D++) {
                var x = this._zeroBits(this.words[D]);
                if (M += x, x !== 26) break
            }
            return M
        }, a.prototype.byteLength = function () {
            return Math.ceil(this.bitLength() / 8)
        }, a.prototype.toTwos = function (M) {
            return this.negative !== 0 ? this.abs().inotn(M).iaddn(1) : this.clone()
        }, a.prototype.fromTwos = function (M) {
            return this.testn(M - 1) ? this.notn(M).iaddn(1).ineg() : this.clone()
        }, a.prototype.isNeg = function () {
            return this.negative !== 0
        }, a.prototype.neg = function () {
            return this.clone().ineg()
        }, a.prototype.ineg = function () {
            return this.isZero() || (this.negative ^= 1), this
        }, a.prototype.iuor = function (M) {
            for (; this.length < M.length;) this.words[this.length++] = 0;
            for (var D = 0; D < M.length; D++) this.words[D] = this.words[D] | M.words[D];
            return this.strip()
        }, a.prototype.ior = function (M) {
            return n((this.negative | M.negative) === 0), this.iuor(M)
        }, a.prototype.or = function (M) {
            return this.length > M.length ? this.clone().ior(M) : M.clone().ior(this)
        }, a.prototype.uor = function (M) {
            return this.length > M.length ? this.clone().iuor(M) : M.clone().iuor(this)
        }, a.prototype.iuand = function (M) {
            var D;
            this.length > M.length ? D = M : D = this;
            for (var x = 0; x < D.length; x++) this.words[x] = this.words[x] & M.words[x];
            return this.length = D.length, this.strip()
        }, a.prototype.iand = function (M) {
            return n((this.negative | M.negative) === 0), this.iuand(M)
        }, a.prototype.and = function (M) {
            return this.length > M.length ? this.clone().iand(M) : M.clone().iand(this)
        }, a.prototype.uand = function (M) {
            return this.length > M.length ? this.clone().iuand(M) : M.clone().iuand(this)
        }, a.prototype.iuxor = function (M) {
            var D, x;
            this.length > M.length ? (D = this, x = M) : (D = M, x = this);
            for (var A = 0; A < x.length; A++) this.words[A] = D.words[A] ^ x.words[A];
            if (this !== D) for (; A < D.length; A++) this.words[A] = D.words[A];
            return this.length = D.length, this.strip()
        }, a.prototype.ixor = function (M) {
            return n((this.negative | M.negative) === 0), this.iuxor(M)
        }, a.prototype.xor = function (M) {
            return this.length > M.length ? this.clone().ixor(M) : M.clone().ixor(this)
        }, a.prototype.uxor = function (M) {
            return this.length > M.length ? this.clone().iuxor(M) : M.clone().iuxor(this)
        }, a.prototype.inotn = function (M) {
            n(typeof M == "number" && M >= 0);
            var D = Math.ceil(M / 26) | 0, x = M % 26;
            this._expand(D), x > 0 && D--;
            for (var A = 0; A < D; A++) this.words[A] = ~this.words[A] & 67108863;
            return x > 0 && (this.words[A] = ~this.words[A] & 67108863 >> 26 - x), this.strip()
        }, a.prototype.notn = function (M) {
            return this.clone().inotn(M)
        }, a.prototype.setn = function (M, D) {
            n(typeof M == "number" && M >= 0);
            var x = M / 26 | 0, A = M % 26;
            return this._expand(x + 1), D ? this.words[x] = this.words[x] | 1 << A : this.words[x] = this.words[x] & ~(1 << A), this.strip()
        }, a.prototype.iadd = function (M) {
            var D;
            if (this.negative !== 0 && M.negative === 0) return this.negative = 0, D = this.isub(M), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && M.negative !== 0) return M.negative = 0, D = this.isub(M), M.negative = 1, D._normSign();
            var x, A;
            this.length > M.length ? (x = this, A = M) : (x = M, A = this);
            for (var B = 0, z = 0; z < A.length; z++) D = (x.words[z] | 0) + (A.words[z] | 0) + B, this.words[z] = D & 67108863, B = D >>> 26;
            for (; B !== 0 && z < x.length; z++) D = (x.words[z] | 0) + B, this.words[z] = D & 67108863, B = D >>> 26;
            if (this.length = x.length, B !== 0) this.words[this.length] = B, this.length++; else if (x !== this) for (; z < x.length; z++) this.words[z] = x.words[z];
            return this
        }, a.prototype.add = function (M) {
            var D;
            return M.negative !== 0 && this.negative === 0 ? (M.negative = 0, D = this.sub(M), M.negative ^= 1, D) : M.negative === 0 && this.negative !== 0 ? (this.negative = 0, D = M.sub(this), this.negative = 1, D) : this.length > M.length ? this.clone().iadd(M) : M.clone().iadd(this)
        }, a.prototype.isub = function (M) {
            if (M.negative !== 0) {
                M.negative = 0;
                var D = this.iadd(M);
                return M.negative = 1, D._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(M), this.negative = 1, this._normSign();
            var x = this.cmp(M);
            if (x === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var A, B;
            x > 0 ? (A = this, B = M) : (A = M, B = this);
            for (var z = 0, j = 0; j < B.length; j++) D = (A.words[j] | 0) - (B.words[j] | 0) + z, z = D >> 26, this.words[j] = D & 67108863;
            for (; z !== 0 && j < A.length; j++) D = (A.words[j] | 0) + z, z = D >> 26, this.words[j] = D & 67108863;
            if (z === 0 && j < A.length && A !== this) for (; j < A.length; j++) this.words[j] = A.words[j];
            return this.length = Math.max(this.length, j), A !== this && (this.negative = 1), this.strip()
        }, a.prototype.sub = function (M) {
            return this.clone().isub(M)
        };

        function S(re, M, D) {
            D.negative = M.negative ^ re.negative;
            var x = re.length + M.length | 0;
            D.length = x, x = x - 1 | 0;
            var A = re.words[0] | 0, B = M.words[0] | 0, z = A * B, j = z & 67108863, $ = z / 67108864 | 0;
            D.words[0] = j;
            for (var C = 1; C < x; C++) {
                for (var R = $ >>> 26, k = $ & 67108863, Q = Math.min(C, M.length - 1), fe = Math.max(0, C - re.length + 1); fe <= Q; fe++) {
                    var ye = C - fe | 0;
                    A = re.words[ye] | 0, B = M.words[fe] | 0, z = A * B + k, R += z / 67108864 | 0, k = z & 67108863
                }
                D.words[C] = k | 0, $ = R | 0
            }
            return $ !== 0 ? D.words[C] = $ | 0 : D.length--, D.strip()
        }

        var T = function (M, D, x) {
            var A = M.words, B = D.words, z = x.words, j = 0, $, C, R, k = A[0] | 0, Q = k & 8191, fe = k >>> 13,
                ye = A[1] | 0, ue = ye & 8191, me = ye >>> 13, Se = A[2] | 0, Ce = Se & 8191, Me = Se >>> 13,
                ve = A[3] | 0, ne = ve & 8191, be = ve >>> 13, Ee = A[4] | 0, Oe = Ee & 8191, ze = Ee >>> 13,
                Be = A[5] | 0, it = Be & 8191, Ue = Be >>> 13, bt = A[6] | 0, gt = bt & 8191, Ot = bt >>> 13,
                zt = A[7] | 0, _t = zt & 8191, Dt = zt >>> 13, rr = A[8] | 0, pe = rr & 8191, te = rr >>> 13,
                X = A[9] | 0, H = X & 8191, U = X >>> 13, q = B[0] | 0, le = q & 8191, xe = q >>> 13, Ae = B[1] | 0,
                De = Ae & 8191, Ze = Ae >>> 13, ft = B[2] | 0, ht = ft & 8191, cr = ft >>> 13, Rt = B[3] | 0,
                Gt = Rt & 8191, sn = Rt >>> 13, Yr = B[4] | 0, br = Yr & 8191, hn = Yr >>> 13, En = B[5] | 0,
                _r = En & 8191, _n = En >>> 13, Nr = B[6] | 0, mr = Nr & 8191, fn = Nr >>> 13, Hn = B[7] | 0,
                Cr = Hn & 8191, An = Hn >>> 13, pn = B[8] | 0, wr = pn & 8191, ke = pn >>> 13, st = B[9] | 0,
                ot = st & 8191, xt = st >>> 13;
            x.negative = M.negative ^ D.negative, x.length = 19, $ = Math.imul(Q, le), C = Math.imul(Q, xe), C = C + Math.imul(fe, le) | 0, R = Math.imul(fe, xe);
            var Yt = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, $ = Math.imul(ue, le), C = Math.imul(ue, xe), C = C + Math.imul(me, le) | 0, R = Math.imul(me, xe), $ = $ + Math.imul(Q, De) | 0, C = C + Math.imul(Q, Ze) | 0, C = C + Math.imul(fe, De) | 0, R = R + Math.imul(fe, Ze) | 0;
            var vr = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, $ = Math.imul(Ce, le), C = Math.imul(Ce, xe), C = C + Math.imul(Me, le) | 0, R = Math.imul(Me, xe), $ = $ + Math.imul(ue, De) | 0, C = C + Math.imul(ue, Ze) | 0, C = C + Math.imul(me, De) | 0, R = R + Math.imul(me, Ze) | 0, $ = $ + Math.imul(Q, ht) | 0, C = C + Math.imul(Q, cr) | 0, C = C + Math.imul(fe, ht) | 0, R = R + Math.imul(fe, cr) | 0;
            var Vr = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, $ = Math.imul(ne, le), C = Math.imul(ne, xe), C = C + Math.imul(be, le) | 0, R = Math.imul(be, xe), $ = $ + Math.imul(Ce, De) | 0, C = C + Math.imul(Ce, Ze) | 0, C = C + Math.imul(Me, De) | 0, R = R + Math.imul(Me, Ze) | 0, $ = $ + Math.imul(ue, ht) | 0, C = C + Math.imul(ue, cr) | 0, C = C + Math.imul(me, ht) | 0, R = R + Math.imul(me, cr) | 0, $ = $ + Math.imul(Q, Gt) | 0, C = C + Math.imul(Q, sn) | 0, C = C + Math.imul(fe, Gt) | 0, R = R + Math.imul(fe, sn) | 0;
            var Ur = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, $ = Math.imul(Oe, le), C = Math.imul(Oe, xe), C = C + Math.imul(ze, le) | 0, R = Math.imul(ze, xe), $ = $ + Math.imul(ne, De) | 0, C = C + Math.imul(ne, Ze) | 0, C = C + Math.imul(be, De) | 0, R = R + Math.imul(be, Ze) | 0, $ = $ + Math.imul(Ce, ht) | 0, C = C + Math.imul(Ce, cr) | 0, C = C + Math.imul(Me, ht) | 0, R = R + Math.imul(Me, cr) | 0, $ = $ + Math.imul(ue, Gt) | 0, C = C + Math.imul(ue, sn) | 0, C = C + Math.imul(me, Gt) | 0, R = R + Math.imul(me, sn) | 0, $ = $ + Math.imul(Q, br) | 0, C = C + Math.imul(Q, hn) | 0, C = C + Math.imul(fe, br) | 0, R = R + Math.imul(fe, hn) | 0;
            var fi = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, $ = Math.imul(it, le), C = Math.imul(it, xe), C = C + Math.imul(Ue, le) | 0, R = Math.imul(Ue, xe), $ = $ + Math.imul(Oe, De) | 0, C = C + Math.imul(Oe, Ze) | 0, C = C + Math.imul(ze, De) | 0, R = R + Math.imul(ze, Ze) | 0, $ = $ + Math.imul(ne, ht) | 0, C = C + Math.imul(ne, cr) | 0, C = C + Math.imul(be, ht) | 0, R = R + Math.imul(be, cr) | 0, $ = $ + Math.imul(Ce, Gt) | 0, C = C + Math.imul(Ce, sn) | 0, C = C + Math.imul(Me, Gt) | 0, R = R + Math.imul(Me, sn) | 0, $ = $ + Math.imul(ue, br) | 0, C = C + Math.imul(ue, hn) | 0, C = C + Math.imul(me, br) | 0, R = R + Math.imul(me, hn) | 0, $ = $ + Math.imul(Q, _r) | 0, C = C + Math.imul(Q, _n) | 0, C = C + Math.imul(fe, _r) | 0, R = R + Math.imul(fe, _n) | 0;
            var In = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, $ = Math.imul(gt, le), C = Math.imul(gt, xe), C = C + Math.imul(Ot, le) | 0, R = Math.imul(Ot, xe), $ = $ + Math.imul(it, De) | 0, C = C + Math.imul(it, Ze) | 0, C = C + Math.imul(Ue, De) | 0, R = R + Math.imul(Ue, Ze) | 0, $ = $ + Math.imul(Oe, ht) | 0, C = C + Math.imul(Oe, cr) | 0, C = C + Math.imul(ze, ht) | 0, R = R + Math.imul(ze, cr) | 0, $ = $ + Math.imul(ne, Gt) | 0, C = C + Math.imul(ne, sn) | 0, C = C + Math.imul(be, Gt) | 0, R = R + Math.imul(be, sn) | 0, $ = $ + Math.imul(Ce, br) | 0, C = C + Math.imul(Ce, hn) | 0, C = C + Math.imul(Me, br) | 0, R = R + Math.imul(Me, hn) | 0, $ = $ + Math.imul(ue, _r) | 0, C = C + Math.imul(ue, _n) | 0, C = C + Math.imul(me, _r) | 0, R = R + Math.imul(me, _n) | 0, $ = $ + Math.imul(Q, mr) | 0, C = C + Math.imul(Q, fn) | 0, C = C + Math.imul(fe, mr) | 0, R = R + Math.imul(fe, fn) | 0;
            var kn = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, $ = Math.imul(_t, le), C = Math.imul(_t, xe), C = C + Math.imul(Dt, le) | 0, R = Math.imul(Dt, xe), $ = $ + Math.imul(gt, De) | 0, C = C + Math.imul(gt, Ze) | 0, C = C + Math.imul(Ot, De) | 0, R = R + Math.imul(Ot, Ze) | 0, $ = $ + Math.imul(it, ht) | 0, C = C + Math.imul(it, cr) | 0, C = C + Math.imul(Ue, ht) | 0, R = R + Math.imul(Ue, cr) | 0, $ = $ + Math.imul(Oe, Gt) | 0, C = C + Math.imul(Oe, sn) | 0, C = C + Math.imul(ze, Gt) | 0, R = R + Math.imul(ze, sn) | 0, $ = $ + Math.imul(ne, br) | 0, C = C + Math.imul(ne, hn) | 0, C = C + Math.imul(be, br) | 0, R = R + Math.imul(be, hn) | 0, $ = $ + Math.imul(Ce, _r) | 0, C = C + Math.imul(Ce, _n) | 0, C = C + Math.imul(Me, _r) | 0, R = R + Math.imul(Me, _n) | 0, $ = $ + Math.imul(ue, mr) | 0, C = C + Math.imul(ue, fn) | 0, C = C + Math.imul(me, mr) | 0, R = R + Math.imul(me, fn) | 0, $ = $ + Math.imul(Q, Cr) | 0, C = C + Math.imul(Q, An) | 0, C = C + Math.imul(fe, Cr) | 0, R = R + Math.imul(fe, An) | 0;
            var Ai = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Ai >>> 26) | 0, Ai &= 67108863, $ = Math.imul(pe, le), C = Math.imul(pe, xe), C = C + Math.imul(te, le) | 0, R = Math.imul(te, xe), $ = $ + Math.imul(_t, De) | 0, C = C + Math.imul(_t, Ze) | 0, C = C + Math.imul(Dt, De) | 0, R = R + Math.imul(Dt, Ze) | 0, $ = $ + Math.imul(gt, ht) | 0, C = C + Math.imul(gt, cr) | 0, C = C + Math.imul(Ot, ht) | 0, R = R + Math.imul(Ot, cr) | 0, $ = $ + Math.imul(it, Gt) | 0, C = C + Math.imul(it, sn) | 0, C = C + Math.imul(Ue, Gt) | 0, R = R + Math.imul(Ue, sn) | 0, $ = $ + Math.imul(Oe, br) | 0, C = C + Math.imul(Oe, hn) | 0, C = C + Math.imul(ze, br) | 0, R = R + Math.imul(ze, hn) | 0, $ = $ + Math.imul(ne, _r) | 0, C = C + Math.imul(ne, _n) | 0, C = C + Math.imul(be, _r) | 0, R = R + Math.imul(be, _n) | 0, $ = $ + Math.imul(Ce, mr) | 0, C = C + Math.imul(Ce, fn) | 0, C = C + Math.imul(Me, mr) | 0, R = R + Math.imul(Me, fn) | 0, $ = $ + Math.imul(ue, Cr) | 0, C = C + Math.imul(ue, An) | 0, C = C + Math.imul(me, Cr) | 0, R = R + Math.imul(me, An) | 0, $ = $ + Math.imul(Q, wr) | 0, C = C + Math.imul(Q, ke) | 0, C = C + Math.imul(fe, wr) | 0, R = R + Math.imul(fe, ke) | 0;
            var Fi = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Fi >>> 26) | 0, Fi &= 67108863, $ = Math.imul(H, le), C = Math.imul(H, xe), C = C + Math.imul(U, le) | 0, R = Math.imul(U, xe), $ = $ + Math.imul(pe, De) | 0, C = C + Math.imul(pe, Ze) | 0, C = C + Math.imul(te, De) | 0, R = R + Math.imul(te, Ze) | 0, $ = $ + Math.imul(_t, ht) | 0, C = C + Math.imul(_t, cr) | 0, C = C + Math.imul(Dt, ht) | 0, R = R + Math.imul(Dt, cr) | 0, $ = $ + Math.imul(gt, Gt) | 0, C = C + Math.imul(gt, sn) | 0, C = C + Math.imul(Ot, Gt) | 0, R = R + Math.imul(Ot, sn) | 0, $ = $ + Math.imul(it, br) | 0, C = C + Math.imul(it, hn) | 0, C = C + Math.imul(Ue, br) | 0, R = R + Math.imul(Ue, hn) | 0, $ = $ + Math.imul(Oe, _r) | 0, C = C + Math.imul(Oe, _n) | 0, C = C + Math.imul(ze, _r) | 0, R = R + Math.imul(ze, _n) | 0, $ = $ + Math.imul(ne, mr) | 0, C = C + Math.imul(ne, fn) | 0, C = C + Math.imul(be, mr) | 0, R = R + Math.imul(be, fn) | 0, $ = $ + Math.imul(Ce, Cr) | 0, C = C + Math.imul(Ce, An) | 0, C = C + Math.imul(Me, Cr) | 0, R = R + Math.imul(Me, An) | 0, $ = $ + Math.imul(ue, wr) | 0, C = C + Math.imul(ue, ke) | 0, C = C + Math.imul(me, wr) | 0, R = R + Math.imul(me, ke) | 0, $ = $ + Math.imul(Q, ot) | 0, C = C + Math.imul(Q, xt) | 0, C = C + Math.imul(fe, ot) | 0, R = R + Math.imul(fe, xt) | 0;
            var Pt = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, $ = Math.imul(H, De), C = Math.imul(H, Ze), C = C + Math.imul(U, De) | 0, R = Math.imul(U, Ze), $ = $ + Math.imul(pe, ht) | 0, C = C + Math.imul(pe, cr) | 0, C = C + Math.imul(te, ht) | 0, R = R + Math.imul(te, cr) | 0, $ = $ + Math.imul(_t, Gt) | 0, C = C + Math.imul(_t, sn) | 0, C = C + Math.imul(Dt, Gt) | 0, R = R + Math.imul(Dt, sn) | 0, $ = $ + Math.imul(gt, br) | 0, C = C + Math.imul(gt, hn) | 0, C = C + Math.imul(Ot, br) | 0, R = R + Math.imul(Ot, hn) | 0, $ = $ + Math.imul(it, _r) | 0, C = C + Math.imul(it, _n) | 0, C = C + Math.imul(Ue, _r) | 0, R = R + Math.imul(Ue, _n) | 0, $ = $ + Math.imul(Oe, mr) | 0, C = C + Math.imul(Oe, fn) | 0, C = C + Math.imul(ze, mr) | 0, R = R + Math.imul(ze, fn) | 0, $ = $ + Math.imul(ne, Cr) | 0, C = C + Math.imul(ne, An) | 0, C = C + Math.imul(be, Cr) | 0, R = R + Math.imul(be, An) | 0, $ = $ + Math.imul(Ce, wr) | 0, C = C + Math.imul(Ce, ke) | 0, C = C + Math.imul(Me, wr) | 0, R = R + Math.imul(Me, ke) | 0, $ = $ + Math.imul(ue, ot) | 0, C = C + Math.imul(ue, xt) | 0, C = C + Math.imul(me, ot) | 0, R = R + Math.imul(me, xt) | 0;
            var Wn = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Wn >>> 26) | 0, Wn &= 67108863, $ = Math.imul(H, ht), C = Math.imul(H, cr), C = C + Math.imul(U, ht) | 0, R = Math.imul(U, cr), $ = $ + Math.imul(pe, Gt) | 0, C = C + Math.imul(pe, sn) | 0, C = C + Math.imul(te, Gt) | 0, R = R + Math.imul(te, sn) | 0, $ = $ + Math.imul(_t, br) | 0, C = C + Math.imul(_t, hn) | 0, C = C + Math.imul(Dt, br) | 0, R = R + Math.imul(Dt, hn) | 0, $ = $ + Math.imul(gt, _r) | 0, C = C + Math.imul(gt, _n) | 0, C = C + Math.imul(Ot, _r) | 0, R = R + Math.imul(Ot, _n) | 0, $ = $ + Math.imul(it, mr) | 0, C = C + Math.imul(it, fn) | 0, C = C + Math.imul(Ue, mr) | 0, R = R + Math.imul(Ue, fn) | 0, $ = $ + Math.imul(Oe, Cr) | 0, C = C + Math.imul(Oe, An) | 0, C = C + Math.imul(ze, Cr) | 0, R = R + Math.imul(ze, An) | 0, $ = $ + Math.imul(ne, wr) | 0, C = C + Math.imul(ne, ke) | 0, C = C + Math.imul(be, wr) | 0, R = R + Math.imul(be, ke) | 0, $ = $ + Math.imul(Ce, ot) | 0, C = C + Math.imul(Ce, xt) | 0, C = C + Math.imul(Me, ot) | 0, R = R + Math.imul(Me, xt) | 0;
            var Da = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Da >>> 26) | 0, Da &= 67108863, $ = Math.imul(H, Gt), C = Math.imul(H, sn), C = C + Math.imul(U, Gt) | 0, R = Math.imul(U, sn), $ = $ + Math.imul(pe, br) | 0, C = C + Math.imul(pe, hn) | 0, C = C + Math.imul(te, br) | 0, R = R + Math.imul(te, hn) | 0, $ = $ + Math.imul(_t, _r) | 0, C = C + Math.imul(_t, _n) | 0, C = C + Math.imul(Dt, _r) | 0, R = R + Math.imul(Dt, _n) | 0, $ = $ + Math.imul(gt, mr) | 0, C = C + Math.imul(gt, fn) | 0, C = C + Math.imul(Ot, mr) | 0, R = R + Math.imul(Ot, fn) | 0, $ = $ + Math.imul(it, Cr) | 0, C = C + Math.imul(it, An) | 0, C = C + Math.imul(Ue, Cr) | 0, R = R + Math.imul(Ue, An) | 0, $ = $ + Math.imul(Oe, wr) | 0, C = C + Math.imul(Oe, ke) | 0, C = C + Math.imul(ze, wr) | 0, R = R + Math.imul(ze, ke) | 0, $ = $ + Math.imul(ne, ot) | 0, C = C + Math.imul(ne, xt) | 0, C = C + Math.imul(be, ot) | 0, R = R + Math.imul(be, xt) | 0;
            var Ma = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, $ = Math.imul(H, br), C = Math.imul(H, hn), C = C + Math.imul(U, br) | 0, R = Math.imul(U, hn), $ = $ + Math.imul(pe, _r) | 0, C = C + Math.imul(pe, _n) | 0, C = C + Math.imul(te, _r) | 0, R = R + Math.imul(te, _n) | 0, $ = $ + Math.imul(_t, mr) | 0, C = C + Math.imul(_t, fn) | 0, C = C + Math.imul(Dt, mr) | 0, R = R + Math.imul(Dt, fn) | 0, $ = $ + Math.imul(gt, Cr) | 0, C = C + Math.imul(gt, An) | 0, C = C + Math.imul(Ot, Cr) | 0, R = R + Math.imul(Ot, An) | 0, $ = $ + Math.imul(it, wr) | 0, C = C + Math.imul(it, ke) | 0, C = C + Math.imul(Ue, wr) | 0, R = R + Math.imul(Ue, ke) | 0, $ = $ + Math.imul(Oe, ot) | 0, C = C + Math.imul(Oe, xt) | 0, C = C + Math.imul(ze, ot) | 0, R = R + Math.imul(ze, xt) | 0;
            var Oa = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Oa >>> 26) | 0, Oa &= 67108863, $ = Math.imul(H, _r), C = Math.imul(H, _n), C = C + Math.imul(U, _r) | 0, R = Math.imul(U, _n), $ = $ + Math.imul(pe, mr) | 0, C = C + Math.imul(pe, fn) | 0, C = C + Math.imul(te, mr) | 0, R = R + Math.imul(te, fn) | 0, $ = $ + Math.imul(_t, Cr) | 0, C = C + Math.imul(_t, An) | 0, C = C + Math.imul(Dt, Cr) | 0, R = R + Math.imul(Dt, An) | 0, $ = $ + Math.imul(gt, wr) | 0, C = C + Math.imul(gt, ke) | 0, C = C + Math.imul(Ot, wr) | 0, R = R + Math.imul(Ot, ke) | 0, $ = $ + Math.imul(it, ot) | 0, C = C + Math.imul(it, xt) | 0, C = C + Math.imul(Ue, ot) | 0, R = R + Math.imul(Ue, xt) | 0;
            var Za = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, $ = Math.imul(H, mr), C = Math.imul(H, fn), C = C + Math.imul(U, mr) | 0, R = Math.imul(U, fn), $ = $ + Math.imul(pe, Cr) | 0, C = C + Math.imul(pe, An) | 0, C = C + Math.imul(te, Cr) | 0, R = R + Math.imul(te, An) | 0, $ = $ + Math.imul(_t, wr) | 0, C = C + Math.imul(_t, ke) | 0, C = C + Math.imul(Dt, wr) | 0, R = R + Math.imul(Dt, ke) | 0, $ = $ + Math.imul(gt, ot) | 0, C = C + Math.imul(gt, xt) | 0, C = C + Math.imul(Ot, ot) | 0, R = R + Math.imul(Ot, xt) | 0;
            var Po = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Po >>> 26) | 0, Po &= 67108863, $ = Math.imul(H, Cr), C = Math.imul(H, An), C = C + Math.imul(U, Cr) | 0, R = Math.imul(U, An), $ = $ + Math.imul(pe, wr) | 0, C = C + Math.imul(pe, ke) | 0, C = C + Math.imul(te, wr) | 0, R = R + Math.imul(te, ke) | 0, $ = $ + Math.imul(_t, ot) | 0, C = C + Math.imul(_t, xt) | 0, C = C + Math.imul(Dt, ot) | 0, R = R + Math.imul(Dt, xt) | 0;
            var Ja = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (Ja >>> 26) | 0, Ja &= 67108863, $ = Math.imul(H, wr), C = Math.imul(H, ke), C = C + Math.imul(U, wr) | 0, R = Math.imul(U, ke), $ = $ + Math.imul(pe, ot) | 0, C = C + Math.imul(pe, xt) | 0, C = C + Math.imul(te, ot) | 0, R = R + Math.imul(te, xt) | 0;
            var qi = (j + $ | 0) + ((C & 8191) << 13) | 0;
            j = (R + (C >>> 13) | 0) + (qi >>> 26) | 0, qi &= 67108863, $ = Math.imul(H, ot), C = Math.imul(H, xt), C = C + Math.imul(U, ot) | 0, R = Math.imul(U, xt);
            var Ko = (j + $ | 0) + ((C & 8191) << 13) | 0;
            return j = (R + (C >>> 13) | 0) + (Ko >>> 26) | 0, Ko &= 67108863, z[0] = Yt, z[1] = vr, z[2] = Vr, z[3] = Ur, z[4] = fi, z[5] = In, z[6] = kn, z[7] = Ai, z[8] = Fi, z[9] = Pt, z[10] = Wn, z[11] = Da, z[12] = Ma, z[13] = Oa, z[14] = Za, z[15] = Po, z[16] = Ja, z[17] = qi, z[18] = Ko, j !== 0 && (z[19] = j, x.length++), x
        };
        Math.imul || (T = S);

        function I(re, M, D) {
            D.negative = M.negative ^ re.negative, D.length = re.length + M.length;
            for (var x = 0, A = 0, B = 0; B < D.length - 1; B++) {
                var z = A;
                A = 0;
                for (var j = x & 67108863, $ = Math.min(B, M.length - 1), C = Math.max(0, B - re.length + 1); C <= $; C++) {
                    var R = B - C, k = re.words[R] | 0, Q = M.words[C] | 0, fe = k * Q, ye = fe & 67108863;
                    z = z + (fe / 67108864 | 0) | 0, ye = ye + j | 0, j = ye & 67108863, z = z + (ye >>> 26) | 0, A += z >>> 26, z &= 67108863
                }
                D.words[B] = j, x = z, z = A
            }
            return x !== 0 ? D.words[B] = x : D.length--, D.strip()
        }

        function N(re, M, D) {
            var x = new P;
            return x.mulp(re, M, D)
        }

        a.prototype.mulTo = function (M, D) {
            var x, A = this.length + M.length;
            return this.length === 10 && M.length === 10 ? x = T(this, M, D) : A < 63 ? x = S(this, M, D) : A < 1024 ? x = I(this, M, D) : x = N(this, M, D), x
        };

        function P(re, M) {
            this.x = re, this.y = M
        }

        P.prototype.makeRBT = function (M) {
            for (var D = new Array(M), x = a.prototype._countBits(M) - 1, A = 0; A < M; A++) D[A] = this.revBin(A, x, M);
            return D
        }, P.prototype.revBin = function (M, D, x) {
            if (M === 0 || M === x - 1) return M;
            for (var A = 0, B = 0; B < D; B++) A |= (M & 1) << D - B - 1, M >>= 1;
            return A
        }, P.prototype.permute = function (M, D, x, A, B, z) {
            for (var j = 0; j < z; j++) A[j] = D[M[j]], B[j] = x[M[j]]
        }, P.prototype.transform = function (M, D, x, A, B, z) {
            this.permute(z, M, D, x, A, B);
            for (var j = 1; j < B; j <<= 1) for (var $ = j << 1, C = Math.cos(2 * Math.PI / $), R = Math.sin(2 * Math.PI / $), k = 0; k < B; k += $) for (var Q = C, fe = R, ye = 0; ye < j; ye++) {
                var ue = x[k + ye], me = A[k + ye], Se = x[k + ye + j], Ce = A[k + ye + j], Me = Q * Se - fe * Ce;
                Ce = Q * Ce + fe * Se, Se = Me, x[k + ye] = ue + Se, A[k + ye] = me + Ce, x[k + ye + j] = ue - Se, A[k + ye + j] = me - Ce, ye !== $ && (Me = C * Q - R * fe, fe = C * fe + R * Q, Q = Me)
            }
        }, P.prototype.guessLen13b = function (M, D) {
            var x = Math.max(D, M) | 1, A = x & 1, B = 0;
            for (x = x / 2 | 0; x; x = x >>> 1) B++;
            return 1 << B + 1 + A
        }, P.prototype.conjugate = function (M, D, x) {
            if (!(x <= 1)) for (var A = 0; A < x / 2; A++) {
                var B = M[A];
                M[A] = M[x - A - 1], M[x - A - 1] = B, B = D[A], D[A] = -D[x - A - 1], D[x - A - 1] = -B
            }
        }, P.prototype.normalize13b = function (M, D) {
            for (var x = 0, A = 0; A < D / 2; A++) {
                var B = Math.round(M[2 * A + 1] / D) * 8192 + Math.round(M[2 * A] / D) + x;
                M[A] = B & 67108863, B < 67108864 ? x = 0 : x = B / 67108864 | 0
            }
            return M
        }, P.prototype.convert13b = function (M, D, x, A) {
            for (var B = 0, z = 0; z < D; z++) B = B + (M[z] | 0), x[2 * z] = B & 8191, B = B >>> 13, x[2 * z + 1] = B & 8191, B = B >>> 13;
            for (z = 2 * D; z < A; ++z) x[z] = 0;
            n(B === 0), n((B & -8192) === 0)
        }, P.prototype.stub = function (M) {
            for (var D = new Array(M), x = 0; x < M; x++) D[x] = 0;
            return D
        }, P.prototype.mulp = function (M, D, x) {
            var A = 2 * this.guessLen13b(M.length, D.length), B = this.makeRBT(A), z = this.stub(A), j = new Array(A),
                $ = new Array(A), C = new Array(A), R = new Array(A), k = new Array(A), Q = new Array(A), fe = x.words;
            fe.length = A, this.convert13b(M.words, M.length, j, A), this.convert13b(D.words, D.length, R, A), this.transform(j, z, $, C, A, B), this.transform(R, z, k, Q, A, B);
            for (var ye = 0; ye < A; ye++) {
                var ue = $[ye] * k[ye] - C[ye] * Q[ye];
                C[ye] = $[ye] * Q[ye] + C[ye] * k[ye], $[ye] = ue
            }
            return this.conjugate($, C, A), this.transform($, C, fe, z, A, B), this.conjugate(fe, z, A), this.normalize13b(fe, A), x.negative = M.negative ^ D.negative, x.length = M.length + D.length, x.strip()
        }, a.prototype.mul = function (M) {
            var D = new a(null);
            return D.words = new Array(this.length + M.length), this.mulTo(M, D)
        }, a.prototype.mulf = function (M) {
            var D = new a(null);
            return D.words = new Array(this.length + M.length), N(this, M, D)
        }, a.prototype.imul = function (M) {
            return this.clone().mulTo(M, this)
        }, a.prototype.imuln = function (M) {
            n(typeof M == "number"), n(M < 67108864);
            for (var D = 0, x = 0; x < this.length; x++) {
                var A = (this.words[x] | 0) * M, B = (A & 67108863) + (D & 67108863);
                D >>= 26, D += A / 67108864 | 0, D += B >>> 26, this.words[x] = B & 67108863
            }
            return D !== 0 && (this.words[x] = D, this.length++), this
        }, a.prototype.muln = function (M) {
            return this.clone().imuln(M)
        }, a.prototype.sqr = function () {
            return this.mul(this)
        }, a.prototype.isqr = function () {
            return this.imul(this.clone())
        }, a.prototype.pow = function (M) {
            var D = b(M);
            if (D.length === 0) return new a(1);
            for (var x = this, A = 0; A < D.length && D[A] === 0; A++, x = x.sqr()) ;
            if (++A < D.length) for (var B = x.sqr(); A < D.length; A++, B = B.sqr()) D[A] !== 0 && (x = x.mul(B));
            return x
        }, a.prototype.iushln = function (M) {
            n(typeof M == "number" && M >= 0);
            var D = M % 26, x = (M - D) / 26, A = 67108863 >>> 26 - D << 26 - D, B;
            if (D !== 0) {
                var z = 0;
                for (B = 0; B < this.length; B++) {
                    var j = this.words[B] & A, $ = (this.words[B] | 0) - j << D;
                    this.words[B] = $ | z, z = j >>> 26 - D
                }
                z && (this.words[B] = z, this.length++)
            }
            if (x !== 0) {
                for (B = this.length - 1; B >= 0; B--) this.words[B + x] = this.words[B];
                for (B = 0; B < x; B++) this.words[B] = 0;
                this.length += x
            }
            return this.strip()
        }, a.prototype.ishln = function (M) {
            return n(this.negative === 0), this.iushln(M)
        }, a.prototype.iushrn = function (M, D, x) {
            n(typeof M == "number" && M >= 0);
            var A;
            D ? A = (D - D % 26) / 26 : A = 0;
            var B = M % 26, z = Math.min((M - B) / 26, this.length), j = 67108863 ^ 67108863 >>> B << B, $ = x;
            if (A -= z, A = Math.max(0, A), $) {
                for (var C = 0; C < z; C++) $.words[C] = this.words[C];
                $.length = z
            }
            if (z !== 0) if (this.length > z) for (this.length -= z, C = 0; C < this.length; C++) this.words[C] = this.words[C + z]; else this.words[0] = 0, this.length = 1;
            var R = 0;
            for (C = this.length - 1; C >= 0 && (R !== 0 || C >= A); C--) {
                var k = this.words[C] | 0;
                this.words[C] = R << 26 - B | k >>> B, R = k & j
            }
            return $ && R !== 0 && ($.words[$.length++] = R), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip()
        }, a.prototype.ishrn = function (M, D, x) {
            return n(this.negative === 0), this.iushrn(M, D, x)
        }, a.prototype.shln = function (M) {
            return this.clone().ishln(M)
        }, a.prototype.ushln = function (M) {
            return this.clone().iushln(M)
        }, a.prototype.shrn = function (M) {
            return this.clone().ishrn(M)
        }, a.prototype.ushrn = function (M) {
            return this.clone().iushrn(M)
        }, a.prototype.testn = function (M) {
            n(typeof M == "number" && M >= 0);
            var D = M % 26, x = (M - D) / 26, A = 1 << D;
            if (this.length <= x) return !1;
            var B = this.words[x];
            return !!(B & A)
        }, a.prototype.imaskn = function (M) {
            n(typeof M == "number" && M >= 0);
            var D = M % 26, x = (M - D) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= x) return this;
            if (D !== 0 && x++, this.length = Math.min(x, this.length), D !== 0) {
                var A = 67108863 ^ 67108863 >>> D << D;
                this.words[this.length - 1] &= A
            }
            return this.strip()
        }, a.prototype.maskn = function (M) {
            return this.clone().imaskn(M)
        }, a.prototype.iaddn = function (M) {
            return n(typeof M == "number"), n(M < 67108864), M < 0 ? this.isubn(-M) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < M ? (this.words[0] = M - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(M), this.negative = 1, this) : this._iaddn(M)
        }, a.prototype._iaddn = function (M) {
            this.words[0] += M;
            for (var D = 0; D < this.length && this.words[D] >= 67108864; D++) this.words[D] -= 67108864, D === this.length - 1 ? this.words[D + 1] = 1 : this.words[D + 1]++;
            return this.length = Math.max(this.length, D + 1), this
        }, a.prototype.isubn = function (M) {
            if (n(typeof M == "number"), n(M < 67108864), M < 0) return this.iaddn(-M);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(M), this.negative = 1, this;
            if (this.words[0] -= M, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var D = 0; D < this.length && this.words[D] < 0; D++) this.words[D] += 67108864, this.words[D + 1] -= 1;
            return this.strip()
        }, a.prototype.addn = function (M) {
            return this.clone().iaddn(M)
        }, a.prototype.subn = function (M) {
            return this.clone().isubn(M)
        }, a.prototype.iabs = function () {
            return this.negative = 0, this
        }, a.prototype.abs = function () {
            return this.clone().iabs()
        }, a.prototype._ishlnsubmul = function (M, D, x) {
            var A = M.length + x, B;
            this._expand(A);
            var z, j = 0;
            for (B = 0; B < M.length; B++) {
                z = (this.words[B + x] | 0) + j;
                var $ = (M.words[B] | 0) * D;
                z -= $ & 67108863, j = (z >> 26) - ($ / 67108864 | 0), this.words[B + x] = z & 67108863
            }
            for (; B < this.length - x; B++) z = (this.words[B + x] | 0) + j, j = z >> 26, this.words[B + x] = z & 67108863;
            if (j === 0) return this.strip();
            for (n(j === -1), j = 0, B = 0; B < this.length; B++) z = -(this.words[B] | 0) + j, j = z >> 26, this.words[B] = z & 67108863;
            return this.negative = 1, this.strip()
        }, a.prototype._wordDiv = function (M, D) {
            var x = this.length - M.length, A = this.clone(), B = M, z = B.words[B.length - 1] | 0,
                j = this._countBits(z);
            x = 26 - j, x !== 0 && (B = B.ushln(x), A.iushln(x), z = B.words[B.length - 1] | 0);
            var $ = A.length - B.length, C;
            if (D !== "mod") {
                C = new a(null), C.length = $ + 1, C.words = new Array(C.length);
                for (var R = 0; R < C.length; R++) C.words[R] = 0
            }
            var k = A.clone()._ishlnsubmul(B, 1, $);
            k.negative === 0 && (A = k, C && (C.words[$] = 1));
            for (var Q = $ - 1; Q >= 0; Q--) {
                var fe = (A.words[B.length + Q] | 0) * 67108864 + (A.words[B.length + Q - 1] | 0);
                for (fe = Math.min(fe / z | 0, 67108863), A._ishlnsubmul(B, fe, Q); A.negative !== 0;) fe--, A.negative = 0, A._ishlnsubmul(B, 1, Q), A.isZero() || (A.negative ^= 1);
                C && (C.words[Q] = fe)
            }
            return C && C.strip(), A.strip(), D !== "div" && x !== 0 && A.iushrn(x), {div: C || null, mod: A}
        }, a.prototype.divmod = function (M, D, x) {
            if (n(!M.isZero()), this.isZero()) return {div: new a(0), mod: new a(0)};
            var A, B, z;
            return this.negative !== 0 && M.negative === 0 ? (z = this.neg().divmod(M, D), D !== "mod" && (A = z.div.neg()), D !== "div" && (B = z.mod.neg(), x && B.negative !== 0 && B.iadd(M)), {
                div: A,
                mod: B
            }) : this.negative === 0 && M.negative !== 0 ? (z = this.divmod(M.neg(), D), D !== "mod" && (A = z.div.neg()), {
                div: A,
                mod: z.mod
            }) : this.negative & M.negative ? (z = this.neg().divmod(M.neg(), D), D !== "div" && (B = z.mod.neg(), x && B.negative !== 0 && B.isub(M)), {
                div: z.div,
                mod: B
            }) : M.length > this.length || this.cmp(M) < 0 ? {
                div: new a(0),
                mod: this
            } : M.length === 1 ? D === "div" ? {div: this.divn(M.words[0]), mod: null} : D === "mod" ? {
                div: null,
                mod: new a(this.modn(M.words[0]))
            } : {div: this.divn(M.words[0]), mod: new a(this.modn(M.words[0]))} : this._wordDiv(M, D)
        }, a.prototype.div = function (M) {
            return this.divmod(M, "div", !1).div
        }, a.prototype.mod = function (M) {
            return this.divmod(M, "mod", !1).mod
        }, a.prototype.umod = function (M) {
            return this.divmod(M, "mod", !0).mod
        }, a.prototype.divRound = function (M) {
            var D = this.divmod(M);
            if (D.mod.isZero()) return D.div;
            var x = D.div.negative !== 0 ? D.mod.isub(M) : D.mod, A = M.ushrn(1), B = M.andln(1), z = x.cmp(A);
            return z < 0 || B === 1 && z === 0 ? D.div : D.div.negative !== 0 ? D.div.isubn(1) : D.div.iaddn(1)
        }, a.prototype.modn = function (M) {
            n(M <= 67108863);
            for (var D = (1 << 26) % M, x = 0, A = this.length - 1; A >= 0; A--) x = (D * x + (this.words[A] | 0)) % M;
            return x
        }, a.prototype.idivn = function (M) {
            n(M <= 67108863);
            for (var D = 0, x = this.length - 1; x >= 0; x--) {
                var A = (this.words[x] | 0) + D * 67108864;
                this.words[x] = A / M | 0, D = A % M
            }
            return this.strip()
        }, a.prototype.divn = function (M) {
            return this.clone().idivn(M)
        }, a.prototype.egcd = function (M) {
            n(M.negative === 0), n(!M.isZero());
            var D = this, x = M.clone();
            D.negative !== 0 ? D = D.umod(M) : D = D.clone();
            for (var A = new a(1), B = new a(0), z = new a(0), j = new a(1), $ = 0; D.isEven() && x.isEven();) D.iushrn(1), x.iushrn(1), ++$;
            for (var C = x.clone(), R = D.clone(); !D.isZero();) {
                for (var k = 0, Q = 1; !(D.words[0] & Q) && k < 26; ++k, Q <<= 1) ;
                if (k > 0) for (D.iushrn(k); k-- > 0;) (A.isOdd() || B.isOdd()) && (A.iadd(C), B.isub(R)), A.iushrn(1), B.iushrn(1);
                for (var fe = 0, ye = 1; !(x.words[0] & ye) && fe < 26; ++fe, ye <<= 1) ;
                if (fe > 0) for (x.iushrn(fe); fe-- > 0;) (z.isOdd() || j.isOdd()) && (z.iadd(C), j.isub(R)), z.iushrn(1), j.iushrn(1);
                D.cmp(x) >= 0 ? (D.isub(x), A.isub(z), B.isub(j)) : (x.isub(D), z.isub(A), j.isub(B))
            }
            return {a: z, b: j, gcd: x.iushln($)}
        }, a.prototype._invmp = function (M) {
            n(M.negative === 0), n(!M.isZero());
            var D = this, x = M.clone();
            D.negative !== 0 ? D = D.umod(M) : D = D.clone();
            for (var A = new a(1), B = new a(0), z = x.clone(); D.cmpn(1) > 0 && x.cmpn(1) > 0;) {
                for (var j = 0, $ = 1; !(D.words[0] & $) && j < 26; ++j, $ <<= 1) ;
                if (j > 0) for (D.iushrn(j); j-- > 0;) A.isOdd() && A.iadd(z), A.iushrn(1);
                for (var C = 0, R = 1; !(x.words[0] & R) && C < 26; ++C, R <<= 1) ;
                if (C > 0) for (x.iushrn(C); C-- > 0;) B.isOdd() && B.iadd(z), B.iushrn(1);
                D.cmp(x) >= 0 ? (D.isub(x), A.isub(B)) : (x.isub(D), B.isub(A))
            }
            var k;
            return D.cmpn(1) === 0 ? k = A : k = B, k.cmpn(0) < 0 && k.iadd(M), k
        }, a.prototype.gcd = function (M) {
            if (this.isZero()) return M.abs();
            if (M.isZero()) return this.abs();
            var D = this.clone(), x = M.clone();
            D.negative = 0, x.negative = 0;
            for (var A = 0; D.isEven() && x.isEven(); A++) D.iushrn(1), x.iushrn(1);
            do {
                for (; D.isEven();) D.iushrn(1);
                for (; x.isEven();) x.iushrn(1);
                var B = D.cmp(x);
                if (B < 0) {
                    var z = D;
                    D = x, x = z
                } else if (B === 0 || x.cmpn(1) === 0) break;
                D.isub(x)
            } while (!0);
            return x.iushln(A)
        }, a.prototype.invm = function (M) {
            return this.egcd(M).a.umod(M)
        }, a.prototype.isEven = function () {
            return (this.words[0] & 1) === 0
        }, a.prototype.isOdd = function () {
            return (this.words[0] & 1) === 1
        }, a.prototype.andln = function (M) {
            return this.words[0] & M
        }, a.prototype.bincn = function (M) {
            n(typeof M == "number");
            var D = M % 26, x = (M - D) / 26, A = 1 << D;
            if (this.length <= x) return this._expand(x + 1), this.words[x] |= A, this;
            for (var B = A, z = x; B !== 0 && z < this.length; z++) {
                var j = this.words[z] | 0;
                j += B, B = j >>> 26, j &= 67108863, this.words[z] = j
            }
            return B !== 0 && (this.words[z] = B, this.length++), this
        }, a.prototype.isZero = function () {
            return this.length === 1 && this.words[0] === 0
        }, a.prototype.cmpn = function (M) {
            var D = M < 0;
            if (this.negative !== 0 && !D) return -1;
            if (this.negative === 0 && D) return 1;
            this.strip();
            var x;
            if (this.length > 1) x = 1; else {
                D && (M = -M), n(M <= 67108863, "Number is too big");
                var A = this.words[0] | 0;
                x = A === M ? 0 : A < M ? -1 : 1
            }
            return this.negative !== 0 ? -x | 0 : x
        }, a.prototype.cmp = function (M) {
            if (this.negative !== 0 && M.negative === 0) return -1;
            if (this.negative === 0 && M.negative !== 0) return 1;
            var D = this.ucmp(M);
            return this.negative !== 0 ? -D | 0 : D
        }, a.prototype.ucmp = function (M) {
            if (this.length > M.length) return 1;
            if (this.length < M.length) return -1;
            for (var D = 0, x = this.length - 1; x >= 0; x--) {
                var A = this.words[x] | 0, B = M.words[x] | 0;
                if (A !== B) {
                    A < B ? D = -1 : A > B && (D = 1);
                    break
                }
            }
            return D
        }, a.prototype.gtn = function (M) {
            return this.cmpn(M) === 1
        }, a.prototype.gt = function (M) {
            return this.cmp(M) === 1
        }, a.prototype.gten = function (M) {
            return this.cmpn(M) >= 0
        }, a.prototype.gte = function (M) {
            return this.cmp(M) >= 0
        }, a.prototype.ltn = function (M) {
            return this.cmpn(M) === -1
        }, a.prototype.lt = function (M) {
            return this.cmp(M) === -1
        }, a.prototype.lten = function (M) {
            return this.cmpn(M) <= 0
        }, a.prototype.lte = function (M) {
            return this.cmp(M) <= 0
        }, a.prototype.eqn = function (M) {
            return this.cmpn(M) === 0
        }, a.prototype.eq = function (M) {
            return this.cmp(M) === 0
        }, a.red = function (M) {
            return new J(M)
        }, a.prototype.toRed = function (M) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), M.convertTo(this)._forceRed(M)
        }, a.prototype.fromRed = function () {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, a.prototype._forceRed = function (M) {
            return this.red = M, this
        }, a.prototype.forceRed = function (M) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(M)
        }, a.prototype.redAdd = function (M) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, M)
        }, a.prototype.redIAdd = function (M) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, M)
        }, a.prototype.redSub = function (M) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, M)
        }, a.prototype.redISub = function (M) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, M)
        }, a.prototype.redShl = function (M) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, M)
        }, a.prototype.redMul = function (M) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, M), this.red.mul(this, M)
        }, a.prototype.redIMul = function (M) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, M), this.red.imul(this, M)
        }, a.prototype.redSqr = function () {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, a.prototype.redISqr = function () {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, a.prototype.redSqrt = function () {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, a.prototype.redInvm = function () {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, a.prototype.redNeg = function () {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, a.prototype.redPow = function (M) {
            return n(this.red && !M.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, M)
        };
        var F = {k256: null, p224: null, p192: null, p25519: null};

        function V(re, M) {
            this.name = re, this.p = new a(M, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }

        V.prototype._tmp = function () {
            var M = new a(null);
            return M.words = new Array(Math.ceil(this.n / 13)), M
        }, V.prototype.ireduce = function (M) {
            var D = M, x;
            do this.split(D, this.tmp), D = this.imulK(D), D = D.iadd(this.tmp), x = D.bitLength(); while (x > this.n);
            var A = x < this.n ? -1 : D.ucmp(this.p);
            return A === 0 ? (D.words[0] = 0, D.length = 1) : A > 0 ? D.isub(this.p) : D.strip !== void 0 ? D.strip() : D._strip(), D
        }, V.prototype.split = function (M, D) {
            M.iushrn(this.n, 0, D)
        }, V.prototype.imulK = function (M) {
            return M.imul(this.k)
        };

        function Y() {
            V.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }

        i(Y, V), Y.prototype.split = function (M, D) {
            for (var x = 4194303, A = Math.min(M.length, 9), B = 0; B < A; B++) D.words[B] = M.words[B];
            if (D.length = A, M.length <= 9) {
                M.words[0] = 0, M.length = 1;
                return
            }
            var z = M.words[9];
            for (D.words[D.length++] = z & x, B = 10; B < M.length; B++) {
                var j = M.words[B] | 0;
                M.words[B - 10] = (j & x) << 4 | z >>> 22, z = j
            }
            z >>>= 22, M.words[B - 10] = z, z === 0 && M.length > 10 ? M.length -= 10 : M.length -= 9
        }, Y.prototype.imulK = function (M) {
            M.words[M.length] = 0, M.words[M.length + 1] = 0, M.length += 2;
            for (var D = 0, x = 0; x < M.length; x++) {
                var A = M.words[x] | 0;
                D += A * 977, M.words[x] = D & 67108863, D = A * 64 + (D / 67108864 | 0)
            }
            return M.words[M.length - 1] === 0 && (M.length--, M.words[M.length - 1] === 0 && M.length--), M
        };

        function ee() {
            V.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }

        i(ee, V);

        function oe() {
            V.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }

        i(oe, V);

        function G() {
            V.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }

        i(G, V), G.prototype.imulK = function (M) {
            for (var D = 0, x = 0; x < M.length; x++) {
                var A = (M.words[x] | 0) * 19 + D, B = A & 67108863;
                A >>>= 26, M.words[x] = B, D = A
            }
            return D !== 0 && (M.words[M.length++] = D), M
        }, a._prime = function (M) {
            if (F[M]) return F[M];
            var D;
            if (M === "k256") D = new Y; else if (M === "p224") D = new ee; else if (M === "p192") D = new oe; else if (M === "p25519") D = new G; else throw new Error("Unknown prime " + M);
            return F[M] = D, D
        };

        function J(re) {
            if (typeof re == "string") {
                var M = a._prime(re);
                this.m = M.p, this.prime = M
            } else n(re.gtn(1), "modulus must be greater than 1"), this.m = re, this.prime = null
        }

        J.prototype._verify1 = function (M) {
            n(M.negative === 0, "red works only with positives"), n(M.red, "red works only with red numbers")
        }, J.prototype._verify2 = function (M, D) {
            n((M.negative | D.negative) === 0, "red works only with positives"), n(M.red && M.red === D.red, "red works only with red numbers")
        }, J.prototype.imod = function (M) {
            return this.prime ? this.prime.ireduce(M)._forceRed(this) : M.umod(this.m)._forceRed(this)
        }, J.prototype.neg = function (M) {
            return M.isZero() ? M.clone() : this.m.sub(M)._forceRed(this)
        }, J.prototype.add = function (M, D) {
            this._verify2(M, D);
            var x = M.add(D);
            return x.cmp(this.m) >= 0 && x.isub(this.m), x._forceRed(this)
        }, J.prototype.iadd = function (M, D) {
            this._verify2(M, D);
            var x = M.iadd(D);
            return x.cmp(this.m) >= 0 && x.isub(this.m), x
        }, J.prototype.sub = function (M, D) {
            this._verify2(M, D);
            var x = M.sub(D);
            return x.cmpn(0) < 0 && x.iadd(this.m), x._forceRed(this)
        }, J.prototype.isub = function (M, D) {
            this._verify2(M, D);
            var x = M.isub(D);
            return x.cmpn(0) < 0 && x.iadd(this.m), x
        }, J.prototype.shl = function (M, D) {
            return this._verify1(M), this.imod(M.ushln(D))
        }, J.prototype.imul = function (M, D) {
            return this._verify2(M, D), this.imod(M.imul(D))
        }, J.prototype.mul = function (M, D) {
            return this._verify2(M, D), this.imod(M.mul(D))
        }, J.prototype.isqr = function (M) {
            return this.imul(M, M.clone())
        }, J.prototype.sqr = function (M) {
            return this.mul(M, M)
        }, J.prototype.sqrt = function (M) {
            if (M.isZero()) return M.clone();
            var D = this.m.andln(3);
            if (n(D % 2 === 1), D === 3) {
                var x = this.m.add(new a(1)).iushrn(2);
                return this.pow(M, x)
            }
            for (var A = this.m.subn(1), B = 0; !A.isZero() && A.andln(1) === 0;) B++, A.iushrn(1);
            n(!A.isZero());
            var z = new a(1).toRed(this), j = z.redNeg(), $ = this.m.subn(1).iushrn(1), C = this.m.bitLength();
            for (C = new a(2 * C * C).toRed(this); this.pow(C, $).cmp(j) !== 0;) ;
            for (var R = this.pow(C, A), k = this.pow(M, A.addn(1).iushrn(1)), Q = this.pow(M, A), fe = B; Q.cmp(z) !== 0;) {
                for (var ye = Q, ue = 0; ye.cmp(z) !== 0; ue++) ye = ye.redSqr();
                n(ue < fe);
                var me = this.pow(R, new a(1).iushln(fe - ue - 1));
                k = k.redMul(me), R = me.redSqr(), Q = Q.redMul(R), fe = ue
            }
            return k
        }, J.prototype.invm = function (M) {
            var D = M._invmp(this.m);
            return D.negative !== 0 ? (D.negative = 0, this.imod(D).redNeg()) : this.imod(D)
        }, J.prototype.pow = function (M, D) {
            if (D.isZero()) return new a(1).toRed(this);
            if (D.cmpn(1) === 0) return M.clone();
            var x = 4, A = new Array(1 << x);
            A[0] = new a(1).toRed(this), A[1] = M;
            for (var B = 2; B < A.length; B++) A[B] = this.mul(A[B - 1], M);
            var z = A[0], j = 0, $ = 0, C = D.bitLength() % 26;
            for (C === 0 && (C = 26), B = D.length - 1; B >= 0; B--) {
                for (var R = D.words[B], k = C - 1; k >= 0; k--) {
                    var Q = R >> k & 1;
                    if (z !== A[0] && (z = this.sqr(z)), Q === 0 && j === 0) {
                        $ = 0;
                        continue
                    }
                    j <<= 1, j |= Q, $++, !($ !== x && (B !== 0 || k !== 0)) && (z = this.mul(z, A[j]), $ = 0, j = 0)
                }
                C = 26
            }
            return z
        }, J.prototype.convertTo = function (M) {
            var D = M.umod(this.m);
            return D === M ? D.clone() : D
        }, J.prototype.convertFrom = function (M) {
            var D = M.clone();
            return D.red = null, D
        }, a.mont = function (M) {
            return new ce(M)
        };

        function ce(re) {
            J.call(this, re), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }

        i(ce, J), ce.prototype.convertTo = function (M) {
            return this.imod(M.ushln(this.shift))
        }, ce.prototype.convertFrom = function (M) {
            var D = this.imod(M.mul(this.rinv));
            return D.red = null, D
        }, ce.prototype.imul = function (M, D) {
            if (M.isZero() || D.isZero()) return M.words[0] = 0, M.length = 1, M;
            var x = M.imul(D), A = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                B = x.isub(A).iushrn(this.shift), z = B;
            return B.cmp(this.m) >= 0 ? z = B.isub(this.m) : B.cmpn(0) < 0 && (z = B.iadd(this.m)), z._forceRed(this)
        }, ce.prototype.mul = function (M, D) {
            if (M.isZero() || D.isZero()) return new a(0)._forceRed(this);
            var x = M.mul(D), A = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                B = x.isub(A).iushrn(this.shift), z = B;
            return B.cmp(this.m) >= 0 ? z = B.isub(this.m) : B.cmpn(0) < 0 && (z = B.iadd(this.m)), z._forceRed(this)
        }, ce.prototype.invm = function (M) {
            var D = this.imod(M._invmp(this.m).mul(this.r2));
            return D._forceRed(this)
        }
    })(t, tn)
})(Owe);
var sc = Owe.exports, r7 = {exports: {}}, qce;

function gQ() {
    if (qce) return r7.exports;
    qce = 1;
    var t;
    r7.exports = function (i) {
        return t || (t = new e(null)), t.generate(i)
    };

    function e(n) {
        this.rand = n
    }

    if (r7.exports.Rand = e, e.prototype.generate = function (i) {
        return this._rand(i)
    }, e.prototype._rand = function (i) {
        if (this.rand.getBytes) return this.rand.getBytes(i);
        for (var a = new Uint8Array(i), o = 0; o < a.length; o++) a[o] = this.rand.getByte();
        return a
    }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function (i) {
        var a = new Uint8Array(i);
        return self.crypto.getRandomValues(a), a
    } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function (i) {
        var a = new Uint8Array(i);
        return self.msCrypto.getRandomValues(a), a
    } : typeof window == "object" && (e.prototype._rand = function () {
        throw new Error("Not implemented yet")
    }); else try {
        var r = LQ();
        if (typeof r.randomBytes != "function") throw new Error("Not supported");
        e.prototype._rand = function (i) {
            return r.randomBytes(i)
        }
    } catch {
    }
    return r7.exports
}

var pz, Gce;

function Pwe() {
    if (Gce) return pz;
    Gce = 1;
    var t = sc, e = gQ();

    function r(n) {
        this.rand = n || new e.Rand
    }

    return pz = r, r.create = function (i) {
        return new r(i)
    }, r.prototype._randbelow = function (i) {
        var a = i.bitLength(), o = Math.ceil(a / 8);
        do var s = new t(this.rand.generate(o)); while (s.cmp(i) >= 0);
        return s
    }, r.prototype._randrange = function (i, a) {
        var o = a.sub(i);
        return i.add(this._randbelow(o))
    }, r.prototype.test = function (i, a, o) {
        var s = i.bitLength(), l = t.mont(i), f = new t(1).toRed(l);
        a || (a = Math.max(1, s / 48 | 0));
        for (var d = i.subn(1), p = 0; !d.testn(p); p++) ;
        for (var g = i.shrn(p), b = d.toRed(l), S = !0; a > 0; a--) {
            var T = this._randrange(new t(2), d);
            o && o(T);
            var I = T.toRed(l).redPow(g);
            if (!(I.cmp(f) === 0 || I.cmp(b) === 0)) {
                for (var N = 1; N < p; N++) {
                    if (I = I.redSqr(), I.cmp(f) === 0) return !1;
                    if (I.cmp(b) === 0) break
                }
                if (N === p) return !1
            }
        }
        return S
    }, r.prototype.getDivisor = function (i, a) {
        var o = i.bitLength(), s = t.mont(i), l = new t(1).toRed(s);
        a || (a = Math.max(1, o / 48 | 0));
        for (var f = i.subn(1), d = 0; !f.testn(d); d++) ;
        for (var p = i.shrn(d), g = f.toRed(s); a > 0; a--) {
            var b = this._randrange(new t(2), f), S = i.gcd(b);
            if (S.cmpn(1) !== 0) return S;
            var T = b.toRed(s).redPow(p);
            if (!(T.cmp(l) === 0 || T.cmp(g) === 0)) {
                for (var I = 1; I < d; I++) {
                    if (T = T.redSqr(), T.cmp(l) === 0) return T.fromRed().subn(1).gcd(i);
                    if (T.cmp(g) === 0) break
                }
                if (I === d) return T = T.redSqr(), T.fromRed().subn(1).gcd(i)
            }
        }
        return !1
    }, pz
}

var mz, Kce;

function Nwe() {
    if (Kce) return mz;
    Kce = 1;
    var t = FE;
    mz = I, I.simpleSieve = S, I.fermatTest = T;
    var e = sc, r = new e(24), n = Pwe(), i = new n, a = new e(1), o = new e(2), s = new e(5);
    new e(16), new e(8);
    var l = new e(10), f = new e(3);
    new e(7);
    var d = new e(11), p = new e(4);
    new e(12);
    var g = null;

    function b() {
        if (g !== null) return g;
        var N = 1048576, P = [];
        P[0] = 2;
        for (var F = 1, V = 3; V < N; V += 2) {
            for (var Y = Math.ceil(Math.sqrt(V)), ee = 0; ee < F && P[ee] <= Y && V % P[ee] !== 0; ee++) ;
            F !== ee && P[ee] <= Y || (P[F++] = V)
        }
        return g = P, P
    }

    function S(N) {
        for (var P = b(), F = 0; F < P.length; F++) if (N.modn(P[F]) === 0) return N.cmpn(P[F]) === 0;
        return !0
    }

    function T(N) {
        var P = e.mont(N);
        return o.toRed(P).redPow(N.subn(1)).fromRed().cmpn(1) === 0
    }

    function I(N, P) {
        if (N < 16) return P === 2 || P === 5 ? new e([140, 123]) : new e([140, 39]);
        P = new e(P);
        for (var F, V; ;) {
            for (F = new e(t(Math.ceil(N / 8))); F.bitLength() > N;) F.ishrn(1);
            if (F.isEven() && F.iadd(a), F.testn(1) || F.iadd(o), P.cmp(o)) {
                if (!P.cmp(s)) for (; F.mod(l).cmp(f);) F.iadd(p)
            } else for (; F.mod(r).cmp(d);) F.iadd(p);
            if (V = F.shrn(1), S(V) && S(F) && T(V) && T(F) && i.test(V) && i.test(F)) return F
        }
    }

    return mz
}

const Xrt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, Qrt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, Zrt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, Jrt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, ent = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, tnt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, rnt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, nnt = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, int = {modp1: Xrt, modp2: Qrt, modp5: Zrt, modp14: Jrt, modp15: ent, modp16: tnt, modp17: rnt, modp18: nnt};
var vz, Yce;

function ant() {
    if (Yce) return vz;
    Yce = 1;
    var t = sc, e = Pwe(), r = new e, n = new t(24), i = new t(11), a = new t(10), o = new t(3), s = new t(7),
        l = Nwe(), f = FE;
    vz = S;

    function d(I, N) {
        return N = N || "utf8", kr.isBuffer(I) || (I = new kr(I, N)), this._pub = new t(I), this
    }

    function p(I, N) {
        return N = N || "utf8", kr.isBuffer(I) || (I = new kr(I, N)), this._priv = new t(I), this
    }

    var g = {};

    function b(I, N) {
        var P = N.toString("hex"), F = [P, I.toString(16)].join("_");
        if (F in g) return g[F];
        var V = 0;
        if (I.isEven() || !l.simpleSieve || !l.fermatTest(I) || !r.test(I)) return V += 1, P === "02" || P === "05" ? V += 8 : V += 4, g[F] = V, V;
        r.test(I.shrn(1)) || (V += 2);
        var Y;
        switch (P) {
            case"02":
                I.mod(n).cmp(i) && (V += 8);
                break;
            case"05":
                Y = I.mod(a), Y.cmp(o) && Y.cmp(s) && (V += 8);
                break;
            default:
                V += 4
        }
        return g[F] = V, V
    }

    function S(I, N, P) {
        this.setGenerator(N), this.__prime = new t(I), this._prime = t.mont(this.__prime), this._primeLen = I.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, P ? (this.setPublicKey = d, this.setPrivateKey = p) : this._primeCode = 8
    }

    Object.defineProperty(S.prototype, "verifyError", {
        enumerable: !0, get: function () {
            return typeof this._primeCode != "number" && (this._primeCode = b(this.__prime, this.__gen)), this._primeCode
        }
    }), S.prototype.generateKeys = function () {
        return this._priv || (this._priv = new t(f(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey()
    }, S.prototype.computeSecret = function (I) {
        I = new t(I), I = I.toRed(this._prime);
        var N = I.redPow(this._priv).fromRed(), P = new kr(N.toArray()), F = this.getPrime();
        if (P.length < F.length) {
            var V = new kr(F.length - P.length);
            V.fill(0), P = kr.concat([V, P])
        }
        return P
    }, S.prototype.getPublicKey = function (N) {
        return T(this._pub, N)
    }, S.prototype.getPrivateKey = function (N) {
        return T(this._priv, N)
    }, S.prototype.getPrime = function (I) {
        return T(this.__prime, I)
    }, S.prototype.getGenerator = function (I) {
        return T(this._gen, I)
    }, S.prototype.setGenerator = function (I, N) {
        return N = N || "utf8", kr.isBuffer(I) || (I = new kr(I, N)), this.__gen = I, this._gen = new t(I), this
    };

    function T(I, N) {
        var P = new kr(I.toArray());
        return N ? P.toString(N) : P
    }

    return vz
}

var Xce;

function ont() {
    if (Xce) return Kb;
    Xce = 1;
    var t = Nwe(), e = int, r = ant();

    function n(o) {
        var s = new kr(e[o].prime, "hex"), l = new kr(e[o].gen, "hex");
        return new r(s, l)
    }

    var i = {binary: !0, hex: !0, base64: !0};

    function a(o, s, l, f) {
        return kr.isBuffer(s) || i[s] === void 0 ? a(o, "binary", s, l) : (s = s || "binary", f = f || "binary", l = l || new kr([2]), kr.isBuffer(l) || (l = new kr(l, f)), typeof o == "number" ? new r(t(o, l), l, !0) : (kr.isBuffer(o) || (o = new kr(o, s)), new r(o, l, !0)))
    }

    return Kb.DiffieHellmanGroup = Kb.createDiffieHellmanGroup = Kb.getDiffieHellman = n, Kb.createDiffieHellman = Kb.DiffieHellman = a, Kb
}

var G5 = {exports: {}}, Lwe = {exports: {}};
(function (t) {
    (function (e, r) {
        function n(D, x) {
            if (!D) throw new Error(x || "Assertion failed")
        }

        function i(D, x) {
            D.super_ = x;
            var A = function () {
            };
            A.prototype = x.prototype, D.prototype = new A, D.prototype.constructor = D
        }

        function a(D, x, A) {
            if (a.isBN(D)) return D;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, D !== null && ((x === "le" || x === "be") && (A = x, x = 10), this._init(D || 0, x || 10, A || "be"))
        }

        typeof e == "object" ? e.exports = a : r.BN = a, a.BN = a, a.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = ME.Buffer
        } catch {
        }
        a.isBN = function (x) {
            return x instanceof a ? !0 : x !== null && typeof x == "object" && x.constructor.wordSize === a.wordSize && Array.isArray(x.words)
        }, a.max = function (x, A) {
            return x.cmp(A) > 0 ? x : A
        }, a.min = function (x, A) {
            return x.cmp(A) < 0 ? x : A
        }, a.prototype._init = function (x, A, B) {
            if (typeof x == "number") return this._initNumber(x, A, B);
            if (typeof x == "object") return this._initArray(x, A, B);
            A === "hex" && (A = 16), n(A === (A | 0) && A >= 2 && A <= 36), x = x.toString().replace(/\s+/g, "");
            var z = 0;
            x[0] === "-" && (z++, this.negative = 1), z < x.length && (A === 16 ? this._parseHex(x, z, B) : (this._parseBase(x, A, z), B === "le" && this._initArray(this.toArray(), A, B)))
        }, a.prototype._initNumber = function (x, A, B) {
            x < 0 && (this.negative = 1, x = -x), x < 67108864 ? (this.words = [x & 67108863], this.length = 1) : x < 4503599627370496 ? (this.words = [x & 67108863, x / 67108864 & 67108863], this.length = 2) : (n(x < 9007199254740992), this.words = [x & 67108863, x / 67108864 & 67108863, 1], this.length = 3), B === "le" && this._initArray(this.toArray(), A, B)
        }, a.prototype._initArray = function (x, A, B) {
            if (n(typeof x.length == "number"), x.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(x.length / 3), this.words = new Array(this.length);
            for (var z = 0; z < this.length; z++) this.words[z] = 0;
            var j, $, C = 0;
            if (B === "be") for (z = x.length - 1, j = 0; z >= 0; z -= 3) $ = x[z] | x[z - 1] << 8 | x[z - 2] << 16, this.words[j] |= $ << C & 67108863, this.words[j + 1] = $ >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, j++); else if (B === "le") for (z = 0, j = 0; z < x.length; z += 3) $ = x[z] | x[z + 1] << 8 | x[z + 2] << 16, this.words[j] |= $ << C & 67108863, this.words[j + 1] = $ >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, j++);
            return this._strip()
        };

        function s(D, x) {
            var A = D.charCodeAt(x);
            if (A >= 48 && A <= 57) return A - 48;
            if (A >= 65 && A <= 70) return A - 55;
            if (A >= 97 && A <= 102) return A - 87;
            n(!1, "Invalid character in " + D)
        }

        function l(D, x, A) {
            var B = s(D, A);
            return A - 1 >= x && (B |= s(D, A - 1) << 4), B
        }

        a.prototype._parseHex = function (x, A, B) {
            this.length = Math.ceil((x.length - A) / 6), this.words = new Array(this.length);
            for (var z = 0; z < this.length; z++) this.words[z] = 0;
            var j = 0, $ = 0, C;
            if (B === "be") for (z = x.length - 1; z >= A; z -= 2) C = l(x, A, z) << j, this.words[$] |= C & 67108863, j >= 18 ? (j -= 18, $ += 1, this.words[$] |= C >>> 26) : j += 8; else {
                var R = x.length - A;
                for (z = R % 2 === 0 ? A + 1 : A; z < x.length; z += 2) C = l(x, A, z) << j, this.words[$] |= C & 67108863, j >= 18 ? (j -= 18, $ += 1, this.words[$] |= C >>> 26) : j += 8
            }
            this._strip()
        };

        function f(D, x, A, B) {
            for (var z = 0, j = 0, $ = Math.min(D.length, A), C = x; C < $; C++) {
                var R = D.charCodeAt(C) - 48;
                z *= B, R >= 49 ? j = R - 49 + 10 : R >= 17 ? j = R - 17 + 10 : j = R, n(R >= 0 && j < B, "Invalid character"), z += j
            }
            return z
        }

        a.prototype._parseBase = function (x, A, B) {
            this.words = [0], this.length = 1;
            for (var z = 0, j = 1; j <= 67108863; j *= A) z++;
            z--, j = j / A | 0;
            for (var $ = x.length - B, C = $ % z, R = Math.min($, $ - C) + B, k = 0, Q = B; Q < R; Q += z) k = f(x, Q, Q + z, A), this.imuln(j), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k);
            if (C !== 0) {
                var fe = 1;
                for (k = f(x, Q, x.length, A), Q = 0; Q < C; Q++) fe *= A;
                this.imuln(fe), this.words[0] + k < 67108864 ? this.words[0] += k : this._iaddn(k)
            }
            this._strip()
        }, a.prototype.copy = function (x) {
            x.words = new Array(this.length);
            for (var A = 0; A < this.length; A++) x.words[A] = this.words[A];
            x.length = this.length, x.negative = this.negative, x.red = this.red
        };

        function d(D, x) {
            D.words = x.words, D.length = x.length, D.negative = x.negative, D.red = x.red
        }

        if (a.prototype._move = function (x) {
            d(x, this)
        }, a.prototype.clone = function () {
            var x = new a(null);
            return this.copy(x), x
        }, a.prototype._expand = function (x) {
            for (; this.length < x;) this.words[this.length++] = 0;
            return this
        }, a.prototype._strip = function () {
            for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
            return this._normSign()
        }, a.prototype._normSign = function () {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
            a.prototype[Symbol.for("nodejs.util.inspect.custom")] = p
        } catch {
            a.prototype.inspect = p
        } else a.prototype.inspect = p;

        function p() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }

        var g = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            b = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            S = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        a.prototype.toString = function (x, A) {
            x = x || 10, A = A | 0 || 1;
            var B;
            if (x === 16 || x === "hex") {
                B = "";
                for (var z = 0, j = 0, $ = 0; $ < this.length; $++) {
                    var C = this.words[$], R = ((C << z | j) & 16777215).toString(16);
                    j = C >>> 24 - z & 16777215, z += 2, z >= 26 && (z -= 26, $--), j !== 0 || $ !== this.length - 1 ? B = g[6 - R.length] + R + B : B = R + B
                }
                for (j !== 0 && (B = j.toString(16) + B); B.length % A !== 0;) B = "0" + B;
                return this.negative !== 0 && (B = "-" + B), B
            }
            if (x === (x | 0) && x >= 2 && x <= 36) {
                var k = b[x], Q = S[x];
                B = "";
                var fe = this.clone();
                for (fe.negative = 0; !fe.isZero();) {
                    var ye = fe.modrn(Q).toString(x);
                    fe = fe.idivn(Q), fe.isZero() ? B = ye + B : B = g[k - ye.length] + ye + B
                }
                for (this.isZero() && (B = "0" + B); B.length % A !== 0;) B = "0" + B;
                return this.negative !== 0 && (B = "-" + B), B
            }
            n(!1, "Base should be between 2 and 36")
        }, a.prototype.toNumber = function () {
            var x = this.words[0];
            return this.length === 2 ? x += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? x += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -x : x
        }, a.prototype.toJSON = function () {
            return this.toString(16, 2)
        }, o && (a.prototype.toBuffer = function (x, A) {
            return this.toArrayLike(o, x, A)
        }), a.prototype.toArray = function (x, A) {
            return this.toArrayLike(Array, x, A)
        };
        var T = function (x, A) {
            return x.allocUnsafe ? x.allocUnsafe(A) : new x(A)
        };
        a.prototype.toArrayLike = function (x, A, B) {
            this._strip();
            var z = this.byteLength(), j = B || Math.max(1, z);
            n(z <= j, "byte array longer than desired length"), n(j > 0, "Requested array length <= 0");
            var $ = T(x, j), C = A === "le" ? "LE" : "BE";
            return this["_toArrayLike" + C]($, z), $
        }, a.prototype._toArrayLikeLE = function (x, A) {
            for (var B = 0, z = 0, j = 0, $ = 0; j < this.length; j++) {
                var C = this.words[j] << $ | z;
                x[B++] = C & 255, B < x.length && (x[B++] = C >> 8 & 255), B < x.length && (x[B++] = C >> 16 & 255), $ === 6 ? (B < x.length && (x[B++] = C >> 24 & 255), z = 0, $ = 0) : (z = C >>> 24, $ += 2)
            }
            if (B < x.length) for (x[B++] = z; B < x.length;) x[B++] = 0
        }, a.prototype._toArrayLikeBE = function (x, A) {
            for (var B = x.length - 1, z = 0, j = 0, $ = 0; j < this.length; j++) {
                var C = this.words[j] << $ | z;
                x[B--] = C & 255, B >= 0 && (x[B--] = C >> 8 & 255), B >= 0 && (x[B--] = C >> 16 & 255), $ === 6 ? (B >= 0 && (x[B--] = C >> 24 & 255), z = 0, $ = 0) : (z = C >>> 24, $ += 2)
            }
            if (B >= 0) for (x[B--] = z; B >= 0;) x[B--] = 0
        }, Math.clz32 ? a.prototype._countBits = function (x) {
            return 32 - Math.clz32(x)
        } : a.prototype._countBits = function (x) {
            var A = x, B = 0;
            return A >= 4096 && (B += 13, A >>>= 13), A >= 64 && (B += 7, A >>>= 7), A >= 8 && (B += 4, A >>>= 4), A >= 2 && (B += 2, A >>>= 2), B + A
        }, a.prototype._zeroBits = function (x) {
            if (x === 0) return 26;
            var A = x, B = 0;
            return A & 8191 || (B += 13, A >>>= 13), A & 127 || (B += 7, A >>>= 7), A & 15 || (B += 4, A >>>= 4), A & 3 || (B += 2, A >>>= 2), A & 1 || B++, B
        }, a.prototype.bitLength = function () {
            var x = this.words[this.length - 1], A = this._countBits(x);
            return (this.length - 1) * 26 + A
        };

        function I(D) {
            for (var x = new Array(D.bitLength()), A = 0; A < x.length; A++) {
                var B = A / 26 | 0, z = A % 26;
                x[A] = D.words[B] >>> z & 1
            }
            return x
        }

        a.prototype.zeroBits = function () {
            if (this.isZero()) return 0;
            for (var x = 0, A = 0; A < this.length; A++) {
                var B = this._zeroBits(this.words[A]);
                if (x += B, B !== 26) break
            }
            return x
        }, a.prototype.byteLength = function () {
            return Math.ceil(this.bitLength() / 8)
        }, a.prototype.toTwos = function (x) {
            return this.negative !== 0 ? this.abs().inotn(x).iaddn(1) : this.clone()
        }, a.prototype.fromTwos = function (x) {
            return this.testn(x - 1) ? this.notn(x).iaddn(1).ineg() : this.clone()
        }, a.prototype.isNeg = function () {
            return this.negative !== 0
        }, a.prototype.neg = function () {
            return this.clone().ineg()
        }, a.prototype.ineg = function () {
            return this.isZero() || (this.negative ^= 1), this
        }, a.prototype.iuor = function (x) {
            for (; this.length < x.length;) this.words[this.length++] = 0;
            for (var A = 0; A < x.length; A++) this.words[A] = this.words[A] | x.words[A];
            return this._strip()
        }, a.prototype.ior = function (x) {
            return n((this.negative | x.negative) === 0), this.iuor(x)
        }, a.prototype.or = function (x) {
            return this.length > x.length ? this.clone().ior(x) : x.clone().ior(this)
        }, a.prototype.uor = function (x) {
            return this.length > x.length ? this.clone().iuor(x) : x.clone().iuor(this)
        }, a.prototype.iuand = function (x) {
            var A;
            this.length > x.length ? A = x : A = this;
            for (var B = 0; B < A.length; B++) this.words[B] = this.words[B] & x.words[B];
            return this.length = A.length, this._strip()
        }, a.prototype.iand = function (x) {
            return n((this.negative | x.negative) === 0), this.iuand(x)
        }, a.prototype.and = function (x) {
            return this.length > x.length ? this.clone().iand(x) : x.clone().iand(this)
        }, a.prototype.uand = function (x) {
            return this.length > x.length ? this.clone().iuand(x) : x.clone().iuand(this)
        }, a.prototype.iuxor = function (x) {
            var A, B;
            this.length > x.length ? (A = this, B = x) : (A = x, B = this);
            for (var z = 0; z < B.length; z++) this.words[z] = A.words[z] ^ B.words[z];
            if (this !== A) for (; z < A.length; z++) this.words[z] = A.words[z];
            return this.length = A.length, this._strip()
        }, a.prototype.ixor = function (x) {
            return n((this.negative | x.negative) === 0), this.iuxor(x)
        }, a.prototype.xor = function (x) {
            return this.length > x.length ? this.clone().ixor(x) : x.clone().ixor(this)
        }, a.prototype.uxor = function (x) {
            return this.length > x.length ? this.clone().iuxor(x) : x.clone().iuxor(this)
        }, a.prototype.inotn = function (x) {
            n(typeof x == "number" && x >= 0);
            var A = Math.ceil(x / 26) | 0, B = x % 26;
            this._expand(A), B > 0 && A--;
            for (var z = 0; z < A; z++) this.words[z] = ~this.words[z] & 67108863;
            return B > 0 && (this.words[z] = ~this.words[z] & 67108863 >> 26 - B), this._strip()
        }, a.prototype.notn = function (x) {
            return this.clone().inotn(x)
        }, a.prototype.setn = function (x, A) {
            n(typeof x == "number" && x >= 0);
            var B = x / 26 | 0, z = x % 26;
            return this._expand(B + 1), A ? this.words[B] = this.words[B] | 1 << z : this.words[B] = this.words[B] & ~(1 << z), this._strip()
        }, a.prototype.iadd = function (x) {
            var A;
            if (this.negative !== 0 && x.negative === 0) return this.negative = 0, A = this.isub(x), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && x.negative !== 0) return x.negative = 0, A = this.isub(x), x.negative = 1, A._normSign();
            var B, z;
            this.length > x.length ? (B = this, z = x) : (B = x, z = this);
            for (var j = 0, $ = 0; $ < z.length; $++) A = (B.words[$] | 0) + (z.words[$] | 0) + j, this.words[$] = A & 67108863, j = A >>> 26;
            for (; j !== 0 && $ < B.length; $++) A = (B.words[$] | 0) + j, this.words[$] = A & 67108863, j = A >>> 26;
            if (this.length = B.length, j !== 0) this.words[this.length] = j, this.length++; else if (B !== this) for (; $ < B.length; $++) this.words[$] = B.words[$];
            return this
        }, a.prototype.add = function (x) {
            var A;
            return x.negative !== 0 && this.negative === 0 ? (x.negative = 0, A = this.sub(x), x.negative ^= 1, A) : x.negative === 0 && this.negative !== 0 ? (this.negative = 0, A = x.sub(this), this.negative = 1, A) : this.length > x.length ? this.clone().iadd(x) : x.clone().iadd(this)
        }, a.prototype.isub = function (x) {
            if (x.negative !== 0) {
                x.negative = 0;
                var A = this.iadd(x);
                return x.negative = 1, A._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(x), this.negative = 1, this._normSign();
            var B = this.cmp(x);
            if (B === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var z, j;
            B > 0 ? (z = this, j = x) : (z = x, j = this);
            for (var $ = 0, C = 0; C < j.length; C++) A = (z.words[C] | 0) - (j.words[C] | 0) + $, $ = A >> 26, this.words[C] = A & 67108863;
            for (; $ !== 0 && C < z.length; C++) A = (z.words[C] | 0) + $, $ = A >> 26, this.words[C] = A & 67108863;
            if ($ === 0 && C < z.length && z !== this) for (; C < z.length; C++) this.words[C] = z.words[C];
            return this.length = Math.max(this.length, C), z !== this && (this.negative = 1), this._strip()
        }, a.prototype.sub = function (x) {
            return this.clone().isub(x)
        };

        function N(D, x, A) {
            A.negative = x.negative ^ D.negative;
            var B = D.length + x.length | 0;
            A.length = B, B = B - 1 | 0;
            var z = D.words[0] | 0, j = x.words[0] | 0, $ = z * j, C = $ & 67108863, R = $ / 67108864 | 0;
            A.words[0] = C;
            for (var k = 1; k < B; k++) {
                for (var Q = R >>> 26, fe = R & 67108863, ye = Math.min(k, x.length - 1), ue = Math.max(0, k - D.length + 1); ue <= ye; ue++) {
                    var me = k - ue | 0;
                    z = D.words[me] | 0, j = x.words[ue] | 0, $ = z * j + fe, Q += $ / 67108864 | 0, fe = $ & 67108863
                }
                A.words[k] = fe | 0, R = Q | 0
            }
            return R !== 0 ? A.words[k] = R | 0 : A.length--, A._strip()
        }

        var P = function (x, A, B) {
            var z = x.words, j = A.words, $ = B.words, C = 0, R, k, Q, fe = z[0] | 0, ye = fe & 8191, ue = fe >>> 13,
                me = z[1] | 0, Se = me & 8191, Ce = me >>> 13, Me = z[2] | 0, ve = Me & 8191, ne = Me >>> 13,
                be = z[3] | 0, Ee = be & 8191, Oe = be >>> 13, ze = z[4] | 0, Be = ze & 8191, it = ze >>> 13,
                Ue = z[5] | 0, bt = Ue & 8191, gt = Ue >>> 13, Ot = z[6] | 0, zt = Ot & 8191, _t = Ot >>> 13,
                Dt = z[7] | 0, rr = Dt & 8191, pe = Dt >>> 13, te = z[8] | 0, X = te & 8191, H = te >>> 13,
                U = z[9] | 0, q = U & 8191, le = U >>> 13, xe = j[0] | 0, Ae = xe & 8191, De = xe >>> 13, Ze = j[1] | 0,
                ft = Ze & 8191, ht = Ze >>> 13, cr = j[2] | 0, Rt = cr & 8191, Gt = cr >>> 13, sn = j[3] | 0,
                Yr = sn & 8191, br = sn >>> 13, hn = j[4] | 0, En = hn & 8191, _r = hn >>> 13, _n = j[5] | 0,
                Nr = _n & 8191, mr = _n >>> 13, fn = j[6] | 0, Hn = fn & 8191, Cr = fn >>> 13, An = j[7] | 0,
                pn = An & 8191, wr = An >>> 13, ke = j[8] | 0, st = ke & 8191, ot = ke >>> 13, xt = j[9] | 0,
                Yt = xt & 8191, vr = xt >>> 13;
            B.negative = x.negative ^ A.negative, B.length = 19, R = Math.imul(ye, Ae), k = Math.imul(ye, De), k = k + Math.imul(ue, Ae) | 0, Q = Math.imul(ue, De);
            var Vr = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, R = Math.imul(Se, Ae), k = Math.imul(Se, De), k = k + Math.imul(Ce, Ae) | 0, Q = Math.imul(Ce, De), R = R + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, ht) | 0, k = k + Math.imul(ue, ft) | 0, Q = Q + Math.imul(ue, ht) | 0;
            var Ur = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, R = Math.imul(ve, Ae), k = Math.imul(ve, De), k = k + Math.imul(ne, Ae) | 0, Q = Math.imul(ne, De), R = R + Math.imul(Se, ft) | 0, k = k + Math.imul(Se, ht) | 0, k = k + Math.imul(Ce, ft) | 0, Q = Q + Math.imul(Ce, ht) | 0, R = R + Math.imul(ye, Rt) | 0, k = k + Math.imul(ye, Gt) | 0, k = k + Math.imul(ue, Rt) | 0, Q = Q + Math.imul(ue, Gt) | 0;
            var fi = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, R = Math.imul(Ee, Ae), k = Math.imul(Ee, De), k = k + Math.imul(Oe, Ae) | 0, Q = Math.imul(Oe, De), R = R + Math.imul(ve, ft) | 0, k = k + Math.imul(ve, ht) | 0, k = k + Math.imul(ne, ft) | 0, Q = Q + Math.imul(ne, ht) | 0, R = R + Math.imul(Se, Rt) | 0, k = k + Math.imul(Se, Gt) | 0, k = k + Math.imul(Ce, Rt) | 0, Q = Q + Math.imul(Ce, Gt) | 0, R = R + Math.imul(ye, Yr) | 0, k = k + Math.imul(ye, br) | 0, k = k + Math.imul(ue, Yr) | 0, Q = Q + Math.imul(ue, br) | 0;
            var In = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, R = Math.imul(Be, Ae), k = Math.imul(Be, De), k = k + Math.imul(it, Ae) | 0, Q = Math.imul(it, De), R = R + Math.imul(Ee, ft) | 0, k = k + Math.imul(Ee, ht) | 0, k = k + Math.imul(Oe, ft) | 0, Q = Q + Math.imul(Oe, ht) | 0, R = R + Math.imul(ve, Rt) | 0, k = k + Math.imul(ve, Gt) | 0, k = k + Math.imul(ne, Rt) | 0, Q = Q + Math.imul(ne, Gt) | 0, R = R + Math.imul(Se, Yr) | 0, k = k + Math.imul(Se, br) | 0, k = k + Math.imul(Ce, Yr) | 0, Q = Q + Math.imul(Ce, br) | 0, R = R + Math.imul(ye, En) | 0, k = k + Math.imul(ye, _r) | 0, k = k + Math.imul(ue, En) | 0, Q = Q + Math.imul(ue, _r) | 0;
            var kn = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, R = Math.imul(bt, Ae), k = Math.imul(bt, De), k = k + Math.imul(gt, Ae) | 0, Q = Math.imul(gt, De), R = R + Math.imul(Be, ft) | 0, k = k + Math.imul(Be, ht) | 0, k = k + Math.imul(it, ft) | 0, Q = Q + Math.imul(it, ht) | 0, R = R + Math.imul(Ee, Rt) | 0, k = k + Math.imul(Ee, Gt) | 0, k = k + Math.imul(Oe, Rt) | 0, Q = Q + Math.imul(Oe, Gt) | 0, R = R + Math.imul(ve, Yr) | 0, k = k + Math.imul(ve, br) | 0, k = k + Math.imul(ne, Yr) | 0, Q = Q + Math.imul(ne, br) | 0, R = R + Math.imul(Se, En) | 0, k = k + Math.imul(Se, _r) | 0, k = k + Math.imul(Ce, En) | 0, Q = Q + Math.imul(Ce, _r) | 0, R = R + Math.imul(ye, Nr) | 0, k = k + Math.imul(ye, mr) | 0, k = k + Math.imul(ue, Nr) | 0, Q = Q + Math.imul(ue, mr) | 0;
            var Ai = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Ai >>> 26) | 0, Ai &= 67108863, R = Math.imul(zt, Ae), k = Math.imul(zt, De), k = k + Math.imul(_t, Ae) | 0, Q = Math.imul(_t, De), R = R + Math.imul(bt, ft) | 0, k = k + Math.imul(bt, ht) | 0, k = k + Math.imul(gt, ft) | 0, Q = Q + Math.imul(gt, ht) | 0, R = R + Math.imul(Be, Rt) | 0, k = k + Math.imul(Be, Gt) | 0, k = k + Math.imul(it, Rt) | 0, Q = Q + Math.imul(it, Gt) | 0, R = R + Math.imul(Ee, Yr) | 0, k = k + Math.imul(Ee, br) | 0, k = k + Math.imul(Oe, Yr) | 0, Q = Q + Math.imul(Oe, br) | 0, R = R + Math.imul(ve, En) | 0, k = k + Math.imul(ve, _r) | 0, k = k + Math.imul(ne, En) | 0, Q = Q + Math.imul(ne, _r) | 0, R = R + Math.imul(Se, Nr) | 0, k = k + Math.imul(Se, mr) | 0, k = k + Math.imul(Ce, Nr) | 0, Q = Q + Math.imul(Ce, mr) | 0, R = R + Math.imul(ye, Hn) | 0, k = k + Math.imul(ye, Cr) | 0, k = k + Math.imul(ue, Hn) | 0, Q = Q + Math.imul(ue, Cr) | 0;
            var Fi = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Fi >>> 26) | 0, Fi &= 67108863, R = Math.imul(rr, Ae), k = Math.imul(rr, De), k = k + Math.imul(pe, Ae) | 0, Q = Math.imul(pe, De), R = R + Math.imul(zt, ft) | 0, k = k + Math.imul(zt, ht) | 0, k = k + Math.imul(_t, ft) | 0, Q = Q + Math.imul(_t, ht) | 0, R = R + Math.imul(bt, Rt) | 0, k = k + Math.imul(bt, Gt) | 0, k = k + Math.imul(gt, Rt) | 0, Q = Q + Math.imul(gt, Gt) | 0, R = R + Math.imul(Be, Yr) | 0, k = k + Math.imul(Be, br) | 0, k = k + Math.imul(it, Yr) | 0, Q = Q + Math.imul(it, br) | 0, R = R + Math.imul(Ee, En) | 0, k = k + Math.imul(Ee, _r) | 0, k = k + Math.imul(Oe, En) | 0, Q = Q + Math.imul(Oe, _r) | 0, R = R + Math.imul(ve, Nr) | 0, k = k + Math.imul(ve, mr) | 0, k = k + Math.imul(ne, Nr) | 0, Q = Q + Math.imul(ne, mr) | 0, R = R + Math.imul(Se, Hn) | 0, k = k + Math.imul(Se, Cr) | 0, k = k + Math.imul(Ce, Hn) | 0, Q = Q + Math.imul(Ce, Cr) | 0, R = R + Math.imul(ye, pn) | 0, k = k + Math.imul(ye, wr) | 0, k = k + Math.imul(ue, pn) | 0, Q = Q + Math.imul(ue, wr) | 0;
            var Pt = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, R = Math.imul(X, Ae), k = Math.imul(X, De), k = k + Math.imul(H, Ae) | 0, Q = Math.imul(H, De), R = R + Math.imul(rr, ft) | 0, k = k + Math.imul(rr, ht) | 0, k = k + Math.imul(pe, ft) | 0, Q = Q + Math.imul(pe, ht) | 0, R = R + Math.imul(zt, Rt) | 0, k = k + Math.imul(zt, Gt) | 0, k = k + Math.imul(_t, Rt) | 0, Q = Q + Math.imul(_t, Gt) | 0, R = R + Math.imul(bt, Yr) | 0, k = k + Math.imul(bt, br) | 0, k = k + Math.imul(gt, Yr) | 0, Q = Q + Math.imul(gt, br) | 0, R = R + Math.imul(Be, En) | 0, k = k + Math.imul(Be, _r) | 0, k = k + Math.imul(it, En) | 0, Q = Q + Math.imul(it, _r) | 0, R = R + Math.imul(Ee, Nr) | 0, k = k + Math.imul(Ee, mr) | 0, k = k + Math.imul(Oe, Nr) | 0, Q = Q + Math.imul(Oe, mr) | 0, R = R + Math.imul(ve, Hn) | 0, k = k + Math.imul(ve, Cr) | 0, k = k + Math.imul(ne, Hn) | 0, Q = Q + Math.imul(ne, Cr) | 0, R = R + Math.imul(Se, pn) | 0, k = k + Math.imul(Se, wr) | 0, k = k + Math.imul(Ce, pn) | 0, Q = Q + Math.imul(Ce, wr) | 0, R = R + Math.imul(ye, st) | 0, k = k + Math.imul(ye, ot) | 0, k = k + Math.imul(ue, st) | 0, Q = Q + Math.imul(ue, ot) | 0;
            var Wn = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Wn >>> 26) | 0, Wn &= 67108863, R = Math.imul(q, Ae), k = Math.imul(q, De), k = k + Math.imul(le, Ae) | 0, Q = Math.imul(le, De), R = R + Math.imul(X, ft) | 0, k = k + Math.imul(X, ht) | 0, k = k + Math.imul(H, ft) | 0, Q = Q + Math.imul(H, ht) | 0, R = R + Math.imul(rr, Rt) | 0, k = k + Math.imul(rr, Gt) | 0, k = k + Math.imul(pe, Rt) | 0, Q = Q + Math.imul(pe, Gt) | 0, R = R + Math.imul(zt, Yr) | 0, k = k + Math.imul(zt, br) | 0, k = k + Math.imul(_t, Yr) | 0, Q = Q + Math.imul(_t, br) | 0, R = R + Math.imul(bt, En) | 0, k = k + Math.imul(bt, _r) | 0, k = k + Math.imul(gt, En) | 0, Q = Q + Math.imul(gt, _r) | 0, R = R + Math.imul(Be, Nr) | 0, k = k + Math.imul(Be, mr) | 0, k = k + Math.imul(it, Nr) | 0, Q = Q + Math.imul(it, mr) | 0, R = R + Math.imul(Ee, Hn) | 0, k = k + Math.imul(Ee, Cr) | 0, k = k + Math.imul(Oe, Hn) | 0, Q = Q + Math.imul(Oe, Cr) | 0, R = R + Math.imul(ve, pn) | 0, k = k + Math.imul(ve, wr) | 0, k = k + Math.imul(ne, pn) | 0, Q = Q + Math.imul(ne, wr) | 0, R = R + Math.imul(Se, st) | 0, k = k + Math.imul(Se, ot) | 0, k = k + Math.imul(Ce, st) | 0, Q = Q + Math.imul(Ce, ot) | 0, R = R + Math.imul(ye, Yt) | 0, k = k + Math.imul(ye, vr) | 0, k = k + Math.imul(ue, Yt) | 0, Q = Q + Math.imul(ue, vr) | 0;
            var Da = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Da >>> 26) | 0, Da &= 67108863, R = Math.imul(q, ft), k = Math.imul(q, ht), k = k + Math.imul(le, ft) | 0, Q = Math.imul(le, ht), R = R + Math.imul(X, Rt) | 0, k = k + Math.imul(X, Gt) | 0, k = k + Math.imul(H, Rt) | 0, Q = Q + Math.imul(H, Gt) | 0, R = R + Math.imul(rr, Yr) | 0, k = k + Math.imul(rr, br) | 0, k = k + Math.imul(pe, Yr) | 0, Q = Q + Math.imul(pe, br) | 0, R = R + Math.imul(zt, En) | 0, k = k + Math.imul(zt, _r) | 0, k = k + Math.imul(_t, En) | 0, Q = Q + Math.imul(_t, _r) | 0, R = R + Math.imul(bt, Nr) | 0, k = k + Math.imul(bt, mr) | 0, k = k + Math.imul(gt, Nr) | 0, Q = Q + Math.imul(gt, mr) | 0, R = R + Math.imul(Be, Hn) | 0, k = k + Math.imul(Be, Cr) | 0, k = k + Math.imul(it, Hn) | 0, Q = Q + Math.imul(it, Cr) | 0, R = R + Math.imul(Ee, pn) | 0, k = k + Math.imul(Ee, wr) | 0, k = k + Math.imul(Oe, pn) | 0, Q = Q + Math.imul(Oe, wr) | 0, R = R + Math.imul(ve, st) | 0, k = k + Math.imul(ve, ot) | 0, k = k + Math.imul(ne, st) | 0, Q = Q + Math.imul(ne, ot) | 0, R = R + Math.imul(Se, Yt) | 0, k = k + Math.imul(Se, vr) | 0, k = k + Math.imul(Ce, Yt) | 0, Q = Q + Math.imul(Ce, vr) | 0;
            var Ma = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, R = Math.imul(q, Rt), k = Math.imul(q, Gt), k = k + Math.imul(le, Rt) | 0, Q = Math.imul(le, Gt), R = R + Math.imul(X, Yr) | 0, k = k + Math.imul(X, br) | 0, k = k + Math.imul(H, Yr) | 0, Q = Q + Math.imul(H, br) | 0, R = R + Math.imul(rr, En) | 0, k = k + Math.imul(rr, _r) | 0, k = k + Math.imul(pe, En) | 0, Q = Q + Math.imul(pe, _r) | 0, R = R + Math.imul(zt, Nr) | 0, k = k + Math.imul(zt, mr) | 0, k = k + Math.imul(_t, Nr) | 0, Q = Q + Math.imul(_t, mr) | 0, R = R + Math.imul(bt, Hn) | 0, k = k + Math.imul(bt, Cr) | 0, k = k + Math.imul(gt, Hn) | 0, Q = Q + Math.imul(gt, Cr) | 0, R = R + Math.imul(Be, pn) | 0, k = k + Math.imul(Be, wr) | 0, k = k + Math.imul(it, pn) | 0, Q = Q + Math.imul(it, wr) | 0, R = R + Math.imul(Ee, st) | 0, k = k + Math.imul(Ee, ot) | 0, k = k + Math.imul(Oe, st) | 0, Q = Q + Math.imul(Oe, ot) | 0, R = R + Math.imul(ve, Yt) | 0, k = k + Math.imul(ve, vr) | 0, k = k + Math.imul(ne, Yt) | 0, Q = Q + Math.imul(ne, vr) | 0;
            var Oa = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Oa >>> 26) | 0, Oa &= 67108863, R = Math.imul(q, Yr), k = Math.imul(q, br), k = k + Math.imul(le, Yr) | 0, Q = Math.imul(le, br), R = R + Math.imul(X, En) | 0, k = k + Math.imul(X, _r) | 0, k = k + Math.imul(H, En) | 0, Q = Q + Math.imul(H, _r) | 0, R = R + Math.imul(rr, Nr) | 0, k = k + Math.imul(rr, mr) | 0, k = k + Math.imul(pe, Nr) | 0, Q = Q + Math.imul(pe, mr) | 0, R = R + Math.imul(zt, Hn) | 0, k = k + Math.imul(zt, Cr) | 0, k = k + Math.imul(_t, Hn) | 0, Q = Q + Math.imul(_t, Cr) | 0, R = R + Math.imul(bt, pn) | 0, k = k + Math.imul(bt, wr) | 0, k = k + Math.imul(gt, pn) | 0, Q = Q + Math.imul(gt, wr) | 0, R = R + Math.imul(Be, st) | 0, k = k + Math.imul(Be, ot) | 0, k = k + Math.imul(it, st) | 0, Q = Q + Math.imul(it, ot) | 0, R = R + Math.imul(Ee, Yt) | 0, k = k + Math.imul(Ee, vr) | 0, k = k + Math.imul(Oe, Yt) | 0, Q = Q + Math.imul(Oe, vr) | 0;
            var Za = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, R = Math.imul(q, En), k = Math.imul(q, _r), k = k + Math.imul(le, En) | 0, Q = Math.imul(le, _r), R = R + Math.imul(X, Nr) | 0, k = k + Math.imul(X, mr) | 0, k = k + Math.imul(H, Nr) | 0, Q = Q + Math.imul(H, mr) | 0, R = R + Math.imul(rr, Hn) | 0, k = k + Math.imul(rr, Cr) | 0, k = k + Math.imul(pe, Hn) | 0, Q = Q + Math.imul(pe, Cr) | 0, R = R + Math.imul(zt, pn) | 0, k = k + Math.imul(zt, wr) | 0, k = k + Math.imul(_t, pn) | 0, Q = Q + Math.imul(_t, wr) | 0, R = R + Math.imul(bt, st) | 0, k = k + Math.imul(bt, ot) | 0, k = k + Math.imul(gt, st) | 0, Q = Q + Math.imul(gt, ot) | 0, R = R + Math.imul(Be, Yt) | 0, k = k + Math.imul(Be, vr) | 0, k = k + Math.imul(it, Yt) | 0, Q = Q + Math.imul(it, vr) | 0;
            var Po = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Po >>> 26) | 0, Po &= 67108863, R = Math.imul(q, Nr), k = Math.imul(q, mr), k = k + Math.imul(le, Nr) | 0, Q = Math.imul(le, mr), R = R + Math.imul(X, Hn) | 0, k = k + Math.imul(X, Cr) | 0, k = k + Math.imul(H, Hn) | 0, Q = Q + Math.imul(H, Cr) | 0, R = R + Math.imul(rr, pn) | 0, k = k + Math.imul(rr, wr) | 0, k = k + Math.imul(pe, pn) | 0, Q = Q + Math.imul(pe, wr) | 0, R = R + Math.imul(zt, st) | 0, k = k + Math.imul(zt, ot) | 0, k = k + Math.imul(_t, st) | 0, Q = Q + Math.imul(_t, ot) | 0, R = R + Math.imul(bt, Yt) | 0, k = k + Math.imul(bt, vr) | 0, k = k + Math.imul(gt, Yt) | 0, Q = Q + Math.imul(gt, vr) | 0;
            var Ja = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Ja >>> 26) | 0, Ja &= 67108863, R = Math.imul(q, Hn), k = Math.imul(q, Cr), k = k + Math.imul(le, Hn) | 0, Q = Math.imul(le, Cr), R = R + Math.imul(X, pn) | 0, k = k + Math.imul(X, wr) | 0, k = k + Math.imul(H, pn) | 0, Q = Q + Math.imul(H, wr) | 0, R = R + Math.imul(rr, st) | 0, k = k + Math.imul(rr, ot) | 0, k = k + Math.imul(pe, st) | 0, Q = Q + Math.imul(pe, ot) | 0, R = R + Math.imul(zt, Yt) | 0, k = k + Math.imul(zt, vr) | 0, k = k + Math.imul(_t, Yt) | 0, Q = Q + Math.imul(_t, vr) | 0;
            var qi = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (qi >>> 26) | 0, qi &= 67108863, R = Math.imul(q, pn), k = Math.imul(q, wr), k = k + Math.imul(le, pn) | 0, Q = Math.imul(le, wr), R = R + Math.imul(X, st) | 0, k = k + Math.imul(X, ot) | 0, k = k + Math.imul(H, st) | 0, Q = Q + Math.imul(H, ot) | 0, R = R + Math.imul(rr, Yt) | 0, k = k + Math.imul(rr, vr) | 0, k = k + Math.imul(pe, Yt) | 0, Q = Q + Math.imul(pe, vr) | 0;
            var Ko = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Ko >>> 26) | 0, Ko &= 67108863, R = Math.imul(q, st), k = Math.imul(q, ot), k = k + Math.imul(le, st) | 0, Q = Math.imul(le, ot), R = R + Math.imul(X, Yt) | 0, k = k + Math.imul(X, vr) | 0, k = k + Math.imul(H, Yt) | 0, Q = Q + Math.imul(H, vr) | 0;
            var Pa = (C + R | 0) + ((k & 8191) << 13) | 0;
            C = (Q + (k >>> 13) | 0) + (Pa >>> 26) | 0, Pa &= 67108863, R = Math.imul(q, Yt), k = Math.imul(q, vr), k = k + Math.imul(le, Yt) | 0, Q = Math.imul(le, vr);
            var Dl = (C + R | 0) + ((k & 8191) << 13) | 0;
            return C = (Q + (k >>> 13) | 0) + (Dl >>> 26) | 0, Dl &= 67108863, $[0] = Vr, $[1] = Ur, $[2] = fi, $[3] = In, $[4] = kn, $[5] = Ai, $[6] = Fi, $[7] = Pt, $[8] = Wn, $[9] = Da, $[10] = Ma, $[11] = Oa, $[12] = Za, $[13] = Po, $[14] = Ja, $[15] = qi, $[16] = Ko, $[17] = Pa, $[18] = Dl, C !== 0 && ($[19] = C, B.length++), B
        };
        Math.imul || (P = N);

        function F(D, x, A) {
            A.negative = x.negative ^ D.negative, A.length = D.length + x.length;
            for (var B = 0, z = 0, j = 0; j < A.length - 1; j++) {
                var $ = z;
                z = 0;
                for (var C = B & 67108863, R = Math.min(j, x.length - 1), k = Math.max(0, j - D.length + 1); k <= R; k++) {
                    var Q = j - k, fe = D.words[Q] | 0, ye = x.words[k] | 0, ue = fe * ye, me = ue & 67108863;
                    $ = $ + (ue / 67108864 | 0) | 0, me = me + C | 0, C = me & 67108863, $ = $ + (me >>> 26) | 0, z += $ >>> 26, $ &= 67108863
                }
                A.words[j] = C, B = $, $ = z
            }
            return B !== 0 ? A.words[j] = B : A.length--, A._strip()
        }

        function V(D, x, A) {
            return F(D, x, A)
        }

        a.prototype.mulTo = function (x, A) {
            var B, z = this.length + x.length;
            return this.length === 10 && x.length === 10 ? B = P(this, x, A) : z < 63 ? B = N(this, x, A) : z < 1024 ? B = F(this, x, A) : B = V(this, x, A), B
        }, a.prototype.mul = function (x) {
            var A = new a(null);
            return A.words = new Array(this.length + x.length), this.mulTo(x, A)
        }, a.prototype.mulf = function (x) {
            var A = new a(null);
            return A.words = new Array(this.length + x.length), V(this, x, A)
        }, a.prototype.imul = function (x) {
            return this.clone().mulTo(x, this)
        }, a.prototype.imuln = function (x) {
            var A = x < 0;
            A && (x = -x), n(typeof x == "number"), n(x < 67108864);
            for (var B = 0, z = 0; z < this.length; z++) {
                var j = (this.words[z] | 0) * x, $ = (j & 67108863) + (B & 67108863);
                B >>= 26, B += j / 67108864 | 0, B += $ >>> 26, this.words[z] = $ & 67108863
            }
            return B !== 0 && (this.words[z] = B, this.length++), A ? this.ineg() : this
        }, a.prototype.muln = function (x) {
            return this.clone().imuln(x)
        }, a.prototype.sqr = function () {
            return this.mul(this)
        }, a.prototype.isqr = function () {
            return this.imul(this.clone())
        }, a.prototype.pow = function (x) {
            var A = I(x);
            if (A.length === 0) return new a(1);
            for (var B = this, z = 0; z < A.length && A[z] === 0; z++, B = B.sqr()) ;
            if (++z < A.length) for (var j = B.sqr(); z < A.length; z++, j = j.sqr()) A[z] !== 0 && (B = B.mul(j));
            return B
        }, a.prototype.iushln = function (x) {
            n(typeof x == "number" && x >= 0);
            var A = x % 26, B = (x - A) / 26, z = 67108863 >>> 26 - A << 26 - A, j;
            if (A !== 0) {
                var $ = 0;
                for (j = 0; j < this.length; j++) {
                    var C = this.words[j] & z, R = (this.words[j] | 0) - C << A;
                    this.words[j] = R | $, $ = C >>> 26 - A
                }
                $ && (this.words[j] = $, this.length++)
            }
            if (B !== 0) {
                for (j = this.length - 1; j >= 0; j--) this.words[j + B] = this.words[j];
                for (j = 0; j < B; j++) this.words[j] = 0;
                this.length += B
            }
            return this._strip()
        }, a.prototype.ishln = function (x) {
            return n(this.negative === 0), this.iushln(x)
        }, a.prototype.iushrn = function (x, A, B) {
            n(typeof x == "number" && x >= 0);
            var z;
            A ? z = (A - A % 26) / 26 : z = 0;
            var j = x % 26, $ = Math.min((x - j) / 26, this.length), C = 67108863 ^ 67108863 >>> j << j, R = B;
            if (z -= $, z = Math.max(0, z), R) {
                for (var k = 0; k < $; k++) R.words[k] = this.words[k];
                R.length = $
            }
            if ($ !== 0) if (this.length > $) for (this.length -= $, k = 0; k < this.length; k++) this.words[k] = this.words[k + $]; else this.words[0] = 0, this.length = 1;
            var Q = 0;
            for (k = this.length - 1; k >= 0 && (Q !== 0 || k >= z); k--) {
                var fe = this.words[k] | 0;
                this.words[k] = Q << 26 - j | fe >>> j, Q = fe & C
            }
            return R && Q !== 0 && (R.words[R.length++] = Q), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, a.prototype.ishrn = function (x, A, B) {
            return n(this.negative === 0), this.iushrn(x, A, B)
        }, a.prototype.shln = function (x) {
            return this.clone().ishln(x)
        }, a.prototype.ushln = function (x) {
            return this.clone().iushln(x)
        }, a.prototype.shrn = function (x) {
            return this.clone().ishrn(x)
        }, a.prototype.ushrn = function (x) {
            return this.clone().iushrn(x)
        }, a.prototype.testn = function (x) {
            n(typeof x == "number" && x >= 0);
            var A = x % 26, B = (x - A) / 26, z = 1 << A;
            if (this.length <= B) return !1;
            var j = this.words[B];
            return !!(j & z)
        }, a.prototype.imaskn = function (x) {
            n(typeof x == "number" && x >= 0);
            var A = x % 26, B = (x - A) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= B) return this;
            if (A !== 0 && B++, this.length = Math.min(B, this.length), A !== 0) {
                var z = 67108863 ^ 67108863 >>> A << A;
                this.words[this.length - 1] &= z
            }
            return this._strip()
        }, a.prototype.maskn = function (x) {
            return this.clone().imaskn(x)
        }, a.prototype.iaddn = function (x) {
            return n(typeof x == "number"), n(x < 67108864), x < 0 ? this.isubn(-x) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= x ? (this.words[0] = x - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(x), this.negative = 1, this) : this._iaddn(x)
        }, a.prototype._iaddn = function (x) {
            this.words[0] += x;
            for (var A = 0; A < this.length && this.words[A] >= 67108864; A++) this.words[A] -= 67108864, A === this.length - 1 ? this.words[A + 1] = 1 : this.words[A + 1]++;
            return this.length = Math.max(this.length, A + 1), this
        }, a.prototype.isubn = function (x) {
            if (n(typeof x == "number"), n(x < 67108864), x < 0) return this.iaddn(-x);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(x), this.negative = 1, this;
            if (this.words[0] -= x, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var A = 0; A < this.length && this.words[A] < 0; A++) this.words[A] += 67108864, this.words[A + 1] -= 1;
            return this._strip()
        }, a.prototype.addn = function (x) {
            return this.clone().iaddn(x)
        }, a.prototype.subn = function (x) {
            return this.clone().isubn(x)
        }, a.prototype.iabs = function () {
            return this.negative = 0, this
        }, a.prototype.abs = function () {
            return this.clone().iabs()
        }, a.prototype._ishlnsubmul = function (x, A, B) {
            var z = x.length + B, j;
            this._expand(z);
            var $, C = 0;
            for (j = 0; j < x.length; j++) {
                $ = (this.words[j + B] | 0) + C;
                var R = (x.words[j] | 0) * A;
                $ -= R & 67108863, C = ($ >> 26) - (R / 67108864 | 0), this.words[j + B] = $ & 67108863
            }
            for (; j < this.length - B; j++) $ = (this.words[j + B] | 0) + C, C = $ >> 26, this.words[j + B] = $ & 67108863;
            if (C === 0) return this._strip();
            for (n(C === -1), C = 0, j = 0; j < this.length; j++) $ = -(this.words[j] | 0) + C, C = $ >> 26, this.words[j] = $ & 67108863;
            return this.negative = 1, this._strip()
        }, a.prototype._wordDiv = function (x, A) {
            var B = this.length - x.length, z = this.clone(), j = x, $ = j.words[j.length - 1] | 0,
                C = this._countBits($);
            B = 26 - C, B !== 0 && (j = j.ushln(B), z.iushln(B), $ = j.words[j.length - 1] | 0);
            var R = z.length - j.length, k;
            if (A !== "mod") {
                k = new a(null), k.length = R + 1, k.words = new Array(k.length);
                for (var Q = 0; Q < k.length; Q++) k.words[Q] = 0
            }
            var fe = z.clone()._ishlnsubmul(j, 1, R);
            fe.negative === 0 && (z = fe, k && (k.words[R] = 1));
            for (var ye = R - 1; ye >= 0; ye--) {
                var ue = (z.words[j.length + ye] | 0) * 67108864 + (z.words[j.length + ye - 1] | 0);
                for (ue = Math.min(ue / $ | 0, 67108863), z._ishlnsubmul(j, ue, ye); z.negative !== 0;) ue--, z.negative = 0, z._ishlnsubmul(j, 1, ye), z.isZero() || (z.negative ^= 1);
                k && (k.words[ye] = ue)
            }
            return k && k._strip(), z._strip(), A !== "div" && B !== 0 && z.iushrn(B), {div: k || null, mod: z}
        }, a.prototype.divmod = function (x, A, B) {
            if (n(!x.isZero()), this.isZero()) return {div: new a(0), mod: new a(0)};
            var z, j, $;
            return this.negative !== 0 && x.negative === 0 ? ($ = this.neg().divmod(x, A), A !== "mod" && (z = $.div.neg()), A !== "div" && (j = $.mod.neg(), B && j.negative !== 0 && j.iadd(x)), {
                div: z,
                mod: j
            }) : this.negative === 0 && x.negative !== 0 ? ($ = this.divmod(x.neg(), A), A !== "mod" && (z = $.div.neg()), {
                div: z,
                mod: $.mod
            }) : this.negative & x.negative ? ($ = this.neg().divmod(x.neg(), A), A !== "div" && (j = $.mod.neg(), B && j.negative !== 0 && j.isub(x)), {
                div: $.div,
                mod: j
            }) : x.length > this.length || this.cmp(x) < 0 ? {
                div: new a(0),
                mod: this
            } : x.length === 1 ? A === "div" ? {div: this.divn(x.words[0]), mod: null} : A === "mod" ? {
                div: null,
                mod: new a(this.modrn(x.words[0]))
            } : {div: this.divn(x.words[0]), mod: new a(this.modrn(x.words[0]))} : this._wordDiv(x, A)
        }, a.prototype.div = function (x) {
            return this.divmod(x, "div", !1).div
        }, a.prototype.mod = function (x) {
            return this.divmod(x, "mod", !1).mod
        }, a.prototype.umod = function (x) {
            return this.divmod(x, "mod", !0).mod
        }, a.prototype.divRound = function (x) {
            var A = this.divmod(x);
            if (A.mod.isZero()) return A.div;
            var B = A.div.negative !== 0 ? A.mod.isub(x) : A.mod, z = x.ushrn(1), j = x.andln(1), $ = B.cmp(z);
            return $ < 0 || j === 1 && $ === 0 ? A.div : A.div.negative !== 0 ? A.div.isubn(1) : A.div.iaddn(1)
        }, a.prototype.modrn = function (x) {
            var A = x < 0;
            A && (x = -x), n(x <= 67108863);
            for (var B = (1 << 26) % x, z = 0, j = this.length - 1; j >= 0; j--) z = (B * z + (this.words[j] | 0)) % x;
            return A ? -z : z
        }, a.prototype.modn = function (x) {
            return this.modrn(x)
        }, a.prototype.idivn = function (x) {
            var A = x < 0;
            A && (x = -x), n(x <= 67108863);
            for (var B = 0, z = this.length - 1; z >= 0; z--) {
                var j = (this.words[z] | 0) + B * 67108864;
                this.words[z] = j / x | 0, B = j % x
            }
            return this._strip(), A ? this.ineg() : this
        }, a.prototype.divn = function (x) {
            return this.clone().idivn(x)
        }, a.prototype.egcd = function (x) {
            n(x.negative === 0), n(!x.isZero());
            var A = this, B = x.clone();
            A.negative !== 0 ? A = A.umod(x) : A = A.clone();
            for (var z = new a(1), j = new a(0), $ = new a(0), C = new a(1), R = 0; A.isEven() && B.isEven();) A.iushrn(1), B.iushrn(1), ++R;
            for (var k = B.clone(), Q = A.clone(); !A.isZero();) {
                for (var fe = 0, ye = 1; !(A.words[0] & ye) && fe < 26; ++fe, ye <<= 1) ;
                if (fe > 0) for (A.iushrn(fe); fe-- > 0;) (z.isOdd() || j.isOdd()) && (z.iadd(k), j.isub(Q)), z.iushrn(1), j.iushrn(1);
                for (var ue = 0, me = 1; !(B.words[0] & me) && ue < 26; ++ue, me <<= 1) ;
                if (ue > 0) for (B.iushrn(ue); ue-- > 0;) ($.isOdd() || C.isOdd()) && ($.iadd(k), C.isub(Q)), $.iushrn(1), C.iushrn(1);
                A.cmp(B) >= 0 ? (A.isub(B), z.isub($), j.isub(C)) : (B.isub(A), $.isub(z), C.isub(j))
            }
            return {a: $, b: C, gcd: B.iushln(R)}
        }, a.prototype._invmp = function (x) {
            n(x.negative === 0), n(!x.isZero());
            var A = this, B = x.clone();
            A.negative !== 0 ? A = A.umod(x) : A = A.clone();
            for (var z = new a(1), j = new a(0), $ = B.clone(); A.cmpn(1) > 0 && B.cmpn(1) > 0;) {
                for (var C = 0, R = 1; !(A.words[0] & R) && C < 26; ++C, R <<= 1) ;
                if (C > 0) for (A.iushrn(C); C-- > 0;) z.isOdd() && z.iadd($), z.iushrn(1);
                for (var k = 0, Q = 1; !(B.words[0] & Q) && k < 26; ++k, Q <<= 1) ;
                if (k > 0) for (B.iushrn(k); k-- > 0;) j.isOdd() && j.iadd($), j.iushrn(1);
                A.cmp(B) >= 0 ? (A.isub(B), z.isub(j)) : (B.isub(A), j.isub(z))
            }
            var fe;
            return A.cmpn(1) === 0 ? fe = z : fe = j, fe.cmpn(0) < 0 && fe.iadd(x), fe
        }, a.prototype.gcd = function (x) {
            if (this.isZero()) return x.abs();
            if (x.isZero()) return this.abs();
            var A = this.clone(), B = x.clone();
            A.negative = 0, B.negative = 0;
            for (var z = 0; A.isEven() && B.isEven(); z++) A.iushrn(1), B.iushrn(1);
            do {
                for (; A.isEven();) A.iushrn(1);
                for (; B.isEven();) B.iushrn(1);
                var j = A.cmp(B);
                if (j < 0) {
                    var $ = A;
                    A = B, B = $
                } else if (j === 0 || B.cmpn(1) === 0) break;
                A.isub(B)
            } while (!0);
            return B.iushln(z)
        }, a.prototype.invm = function (x) {
            return this.egcd(x).a.umod(x)
        }, a.prototype.isEven = function () {
            return (this.words[0] & 1) === 0
        }, a.prototype.isOdd = function () {
            return (this.words[0] & 1) === 1
        }, a.prototype.andln = function (x) {
            return this.words[0] & x
        }, a.prototype.bincn = function (x) {
            n(typeof x == "number");
            var A = x % 26, B = (x - A) / 26, z = 1 << A;
            if (this.length <= B) return this._expand(B + 1), this.words[B] |= z, this;
            for (var j = z, $ = B; j !== 0 && $ < this.length; $++) {
                var C = this.words[$] | 0;
                C += j, j = C >>> 26, C &= 67108863, this.words[$] = C
            }
            return j !== 0 && (this.words[$] = j, this.length++), this
        }, a.prototype.isZero = function () {
            return this.length === 1 && this.words[0] === 0
        }, a.prototype.cmpn = function (x) {
            var A = x < 0;
            if (this.negative !== 0 && !A) return -1;
            if (this.negative === 0 && A) return 1;
            this._strip();
            var B;
            if (this.length > 1) B = 1; else {
                A && (x = -x), n(x <= 67108863, "Number is too big");
                var z = this.words[0] | 0;
                B = z === x ? 0 : z < x ? -1 : 1
            }
            return this.negative !== 0 ? -B | 0 : B
        }, a.prototype.cmp = function (x) {
            if (this.negative !== 0 && x.negative === 0) return -1;
            if (this.negative === 0 && x.negative !== 0) return 1;
            var A = this.ucmp(x);
            return this.negative !== 0 ? -A | 0 : A
        }, a.prototype.ucmp = function (x) {
            if (this.length > x.length) return 1;
            if (this.length < x.length) return -1;
            for (var A = 0, B = this.length - 1; B >= 0; B--) {
                var z = this.words[B] | 0, j = x.words[B] | 0;
                if (z !== j) {
                    z < j ? A = -1 : z > j && (A = 1);
                    break
                }
            }
            return A
        }, a.prototype.gtn = function (x) {
            return this.cmpn(x) === 1
        }, a.prototype.gt = function (x) {
            return this.cmp(x) === 1
        }, a.prototype.gten = function (x) {
            return this.cmpn(x) >= 0
        }, a.prototype.gte = function (x) {
            return this.cmp(x) >= 0
        }, a.prototype.ltn = function (x) {
            return this.cmpn(x) === -1
        }, a.prototype.lt = function (x) {
            return this.cmp(x) === -1
        }, a.prototype.lten = function (x) {
            return this.cmpn(x) <= 0
        }, a.prototype.lte = function (x) {
            return this.cmp(x) <= 0
        }, a.prototype.eqn = function (x) {
            return this.cmpn(x) === 0
        }, a.prototype.eq = function (x) {
            return this.cmp(x) === 0
        }, a.red = function (x) {
            return new re(x)
        }, a.prototype.toRed = function (x) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), x.convertTo(this)._forceRed(x)
        }, a.prototype.fromRed = function () {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, a.prototype._forceRed = function (x) {
            return this.red = x, this
        }, a.prototype.forceRed = function (x) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(x)
        }, a.prototype.redAdd = function (x) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, x)
        }, a.prototype.redIAdd = function (x) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, x)
        }, a.prototype.redSub = function (x) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, x)
        }, a.prototype.redISub = function (x) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, x)
        }, a.prototype.redShl = function (x) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, x)
        }, a.prototype.redMul = function (x) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, x), this.red.mul(this, x)
        }, a.prototype.redIMul = function (x) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, x), this.red.imul(this, x)
        }, a.prototype.redSqr = function () {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, a.prototype.redISqr = function () {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, a.prototype.redSqrt = function () {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, a.prototype.redInvm = function () {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, a.prototype.redNeg = function () {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, a.prototype.redPow = function (x) {
            return n(this.red && !x.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, x)
        };
        var Y = {k256: null, p224: null, p192: null, p25519: null};

        function ee(D, x) {
            this.name = D, this.p = new a(x, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }

        ee.prototype._tmp = function () {
            var x = new a(null);
            return x.words = new Array(Math.ceil(this.n / 13)), x
        }, ee.prototype.ireduce = function (x) {
            var A = x, B;
            do this.split(A, this.tmp), A = this.imulK(A), A = A.iadd(this.tmp), B = A.bitLength(); while (B > this.n);
            var z = B < this.n ? -1 : A.ucmp(this.p);
            return z === 0 ? (A.words[0] = 0, A.length = 1) : z > 0 ? A.isub(this.p) : A.strip !== void 0 ? A.strip() : A._strip(), A
        }, ee.prototype.split = function (x, A) {
            x.iushrn(this.n, 0, A)
        }, ee.prototype.imulK = function (x) {
            return x.imul(this.k)
        };

        function oe() {
            ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }

        i(oe, ee), oe.prototype.split = function (x, A) {
            for (var B = 4194303, z = Math.min(x.length, 9), j = 0; j < z; j++) A.words[j] = x.words[j];
            if (A.length = z, x.length <= 9) {
                x.words[0] = 0, x.length = 1;
                return
            }
            var $ = x.words[9];
            for (A.words[A.length++] = $ & B, j = 10; j < x.length; j++) {
                var C = x.words[j] | 0;
                x.words[j - 10] = (C & B) << 4 | $ >>> 22, $ = C
            }
            $ >>>= 22, x.words[j - 10] = $, $ === 0 && x.length > 10 ? x.length -= 10 : x.length -= 9
        }, oe.prototype.imulK = function (x) {
            x.words[x.length] = 0, x.words[x.length + 1] = 0, x.length += 2;
            for (var A = 0, B = 0; B < x.length; B++) {
                var z = x.words[B] | 0;
                A += z * 977, x.words[B] = A & 67108863, A = z * 64 + (A / 67108864 | 0)
            }
            return x.words[x.length - 1] === 0 && (x.length--, x.words[x.length - 1] === 0 && x.length--), x
        };

        function G() {
            ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }

        i(G, ee);

        function J() {
            ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }

        i(J, ee);

        function ce() {
            ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }

        i(ce, ee), ce.prototype.imulK = function (x) {
            for (var A = 0, B = 0; B < x.length; B++) {
                var z = (x.words[B] | 0) * 19 + A, j = z & 67108863;
                z >>>= 26, x.words[B] = j, A = z
            }
            return A !== 0 && (x.words[x.length++] = A), x
        }, a._prime = function (x) {
            if (Y[x]) return Y[x];
            var A;
            if (x === "k256") A = new oe; else if (x === "p224") A = new G; else if (x === "p192") A = new J; else if (x === "p25519") A = new ce; else throw new Error("Unknown prime " + x);
            return Y[x] = A, A
        };

        function re(D) {
            if (typeof D == "string") {
                var x = a._prime(D);
                this.m = x.p, this.prime = x
            } else n(D.gtn(1), "modulus must be greater than 1"), this.m = D, this.prime = null
        }

        re.prototype._verify1 = function (x) {
            n(x.negative === 0, "red works only with positives"), n(x.red, "red works only with red numbers")
        }, re.prototype._verify2 = function (x, A) {
            n((x.negative | A.negative) === 0, "red works only with positives"), n(x.red && x.red === A.red, "red works only with red numbers")
        }, re.prototype.imod = function (x) {
            return this.prime ? this.prime.ireduce(x)._forceRed(this) : (d(x, x.umod(this.m)._forceRed(this)), x)
        }, re.prototype.neg = function (x) {
            return x.isZero() ? x.clone() : this.m.sub(x)._forceRed(this)
        }, re.prototype.add = function (x, A) {
            this._verify2(x, A);
            var B = x.add(A);
            return B.cmp(this.m) >= 0 && B.isub(this.m), B._forceRed(this)
        }, re.prototype.iadd = function (x, A) {
            this._verify2(x, A);
            var B = x.iadd(A);
            return B.cmp(this.m) >= 0 && B.isub(this.m), B
        }, re.prototype.sub = function (x, A) {
            this._verify2(x, A);
            var B = x.sub(A);
            return B.cmpn(0) < 0 && B.iadd(this.m), B._forceRed(this)
        }, re.prototype.isub = function (x, A) {
            this._verify2(x, A);
            var B = x.isub(A);
            return B.cmpn(0) < 0 && B.iadd(this.m), B
        }, re.prototype.shl = function (x, A) {
            return this._verify1(x), this.imod(x.ushln(A))
        }, re.prototype.imul = function (x, A) {
            return this._verify2(x, A), this.imod(x.imul(A))
        }, re.prototype.mul = function (x, A) {
            return this._verify2(x, A), this.imod(x.mul(A))
        }, re.prototype.isqr = function (x) {
            return this.imul(x, x.clone())
        }, re.prototype.sqr = function (x) {
            return this.mul(x, x)
        }, re.prototype.sqrt = function (x) {
            if (x.isZero()) return x.clone();
            var A = this.m.andln(3);
            if (n(A % 2 === 1), A === 3) {
                var B = this.m.add(new a(1)).iushrn(2);
                return this.pow(x, B)
            }
            for (var z = this.m.subn(1), j = 0; !z.isZero() && z.andln(1) === 0;) j++, z.iushrn(1);
            n(!z.isZero());
            var $ = new a(1).toRed(this), C = $.redNeg(), R = this.m.subn(1).iushrn(1), k = this.m.bitLength();
            for (k = new a(2 * k * k).toRed(this); this.pow(k, R).cmp(C) !== 0;) ;
            for (var Q = this.pow(k, z), fe = this.pow(x, z.addn(1).iushrn(1)), ye = this.pow(x, z), ue = j; ye.cmp($) !== 0;) {
                for (var me = ye, Se = 0; me.cmp($) !== 0; Se++) me = me.redSqr();
                n(Se < ue);
                var Ce = this.pow(Q, new a(1).iushln(ue - Se - 1));
                fe = fe.redMul(Ce), Q = Ce.redSqr(), ye = ye.redMul(Q), ue = Se
            }
            return fe
        }, re.prototype.invm = function (x) {
            var A = x._invmp(this.m);
            return A.negative !== 0 ? (A.negative = 0, this.imod(A).redNeg()) : this.imod(A)
        }, re.prototype.pow = function (x, A) {
            if (A.isZero()) return new a(1).toRed(this);
            if (A.cmpn(1) === 0) return x.clone();
            var B = 4, z = new Array(1 << B);
            z[0] = new a(1).toRed(this), z[1] = x;
            for (var j = 2; j < z.length; j++) z[j] = this.mul(z[j - 1], x);
            var $ = z[0], C = 0, R = 0, k = A.bitLength() % 26;
            for (k === 0 && (k = 26), j = A.length - 1; j >= 0; j--) {
                for (var Q = A.words[j], fe = k - 1; fe >= 0; fe--) {
                    var ye = Q >> fe & 1;
                    if ($ !== z[0] && ($ = this.sqr($)), ye === 0 && C === 0) {
                        R = 0;
                        continue
                    }
                    C <<= 1, C |= ye, R++, !(R !== B && (j !== 0 || fe !== 0)) && ($ = this.mul($, z[C]), R = 0, C = 0)
                }
                k = 26
            }
            return $
        }, re.prototype.convertTo = function (x) {
            var A = x.umod(this.m);
            return A === x ? A.clone() : A
        }, re.prototype.convertFrom = function (x) {
            var A = x.clone();
            return A.red = null, A
        }, a.mont = function (x) {
            return new M(x)
        };

        function M(D) {
            re.call(this, D), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }

        i(M, re), M.prototype.convertTo = function (x) {
            return this.imod(x.ushln(this.shift))
        }, M.prototype.convertFrom = function (x) {
            var A = this.imod(x.mul(this.rinv));
            return A.red = null, A
        }, M.prototype.imul = function (x, A) {
            if (x.isZero() || A.isZero()) return x.words[0] = 0, x.length = 1, x;
            var B = x.imul(A), z = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                j = B.isub(z).iushrn(this.shift), $ = j;
            return j.cmp(this.m) >= 0 ? $ = j.isub(this.m) : j.cmpn(0) < 0 && ($ = j.iadd(this.m)), $._forceRed(this)
        }, M.prototype.mul = function (x, A) {
            if (x.isZero() || A.isZero()) return new a(0)._forceRed(this);
            var B = x.mul(A), z = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                j = B.isub(z).iushrn(this.shift), $ = j;
            return j.cmp(this.m) >= 0 ? $ = j.isub(this.m) : j.cmpn(0) < 0 && ($ = j.iadd(this.m)), $._forceRed(this)
        }, M.prototype.invm = function (x) {
            var A = this.imod(x._invmp(this.m).mul(this.r2));
            return A._forceRed(this)
        }
    })(t, tn)
})(Lwe);
var P8 = Lwe.exports;
const Qce = za(P8);
var Zx = P8, snt = FE;

function cnt(t) {
    var e = Bwe(t), r = e.toRed(Zx.mont(t.modulus)).redPow(new Zx(t.publicExponent)).fromRed();
    return {blinder: r, unblinder: e.invm(t.modulus)}
}

function Bwe(t) {
    var e = t.modulus.byteLength(), r;
    do r = new Zx(snt(e)); while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
    return r
}

function $we(t, e) {
    var r = cnt(e), n = e.modulus.byteLength(), i = new Zx(t).mul(r.blinder).umod(e.modulus),
        a = i.toRed(Zx.mont(e.prime1)), o = i.toRed(Zx.mont(e.prime2)), s = e.coefficient, l = e.prime1, f = e.prime2,
        d = a.redPow(e.exponent1).fromRed(), p = o.redPow(e.exponent2).fromRed(), g = d.isub(p).imul(s).umod(l).imul(f);
    return p.iadd(g).imul(r.unblinder).umod(e.modulus).toArrayLike(kr, "be", n)
}

$we.getr = Bwe;
var yQ = $we, gz = {};
const lnt = "elliptic", unt = "6.5.4", fnt = "EC cryptography", dnt = "lib/elliptic.js", hnt = ["lib"], pnt = {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
    }, mnt = {type: "git", url: "git@github.com:indutny/elliptic"}, vnt = ["EC", "Elliptic", "curve", "Cryptography"],
    gnt = "Fedor Indutny <fedor@indutny.com>", ynt = "MIT", bnt = {url: "https://github.com/indutny/elliptic/issues"},
    wnt = "https://github.com/indutny/elliptic", Snt = {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
    }, _nt = {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
    }, xnt = {
        name: lnt,
        version: unt,
        description: fnt,
        main: dnt,
        files: hnt,
        scripts: pnt,
        repository: mnt,
        keywords: vnt,
        author: gnt,
        license: ynt,
        bugs: bnt,
        homepage: wnt,
        devDependencies: Snt,
        dependencies: _nt
    };
var Jf = {}, bQ = {};
(function (t) {
    var e = t;

    function r(a, o) {
        if (Array.isArray(a)) return a.slice();
        if (!a) return [];
        var s = [];
        if (typeof a != "string") {
            for (var l = 0; l < a.length; l++) s[l] = a[l] | 0;
            return s
        }
        if (o === "hex") {
            a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
            for (var l = 0; l < a.length; l += 2) s.push(parseInt(a[l] + a[l + 1], 16))
        } else for (var l = 0; l < a.length; l++) {
            var f = a.charCodeAt(l), d = f >> 8, p = f & 255;
            d ? s.push(d, p) : s.push(p)
        }
        return s
    }

    e.toArray = r;

    function n(a) {
        return a.length === 1 ? "0" + a : a
    }

    e.zero2 = n;

    function i(a) {
        for (var o = "", s = 0; s < a.length; s++) o += n(a[s].toString(16));
        return o
    }

    e.toHex = i, e.encode = function (o, s) {
        return s === "hex" ? i(o) : o
    }
})(bQ);
(function (t) {
    var e = t, r = sc, n = nh, i = bQ;
    e.assert = n, e.toArray = i.toArray, e.zero2 = i.zero2, e.toHex = i.toHex, e.encode = i.encode;

    function a(d, p, g) {
        var b = new Array(Math.max(d.bitLength(), g) + 1);
        b.fill(0);
        for (var S = 1 << p + 1, T = d.clone(), I = 0; I < b.length; I++) {
            var N, P = T.andln(S - 1);
            T.isOdd() ? (P > (S >> 1) - 1 ? N = (S >> 1) - P : N = P, T.isubn(N)) : N = 0, b[I] = N, T.iushrn(1)
        }
        return b
    }

    e.getNAF = a;

    function o(d, p) {
        var g = [[], []];
        d = d.clone(), p = p.clone();
        for (var b = 0, S = 0, T; d.cmpn(-b) > 0 || p.cmpn(-S) > 0;) {
            var I = d.andln(3) + b & 3, N = p.andln(3) + S & 3;
            I === 3 && (I = -1), N === 3 && (N = -1);
            var P;
            I & 1 ? (T = d.andln(7) + b & 7, (T === 3 || T === 5) && N === 2 ? P = -I : P = I) : P = 0, g[0].push(P);
            var F;
            N & 1 ? (T = p.andln(7) + S & 7, (T === 3 || T === 5) && I === 2 ? F = -N : F = N) : F = 0, g[1].push(F), 2 * b === P + 1 && (b = 1 - b), 2 * S === F + 1 && (S = 1 - S), d.iushrn(1), p.iushrn(1)
        }
        return g
    }

    e.getJSF = o;

    function s(d, p, g) {
        var b = "_" + p;
        d.prototype[p] = function () {
            return this[b] !== void 0 ? this[b] : this[b] = g.call(this)
        }
    }

    e.cachedProperty = s;

    function l(d) {
        return typeof d == "string" ? e.toArray(d, "hex") : d
    }

    e.parseBytes = l;

    function f(d) {
        return new r(d, "hex", "le")
    }

    e.intFromLE = f
})(Jf);
var wQ = {}, Yb = sc, N8 = Jf, iO = N8.getNAF, Ent = N8.getJSF, aO = N8.assert;

function w1(t, e) {
    this.type = t, this.p = new Yb(e.p, 16), this.red = e.prime ? Yb.red(e.prime) : Yb.mont(this.p), this.zero = new Yb(0).toRed(this.red), this.one = new Yb(1).toRed(this.red), this.two = new Yb(2).toRed(this.red), this.n = e.n && new Yb(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
}

var mN = w1;
w1.prototype.point = function () {
    throw new Error("Not implemented")
};
w1.prototype.validate = function () {
    throw new Error("Not implemented")
};
w1.prototype._fixedNafMul = function (e, r) {
    aO(e.precomputed);
    var n = e._getDoubles(), i = iO(r, 1, this._bitLength), a = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
    a /= 3;
    var o = [], s, l;
    for (s = 0; s < i.length; s += n.step) {
        l = 0;
        for (var f = s + n.step - 1; f >= s; f--) l = (l << 1) + i[f];
        o.push(l)
    }
    for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), g = a; g > 0; g--) {
        for (s = 0; s < o.length; s++) l = o[s], l === g ? p = p.mixedAdd(n.points[s]) : l === -g && (p = p.mixedAdd(n.points[s].neg()));
        d = d.add(p)
    }
    return d.toP()
};
w1.prototype._wnafMul = function (e, r) {
    var n = 4, i = e._getNAFPoints(n);
    n = i.wnd;
    for (var a = i.points, o = iO(r, n, this._bitLength), s = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
        for (var f = 0; l >= 0 && o[l] === 0; l--) f++;
        if (l >= 0 && f++, s = s.dblp(f), l < 0) break;
        var d = o[l];
        aO(d !== 0), e.type === "affine" ? d > 0 ? s = s.mixedAdd(a[d - 1 >> 1]) : s = s.mixedAdd(a[-d - 1 >> 1].neg()) : d > 0 ? s = s.add(a[d - 1 >> 1]) : s = s.add(a[-d - 1 >> 1].neg())
    }
    return e.type === "affine" ? s.toP() : s
};
w1.prototype._wnafMulAdd = function (e, r, n, i, a) {
    var o = this._wnafT1, s = this._wnafT2, l = this._wnafT3, f = 0, d, p, g;
    for (d = 0; d < i; d++) {
        g = r[d];
        var b = g._getNAFPoints(e);
        o[d] = b.wnd, s[d] = b.points
    }
    for (d = i - 1; d >= 1; d -= 2) {
        var S = d - 1, T = d;
        if (o[S] !== 1 || o[T] !== 1) {
            l[S] = iO(n[S], o[S], this._bitLength), l[T] = iO(n[T], o[T], this._bitLength), f = Math.max(l[S].length, f), f = Math.max(l[T].length, f);
            continue
        }
        var I = [r[S], null, null, r[T]];
        r[S].y.cmp(r[T].y) === 0 ? (I[1] = r[S].add(r[T]), I[2] = r[S].toJ().mixedAdd(r[T].neg())) : r[S].y.cmp(r[T].y.redNeg()) === 0 ? (I[1] = r[S].toJ().mixedAdd(r[T]), I[2] = r[S].add(r[T].neg())) : (I[1] = r[S].toJ().mixedAdd(r[T]), I[2] = r[S].toJ().mixedAdd(r[T].neg()));
        var N = [-3, -1, -5, -7, 0, 7, 5, 1, 3], P = Ent(n[S], n[T]);
        for (f = Math.max(P[0].length, f), l[S] = new Array(f), l[T] = new Array(f), p = 0; p < f; p++) {
            var F = P[0][p] | 0, V = P[1][p] | 0;
            l[S][p] = N[(F + 1) * 3 + (V + 1)], l[T][p] = 0, s[S] = I
        }
    }
    var Y = this.jpoint(null, null, null), ee = this._wnafT4;
    for (d = f; d >= 0; d--) {
        for (var oe = 0; d >= 0;) {
            var G = !0;
            for (p = 0; p < i; p++) ee[p] = l[p][d] | 0, ee[p] !== 0 && (G = !1);
            if (!G) break;
            oe++, d--
        }
        if (d >= 0 && oe++, Y = Y.dblp(oe), d < 0) break;
        for (p = 0; p < i; p++) {
            var J = ee[p];
            J !== 0 && (J > 0 ? g = s[p][J - 1 >> 1] : J < 0 && (g = s[p][-J - 1 >> 1].neg()), g.type === "affine" ? Y = Y.mixedAdd(g) : Y = Y.add(g))
        }
    }
    for (d = 0; d < i; d++) s[d] = null;
    return a ? Y : Y.toP()
};

function ah(t, e) {
    this.curve = t, this.type = e, this.precomputed = null
}

w1.BasePoint = ah;
ah.prototype.eq = function () {
    throw new Error("Not implemented")
};
ah.prototype.validate = function () {
    return this.curve.validate(this)
};
w1.prototype.decodePoint = function (e, r) {
    e = N8.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
        e[0] === 6 ? aO(e[e.length - 1] % 2 === 0) : e[0] === 7 && aO(e[e.length - 1] % 2 === 1);
        var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format")
};
ah.prototype.encodeCompressed = function (e) {
    return this.encode(e, !0)
};
ah.prototype._encode = function (e) {
    var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
};
ah.prototype.encode = function (e, r) {
    return N8.encode(this._encode(r), e)
};
ah.prototype.precompute = function (e) {
    if (this.precomputed) return this;
    var r = {doubles: null, naf: null, beta: null};
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this
};
ah.prototype._hasDoubles = function (e) {
    if (!this.precomputed) return !1;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1
};
ah.prototype._getDoubles = function (e, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var n = [this], i = this, a = 0; a < r; a += e) {
        for (var o = 0; o < e; o++) i = i.dbl();
        n.push(i)
    }
    return {step: e, points: n}
};
ah.prototype._getNAFPoints = function (e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), a = 1; a < n; a++) r[a] = r[a - 1].add(i);
    return {wnd: e, points: r}
};
ah.prototype._getBeta = function () {
    return null
};
ah.prototype.dblp = function (e) {
    for (var r = this, n = 0; n < e; n++) r = r.dbl();
    return r
};
var Tnt = Jf, ko = sc, SQ = Xn, zE = mN, Cnt = Tnt.assert;

function oh(t) {
    zE.call(this, "short", t), this.a = new ko(t.a, 16).toRed(this.red), this.b = new ko(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
}

SQ(oh, zE);
var Ant = oh;
oh.prototype._getEndomorphism = function (e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n;
        if (e.beta) r = new ko(e.beta, 16).toRed(this.red); else {
            var i = this._getEndoRoots(this.p);
            r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red)
        }
        if (e.lambda) n = new ko(e.lambda, 16); else {
            var a = this._getEndoRoots(this.n);
            this.g.mul(a[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = a[0] : (n = a[1], Cnt(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var o;
        return e.basis ? o = e.basis.map(function (s) {
            return {a: new ko(s.a, 16), b: new ko(s.b, 16)}
        }) : o = this._getEndoBasis(n), {beta: r, lambda: n, basis: o}
    }
};
oh.prototype._getEndoRoots = function (e) {
    var r = e === this.p ? this.red : ko.mont(e), n = new ko(2).toRed(r).redInvm(), i = n.redNeg(),
        a = new ko(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(a).fromRed(), s = i.redSub(a).fromRed();
    return [o, s]
};
oh.prototype._getEndoBasis = function (e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), a = new ko(1), o = new ko(0), s = new ko(0), l = new ko(1), f, d, p, g, b, S, T, I = 0, N, P; n.cmpn(0) !== 0;) {
        var F = i.div(n);
        N = i.sub(F.mul(n)), P = s.sub(F.mul(a));
        var V = l.sub(F.mul(o));
        if (!p && N.cmp(r) < 0) f = T.neg(), d = a, p = N.neg(), g = P; else if (p && ++I === 2) break;
        T = N, i = n, n = N, s = a, a = P, l = o, o = V
    }
    b = N.neg(), S = P;
    var Y = p.sqr().add(g.sqr()), ee = b.sqr().add(S.sqr());
    return ee.cmp(Y) >= 0 && (b = f, S = d), p.negative && (p = p.neg(), g = g.neg()), b.negative && (b = b.neg(), S = S.neg()), [{
        a: p,
        b: g
    }, {a: b, b: S}]
};
oh.prototype._endoSplit = function (e) {
    var r = this.endo.basis, n = r[0], i = r[1], a = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n),
        s = a.mul(n.a), l = o.mul(i.a), f = a.mul(n.b), d = o.mul(i.b), p = e.sub(s).sub(l), g = f.add(d).neg();
    return {k1: p, k2: g}
};
oh.prototype.pointFromX = function (e, r) {
    e = new ko(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point");
    var a = i.fromRed().isOdd();
    return (r && !a || !r && a) && (i = i.redNeg()), this.point(e, i)
};
oh.prototype.validate = function (e) {
    if (e.inf) return !0;
    var r = e.x, n = e.y, i = this.a.redMul(r), a = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(a).cmpn(0) === 0
};
oh.prototype._endoWnafMulAdd = function (e, r, n) {
    for (var i = this._endoWnafT1, a = this._endoWnafT2, o = 0; o < e.length; o++) {
        var s = this._endoSplit(r[o]), l = e[o], f = l._getBeta();
        s.k1.negative && (s.k1.ineg(), l = l.neg(!0)), s.k2.negative && (s.k2.ineg(), f = f.neg(!0)), i[o * 2] = l, i[o * 2 + 1] = f, a[o * 2] = s.k1, a[o * 2 + 1] = s.k2
    }
    for (var d = this._wnafMulAdd(1, i, a, o * 2, n), p = 0; p < o * 2; p++) i[p] = null, a[p] = null;
    return d
};

function cc(t, e, r, n) {
    zE.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new ko(e, 16), this.y = new ko(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
}

SQ(cc, zE.BasePoint);
oh.prototype.point = function (e, r, n) {
    return new cc(this, e, r, n)
};
oh.prototype.pointFromJSON = function (e, r) {
    return cc.fromJSON(this, e, r)
};
cc.prototype._getBeta = function () {
    if (this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta) return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
            var n = this.curve, i = function (a) {
                return n.point(a.x.redMul(n.endo.beta), a.y)
            };
            e.beta = r, r.precomputed = {
                beta: null,
                naf: e.naf && {wnd: e.naf.wnd, points: e.naf.points.map(i)},
                doubles: e.doubles && {step: e.doubles.step, points: e.doubles.points.map(i)}
            }
        }
        return r
    }
};
cc.prototype.toJSON = function () {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
        }, naf: this.precomputed.naf && {wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1)}
    }] : [this.x, this.y]
};
cc.fromJSON = function (e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2]) return i;

    function a(s) {
        return e.point(s[0], s[1], n)
    }

    var o = r[2];
    return i.precomputed = {
        beta: null,
        doubles: o.doubles && {step: o.doubles.step, points: [i].concat(o.doubles.points.map(a))},
        naf: o.naf && {wnd: o.naf.wnd, points: [i].concat(o.naf.points.map(a))}
    }, i
};
cc.prototype.inspect = function () {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
};
cc.prototype.isInfinity = function () {
    return this.inf
};
cc.prototype.add = function (e) {
    if (this.inf) return e;
    if (e.inf) return this;
    if (this.eq(e)) return this.dbl();
    if (this.neg().eq(e)) return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i)
};
cc.prototype.dbl = function () {
    if (this.inf) return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0) return this.curve.point(null, null);
    var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), a = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        o = a.redSqr().redISub(this.x.redAdd(this.x)), s = a.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, s)
};
cc.prototype.getX = function () {
    return this.x.fromRed()
};
cc.prototype.getY = function () {
    return this.y.fromRed()
};
cc.prototype.mul = function (e) {
    return e = new ko(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
};
cc.prototype.mulAdd = function (e, r, n) {
    var i = [this, r], a = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, a) : this.curve._wnafMulAdd(1, i, a, 2)
};
cc.prototype.jmulAdd = function (e, r, n) {
    var i = [this, r], a = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, a, !0) : this.curve._wnafMulAdd(1, i, a, 2, !0)
};
cc.prototype.eq = function (e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
};
cc.prototype.neg = function (e) {
    if (this.inf) return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
        var n = this.precomputed, i = function (a) {
            return a.neg()
        };
        r.precomputed = {
            naf: n.naf && {wnd: n.naf.wnd, points: n.naf.points.map(i)},
            doubles: n.doubles && {step: n.doubles.step, points: n.doubles.points.map(i)}
        }
    }
    return r
};
cc.prototype.toJ = function () {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e
};

function Gc(t, e, r, n) {
    zE.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ko(0)) : (this.x = new ko(e, 16), this.y = new ko(r, 16), this.z = new ko(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
}

SQ(Gc, zE.BasePoint);
oh.prototype.jpoint = function (e, r, n) {
    return new Gc(this, e, r, n)
};
Gc.prototype.toP = function () {
    if (this.isInfinity()) return this.curve.point(null, null);
    var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i)
};
Gc.prototype.neg = function () {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
};
Gc.prototype.add = function (e) {
    if (this.isInfinity()) return e;
    if (e.isInfinity()) return this;
    var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), a = e.x.redMul(n),
        o = this.y.redMul(r.redMul(e.z)), s = e.y.redMul(n.redMul(this.z)), l = i.redSub(a), f = o.redSub(s);
    if (l.cmpn(0) === 0) return f.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var d = l.redSqr(), p = d.redMul(l), g = i.redMul(d), b = f.redSqr().redIAdd(p).redISub(g).redISub(g),
        S = f.redMul(g.redISub(b)).redISub(o.redMul(p)), T = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(b, S, T)
};
Gc.prototype.mixedAdd = function (e) {
    if (this.isInfinity()) return e.toJ();
    if (e.isInfinity()) return this;
    var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), a = this.y, o = e.y.redMul(r).redMul(this.z),
        s = n.redSub(i), l = a.redSub(o);
    if (s.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var f = s.redSqr(), d = f.redMul(s), p = n.redMul(f), g = l.redSqr().redIAdd(d).redISub(p).redISub(p),
        b = l.redMul(p.redISub(g)).redISub(a.redMul(d)), S = this.z.redMul(s);
    return this.curve.jpoint(g, b, S)
};
Gc.prototype.dblp = function (e) {
    if (e === 0) return this;
    if (this.isInfinity()) return this;
    if (!e) return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this;
        for (r = 0; r < e; r++) n = n.dbl();
        return n
    }
    var i = this.curve.a, a = this.curve.tinv, o = this.x, s = this.y, l = this.z, f = l.redSqr().redSqr(),
        d = s.redAdd(s);
    for (r = 0; r < e; r++) {
        var p = o.redSqr(), g = d.redSqr(), b = g.redSqr(), S = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(f)),
            T = o.redMul(g), I = S.redSqr().redISub(T.redAdd(T)), N = T.redISub(I), P = S.redMul(N);
        P = P.redIAdd(P).redISub(b);
        var F = d.redMul(l);
        r + 1 < e && (f = f.redMul(b)), o = I, l = F, d = P
    }
    return this.curve.jpoint(o, d.redMul(a), l)
};
Gc.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
};
Gc.prototype._zeroDbl = function () {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(), a = this.y.redSqr(), o = a.redSqr(),
            s = this.x.redAdd(a).redSqr().redISub(i).redISub(o);
        s = s.redIAdd(s);
        var l = i.redAdd(i).redIAdd(i), f = l.redSqr().redISub(s).redISub(s), d = o.redIAdd(o);
        d = d.redIAdd(d), d = d.redIAdd(d), e = f, r = l.redMul(s.redISub(f)).redISub(d), n = this.y.redAdd(this.y)
    } else {
        var p = this.x.redSqr(), g = this.y.redSqr(), b = g.redSqr(),
            S = this.x.redAdd(g).redSqr().redISub(p).redISub(b);
        S = S.redIAdd(S);
        var T = p.redAdd(p).redIAdd(p), I = T.redSqr(), N = b.redIAdd(b);
        N = N.redIAdd(N), N = N.redIAdd(N), e = I.redISub(S).redISub(S), r = T.redMul(S.redISub(e)).redISub(N), n = this.y.redMul(this.z), n = n.redIAdd(n)
    }
    return this.curve.jpoint(e, r, n)
};
Gc.prototype._threeDbl = function () {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(), a = this.y.redSqr(), o = a.redSqr(),
            s = this.x.redAdd(a).redSqr().redISub(i).redISub(o);
        s = s.redIAdd(s);
        var l = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), f = l.redSqr().redISub(s).redISub(s);
        e = f;
        var d = o.redIAdd(o);
        d = d.redIAdd(d), d = d.redIAdd(d), r = l.redMul(s.redISub(f)).redISub(d), n = this.y.redAdd(this.y)
    } else {
        var p = this.z.redSqr(), g = this.y.redSqr(), b = this.x.redMul(g),
            S = this.x.redSub(p).redMul(this.x.redAdd(p));
        S = S.redAdd(S).redIAdd(S);
        var T = b.redIAdd(b);
        T = T.redIAdd(T);
        var I = T.redAdd(T);
        e = S.redSqr().redISub(I), n = this.y.redAdd(this.z).redSqr().redISub(g).redISub(p);
        var N = g.redSqr();
        N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N), r = S.redMul(T.redISub(e)).redISub(N)
    }
    return this.curve.jpoint(e, r, n)
};
Gc.prototype._dbl = function () {
    var e = this.curve.a, r = this.x, n = this.y, i = this.z, a = i.redSqr().redSqr(), o = r.redSqr(), s = n.redSqr(),
        l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(a)), f = r.redAdd(r);
    f = f.redIAdd(f);
    var d = f.redMul(s), p = l.redSqr().redISub(d.redAdd(d)), g = d.redISub(p), b = s.redSqr();
    b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b);
    var S = l.redMul(g).redISub(b), T = n.redAdd(n).redMul(i);
    return this.curve.jpoint(p, S, T)
};
Gc.prototype.trpl = function () {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), a = e.redAdd(e).redIAdd(e),
        o = a.redSqr(), s = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    s = s.redIAdd(s), s = s.redAdd(s).redIAdd(s), s = s.redISub(o);
    var l = s.redSqr(), f = i.redIAdd(i);
    f = f.redIAdd(f), f = f.redIAdd(f), f = f.redIAdd(f);
    var d = a.redIAdd(s).redSqr().redISub(o).redISub(l).redISub(f), p = r.redMul(d);
    p = p.redIAdd(p), p = p.redIAdd(p);
    var g = this.x.redMul(l).redISub(p);
    g = g.redIAdd(g), g = g.redIAdd(g);
    var b = this.y.redMul(d.redMul(f.redISub(d)).redISub(s.redMul(l)));
    b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b);
    var S = this.z.redAdd(s).redSqr().redISub(n).redISub(l);
    return this.curve.jpoint(g, b, S)
};
Gc.prototype.mul = function (e, r) {
    return e = new ko(e, r), this.curve._wnafMul(this, e)
};
Gc.prototype.eq = function (e) {
    if (e.type === "affine") return this.eq(e.toJ());
    if (this === e) return !0;
    var r = this.z.redSqr(), n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1;
    var i = r.redMul(this.z), a = n.redMul(e.z);
    return this.y.redMul(a).redISub(e.y.redMul(i)).cmpn(0) === 0
};
Gc.prototype.eqXToP = function (e) {
    var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0) return !0;
    for (var i = e.clone(), a = this.curve.redN.redMul(r); ;) {
        if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
        if (n.redIAdd(a), this.x.cmp(n) === 0) return !0
    }
};
Gc.prototype.inspect = function () {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
};
Gc.prototype.isInfinity = function () {
    return this.z.cmpn(0) === 0
};
var Ex = sc, Fwe = Xn, vN = mN, Int = Jf;

function VE(t) {
    vN.call(this, "mont", t), this.a = new Ex(t.a, 16).toRed(this.red), this.b = new Ex(t.b, 16).toRed(this.red), this.i4 = new Ex(4).toRed(this.red).redInvm(), this.two = new Ex(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
}

Fwe(VE, vN);
var knt = VE;
VE.prototype.validate = function (e) {
    var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), a = i.redSqrt();
    return a.redSqr().cmp(i) === 0
};

function tc(t, e, r) {
    vN.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Ex(e, 16), this.z = new Ex(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
}

Fwe(tc, vN.BasePoint);
VE.prototype.decodePoint = function (e, r) {
    return this.point(Int.toArray(e, r), 1)
};
VE.prototype.point = function (e, r) {
    return new tc(this, e, r)
};
VE.prototype.pointFromJSON = function (e) {
    return tc.fromJSON(this, e)
};
tc.prototype.precompute = function () {
};
tc.prototype._encode = function () {
    return this.getX().toArray("be", this.curve.p.byteLength())
};
tc.fromJSON = function (e, r) {
    return new tc(e, r[0], r[1] || e.one)
};
tc.prototype.inspect = function () {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
};
tc.prototype.isInfinity = function () {
    return this.z.cmpn(0) === 0
};
tc.prototype.dbl = function () {
    var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), a = r.redSub(i),
        o = r.redMul(i), s = a.redMul(i.redAdd(this.curve.a24.redMul(a)));
    return this.curve.point(o, s)
};
tc.prototype.add = function () {
    throw new Error("Not supported on Montgomery curve")
};
tc.prototype.diffAdd = function (e, r) {
    var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), a = e.x.redAdd(e.z), o = e.x.redSub(e.z), s = o.redMul(n),
        l = a.redMul(i), f = r.z.redMul(s.redAdd(l).redSqr()), d = r.x.redMul(s.redISub(l).redSqr());
    return this.curve.point(f, d)
};
tc.prototype.mul = function (e) {
    for (var r = e.clone(), n = this, i = this.curve.point(null, null), a = this, o = []; r.cmpn(0) !== 0; r.iushrn(1)) o.push(r.andln(1));
    for (var s = o.length - 1; s >= 0; s--) o[s] === 0 ? (n = n.diffAdd(i, a), i = i.dbl()) : (i = n.diffAdd(i, a), n = n.dbl());
    return i
};
tc.prototype.mulAdd = function () {
    throw new Error("Not supported on Montgomery curve")
};
tc.prototype.jumlAdd = function () {
    throw new Error("Not supported on Montgomery curve")
};
tc.prototype.eq = function (e) {
    return this.getX().cmp(e.getX()) === 0
};
tc.prototype.normalize = function () {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
};
tc.prototype.getX = function () {
    return this.normalize(), this.x.fromRed()
};
var Rnt = Jf, dv = sc, Uwe = Xn, gN = mN, Dnt = Rnt.assert;

function Q0(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, gN.call(this, "edwards", t), this.a = new dv(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new dv(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new dv(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Dnt(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1
}

Uwe(Q0, gN);
var Mnt = Q0;
Q0.prototype._mulA = function (e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e)
};
Q0.prototype._mulC = function (e) {
    return this.oneC ? e : this.c.redMul(e)
};
Q0.prototype.jpoint = function (e, r, n, i) {
    return this.point(e, r, n, i)
};
Q0.prototype.pointFromX = function (e, r) {
    e = new dv(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), a = this.one.redSub(this.c2.redMul(this.d).redMul(n)),
        o = i.redMul(a.redInvm()), s = o.redSqrt();
    if (s.redSqr().redSub(o).cmp(this.zero) !== 0) throw new Error("invalid point");
    var l = s.fromRed().isOdd();
    return (r && !l || !r && l) && (s = s.redNeg()), this.point(e, s)
};
Q0.prototype.pointFromY = function (e, r) {
    e = new dv(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = n.redSub(this.c2), a = n.redMul(this.d).redMul(this.c2).redSub(this.a),
        o = i.redMul(a.redInvm());
    if (o.cmp(this.zero) === 0) {
        if (r) throw new Error("invalid point");
        return this.point(this.zero, e)
    }
    var s = o.redSqrt();
    if (s.redSqr().redSub(o).cmp(this.zero) !== 0) throw new Error("invalid point");
    return s.fromRed().isOdd() !== r && (s = s.redNeg()), this.point(s, e)
};
Q0.prototype.validate = function (e) {
    if (e.isInfinity()) return !0;
    e.normalize();
    var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n),
        a = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
    return i.cmp(a) === 0
};

function Aa(t, e, r, n, i) {
    gN.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new dv(e, 16), this.y = new dv(r, 16), this.z = n ? new dv(n, 16) : this.curve.one, this.t = i && new dv(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
}

Uwe(Aa, gN.BasePoint);
Q0.prototype.pointFromJSON = function (e) {
    return Aa.fromJSON(this, e)
};
Q0.prototype.point = function (e, r, n, i) {
    return new Aa(this, e, r, n, i)
};
Aa.fromJSON = function (e, r) {
    return new Aa(e, r[0], r[1], r[2])
};
Aa.prototype.inspect = function () {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
};
Aa.prototype.isInfinity = function () {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
};
Aa.prototype._extDbl = function () {
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
    n = n.redIAdd(n);
    var i = this.curve._mulA(e), a = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), o = i.redAdd(r),
        s = o.redSub(n), l = i.redSub(r), f = a.redMul(s), d = o.redMul(l), p = a.redMul(l), g = s.redMul(o);
    return this.curve.point(f, d, g, p)
};
Aa.prototype._projDbl = function () {
    var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, a, o, s, l, f;
    if (this.curve.twisted) {
        s = this.curve._mulA(r);
        var d = s.redAdd(n);
        this.zOne ? (i = e.redSub(r).redSub(n).redMul(d.redSub(this.curve.two)), a = d.redMul(s.redSub(n)), o = d.redSqr().redSub(d).redSub(d)) : (l = this.z.redSqr(), f = d.redSub(l).redISub(l), i = e.redSub(r).redISub(n).redMul(f), a = d.redMul(s.redSub(n)), o = d.redMul(f))
    } else s = r.redAdd(n), l = this.curve._mulC(this.z).redSqr(), f = s.redSub(l).redSub(l), i = this.curve._mulC(e.redISub(s)).redMul(f), a = this.curve._mulC(s).redMul(r.redISub(n)), o = s.redMul(f);
    return this.curve.point(i, a, o)
};
Aa.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
};
Aa.prototype._extAdd = function (e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
        i = this.t.redMul(this.curve.dd).redMul(e.t), a = this.z.redMul(e.z.redAdd(e.z)), o = n.redSub(r),
        s = a.redSub(i), l = a.redAdd(i), f = n.redAdd(r), d = o.redMul(s), p = l.redMul(f), g = o.redMul(f),
        b = s.redMul(l);
    return this.curve.point(d, p, b, g)
};
Aa.prototype._projAdd = function (e) {
    var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), a = this.y.redMul(e.y),
        o = this.curve.d.redMul(i).redMul(a), s = n.redSub(o), l = n.redAdd(o),
        f = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(a), d = r.redMul(s).redMul(f), p, g;
    return this.curve.twisted ? (p = r.redMul(l).redMul(a.redSub(this.curve._mulA(i))), g = s.redMul(l)) : (p = r.redMul(l).redMul(a.redSub(i)), g = this.curve._mulC(s).redMul(l)), this.curve.point(d, p, g)
};
Aa.prototype.add = function (e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e)
};
Aa.prototype.mul = function (e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e)
};
Aa.prototype.mulAdd = function (e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !1)
};
Aa.prototype.jmulAdd = function (e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !0)
};
Aa.prototype.normalize = function () {
    if (this.zOne) return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this
};
Aa.prototype.neg = function () {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
};
Aa.prototype.getX = function () {
    return this.normalize(), this.x.fromRed()
};
Aa.prototype.getY = function () {
    return this.normalize(), this.y.fromRed()
};
Aa.prototype.eq = function (e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0
};
Aa.prototype.eqXToP = function (e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0) return !0;
    for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ;) {
        if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
        if (r.redIAdd(i), this.x.cmp(r) === 0) return !0
    }
};
Aa.prototype.toP = Aa.prototype.normalize;
Aa.prototype.mixedAdd = Aa.prototype.add;
(function (t) {
    var e = t;
    e.base = mN, e.short = Ant, e.mont = knt, e.edwards = Mnt
})(wQ);
var yN = {}, L8 = {}, ui = {}, Ont = nh, Pnt = Xn;
ui.inherits = Pnt;

function Nnt(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320
}

function Lnt(t, e) {
    if (Array.isArray(t)) return t.slice();
    if (!t) return [];
    var r = [];
    if (typeof t == "string") if (e) {
        if (e === "hex") for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2) r.push(parseInt(t[i] + t[i + 1], 16))
    } else for (var n = 0, i = 0; i < t.length; i++) {
        var a = t.charCodeAt(i);
        a < 128 ? r[n++] = a : a < 2048 ? (r[n++] = a >> 6 | 192, r[n++] = a & 63 | 128) : Nnt(t, i) ? (a = 65536 + ((a & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = a >> 18 | 240, r[n++] = a >> 12 & 63 | 128, r[n++] = a >> 6 & 63 | 128, r[n++] = a & 63 | 128) : (r[n++] = a >> 12 | 224, r[n++] = a >> 6 & 63 | 128, r[n++] = a & 63 | 128)
    } else for (i = 0; i < t.length; i++) r[i] = t[i] | 0;
    return r
}

ui.toArray = Lnt;

function Bnt(t) {
    for (var e = "", r = 0; r < t.length; r++) e += zwe(t[r].toString(16));
    return e
}

ui.toHex = Bnt;

function jwe(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0
}

ui.htonl = jwe;

function $nt(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
        var i = t[n];
        e === "little" && (i = jwe(i)), r += Vwe(i.toString(16))
    }
    return r
}

ui.toHex32 = $nt;

function zwe(t) {
    return t.length === 1 ? "0" + t : t
}

ui.zero2 = zwe;

function Vwe(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t
}

ui.zero8 = Vwe;

function Fnt(t, e, r, n) {
    var i = r - e;
    Ont(i % 4 === 0);
    for (var a = new Array(i / 4), o = 0, s = e; o < a.length; o++, s += 4) {
        var l;
        n === "big" ? l = t[s] << 24 | t[s + 1] << 16 | t[s + 2] << 8 | t[s + 3] : l = t[s + 3] << 24 | t[s + 2] << 16 | t[s + 1] << 8 | t[s], a[o] = l >>> 0
    }
    return a
}

ui.join32 = Fnt;

function Unt(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
        var a = t[n];
        e === "big" ? (r[i] = a >>> 24, r[i + 1] = a >>> 16 & 255, r[i + 2] = a >>> 8 & 255, r[i + 3] = a & 255) : (r[i + 3] = a >>> 24, r[i + 2] = a >>> 16 & 255, r[i + 1] = a >>> 8 & 255, r[i] = a & 255)
    }
    return r
}

ui.split32 = Unt;

function jnt(t, e) {
    return t >>> e | t << 32 - e
}

ui.rotr32 = jnt;

function znt(t, e) {
    return t << e | t >>> 32 - e
}

ui.rotl32 = znt;

function Vnt(t, e) {
    return t + e >>> 0
}

ui.sum32 = Vnt;

function Hnt(t, e, r) {
    return t + e + r >>> 0
}

ui.sum32_3 = Hnt;

function Wnt(t, e, r, n) {
    return t + e + r + n >>> 0
}

ui.sum32_4 = Wnt;

function qnt(t, e, r, n, i) {
    return t + e + r + n + i >>> 0
}

ui.sum32_5 = qnt;

function Gnt(t, e, r, n) {
    var i = t[e], a = t[e + 1], o = n + a >>> 0, s = (o < n ? 1 : 0) + r + i;
    t[e] = s >>> 0, t[e + 1] = o
}

ui.sum64 = Gnt;

function Knt(t, e, r, n) {
    var i = e + n >>> 0, a = (i < e ? 1 : 0) + t + r;
    return a >>> 0
}

ui.sum64_hi = Knt;

function Ynt(t, e, r, n) {
    var i = e + n;
    return i >>> 0
}

ui.sum64_lo = Ynt;

function Xnt(t, e, r, n, i, a, o, s) {
    var l = 0, f = e;
    f = f + n >>> 0, l += f < e ? 1 : 0, f = f + a >>> 0, l += f < a ? 1 : 0, f = f + s >>> 0, l += f < s ? 1 : 0;
    var d = t + r + i + o + l;
    return d >>> 0
}

ui.sum64_4_hi = Xnt;

function Qnt(t, e, r, n, i, a, o, s) {
    var l = e + n + a + s;
    return l >>> 0
}

ui.sum64_4_lo = Qnt;

function Znt(t, e, r, n, i, a, o, s, l, f) {
    var d = 0, p = e;
    p = p + n >>> 0, d += p < e ? 1 : 0, p = p + a >>> 0, d += p < a ? 1 : 0, p = p + s >>> 0, d += p < s ? 1 : 0, p = p + f >>> 0, d += p < f ? 1 : 0;
    var g = t + r + i + o + l + d;
    return g >>> 0
}

ui.sum64_5_hi = Znt;

function Jnt(t, e, r, n, i, a, o, s, l, f) {
    var d = e + n + a + s + f;
    return d >>> 0
}

ui.sum64_5_lo = Jnt;

function eit(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0
}

ui.rotr64_hi = eit;

function tit(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}

ui.rotr64_lo = tit;

function rit(t, e, r) {
    return t >>> r
}

ui.shr64_hi = rit;

function nit(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}

ui.shr64_lo = nit;
var HE = {}, Zce = ui, iit = nh;

function bN() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
}

HE.BlockHash = bN;
bN.prototype.update = function (e, r) {
    if (e = Zce.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var n = e.length % this._delta8;
        this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Zce.join32(e, 0, e.length - n, this.endian);
        for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
    }
    return this
};
bN.prototype.digest = function (e) {
    return this.update(this._pad()), iit(this.pending === null), this._digest(e)
};
bN.prototype._pad = function () {
    var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
    i[0] = 128;
    for (var a = 1; a < n; a++) i[a] = 0;
    if (e <<= 3, this.endian === "big") {
        for (var o = 8; o < this.padLength; o++) i[a++] = 0;
        i[a++] = 0, i[a++] = 0, i[a++] = 0, i[a++] = 0, i[a++] = e >>> 24 & 255, i[a++] = e >>> 16 & 255, i[a++] = e >>> 8 & 255, i[a++] = e & 255
    } else for (i[a++] = e & 255, i[a++] = e >>> 8 & 255, i[a++] = e >>> 16 & 255, i[a++] = e >>> 24 & 255, i[a++] = 0, i[a++] = 0, i[a++] = 0, i[a++] = 0, o = 8; o < this.padLength; o++) i[a++] = 0;
    return i
};
var WE = {}, Z0 = {}, ait = ui, R0 = ait.rotr32;

function oit(t, e, r, n) {
    if (t === 0) return Hwe(e, r, n);
    if (t === 1 || t === 3) return qwe(e, r, n);
    if (t === 2) return Wwe(e, r, n)
}

Z0.ft_1 = oit;

function Hwe(t, e, r) {
    return t & e ^ ~t & r
}

Z0.ch32 = Hwe;

function Wwe(t, e, r) {
    return t & e ^ t & r ^ e & r
}

Z0.maj32 = Wwe;

function qwe(t, e, r) {
    return t ^ e ^ r
}

Z0.p32 = qwe;

function sit(t) {
    return R0(t, 2) ^ R0(t, 13) ^ R0(t, 22)
}

Z0.s0_256 = sit;

function cit(t) {
    return R0(t, 6) ^ R0(t, 11) ^ R0(t, 25)
}

Z0.s1_256 = cit;

function lit(t) {
    return R0(t, 7) ^ R0(t, 18) ^ t >>> 3
}

Z0.g0_256 = lit;

function uit(t) {
    return R0(t, 17) ^ R0(t, 19) ^ t >>> 10
}

Z0.g1_256 = uit;
var L4 = ui, fit = HE, dit = Z0, yz = L4.rotl32, K5 = L4.sum32, hit = L4.sum32_5, pit = dit.ft_1, Gwe = fit.BlockHash,
    mit = [1518500249, 1859775393, 2400959708, 3395469782];

function V0() {
    if (!(this instanceof V0)) return new V0;
    Gwe.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
}

L4.inherits(V0, Gwe);
var vit = V0;
V0.blockSize = 512;
V0.outSize = 160;
V0.hmacStrength = 80;
V0.padLength = 64;
V0.prototype._update = function (e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = yz(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var a = this.h[0], o = this.h[1], s = this.h[2], l = this.h[3], f = this.h[4];
    for (i = 0; i < n.length; i++) {
        var d = ~~(i / 20), p = hit(yz(a, 5), pit(d, o, s, l), f, n[i], mit[d]);
        f = l, l = s, s = yz(o, 30), o = a, a = p
    }
    this.h[0] = K5(this.h[0], a), this.h[1] = K5(this.h[1], o), this.h[2] = K5(this.h[2], s), this.h[3] = K5(this.h[3], l), this.h[4] = K5(this.h[4], f)
};
V0.prototype._digest = function (e) {
    return e === "hex" ? L4.toHex32(this.h, "big") : L4.split32(this.h, "big")
};
var B4 = ui, git = HE, qE = Z0, yit = nh, Fh = B4.sum32, bit = B4.sum32_4, wit = B4.sum32_5, Sit = qE.ch32,
    _it = qE.maj32, xit = qE.s0_256, Eit = qE.s1_256, Tit = qE.g0_256, Cit = qE.g1_256, Kwe = git.BlockHash,
    Ait = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

function H0() {
    if (!(this instanceof H0)) return new H0;
    Kwe.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = Ait, this.W = new Array(64)
}

B4.inherits(H0, Kwe);
var Ywe = H0;
H0.blockSize = 512;
H0.outSize = 256;
H0.hmacStrength = 192;
H0.padLength = 64;
H0.prototype._update = function (e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = bit(Cit(n[i - 2]), n[i - 7], Tit(n[i - 15]), n[i - 16]);
    var a = this.h[0], o = this.h[1], s = this.h[2], l = this.h[3], f = this.h[4], d = this.h[5], p = this.h[6],
        g = this.h[7];
    for (yit(this.k.length === n.length), i = 0; i < n.length; i++) {
        var b = wit(g, Eit(f), Sit(f, d, p), this.k[i], n[i]), S = Fh(xit(a), _it(a, o, s));
        g = p, p = d, d = f, f = Fh(l, b), l = s, s = o, o = a, a = Fh(b, S)
    }
    this.h[0] = Fh(this.h[0], a), this.h[1] = Fh(this.h[1], o), this.h[2] = Fh(this.h[2], s), this.h[3] = Fh(this.h[3], l), this.h[4] = Fh(this.h[4], f), this.h[5] = Fh(this.h[5], d), this.h[6] = Fh(this.h[6], p), this.h[7] = Fh(this.h[7], g)
};
H0.prototype._digest = function (e) {
    return e === "hex" ? B4.toHex32(this.h, "big") : B4.split32(this.h, "big")
};
var Mq = ui, Xwe = Ywe;

function Nv() {
    if (!(this instanceof Nv)) return new Nv;
    Xwe.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
}

Mq.inherits(Nv, Xwe);
var Iit = Nv;
Nv.blockSize = 512;
Nv.outSize = 224;
Nv.hmacStrength = 192;
Nv.padLength = 64;
Nv.prototype._digest = function (e) {
    return e === "hex" ? Mq.toHex32(this.h.slice(0, 7), "big") : Mq.split32(this.h.slice(0, 7), "big")
};
var of = ui, kit = HE, Rit = nh, D0 = of.rotr64_hi, M0 = of.rotr64_lo, Qwe = of.shr64_hi, Zwe = of.shr64_lo,
    ty = of.sum64, bz = of.sum64_hi, wz = of.sum64_lo, Dit = of.sum64_4_hi, Mit = of.sum64_4_lo, Oit = of.sum64_5_hi,
    Pit = of.sum64_5_lo, Jwe = kit.BlockHash,
    Nit = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

function pp() {
    if (!(this instanceof pp)) return new pp;
    Jwe.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = Nit, this.W = new Array(160)
}

of.inherits(pp, Jwe);
var eSe = pp;
pp.blockSize = 1024;
pp.outSize = 512;
pp.hmacStrength = 192;
pp.padLength = 128;
pp.prototype._prepareBlock = function (e, r) {
    for (var n = this.W, i = 0; i < 32; i++) n[i] = e[r + i];
    for (; i < n.length; i += 2) {
        var a = qit(n[i - 4], n[i - 3]), o = Git(n[i - 4], n[i - 3]), s = n[i - 14], l = n[i - 13],
            f = Hit(n[i - 30], n[i - 29]), d = Wit(n[i - 30], n[i - 29]), p = n[i - 32], g = n[i - 31];
        n[i] = Dit(a, o, s, l, f, d, p, g), n[i + 1] = Mit(a, o, s, l, f, d, p, g)
    }
};
pp.prototype._update = function (e, r) {
    this._prepareBlock(e, r);
    var n = this.W, i = this.h[0], a = this.h[1], o = this.h[2], s = this.h[3], l = this.h[4], f = this.h[5],
        d = this.h[6], p = this.h[7], g = this.h[8], b = this.h[9], S = this.h[10], T = this.h[11], I = this.h[12],
        N = this.h[13], P = this.h[14], F = this.h[15];
    Rit(this.k.length === n.length);
    for (var V = 0; V < n.length; V += 2) {
        var Y = P, ee = F, oe = zit(g, b), G = Vit(g, b), J = Lit(g, b, S, T, I), ce = Bit(g, b, S, T, I, N),
            re = this.k[V], M = this.k[V + 1], D = n[V], x = n[V + 1], A = Oit(Y, ee, oe, G, J, ce, re, M, D, x),
            B = Pit(Y, ee, oe, G, J, ce, re, M, D, x);
        Y = Uit(i, a), ee = jit(i, a), oe = $it(i, a, o, s, l), G = Fit(i, a, o, s, l, f);
        var z = bz(Y, ee, oe, G), j = wz(Y, ee, oe, G);
        P = I, F = N, I = S, N = T, S = g, T = b, g = bz(d, p, A, B), b = wz(p, p, A, B), d = l, p = f, l = o, f = s, o = i, s = a, i = bz(A, B, z, j), a = wz(A, B, z, j)
    }
    ty(this.h, 0, i, a), ty(this.h, 2, o, s), ty(this.h, 4, l, f), ty(this.h, 6, d, p), ty(this.h, 8, g, b), ty(this.h, 10, S, T), ty(this.h, 12, I, N), ty(this.h, 14, P, F)
};
pp.prototype._digest = function (e) {
    return e === "hex" ? of.toHex32(this.h, "big") : of.split32(this.h, "big")
};

function Lit(t, e, r, n, i) {
    var a = t & r ^ ~t & i;
    return a < 0 && (a += 4294967296), a
}

function Bit(t, e, r, n, i, a) {
    var o = e & n ^ ~e & a;
    return o < 0 && (o += 4294967296), o
}

function $it(t, e, r, n, i) {
    var a = t & r ^ t & i ^ r & i;
    return a < 0 && (a += 4294967296), a
}

function Fit(t, e, r, n, i, a) {
    var o = e & n ^ e & a ^ n & a;
    return o < 0 && (o += 4294967296), o
}

function Uit(t, e) {
    var r = D0(t, e, 28), n = D0(e, t, 2), i = D0(e, t, 7), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function jit(t, e) {
    var r = M0(t, e, 28), n = M0(e, t, 2), i = M0(e, t, 7), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function zit(t, e) {
    var r = D0(t, e, 14), n = D0(t, e, 18), i = D0(e, t, 9), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function Vit(t, e) {
    var r = M0(t, e, 14), n = M0(t, e, 18), i = M0(e, t, 9), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function Hit(t, e) {
    var r = D0(t, e, 1), n = D0(t, e, 8), i = Qwe(t, e, 7), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function Wit(t, e) {
    var r = M0(t, e, 1), n = M0(t, e, 8), i = Zwe(t, e, 7), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function qit(t, e) {
    var r = D0(t, e, 19), n = D0(e, t, 29), i = Qwe(t, e, 6), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

function Git(t, e) {
    var r = M0(t, e, 19), n = M0(e, t, 29), i = Zwe(t, e, 6), a = r ^ n ^ i;
    return a < 0 && (a += 4294967296), a
}

var Oq = ui, tSe = eSe;

function Lv() {
    if (!(this instanceof Lv)) return new Lv;
    tSe.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
}

Oq.inherits(Lv, tSe);
var Kit = Lv;
Lv.blockSize = 1024;
Lv.outSize = 384;
Lv.hmacStrength = 192;
Lv.padLength = 128;
Lv.prototype._digest = function (e) {
    return e === "hex" ? Oq.toHex32(this.h.slice(0, 12), "big") : Oq.split32(this.h.slice(0, 12), "big")
};
WE.sha1 = vit;
WE.sha224 = Iit;
WE.sha256 = Ywe;
WE.sha384 = Kit;
WE.sha512 = eSe;
var rSe = {}, uS = ui, Yit = HE, n7 = uS.rotl32, Jce = uS.sum32, Y5 = uS.sum32_3, ele = uS.sum32_4, nSe = Yit.BlockHash;

function W0() {
    if (!(this instanceof W0)) return new W0;
    nSe.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
}

uS.inherits(W0, nSe);
rSe.ripemd160 = W0;
W0.blockSize = 512;
W0.outSize = 160;
W0.hmacStrength = 192;
W0.padLength = 64;
W0.prototype._update = function (e, r) {
    for (var n = this.h[0], i = this.h[1], a = this.h[2], o = this.h[3], s = this.h[4], l = n, f = i, d = a, p = o, g = s, b = 0; b < 80; b++) {
        var S = Jce(n7(ele(n, tle(b, i, a, o), e[Zit[b] + r], Xit(b)), eat[b]), s);
        n = s, s = o, o = n7(a, 10), a = i, i = S, S = Jce(n7(ele(l, tle(79 - b, f, d, p), e[Jit[b] + r], Qit(b)), tat[b]), g), l = g, g = p, p = n7(d, 10), d = f, f = S
    }
    S = Y5(this.h[1], a, p), this.h[1] = Y5(this.h[2], o, g), this.h[2] = Y5(this.h[3], s, l), this.h[3] = Y5(this.h[4], n, f), this.h[4] = Y5(this.h[0], i, d), this.h[0] = S
};
W0.prototype._digest = function (e) {
    return e === "hex" ? uS.toHex32(this.h, "little") : uS.split32(this.h, "little")
};

function tle(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n)
}

function Xit(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
}

function Qit(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
}

var Zit = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    Jit = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
    eat = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
    tat = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
    rat = ui, nat = nh;

function $4(t, e, r) {
    if (!(this instanceof $4)) return new $4(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(rat.toArray(e, r))
}

var iat = $4;
$4.prototype._init = function (e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), nat(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++) e.push(0);
    for (r = 0; r < e.length; r++) e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++) e[r] ^= 106;
    this.outer = new this.Hash().update(e)
};
$4.prototype.update = function (e, r) {
    return this.inner.update(e, r), this
};
$4.prototype.digest = function (e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
};
(function (t) {
    var e = t;
    e.utils = ui, e.common = HE, e.sha = WE, e.ripemd = rSe, e.hmac = iat, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160
})(L8);
const uJt = za(L8);
var Sz, rle;

function aat() {
    return rle || (rle = 1, Sz = {
        doubles: {
            step: 4,
            points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
        }, naf: {
            wnd: 7,
            points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
        }
    }), Sz
}

(function (t) {
    var e = t, r = L8, n = wQ, i = Jf, a = i.assert;

    function o(f) {
        f.type === "short" ? this.curve = new n.short(f) : f.type === "edwards" ? this.curve = new n.edwards(f) : this.curve = new n.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, a(this.g.validate(), "Invalid curve"), a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
    }

    e.PresetCurve = o;

    function s(f, d) {
        Object.defineProperty(e, f, {
            configurable: !0, enumerable: !0, get: function () {
                var p = new o(d);
                return Object.defineProperty(e, f, {configurable: !0, enumerable: !0, value: p}), p
            }
        })
    }

    s("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: r.sha256,
        gRed: !1,
        g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
    }), s("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: r.sha256,
        gRed: !1,
        g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
    }), s("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: r.sha256,
        gRed: !1,
        g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
    }), s("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: r.sha384,
        gRed: !1,
        g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
    }), s("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: r.sha512,
        gRed: !1,
        g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
    }), s("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: r.sha256,
        gRed: !1,
        g: ["9"]
    }), s("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: r.sha256,
        gRed: !1,
        g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
    });
    var l;
    try {
        l = aat()
    } catch {
        l = void 0
    }
    s("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: r.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15"}],
        gRed: !1,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", l]
    })
})(yN);
var oat = L8, Uw = bQ, iSe = nh;

function e1(t) {
    if (!(this instanceof e1)) return new e1(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Uw.toArray(t.entropy, t.entropyEnc || "hex"), r = Uw.toArray(t.nonce, t.nonceEnc || "hex"),
        n = Uw.toArray(t.pers, t.persEnc || "hex");
    iSe(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
}

var sat = e1;
e1.prototype._init = function (e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var a = 0; a < this.V.length; a++) this.K[a] = 0, this.V[a] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
};
e1.prototype._hmac = function () {
    return new oat.hmac(this.hash, this.K)
};
e1.prototype._update = function (e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
};
e1.prototype.reseed = function (e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = Uw.toArray(e, r), n = Uw.toArray(n, i), iSe(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
};
e1.prototype.generate = function (e, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = Uw.toArray(n, i || "hex"), this._update(n));
    for (var a = []; a.length < e;) this.V = this._hmac().update(this.V).digest(), a = a.concat(this.V);
    var o = a.slice(0, e);
    return this._update(n), this._reseed++, Uw.encode(o, r)
};
var cat = sc, lat = Jf, Pq = lat.assert;

function Tl(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
}

var uat = Tl;
Tl.fromPublic = function (e, r, n) {
    return r instanceof Tl ? r : new Tl(e, {pub: r, pubEnc: n})
};
Tl.fromPrivate = function (e, r, n) {
    return r instanceof Tl ? r : new Tl(e, {priv: r, privEnc: n})
};
Tl.prototype.validate = function () {
    var e = this.getPublic();
    return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {result: !0, reason: null} : {
        result: !1,
        reason: "Public key * N != O"
    } : {result: !1, reason: "Public key is not a point"}
};
Tl.prototype.getPublic = function (e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub
};
Tl.prototype.getPrivate = function (e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
};
Tl.prototype._importPrivate = function (e, r) {
    this.priv = new cat(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n)
};
Tl.prototype._importPublic = function (e, r) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont" ? Pq(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Pq(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return
    }
    this.pub = this.ec.curve.decodePoint(e, r)
};
Tl.prototype.derive = function (e) {
    return e.validate() || Pq(e.validate(), "public point not validated"), e.mul(this.priv).getX()
};
Tl.prototype.sign = function (e, r, n) {
    return this.ec.sign(e, this, r, n)
};
Tl.prototype.verify = function (e, r) {
    return this.ec.verify(e, r, this)
};
Tl.prototype.inspect = function () {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
};
var oO = sc, _Q = Jf, fat = _Q.assert;

function wN(t, e) {
    if (t instanceof wN) return t;
    this._importDER(t, e) || (fat(t.r && t.s, "Signature without r or s"), this.r = new oO(t.r, 16), this.s = new oO(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
}

var dat = wN;

function hat() {
    this.place = 0
}

function _z(t, e) {
    var r = t[e.place++];
    if (!(r & 128)) return r;
    var n = r & 15;
    if (n === 0 || n > 4) return !1;
    for (var i = 0, a = 0, o = e.place; a < n; a++, o++) i <<= 8, i |= t[o], i >>>= 0;
    return i <= 127 ? !1 : (e.place = o, i)
}

function nle(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r;) e++;
    return e === 0 ? t : t.slice(e)
}

wN.prototype._importDER = function (e, r) {
    e = _Q.toArray(e, r);
    var n = new hat;
    if (e[n.place++] !== 48) return !1;
    var i = _z(e, n);
    if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
    var a = _z(e, n);
    if (a === !1) return !1;
    var o = e.slice(n.place, a + n.place);
    if (n.place += a, e[n.place++] !== 2) return !1;
    var s = _z(e, n);
    if (s === !1 || e.length !== s + n.place) return !1;
    var l = e.slice(n.place, s + n.place);
    if (o[0] === 0) if (o[1] & 128) o = o.slice(1); else return !1;
    if (l[0] === 0) if (l[1] & 128) l = l.slice(1); else return !1;
    return this.r = new oO(o), this.s = new oO(l), this.recoveryParam = null, !0
};

function xz(t, e) {
    if (e < 128) {
        t.push(e);
        return
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r;) t.push(e >>> (r << 3) & 255);
    t.push(e)
}

wN.prototype.toDER = function (e) {
    var r = this.r.toArray(), n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = nle(r), n = nle(n); !n[0] && !(n[1] & 128);) n = n.slice(1);
    var i = [2];
    xz(i, r.length), i = i.concat(r), i.push(2), xz(i, n.length);
    var a = i.concat(n), o = [48];
    return xz(o, a.length), o = o.concat(a), _Q.encode(o, e)
};
var Ez, ile;

function pat() {
    if (ile) return Ez;
    ile = 1;
    var t = sc, e = sat, r = Jf, n = yN, i = gQ(), a = r.assert, o = uat, s = dat;

    function l(f) {
        if (!(this instanceof l)) return new l(f);
        typeof f == "string" && (a(Object.prototype.hasOwnProperty.call(n, f), "Unknown curve " + f), f = n[f]), f instanceof n.PresetCurve && (f = {curve: f}), this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash
    }

    return Ez = l, l.prototype.keyPair = function (d) {
        return new o(this, d)
    }, l.prototype.keyFromPrivate = function (d, p) {
        return o.fromPrivate(this, d, p)
    }, l.prototype.keyFromPublic = function (d, p) {
        return o.fromPublic(this, d, p)
    }, l.prototype.genKeyPair = function (d) {
        d || (d = {});
        for (var p = new e({
            hash: this.hash,
            pers: d.pers,
            persEnc: d.persEnc || "utf8",
            entropy: d.entropy || i(this.hash.hmacStrength),
            entropyEnc: d.entropy && d.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), g = this.n.byteLength(), b = this.n.sub(new t(2)); ;) {
            var S = new t(p.generate(g));
            if (!(S.cmp(b) > 0)) return S.iaddn(1), this.keyFromPrivate(S)
        }
    }, l.prototype._truncateToN = function (d, p) {
        var g = d.byteLength() * 8 - this.n.bitLength();
        return g > 0 && (d = d.ushrn(g)), !p && d.cmp(this.n) >= 0 ? d.sub(this.n) : d
    }, l.prototype.sign = function (d, p, g, b) {
        typeof g == "object" && (b = g, g = null), b || (b = {}), p = this.keyFromPrivate(p, g), d = this._truncateToN(new t(d, 16));
        for (var S = this.n.byteLength(), T = p.getPrivate().toArray("be", S), I = d.toArray("be", S), N = new e({
            hash: this.hash,
            entropy: T,
            nonce: I,
            pers: b.pers,
            persEnc: b.persEnc || "utf8"
        }), P = this.n.sub(new t(1)), F = 0; ; F++) {
            var V = b.k ? b.k(F) : new t(N.generate(this.n.byteLength()));
            if (V = this._truncateToN(V, !0), !(V.cmpn(1) <= 0 || V.cmp(P) >= 0)) {
                var Y = this.g.mul(V);
                if (!Y.isInfinity()) {
                    var ee = Y.getX(), oe = ee.umod(this.n);
                    if (oe.cmpn(0) !== 0) {
                        var G = V.invm(this.n).mul(oe.mul(p.getPrivate()).iadd(d));
                        if (G = G.umod(this.n), G.cmpn(0) !== 0) {
                            var J = (Y.getY().isOdd() ? 1 : 0) | (ee.cmp(oe) !== 0 ? 2 : 0);
                            return b.canonical && G.cmp(this.nh) > 0 && (G = this.n.sub(G), J ^= 1), new s({
                                r: oe,
                                s: G,
                                recoveryParam: J
                            })
                        }
                    }
                }
            }
        }
    }, l.prototype.verify = function (d, p, g, b) {
        d = this._truncateToN(new t(d, 16)), g = this.keyFromPublic(g, b), p = new s(p, "hex");
        var S = p.r, T = p.s;
        if (S.cmpn(1) < 0 || S.cmp(this.n) >= 0 || T.cmpn(1) < 0 || T.cmp(this.n) >= 0) return !1;
        var I = T.invm(this.n), N = I.mul(d).umod(this.n), P = I.mul(S).umod(this.n), F;
        return this.curve._maxwellTrick ? (F = this.g.jmulAdd(N, g.getPublic(), P), F.isInfinity() ? !1 : F.eqXToP(S)) : (F = this.g.mulAdd(N, g.getPublic(), P), F.isInfinity() ? !1 : F.getX().umod(this.n).cmp(S) === 0)
    }, l.prototype.recoverPubKey = function (f, d, p, g) {
        a((3 & p) === p, "The recovery param is more than two bits"), d = new s(d, g);
        var b = this.n, S = new t(f), T = d.r, I = d.s, N = p & 1, P = p >> 1;
        if (T.cmp(this.curve.p.umod(this.curve.n)) >= 0 && P) throw new Error("Unable to find sencond key candinate");
        P ? T = this.curve.pointFromX(T.add(this.curve.n), N) : T = this.curve.pointFromX(T, N);
        var F = d.r.invm(b), V = b.sub(S).mul(F).umod(b), Y = I.mul(F).umod(b);
        return this.g.mulAdd(V, T, Y)
    }, l.prototype.getKeyRecoveryParam = function (f, d, p, g) {
        if (d = new s(d, g), d.recoveryParam !== null) return d.recoveryParam;
        for (var b = 0; b < 4; b++) {
            var S;
            try {
                S = this.recoverPubKey(f, d, b)
            } catch {
                continue
            }
            if (S.eq(p)) return b
        }
        throw new Error("Unable to find valid recovery factor")
    }, Ez
}

var B8 = Jf, aSe = B8.assert, ale = B8.parseBytes, GE = B8.cachedProperty;

function ec(t, e) {
    this.eddsa = t, this._secret = ale(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = ale(e.pub)
}

ec.fromPublic = function (e, r) {
    return r instanceof ec ? r : new ec(e, {pub: r})
};
ec.fromSecret = function (e, r) {
    return r instanceof ec ? r : new ec(e, {secret: r})
};
ec.prototype.secret = function () {
    return this._secret
};
GE(ec, "pubBytes", function () {
    return this.eddsa.encodePoint(this.pub())
});
GE(ec, "pub", function () {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
});
GE(ec, "privBytes", function () {
    var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
    return i[0] &= 248, i[n] &= 127, i[n] |= 64, i
});
GE(ec, "priv", function () {
    return this.eddsa.decodeInt(this.privBytes())
});
GE(ec, "hash", function () {
    return this.eddsa.hash().update(this.secret()).digest()
});
GE(ec, "messagePrefix", function () {
    return this.hash().slice(this.eddsa.encodingLength)
});
ec.prototype.sign = function (e) {
    return aSe(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this)
};
ec.prototype.verify = function (e, r) {
    return this.eddsa.verify(e, r, this)
};
ec.prototype.getSecret = function (e) {
    return aSe(this._secret, "KeyPair is public only"), B8.encode(this.secret(), e)
};
ec.prototype.getPublic = function (e) {
    return B8.encode(this.pubBytes(), e)
};
var mat = ec, vat = sc, SN = Jf, gat = SN.assert, _N = SN.cachedProperty, yat = SN.parseBytes;

function $S(t, e) {
    this.eddsa = t, typeof e != "object" && (e = yat(e)), Array.isArray(e) && (e = {
        R: e.slice(0, t.encodingLength),
        S: e.slice(t.encodingLength)
    }), gat(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof vat && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded
}

_N($S, "S", function () {
    return this.eddsa.decodeInt(this.Sencoded())
});
_N($S, "R", function () {
    return this.eddsa.decodePoint(this.Rencoded())
});
_N($S, "Rencoded", function () {
    return this.eddsa.encodePoint(this.R())
});
_N($S, "Sencoded", function () {
    return this.eddsa.encodeInt(this.S())
});
$S.prototype.toBytes = function () {
    return this.Rencoded().concat(this.Sencoded())
};
$S.prototype.toHex = function () {
    return SN.encode(this.toBytes(), "hex").toUpperCase()
};
var bat = $S, wat = L8, Sat = yN, F4 = Jf, _at = F4.assert, oSe = F4.parseBytes, sSe = mat, ole = bat;

function sf(t) {
    if (_at(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof sf)) return new sf(t);
    t = Sat[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = wat.sha512
}

var xat = sf;
sf.prototype.sign = function (e, r) {
    e = oSe(e);
    var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), a = this.g.mul(i), o = this.encodePoint(a),
        s = this.hashInt(o, n.pubBytes(), e).mul(n.priv()), l = i.add(s).umod(this.curve.n);
    return this.makeSignature({R: a, S: l, Rencoded: o})
};
sf.prototype.verify = function (e, r, n) {
    e = oSe(e), r = this.makeSignature(r);
    var i = this.keyFromPublic(n), a = this.hashInt(r.Rencoded(), i.pubBytes(), e), o = this.g.mul(r.S()),
        s = r.R().add(i.pub().mul(a));
    return s.eq(o)
};
sf.prototype.hashInt = function () {
    for (var e = this.hash(), r = 0; r < arguments.length; r++) e.update(arguments[r]);
    return F4.intFromLE(e.digest()).umod(this.curve.n)
};
sf.prototype.keyFromPublic = function (e) {
    return sSe.fromPublic(this, e)
};
sf.prototype.keyFromSecret = function (e) {
    return sSe.fromSecret(this, e)
};
sf.prototype.makeSignature = function (e) {
    return e instanceof ole ? e : new ole(this, e)
};
sf.prototype.encodePoint = function (e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r
};
sf.prototype.decodePoint = function (e) {
    e = F4.parseBytes(e);
    var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, a = F4.intFromLE(n);
    return this.curve.pointFromY(a, i)
};
sf.prototype.encodeInt = function (e) {
    return e.toArray("le", this.encodingLength)
};
sf.prototype.decodeInt = function (e) {
    return F4.intFromLE(e)
};
sf.prototype.isPoint = function (e) {
    return e instanceof this.pointClass
};
var sle;

function xQ() {
    return sle || (sle = 1, function (t) {
        var e = t;
        e.version = xnt.version, e.utils = Jf, e.rand = gQ(), e.curve = wQ, e.curves = yN, e.ec = pat(), e.eddsa = xat
    }(gz)), gz
}

var Sp = {}, EQ = {}, cSe = {}, TQ = {}, CD = qr, Jx = CD.Buffer, zd = {}, Vd;
for (Vd in CD) CD.hasOwnProperty(Vd) && (Vd === "SlowBuffer" || Vd === "Buffer" || (zd[Vd] = CD[Vd]));
var e4 = zd.Buffer = {};
for (Vd in Jx) Jx.hasOwnProperty(Vd) && (Vd === "allocUnsafe" || Vd === "allocUnsafeSlow" || (e4[Vd] = Jx[Vd]));
zd.Buffer.prototype = Jx.prototype;
(!e4.from || e4.from === Uint8Array.from) && (e4.from = function (t, e, r) {
    if (typeof t == "number") throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length > "u") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return Jx(t, e, r)
});
e4.alloc || (e4.alloc = function (t, e, r) {
    if (typeof t != "number") throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30)) throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var n = Jx(t);
    return !e || e.length === 0 ? n.fill(0) : typeof r == "string" ? n.fill(e, r) : n.fill(e), n
});
if (!zd.kStringMaxLength) try {
    zd.kStringMaxLength = Ve.binding("buffer").kStringMaxLength
} catch {
}
zd.constants || (zd.constants = {MAX_LENGTH: zd.kMaxLength}, zd.kStringMaxLength && (zd.constants.MAX_STRING_LENGTH = zd.kStringMaxLength));
var CQ = zd, xN = {};
const Eat = Xn;

function sh(t) {
    this._reporterState = {obj: null, path: [], options: t || {}, errors: []}
}

xN.Reporter = sh;
sh.prototype.isError = function (e) {
    return e instanceof U4
};
sh.prototype.save = function () {
    const e = this._reporterState;
    return {obj: e.obj, pathLen: e.path.length}
};
sh.prototype.restore = function (e) {
    const r = this._reporterState;
    r.obj = e.obj, r.path = r.path.slice(0, e.pathLen)
};
sh.prototype.enterKey = function (e) {
    return this._reporterState.path.push(e)
};
sh.prototype.exitKey = function (e) {
    const r = this._reporterState;
    r.path = r.path.slice(0, e - 1)
};
sh.prototype.leaveKey = function (e, r, n) {
    const i = this._reporterState;
    this.exitKey(e), i.obj !== null && (i.obj[r] = n)
};
sh.prototype.path = function () {
    return this._reporterState.path.join("/")
};
sh.prototype.enterObject = function () {
    const e = this._reporterState, r = e.obj;
    return e.obj = {}, r
};
sh.prototype.leaveObject = function (e) {
    const r = this._reporterState, n = r.obj;
    return r.obj = e, n
};
sh.prototype.error = function (e) {
    let r;
    const n = this._reporterState, i = e instanceof U4;
    if (i ? r = e : r = new U4(n.path.map(function (a) {
        return "[" + JSON.stringify(a) + "]"
    }).join(""), e.message || e), !n.options.partial) throw r;
    return i || n.errors.push(r), r
};
sh.prototype.wrapResult = function (e) {
    const r = this._reporterState;
    return r.options.partial ? {result: this.isError(e) ? null : e, errors: r.errors} : e
};

function U4(t, e) {
    this.path = t, this.rethrow(e)
}

Eat(U4, Error);
U4.prototype.rethrow = function (e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, U4), !this.stack) try {
        throw new Error(this.message)
    } catch (r) {
        this.stack = r.stack
    }
    return this
};
var fS = {};
const Tat = Xn, EN = xN.Reporter, j4 = CQ.Buffer;

function Qd(t, e) {
    if (EN.call(this, e), !j4.isBuffer(t)) {
        this.error("Input not Buffer");
        return
    }
    this.base = t, this.offset = 0, this.length = t.length
}

Tat(Qd, EN);
fS.DecoderBuffer = Qd;
Qd.isDecoderBuffer = function (e) {
    return e instanceof Qd ? !0 : typeof e == "object" && j4.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function"
};
Qd.prototype.save = function () {
    return {offset: this.offset, reporter: EN.prototype.save.call(this)}
};
Qd.prototype.restore = function (e) {
    const r = new Qd(this.base);
    return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, EN.prototype.restore.call(this, e.reporter), r
};
Qd.prototype.isEmpty = function () {
    return this.offset === this.length
};
Qd.prototype.readUInt8 = function (e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun")
};
Qd.prototype.skip = function (e, r) {
    if (!(this.offset + e <= this.length)) return this.error(r || "DecoderBuffer overrun");
    const n = new Qd(this.base);
    return n._reporterState = this._reporterState, n.offset = this.offset, n.length = this.offset + e, this.offset += e, n
};
Qd.prototype.raw = function (e) {
    return this.base.slice(e ? e.offset : this.offset, this.length)
};

function z4(t, e) {
    if (Array.isArray(t)) this.length = 0, this.value = t.map(function (r) {
        return z4.isEncoderBuffer(r) || (r = new z4(r, e)), this.length += r.length, r
    }, this); else if (typeof t == "number") {
        if (!(0 <= t && t <= 255)) return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1
    } else if (typeof t == "string") this.value = t, this.length = j4.byteLength(t); else if (j4.isBuffer(t)) this.value = t, this.length = t.length; else return e.error("Unsupported type: " + typeof t)
}

fS.EncoderBuffer = z4;
z4.isEncoderBuffer = function (e) {
    return e instanceof z4 ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function"
};
z4.prototype.join = function (e, r) {
    return e || (e = j4.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function (n) {
        n.join(e, r), r += n.length
    }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : j4.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e
};
const Cat = xN.Reporter, Aat = fS.EncoderBuffer, Iat = fS.DecoderBuffer, mu = nh,
    lSe = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"],
    kat = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(lSe),
    Rat = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];

function ha(t, e, r) {
    const n = {};
    this._baseState = n, n.name = r, n.enc = t, n.parent = e || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = !1, n.any = !1, n.obj = !1, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap())
}

var AQ = ha;
const Dat = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
ha.prototype.clone = function () {
    const e = this._baseState, r = {};
    Dat.forEach(function (i) {
        r[i] = e[i]
    });
    const n = new this.constructor(r.parent);
    return n._baseState = r, n
};
ha.prototype._wrap = function () {
    const e = this._baseState;
    kat.forEach(function (r) {
        this[r] = function () {
            const i = new this.constructor(this);
            return e.children.push(i), i[r].apply(i, arguments)
        }
    }, this)
};
ha.prototype._init = function (e) {
    const r = this._baseState;
    mu(r.parent === null), e.call(this), r.children = r.children.filter(function (n) {
        return n._baseState.parent === this
    }, this), mu.equal(r.children.length, 1, "Root node can have only one child")
};
ha.prototype._useArgs = function (e) {
    const r = this._baseState, n = e.filter(function (i) {
        return i instanceof this.constructor
    }, this);
    e = e.filter(function (i) {
        return !(i instanceof this.constructor)
    }, this), n.length !== 0 && (mu(r.children === null), r.children = n, n.forEach(function (i) {
        i._baseState.parent = this
    }, this)), e.length !== 0 && (mu(r.args === null), r.args = e, r.reverseArgs = e.map(function (i) {
        if (typeof i != "object" || i.constructor !== Object) return i;
        const a = {};
        return Object.keys(i).forEach(function (o) {
            o == (o | 0) && (o |= 0);
            const s = i[o];
            a[s] = o
        }), a
    }))
};
Rat.forEach(function (t) {
    ha.prototype[t] = function () {
        const r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc)
    }
});
lSe.forEach(function (t) {
    ha.prototype[t] = function () {
        const r = this._baseState, n = Array.prototype.slice.call(arguments);
        return mu(r.tag === null), r.tag = t, this._useArgs(n), this
    }
});
ha.prototype.use = function (e) {
    mu(e);
    const r = this._baseState;
    return mu(r.use === null), r.use = e, this
};
ha.prototype.optional = function () {
    const e = this._baseState;
    return e.optional = !0, this
};
ha.prototype.def = function (e) {
    const r = this._baseState;
    return mu(r.default === null), r.default = e, r.optional = !0, this
};
ha.prototype.explicit = function (e) {
    const r = this._baseState;
    return mu(r.explicit === null && r.implicit === null), r.explicit = e, this
};
ha.prototype.implicit = function (e) {
    const r = this._baseState;
    return mu(r.explicit === null && r.implicit === null), r.implicit = e, this
};
ha.prototype.obj = function () {
    const e = this._baseState, r = Array.prototype.slice.call(arguments);
    return e.obj = !0, r.length !== 0 && this._useArgs(r), this
};
ha.prototype.key = function (e) {
    const r = this._baseState;
    return mu(r.key === null), r.key = e, this
};
ha.prototype.any = function () {
    const e = this._baseState;
    return e.any = !0, this
};
ha.prototype.choice = function (e) {
    const r = this._baseState;
    return mu(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function (n) {
        return e[n]
    })), this
};
ha.prototype.contains = function (e) {
    const r = this._baseState;
    return mu(r.use === null), r.contains = e, this
};
ha.prototype._decode = function (e, r) {
    const n = this._baseState;
    if (n.parent === null) return e.wrapResult(n.children[0]._decode(e, r));
    let i = n.default, a = !0, o = null;
    if (n.key !== null && (o = e.enterKey(n.key)), n.optional) {
        let l = null;
        if (n.explicit !== null ? l = n.explicit : n.implicit !== null ? l = n.implicit : n.tag !== null && (l = n.tag), l === null && !n.any) {
            const f = e.save();
            try {
                n.choice === null ? this._decodeGeneric(n.tag, e, r) : this._decodeChoice(e, r), a = !0
            } catch {
                a = !1
            }
            e.restore(f)
        } else if (a = this._peekTag(e, l, n.any), e.isError(a)) return a
    }
    let s;
    if (n.obj && a && (s = e.enterObject()), a) {
        if (n.explicit !== null) {
            const f = this._decodeTag(e, n.explicit);
            if (e.isError(f)) return f;
            e = f
        }
        const l = e.offset;
        if (n.use === null && n.choice === null) {
            let f;
            n.any && (f = e.save());
            const d = this._decodeTag(e, n.implicit !== null ? n.implicit : n.tag, n.any);
            if (e.isError(d)) return d;
            n.any ? i = e.raw(f) : e = d
        }
        if (r && r.track && n.tag !== null && r.track(e.path(), l, e.length, "tagged"), r && r.track && n.tag !== null && r.track(e.path(), e.offset, e.length, "content"), n.any || (n.choice === null ? i = this._decodeGeneric(n.tag, e, r) : i = this._decodeChoice(e, r)), e.isError(i)) return i;
        if (!n.any && n.choice === null && n.children !== null && n.children.forEach(function (d) {
            d._decode(e, r)
        }), n.contains && (n.tag === "octstr" || n.tag === "bitstr")) {
            const f = new Iat(i);
            i = this._getUse(n.contains, e._reporterState.obj)._decode(f, r)
        }
    }
    return n.obj && a && (i = e.leaveObject(s)), n.key !== null && (i !== null || a === !0) ? e.leaveKey(o, n.key, i) : o !== null && e.exitKey(o), i
};
ha.prototype._decodeGeneric = function (e, r, n) {
    const i = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(r, e, n) : e === "objid" && i.args ? this._decodeObjid(r, i.args[0], i.args[1], n) : e === "objid" ? this._decodeObjid(r, null, null, n) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, n) : e === "null_" ? this._decodeNull(r, n) : e === "bool" ? this._decodeBool(r, n) : e === "objDesc" ? this._decodeStr(r, e, n) : e === "int" || e === "enum" ? this._decodeInt(r, i.args && i.args[0], n) : i.use !== null ? this._getUse(i.use, r._reporterState.obj)._decode(r, n) : r.error("unknown tag: " + e)
};
ha.prototype._getUse = function (e, r) {
    const n = this._baseState;
    return n.useDecoder = this._use(e, r), mu(n.useDecoder._baseState.parent === null), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder
};
ha.prototype._decodeChoice = function (e, r) {
    const n = this._baseState;
    let i = null, a = !1;
    return Object.keys(n.choice).some(function (o) {
        const s = e.save(), l = n.choice[o];
        try {
            const f = l._decode(e, r);
            if (e.isError(f)) return !1;
            i = {type: o, value: f}, a = !0
        } catch {
            return e.restore(s), !1
        }
        return !0
    }, this), a ? i : e.error("Choice not matched")
};
ha.prototype._createEncoderBuffer = function (e) {
    return new Aat(e, this.reporter)
};
ha.prototype._encode = function (e, r, n) {
    const i = this._baseState;
    if (i.default !== null && i.default === e) return;
    const a = this._encodeValue(e, r, n);
    if (a !== void 0 && !this._skipDefault(a, r, n)) return a
};
ha.prototype._encodeValue = function (e, r, n) {
    const i = this._baseState;
    if (i.parent === null) return i.children[0]._encode(e, r || new Cat);
    let a = null;
    if (this.reporter = r, i.optional && e === void 0) if (i.default !== null) e = i.default; else return;
    let o = null, s = !1;
    if (i.any) a = this._createEncoderBuffer(e); else if (i.choice) a = this._encodeChoice(e, r); else if (i.contains) o = this._getUse(i.contains, n)._encode(e, r), s = !0; else if (i.children) o = i.children.map(function (l) {
        if (l._baseState.tag === "null_") return l._encode(null, r, e);
        if (l._baseState.key === null) return r.error("Child should have a key");
        const f = r.enterKey(l._baseState.key);
        if (typeof e != "object") return r.error("Child expected, but input is not object");
        const d = l._encode(e[l._baseState.key], r, e);
        return r.leaveKey(f), d
    }, this).filter(function (l) {
        return l
    }), o = this._createEncoderBuffer(o); else if (i.tag === "seqof" || i.tag === "setof") {
        if (!(i.args && i.args.length === 1)) return r.error("Too many args for : " + i.tag);
        if (!Array.isArray(e)) return r.error("seqof/setof, but data is not Array");
        const l = this.clone();
        l._baseState.implicit = null, o = this._createEncoderBuffer(e.map(function (f) {
            const d = this._baseState;
            return this._getUse(d.args[0], e)._encode(f, r)
        }, l))
    } else i.use !== null ? a = this._getUse(i.use, n)._encode(e, r) : (o = this._encodePrimitive(i.tag, e), s = !0);
    if (!i.any && i.choice === null) {
        const l = i.implicit !== null ? i.implicit : i.tag, f = i.implicit === null ? "universal" : "context";
        l === null ? i.use === null && r.error("Tag could be omitted only for .use()") : i.use === null && (a = this._encodeComposite(l, s, f, o))
    }
    return i.explicit !== null && (a = this._encodeComposite(i.explicit, !1, "context", a)), a
};
ha.prototype._encodeChoice = function (e, r) {
    const n = this._baseState, i = n.choice[e.type];
    return i || mu(!1, e.type + " not found in " + JSON.stringify(Object.keys(n.choice))), i._encode(e.value, r)
};
ha.prototype._encodePrimitive = function (e, r) {
    const n = this._baseState;
    if (/str$/.test(e)) return this._encodeStr(r, e);
    if (e === "objid" && n.args) return this._encodeObjid(r, n.reverseArgs[0], n.args[1]);
    if (e === "objid") return this._encodeObjid(r, null, null);
    if (e === "gentime" || e === "utctime") return this._encodeTime(r, e);
    if (e === "null_") return this._encodeNull();
    if (e === "int" || e === "enum") return this._encodeInt(r, n.args && n.reverseArgs[0]);
    if (e === "bool") return this._encodeBool(r);
    if (e === "objDesc") return this._encodeStr(r, e);
    throw new Error("Unsupported tag: " + e)
};
ha.prototype._isNumstr = function (e) {
    return /^[0-9 ]*$/.test(e)
};
ha.prototype._isPrintstr = function (e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e)
};
var TN = {};
(function (t) {
    function e(r) {
        const n = {};
        return Object.keys(r).forEach(function (i) {
            (i | 0) == i && (i = i | 0);
            const a = r[i];
            n[a] = i
        }), n
    }

    t.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
    }, t.tagClassByName = e(t.tagClass), t.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
    }, t.tagByName = e(t.tag)
})(TN);
const Mat = Xn, rv = CQ.Buffer, uSe = AQ, Tz = TN;

function fSe(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new _p, this.tree._init(t.body)
}

var dSe = fSe;
fSe.prototype.encode = function (e, r) {
    return this.tree._encode(e, r).join()
};

function _p(t) {
    uSe.call(this, "der", t)
}

Mat(_p, uSe);
_p.prototype._encodeComposite = function (e, r, n, i) {
    const a = Oat(e, r, n, this.reporter);
    if (i.length < 128) {
        const l = rv.alloc(2);
        return l[0] = a, l[1] = i.length, this._createEncoderBuffer([l, i])
    }
    let o = 1;
    for (let l = i.length; l >= 256; l >>= 8) o++;
    const s = rv.alloc(2 + o);
    s[0] = a, s[1] = 128 | o;
    for (let l = 1 + o, f = i.length; f > 0; l--, f >>= 8) s[l] = f & 255;
    return this._createEncoderBuffer([s, i])
};
_p.prototype._encodeStr = function (e, r) {
    if (r === "bitstr") return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r === "bmpstr") {
        const n = rv.alloc(e.length * 2);
        for (let i = 0; i < e.length; i++) n.writeUInt16BE(e.charCodeAt(i), i * 2);
        return this._createEncoderBuffer(n)
    } else return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported")
};
_p.prototype._encodeObjid = function (e, r, n) {
    if (typeof e == "string") {
        if (!r) return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e)) return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let s = 0; s < e.length; s++) e[s] |= 0
    } else if (Array.isArray(e)) {
        e = e.slice();
        for (let s = 0; s < e.length; s++) e[s] |= 0
    }
    if (!Array.isArray(e)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!n) {
        if (e[1] >= 40) return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1])
    }
    let i = 0;
    for (let s = 0; s < e.length; s++) {
        let l = e[s];
        for (i++; l >= 128; l >>= 7) i++
    }
    const a = rv.alloc(i);
    let o = a.length - 1;
    for (let s = e.length - 1; s >= 0; s--) {
        let l = e[s];
        for (a[o--] = l & 127; (l >>= 7) > 0;) a[o--] = 128 | l & 127
    }
    return this._createEncoderBuffer(a)
};

function kd(t) {
    return t < 10 ? "0" + t : t
}

_p.prototype._encodeTime = function (e, r) {
    let n;
    const i = new Date(e);
    return r === "gentime" ? n = [kd(i.getUTCFullYear()), kd(i.getUTCMonth() + 1), kd(i.getUTCDate()), kd(i.getUTCHours()), kd(i.getUTCMinutes()), kd(i.getUTCSeconds()), "Z"].join("") : r === "utctime" ? n = [kd(i.getUTCFullYear() % 100), kd(i.getUTCMonth() + 1), kd(i.getUTCDate()), kd(i.getUTCHours()), kd(i.getUTCMinutes()), kd(i.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(n, "octstr")
};
_p.prototype._encodeNull = function () {
    return this._createEncoderBuffer("")
};
_p.prototype._encodeInt = function (e, r) {
    if (typeof e == "string") {
        if (!r) return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e]
    }
    if (typeof e != "number" && !rv.isBuffer(e)) {
        const a = e.toArray();
        !e.sign && a[0] & 128 && a.unshift(0), e = rv.from(a)
    }
    if (rv.isBuffer(e)) {
        let a = e.length;
        e.length === 0 && a++;
        const o = rv.alloc(a);
        return e.copy(o), e.length === 0 && (o[0] = 0), this._createEncoderBuffer(o)
    }
    if (e < 128) return this._createEncoderBuffer(e);
    if (e < 256) return this._createEncoderBuffer([0, e]);
    let n = 1;
    for (let a = e; a >= 256; a >>= 8) n++;
    const i = new Array(n);
    for (let a = i.length - 1; a >= 0; a--) i[a] = e & 255, e >>= 8;
    return i[0] & 128 && i.unshift(0), this._createEncoderBuffer(rv.from(i))
};
_p.prototype._encodeBool = function (e) {
    return this._createEncoderBuffer(e ? 255 : 0)
};
_p.prototype._use = function (e, r) {
    return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree
};
_p.prototype._skipDefault = function (e, r, n) {
    const i = this._baseState;
    let a;
    if (i.default === null) return !1;
    const o = e.join();
    if (i.defaultBuffer === void 0 && (i.defaultBuffer = this._encodeValue(i.default, r, n).join()), o.length !== i.defaultBuffer.length) return !1;
    for (a = 0; a < o.length; a++) if (o[a] !== i.defaultBuffer[a]) return !1;
    return !0
};

function Oat(t, e, r, n) {
    let i;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), Tz.tagByName.hasOwnProperty(t)) i = Tz.tagByName[t]; else if (typeof t == "number" && (t | 0) === t) i = t; else return n.error("Unknown tag: " + t);
    return i >= 31 ? n.error("Multi-octet tag encoding unsupported") : (e || (i |= 32), i |= Tz.tagClassByName[r || "universal"] << 6, i)
}

const Pat = Xn, IQ = dSe;

function kQ(t) {
    IQ.call(this, t), this.enc = "pem"
}

Pat(kQ, IQ);
var Nat = kQ;
kQ.prototype.encode = function (e, r) {
    const i = IQ.prototype.encode.call(this, e).toString("base64"), a = ["-----BEGIN " + r.label + "-----"];
    for (let o = 0; o < i.length; o += 64) a.push(i.slice(o, o + 64));
    return a.push("-----END " + r.label + "-----"), a.join(`
`)
};
(function (t) {
    const e = t;
    e.der = dSe, e.pem = Nat
})(TQ);
var RQ = {};
const Lat = Xn, Bat = sc, cle = fS.DecoderBuffer, hSe = AQ, lle = TN;

function pSe(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new ed, this.tree._init(t.body)
}

var mSe = pSe;
pSe.prototype.decode = function (e, r) {
    return cle.isDecoderBuffer(e) || (e = new cle(e, r)), this.tree._decode(e, r)
};

function ed(t) {
    hSe.call(this, "der", t)
}

Lat(ed, hSe);
ed.prototype._peekTag = function (e, r, n) {
    if (e.isEmpty()) return !1;
    const i = e.save(), a = DQ(e, 'Failed to peek tag: "' + r + '"');
    return e.isError(a) ? a : (e.restore(i), a.tag === r || a.tagStr === r || a.tagStr + "of" === r || n)
};
ed.prototype._decodeTag = function (e, r, n) {
    const i = DQ(e, 'Failed to decode tag of "' + r + '"');
    if (e.isError(i)) return i;
    let a = vSe(e, i.primitive, 'Failed to get length of "' + r + '"');
    if (e.isError(a)) return a;
    if (!n && i.tag !== r && i.tagStr !== r && i.tagStr + "of" !== r) return e.error('Failed to match tag: "' + r + '"');
    if (i.primitive || a !== null) return e.skip(a, 'Failed to match body of: "' + r + '"');
    const o = e.save(), s = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(s) ? s : (a = e.offset - o.offset, e.restore(o), e.skip(a, 'Failed to match body of: "' + r + '"'))
};
ed.prototype._skipUntilEnd = function (e, r) {
    for (; ;) {
        const n = DQ(e, r);
        if (e.isError(n)) return n;
        const i = vSe(e, n.primitive, r);
        if (e.isError(i)) return i;
        let a;
        if (n.primitive || i !== null ? a = e.skip(i) : a = this._skipUntilEnd(e, r), e.isError(a)) return a;
        if (n.tagStr === "end") break
    }
};
ed.prototype._decodeList = function (e, r, n, i) {
    const a = [];
    for (; !e.isEmpty();) {
        const o = this._peekTag(e, "end");
        if (e.isError(o)) return o;
        const s = n.decode(e, "der", i);
        if (e.isError(s) && o) break;
        a.push(s)
    }
    return a
};
ed.prototype._decodeStr = function (e, r) {
    if (r === "bitstr") {
        const n = e.readUInt8();
        return e.isError(n) ? n : {unused: n, data: e.raw()}
    } else if (r === "bmpstr") {
        const n = e.raw();
        if (n.length % 2 === 1) return e.error("Decoding of string type: bmpstr length mismatch");
        let i = "";
        for (let a = 0; a < n.length / 2; a++) i += String.fromCharCode(n.readUInt16BE(a * 2));
        return i
    } else if (r === "numstr") {
        const n = e.raw().toString("ascii");
        return this._isNumstr(n) ? n : e.error("Decoding of string type: numstr unsupported characters")
    } else {
        if (r === "octstr") return e.raw();
        if (r === "objDesc") return e.raw();
        if (r === "printstr") {
            const n = e.raw().toString("ascii");
            return this._isPrintstr(n) ? n : e.error("Decoding of string type: printstr unsupported characters")
        } else return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported")
    }
};
ed.prototype._decodeObjid = function (e, r, n) {
    let i;
    const a = [];
    let o = 0, s = 0;
    for (; !e.isEmpty();) s = e.readUInt8(), o <<= 7, o |= s & 127, s & 128 || (a.push(o), o = 0);
    s & 128 && a.push(o);
    const l = a[0] / 40 | 0, f = a[0] % 40;
    if (n ? i = a : i = [l, f].concat(a.slice(1)), r) {
        let d = r[i.join(" ")];
        d === void 0 && (d = r[i.join(".")]), d !== void 0 && (i = d)
    }
    return i
};
ed.prototype._decodeTime = function (e, r) {
    const n = e.raw().toString();
    let i, a, o, s, l, f;
    if (r === "gentime") i = n.slice(0, 4) | 0, a = n.slice(4, 6) | 0, o = n.slice(6, 8) | 0, s = n.slice(8, 10) | 0, l = n.slice(10, 12) | 0, f = n.slice(12, 14) | 0; else if (r === "utctime") i = n.slice(0, 2) | 0, a = n.slice(2, 4) | 0, o = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, l = n.slice(8, 10) | 0, f = n.slice(10, 12) | 0, i < 70 ? i = 2e3 + i : i = 1900 + i; else return e.error("Decoding " + r + " time is not supported yet");
    return Date.UTC(i, a - 1, o, s, l, f, 0)
};
ed.prototype._decodeNull = function () {
    return null
};
ed.prototype._decodeBool = function (e) {
    const r = e.readUInt8();
    return e.isError(r) ? r : r !== 0
};
ed.prototype._decodeInt = function (e, r) {
    const n = e.raw();
    let i = new Bat(n);
    return r && (i = r[i.toString(10)] || i), i
};
ed.prototype._use = function (e, r) {
    return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree
};

function DQ(t, e) {
    let r = t.readUInt8(e);
    if (t.isError(r)) return r;
    const n = lle.tagClass[r >> 6], i = (r & 32) === 0;
    if ((r & 31) === 31) {
        let o = r;
        for (r = 0; (o & 128) === 128;) {
            if (o = t.readUInt8(e), t.isError(o)) return o;
            r <<= 7, r |= o & 127
        }
    } else r &= 31;
    const a = lle.tag[r];
    return {cls: n, primitive: i, tag: r, tagStr: a}
}

function vSe(t, e, r) {
    let n = t.readUInt8(r);
    if (t.isError(n)) return n;
    if (!e && n === 128) return null;
    if (!(n & 128)) return n;
    const i = n & 127;
    if (i > 4) return t.error("length octect is too long");
    n = 0;
    for (let a = 0; a < i; a++) {
        n <<= 8;
        const o = t.readUInt8(r);
        if (t.isError(o)) return o;
        n |= o
    }
    return n
}

const $at = Xn, Fat = CQ.Buffer, MQ = mSe;

function OQ(t) {
    MQ.call(this, t), this.enc = "pem"
}

$at(OQ, MQ);
var Uat = OQ;
OQ.prototype.decode = function (e, r) {
    const n = e.toString().split(/[\r\n]+/g), i = r.label.toUpperCase(), a = /^-----(BEGIN|END) ([^-]+)-----$/;
    let o = -1, s = -1;
    for (let d = 0; d < n.length; d++) {
        const p = n[d].match(a);
        if (p !== null && p[2] === i) if (o === -1) {
            if (p[1] !== "BEGIN") break;
            o = d
        } else {
            if (p[1] !== "END") break;
            s = d;
            break
        }
    }
    if (o === -1 || s === -1) throw new Error("PEM section not found for: " + i);
    const l = n.slice(o + 1, s).join("");
    l.replace(/[^a-z0-9+/=]+/gi, "");
    const f = Fat.from(l, "base64");
    return MQ.prototype.decode.call(this, f, r)
};
(function (t) {
    const e = t;
    e.der = mSe, e.pem = Uat
})(RQ);
(function (t) {
    const e = TQ, r = RQ, n = Xn, i = t;
    i.define = function (s, l) {
        return new a(s, l)
    };

    function a(o, s) {
        this.name = o, this.body = s, this.decoders = {}, this.encoders = {}
    }

    a.prototype._createNamed = function (s) {
        const l = this.name;

        function f(d) {
            this._initNamed(d, l)
        }

        return n(f, s), f.prototype._initNamed = function (p, g) {
            s.call(this, p, g)
        }, new f(this)
    }, a.prototype._getDecoder = function (s) {
        return s = s || "der", this.decoders.hasOwnProperty(s) || (this.decoders[s] = this._createNamed(r[s])), this.decoders[s]
    }, a.prototype.decode = function (s, l, f) {
        return this._getDecoder(l).decode(s, f)
    }, a.prototype._getEncoder = function (s) {
        return s = s || "der", this.encoders.hasOwnProperty(s) || (this.encoders[s] = this._createNamed(e[s])), this.encoders[s]
    }, a.prototype.encode = function (s, l, f) {
        return this._getEncoder(l).encode(s, f)
    }
})(cSe);
var gSe = {};
(function (t) {
    const e = t;
    e.Reporter = xN.Reporter, e.DecoderBuffer = fS.DecoderBuffer, e.EncoderBuffer = fS.EncoderBuffer, e.Node = AQ
})(gSe);
var ySe = {};
(function (t) {
    const e = t;
    e._reverse = function (n) {
        const i = {};
        return Object.keys(n).forEach(function (a) {
            (a | 0) == a && (a = a | 0);
            const o = n[a];
            i[o] = a
        }), i
    }, e.der = TN
})(ySe);
(function (t) {
    const e = t;
    e.bignum = sc, e.define = cSe.define, e.base = gSe, e.constants = ySe, e.decoders = RQ, e.encoders = TQ
})(EQ);
var xp = EQ, ule = xp.define("Time", function () {
    this.choice({utcTime: this.utctime(), generalTime: this.gentime()})
}), jat = xp.define("AttributeTypeValue", function () {
    this.seq().obj(this.key("type").objid(), this.key("value").any())
}), PQ = xp.define("AlgorithmIdentifier", function () {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
}), zat = xp.define("SubjectPublicKeyInfo", function () {
    this.seq().obj(this.key("algorithm").use(PQ), this.key("subjectPublicKey").bitstr())
}), Vat = xp.define("RelativeDistinguishedName", function () {
    this.setof(jat)
}), Hat = xp.define("RDNSequence", function () {
    this.seqof(Vat)
}), fle = xp.define("Name", function () {
    this.choice({rdnSequence: this.use(Hat)})
}), Wat = xp.define("Validity", function () {
    this.seq().obj(this.key("notBefore").use(ule), this.key("notAfter").use(ule))
}), qat = xp.define("Extension", function () {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
}), Gat = xp.define("TBSCertificate", function () {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(PQ), this.key("issuer").use(fle), this.key("validity").use(Wat), this.key("subject").use(fle), this.key("subjectPublicKeyInfo").use(zat), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(qat).optional())
}), Kat = xp.define("X509Certificate", function () {
    this.seq().obj(this.key("tbsCertificate").use(Gat), this.key("signatureAlgorithm").use(PQ), this.key("signatureValue").bitstr())
}), Yat = Kat, Ep = EQ;
Sp.certificate = Yat;
var Xat = Ep.define("RSAPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
});
Sp.RSAPrivateKey = Xat;
var Qat = Ep.define("RSAPublicKey", function () {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
});
Sp.RSAPublicKey = Qat;
var Zat = Ep.define("SubjectPublicKeyInfo", function () {
    this.seq().obj(this.key("algorithm").use(bSe), this.key("subjectPublicKey").bitstr())
});
Sp.PublicKey = Zat;
var bSe = Ep.define("AlgorithmIdentifier", function () {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
}), Jat = Ep.define("PrivateKeyInfo", function () {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(bSe), this.key("subjectPrivateKey").octstr())
});
Sp.PrivateKey = Jat;
var eot = Ep.define("EncryptedPrivateKeyInfo", function () {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
});
Sp.EncryptedPrivateKey = eot;
var tot = Ep.define("DSAPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
});
Sp.DSAPrivateKey = tot;
Sp.DSAparam = Ep.define("DSAparam", function () {
    this.int()
});
var rot = Ep.define("ECPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(not), this.key("publicKey").optional().explicit(1).bitstr())
});
Sp.ECPrivateKey = rot;
var not = Ep.define("ECParameters", function () {
    this.choice({namedCurve: this.objid()})
});
Sp.signature = Ep.define("signature", function () {
    this.seq().obj(this.key("r").int(), this.key("s").int())
});
const iot = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var aot = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
    oot = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
    sot = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, cot = dN, lot = qf,
    i7 = Vn.Buffer, uot = function (t, e) {
        var r = t.toString(), n = r.match(aot), i;
        if (n) {
            var o = "aes" + n[1], s = i7.from(n[2], "hex"), l = i7.from(n[3].replace(/[\r\n]/g, ""), "base64"),
                f = cot(e, s.slice(0, 8), parseInt(n[1], 10)).key, d = [], p = lot.createDecipheriv(o, f, s);
            d.push(p.update(l)), d.push(p.final()), i = i7.concat(d)
        } else {
            var a = r.match(sot);
            i = i7.from(a[2].replace(/[\r\n]/g, ""), "base64")
        }
        var g = r.match(oot)[1];
        return {tag: g, data: i}
    }, zu = Sp, fot = iot, dot = uot, hot = qf, pot = cN, Nq = Vn.Buffer, CN = wSe;

function wSe(t) {
    var e;
    typeof t == "object" && !Nq.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = Nq.from(t));
    var r = dot(t, e), n = r.tag, i = r.data, a, o;
    switch (n) {
        case"CERTIFICATE":
            o = zu.certificate.decode(i, "der").tbsCertificate.subjectPublicKeyInfo;
        case"PUBLIC KEY":
            switch (o || (o = zu.PublicKey.decode(i, "der")), a = o.algorithm.algorithm.join("."), a) {
                case"1.2.840.113549.1.1.1":
                    return zu.RSAPublicKey.decode(o.subjectPublicKey.data, "der");
                case"1.2.840.10045.2.1":
                    return o.subjectPrivateKey = o.subjectPublicKey, {type: "ec", data: o};
                case"1.2.840.10040.4.1":
                    return o.algorithm.params.pub_key = zu.DSAparam.decode(o.subjectPublicKey.data, "der"), {
                        type: "dsa",
                        data: o.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + a)
            }
        case"ENCRYPTED PRIVATE KEY":
            i = zu.EncryptedPrivateKey.decode(i, "der"), i = mot(i, e);
        case"PRIVATE KEY":
            switch (o = zu.PrivateKey.decode(i, "der"), a = o.algorithm.algorithm.join("."), a) {
                case"1.2.840.113549.1.1.1":
                    return zu.RSAPrivateKey.decode(o.subjectPrivateKey, "der");
                case"1.2.840.10045.2.1":
                    return {
                        curve: o.algorithm.curve,
                        privateKey: zu.ECPrivateKey.decode(o.subjectPrivateKey, "der").privateKey
                    };
                case"1.2.840.10040.4.1":
                    return o.algorithm.params.priv_key = zu.DSAparam.decode(o.subjectPrivateKey, "der"), {
                        type: "dsa",
                        params: o.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + a)
            }
        case"RSA PUBLIC KEY":
            return zu.RSAPublicKey.decode(i, "der");
        case"RSA PRIVATE KEY":
            return zu.RSAPrivateKey.decode(i, "der");
        case"DSA PRIVATE KEY":
            return {type: "dsa", params: zu.DSAPrivateKey.decode(i, "der")};
        case"EC PRIVATE KEY":
            return i = zu.ECPrivateKey.decode(i, "der"), {curve: i.parameters.value, privateKey: i.privateKey};
        default:
            throw new Error("unknown key type " + n)
    }
}

wSe.signature = zu.signature;

function mot(t, e) {
    var r = t.algorithm.decrypt.kde.kdeparams.salt,
        n = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
        i = fot[t.algorithm.decrypt.cipher.algo.join(".")], a = t.algorithm.decrypt.cipher.iv, o = t.subjectPrivateKey,
        s = parseInt(i.split("-")[1], 10) / 8, l = pot.pbkdf2Sync(e, r, n, s, "sha1"),
        f = hot.createDecipheriv(i, l, a), d = [];
    return d.push(f.update(o)), d.push(f.final()), Nq.concat(d)
}

const SSe = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var dle;

function vot() {
    if (dle) return G5.exports;
    dle = 1;
    var t = Vn.Buffer, e = zbe, r = yQ, n = xQ().ec, i = P8, a = CN, o = SSe, s = 1;

    function l(N, P, F, V, Y) {
        var ee = a(P);
        if (ee.curve) {
            if (V !== "ecdsa" && V !== "ecdsa/rsa") throw new Error("wrong private key type");
            return f(N, ee)
        } else if (ee.type === "dsa") {
            if (V !== "dsa") throw new Error("wrong private key type");
            return d(N, ee, F)
        }
        if (V !== "rsa" && V !== "ecdsa/rsa") throw new Error("wrong private key type");
        if (P.padding !== void 0 && P.padding !== s) throw new Error("illegal or unsupported padding mode");
        N = t.concat([Y, N]);
        for (var oe = ee.modulus.byteLength(), G = [0, 1]; N.length + G.length + 1 < oe;) G.push(255);
        G.push(0);
        for (var J = -1; ++J < N.length;) G.push(N[J]);
        var ce = r(G, ee);
        return ce
    }

    function f(N, P) {
        var F = o[P.curve.join(".")];
        if (!F) throw new Error("unknown curve " + P.curve.join("."));
        var V = new n(F), Y = V.keyFromPrivate(P.privateKey), ee = Y.sign(N);
        return t.from(ee.toDER())
    }

    function d(N, P, F) {
        for (var V = P.params.priv_key, Y = P.params.p, ee = P.params.q, oe = P.params.g, G = new i(0), J, ce = b(N, ee).mod(ee), re = !1, M = g(V, ee, N, F); re === !1;) J = T(ee, M, F), G = I(oe, J, Y, ee), re = J.invm(ee).imul(ce.add(V.mul(G))).mod(ee), re.cmpn(0) === 0 && (re = !1, G = new i(0));
        return p(G, re)
    }

    function p(N, P) {
        N = N.toArray(), P = P.toArray(), N[0] & 128 && (N = [0].concat(N)), P[0] & 128 && (P = [0].concat(P));
        var F = N.length + P.length + 4, V = [48, F, 2, N.length];
        return V = V.concat(N, [2, P.length], P), t.from(V)
    }

    function g(N, P, F, V) {
        if (N = t.from(N.toArray()), N.length < P.byteLength()) {
            var Y = t.alloc(P.byteLength() - N.length);
            N = t.concat([Y, N])
        }
        var ee = F.length, oe = S(F, P), G = t.alloc(ee);
        G.fill(1);
        var J = t.alloc(ee);
        return J = e(V, J).update(G).update(t.from([0])).update(N).update(oe).digest(), G = e(V, J).update(G).digest(), J = e(V, J).update(G).update(t.from([1])).update(N).update(oe).digest(), G = e(V, J).update(G).digest(), {
            k: J,
            v: G
        }
    }

    function b(N, P) {
        var F = new i(N), V = (N.length << 3) - P.bitLength();
        return V > 0 && F.ishrn(V), F
    }

    function S(N, P) {
        N = b(N, P), N = N.mod(P);
        var F = t.from(N.toArray());
        if (F.length < P.byteLength()) {
            var V = t.alloc(P.byteLength() - F.length);
            F = t.concat([V, F])
        }
        return F
    }

    function T(N, P, F) {
        var V, Y;
        do {
            for (V = t.alloc(0); V.length * 8 < N.bitLength();) P.v = e(F, P.k).update(P.v).digest(), V = t.concat([V, P.v]);
            Y = b(V, N), P.k = e(F, P.k).update(P.v).update(t.from([0])).digest(), P.v = e(F, P.k).update(P.v).digest()
        } while (Y.cmp(N) !== -1);
        return Y
    }

    function I(N, P, F, V) {
        return N.toRed(i.mont(F)).redPow(P).fromRed().mod(V)
    }

    return G5.exports = l, G5.exports.getKey = g, G5.exports.makeKey = T, G5.exports
}

var Cz, hle;

function got() {
    if (hle) return Cz;
    hle = 1;
    var t = Vn.Buffer, e = P8, r = xQ().ec, n = CN, i = SSe;

    function a(f, d, p, g, b) {
        var S = n(p);
        if (S.type === "ec") {
            if (g !== "ecdsa" && g !== "ecdsa/rsa") throw new Error("wrong public key type");
            return o(f, d, S)
        } else if (S.type === "dsa") {
            if (g !== "dsa") throw new Error("wrong public key type");
            return s(f, d, S)
        }
        if (g !== "rsa" && g !== "ecdsa/rsa") throw new Error("wrong public key type");
        d = t.concat([b, d]);
        for (var T = S.modulus.byteLength(), I = [1], N = 0; d.length + I.length + 2 < T;) I.push(255), N += 1;
        I.push(0);
        for (var P = -1; ++P < d.length;) I.push(d[P]);
        I = t.from(I);
        var F = e.mont(S.modulus);
        f = new e(f).toRed(F), f = f.redPow(new e(S.publicExponent)), f = t.from(f.fromRed().toArray());
        var V = N < 8 ? 1 : 0;
        for (T = Math.min(f.length, I.length), f.length !== I.length && (V = 1), P = -1; ++P < T;) V |= f[P] ^ I[P];
        return V === 0
    }

    function o(f, d, p) {
        var g = i[p.data.algorithm.curve.join(".")];
        if (!g) throw new Error("unknown curve " + p.data.algorithm.curve.join("."));
        var b = new r(g), S = p.data.subjectPrivateKey.data;
        return b.verify(d, f, S)
    }

    function s(f, d, p) {
        var g = p.data.p, b = p.data.q, S = p.data.g, T = p.data.pub_key, I = n.signature.decode(f, "der"), N = I.s,
            P = I.r;
        l(N, b), l(P, b);
        var F = e.mont(g), V = N.invm(b),
            Y = S.toRed(F).redPow(new e(d).mul(V).mod(b)).fromRed().mul(T.toRed(F).redPow(P.mul(V).mod(b)).fromRed()).mod(g).mod(b);
        return Y.cmp(P) === 0
    }

    function l(f, d) {
        if (f.cmpn(0) <= 0) throw new Error("invalid sig");
        if (f.cmp(d) >= 0) throw new Error("invalid sig")
    }

    return Cz = a, Cz
}

var Az, ple;

function yot() {
    if (ple) return Az;
    ple = 1;
    var t = Vn.Buffer, e = I8, r = xbe, n = Xn, i = vot(), a = got(), o = Vbe;
    Object.keys(o).forEach(function (p) {
        o[p].id = t.from(o[p].id, "hex"), o[p.toLowerCase()] = o[p]
    });

    function s(p) {
        r.Writable.call(this);
        var g = o[p];
        if (!g) throw new Error("Unknown message digest");
        this._hashType = g.hash, this._hash = e(g.hash), this._tag = g.id, this._signType = g.sign
    }

    n(s, r.Writable), s.prototype._write = function (g, b, S) {
        this._hash.update(g), S()
    }, s.prototype.update = function (g, b) {
        return this._hash.update(typeof g == "string" ? t.from(g, b) : g), this
    }, s.prototype.sign = function (g, b) {
        this.end();
        var S = this._hash.digest(), T = i(S, g, this._hashType, this._signType, this._tag);
        return b ? T.toString(b) : T
    };

    function l(p) {
        r.Writable.call(this);
        var g = o[p];
        if (!g) throw new Error("Unknown message digest");
        this._hash = e(g.hash), this._tag = g.id, this._signType = g.sign
    }

    n(l, r.Writable), l.prototype._write = function (g, b, S) {
        this._hash.update(g), S()
    }, l.prototype.update = function (g, b) {
        return this._hash.update(typeof g == "string" ? t.from(g, b) : g), this
    }, l.prototype.verify = function (g, b, S) {
        var T = typeof b == "string" ? t.from(b, S) : b;
        this.end();
        var I = this._hash.digest();
        return a(T, I, g, this._signType, this._tag)
    };

    function f(p) {
        return new s(p)
    }

    function d(p) {
        return new l(p)
    }

    return Az = {Sign: f, Verify: d, createSign: f, createVerify: d}, Az
}

var Iz, mle;

function bot() {
    if (mle) return Iz;
    mle = 1;
    var t = xQ(), e = sc;
    Iz = function (o) {
        return new n(o)
    };
    var r = {
        secp256k1: {name: "secp256k1", byteLength: 32},
        secp224r1: {name: "p224", byteLength: 28},
        prime256v1: {name: "p256", byteLength: 32},
        prime192v1: {name: "p192", byteLength: 24},
        ed25519: {name: "ed25519", byteLength: 32},
        secp384r1: {name: "p384", byteLength: 48},
        secp521r1: {name: "p521", byteLength: 66}
    };
    r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;

    function n(a) {
        this.curveType = r[a], this.curveType || (this.curveType = {name: a}), this.curve = new t.ec(this.curveType.name), this.keys = void 0
    }

    n.prototype.generateKeys = function (a, o) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(a, o)
    }, n.prototype.computeSecret = function (a, o, s) {
        o = o || "utf8", kr.isBuffer(a) || (a = new kr(a, o));
        var l = this.curve.keyFromPublic(a).getPublic(), f = l.mul(this.keys.getPrivate()).getX();
        return i(f, s, this.curveType.byteLength)
    }, n.prototype.getPublicKey = function (a, o) {
        var s = this.keys.getPublic(o === "compressed", !0);
        return o === "hybrid" && (s[s.length - 1] % 2 ? s[0] = 7 : s[0] = 6), i(s, a)
    }, n.prototype.getPrivateKey = function (a) {
        return i(this.keys.getPrivate(), a)
    }, n.prototype.setPublicKey = function (a, o) {
        return o = o || "utf8", kr.isBuffer(a) || (a = new kr(a, o)), this.keys._importPublic(a), this
    }, n.prototype.setPrivateKey = function (a, o) {
        o = o || "utf8", kr.isBuffer(a) || (a = new kr(a, o));
        var s = new e(a);
        return s = s.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(s), this
    };

    function i(a, o, s) {
        Array.isArray(a) || (a = a.toArray());
        var l = new kr(a);
        if (s && l.length < s) {
            var f = new kr(s - l.length);
            f.fill(0), l = kr.concat([f, l])
        }
        return o ? l.toString(o) : l
    }

    return Iz
}

var _Se = {}, wot = I8, Lq = Vn.Buffer, xSe = function (t, e) {
    for (var r = Lq.alloc(0), n = 0, i; r.length < e;) i = Sot(n++), r = Lq.concat([r, wot("sha1").update(t).update(i).digest()]);
    return r.slice(0, e)
};

function Sot(t) {
    var e = Lq.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e
}

var ESe = function (e, r) {
    for (var n = e.length, i = -1; ++i < n;) e[i] ^= r[i];
    return e
}, vle = sc, _ot = Vn.Buffer;

function xot(t, e) {
    return _ot.from(t.toRed(vle.mont(e.modulus)).redPow(new vle(e.publicExponent)).fromRed().toArray())
}

var TSe = xot, Eot = CN, Bq = FE, Tot = I8, gle = xSe, yle = ESe, NQ = sc, Cot = TSe, Aot = yQ, Wh = Vn.Buffer,
    Iot = function (e, r, n) {
        var i;
        e.padding ? i = e.padding : n ? i = 1 : i = 4;
        var a = Eot(e), o;
        if (i === 4) o = kot(a, r); else if (i === 1) o = Rot(a, r, n); else if (i === 3) {
            if (o = new NQ(r), o.cmp(a.modulus) >= 0) throw new Error("data too long for modulus")
        } else throw new Error("unknown padding");
        return n ? Aot(o, a) : Cot(o, a)
    };

function kot(t, e) {
    var r = t.modulus.byteLength(), n = e.length, i = Tot("sha1").update(Wh.alloc(0)).digest(), a = i.length, o = 2 * a;
    if (n > r - o - 2) throw new Error("message too long");
    var s = Wh.alloc(r - n - o - 2), l = r - a - 1, f = Bq(a),
        d = yle(Wh.concat([i, s, Wh.alloc(1, 1), e], l), gle(f, l)), p = yle(f, gle(d, a));
    return new NQ(Wh.concat([Wh.alloc(1), p, d], r))
}

function Rot(t, e, r) {
    var n = e.length, i = t.modulus.byteLength();
    if (n > i - 11) throw new Error("message too long");
    var a;
    return r ? a = Wh.alloc(i - n - 3, 255) : a = Dot(i - n - 3), new NQ(Wh.concat([Wh.from([0, r ? 1 : 2]), a, Wh.alloc(1), e], i))
}

function Dot(t) {
    for (var e = Wh.allocUnsafe(t), r = 0, n = Bq(t * 2), i = 0, a; r < t;) i === n.length && (n = Bq(t * 2), i = 0), a = n[i++], a && (e[r++] = a);
    return e
}

var Mot = CN, ble = xSe, wle = ESe, Sle = sc, Oot = yQ, Pot = I8, Not = TSe, fA = Vn.Buffer, Lot = function (e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var a = Mot(e), o = a.modulus.byteLength();
    if (r.length > o || new Sle(r).cmp(a.modulus) >= 0) throw new Error("decryption error");
    var s;
    n ? s = Not(new Sle(r), a) : s = Oot(r, a);
    var l = fA.alloc(o - s.length);
    if (s = fA.concat([l, s], o), i === 4) return Bot(a, s);
    if (i === 1) return $ot(a, s, n);
    if (i === 3) return s;
    throw new Error("unknown padding")
};

function Bot(t, e) {
    var r = t.modulus.byteLength(), n = Pot("sha1").update(fA.alloc(0)).digest(), i = n.length;
    if (e[0] !== 0) throw new Error("decryption error");
    var a = e.slice(1, i + 1), o = e.slice(i + 1), s = wle(a, ble(o, i)), l = wle(o, ble(s, r - i - 1));
    if (Fot(n, l.slice(0, i))) throw new Error("decryption error");
    for (var f = i; l[f] === 0;) f++;
    if (l[f++] !== 1) throw new Error("decryption error");
    return l.slice(f)
}

function $ot(t, e, r) {
    for (var n = e.slice(0, 2), i = 2, a = 0; e[i++] !== 0;) if (i >= e.length) {
        a++;
        break
    }
    var o = e.slice(2, i - 1);
    if ((n.toString("hex") !== "0002" && !r || n.toString("hex") !== "0001" && r) && a++, o.length < 8 && a++, a) throw new Error("decryption error");
    return e.slice(i)
}

function Fot(t, e) {
    t = fA.from(t), e = fA.from(e);
    var r = 0, n = t.length;
    t.length !== e.length && (r++, n = Math.min(t.length, e.length));
    for (var i = -1; ++i < n;) r += t[i] ^ e[i];
    return r
}

(function (t) {
    t.publicEncrypt = Iot, t.privateDecrypt = Lot, t.privateEncrypt = function (r, n) {
        return t.publicEncrypt(r, n, !0)
    }, t.publicDecrypt = function (r, n) {
        return t.privateDecrypt(r, n, !0)
    }
})(_Se);
var TT = {};

function _le() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
}

var CSe = Vn, xle = FE, ASe = CSe.Buffer, ISe = CSe.kMaxLength, $q = tn.crypto || tn.msCrypto,
    kSe = Math.pow(2, 32) - 1;

function RSe(t, e) {
    if (typeof t != "number" || t !== t) throw new TypeError("offset must be a number");
    if (t > kSe || t < 0) throw new TypeError("offset must be a uint32");
    if (t > ISe || t > e) throw new RangeError("offset out of range")
}

function DSe(t, e, r) {
    if (typeof t != "number" || t !== t) throw new TypeError("size must be a number");
    if (t > kSe || t < 0) throw new TypeError("size must be a uint32");
    if (t + e > r || t > ISe) throw new RangeError("buffer too small")
}

$q && $q.getRandomValues || !Ve.browser ? (TT.randomFill = Uot, TT.randomFillSync = jot) : (TT.randomFill = _le, TT.randomFillSync = _le);

function Uot(t, e, r, n) {
    if (!ASe.isBuffer(t) && !(t instanceof tn.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function") n = e, e = 0, r = t.length; else if (typeof r == "function") n = r, r = t.length - e; else if (typeof n != "function") throw new TypeError('"cb" argument must be a function');
    return RSe(e, t.length), DSe(r, e, t.length), MSe(t, e, r, n)
}

function MSe(t, e, r, n) {
    if (Ve.browser) {
        var i = t.buffer, a = new Uint8Array(i, e, r);
        if ($q.getRandomValues(a), n) {
            Ve.nextTick(function () {
                n(null, t)
            });
            return
        }
        return t
    }
    if (n) {
        xle(r, function (s, l) {
            if (s) return n(s);
            l.copy(t, e), n(null, t)
        });
        return
    }
    var o = xle(r);
    return o.copy(t, e), t
}

function jot(t, e, r) {
    if (typeof e > "u" && (e = 0), !ASe.isBuffer(t) && !(t instanceof tn.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return RSe(e, t.length), r === void 0 && (r = t.length - e), DSe(r, e, t.length), MSe(t, e, r)
}

var Ele;

function LQ() {
    if (Ele) return On;
    Ele = 1, On.randomBytes = On.rng = On.pseudoRandomBytes = On.prng = FE, On.createHash = On.Hash = I8, On.createHmac = On.Hmac = zbe;
    var t = wtt, e = Object.keys(t), r = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(e);
    On.getHashes = function () {
        return r
    };
    var n = cN;
    On.pbkdf2 = n.pbkdf2, On.pbkdf2Sync = n.pbkdf2Sync;
    var i = hp;
    On.Cipher = i.Cipher, On.createCipher = i.createCipher, On.Cipheriv = i.Cipheriv, On.createCipheriv = i.createCipheriv, On.Decipher = i.Decipher, On.createDecipher = i.createDecipher, On.Decipheriv = i.Decipheriv, On.createDecipheriv = i.createDecipheriv, On.getCiphers = i.getCiphers, On.listCiphers = i.listCiphers;
    var a = ont();
    On.DiffieHellmanGroup = a.DiffieHellmanGroup, On.createDiffieHellmanGroup = a.createDiffieHellmanGroup, On.getDiffieHellman = a.getDiffieHellman, On.createDiffieHellman = a.createDiffieHellman, On.DiffieHellman = a.DiffieHellman;
    var o = yot();
    On.createSign = o.createSign, On.Sign = o.Sign, On.createVerify = o.createVerify, On.Verify = o.Verify, On.createECDH = bot();
    var s = _Se;
    On.publicEncrypt = s.publicEncrypt, On.privateEncrypt = s.privateEncrypt, On.publicDecrypt = s.publicDecrypt, On.privateDecrypt = s.privateDecrypt;
    var l = TT;
    return On.randomFill = l.randomFill, On.randomFillSync = l.randomFillSync, On.createCredentials = function () {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`))
    }, On.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    }, On
}

var OSe = {}, PSe = {}, zot = Ige, BQ = function () {
    return zot() && !!Symbol.toStringTag
}, Vot = BQ(), Hot = cX, Fq = Hot("Object.prototype.toString"), AN = function (e) {
    return Vot && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : Fq(e) === "[object Arguments]"
}, NSe = function (e) {
    return AN(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && Fq(e) !== "[object Array]" && Fq(e.callee) === "[object Function]"
}, Wot = function () {
    return AN(arguments)
}();
AN.isLegacyArguments = NSe;
var qot = Wot ? AN : NSe, Got = Object.prototype.toString, Kot = Function.prototype.toString,
    Yot = /^\s*(?:function)?\*/, LSe = BQ(), kz = Object.getPrototypeOf, Xot = function () {
        if (!LSe) return !1;
        try {
            return Function("return function*() {}")()
        } catch {
        }
    }, Rz, Qot = function (e) {
        if (typeof e != "function") return !1;
        if (Yot.test(Kot.call(e))) return !0;
        if (!LSe) {
            var r = Got.call(e);
            return r === "[object GeneratorFunction]"
        }
        if (!kz) return !1;
        if (typeof Rz > "u") {
            var n = Xot();
            Rz = n ? kz(n) : !1
        }
        return kz(e) === Rz
    }, BSe = Function.prototype.toString, Tx = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Uq, AD;
if (typeof Tx == "function" && typeof Object.defineProperty == "function") try {
    Uq = Object.defineProperty({}, "length", {
        get: function () {
            throw AD
        }
    }), AD = {}, Tx(function () {
        throw 42
    }, null, Uq)
} catch (t) {
    t !== AD && (Tx = null)
} else Tx = null;
var Zot = /^\s*class\b/, jq = function (e) {
        try {
            var r = BSe.call(e);
            return Zot.test(r)
        } catch {
            return !1
        }
    }, Dz = function (e) {
        try {
            return jq(e) ? !1 : (BSe.call(e), !0)
        } catch {
            return !1
        }
    }, ID = Object.prototype.toString, Jot = "[object Object]", est = "[object Function]",
    tst = "[object GeneratorFunction]", rst = "[object HTMLAllCollection]", nst = "[object HTML document.all class]",
    ist = "[object HTMLCollection]", ast = typeof Symbol == "function" && !!Symbol.toStringTag, ost = !(0 in [,]),
    zq = function () {
        return !1
    };
if (typeof document == "object") {
    var sst = document.all;
    ID.call(sst) === ID.call(document.all) && (zq = function (e) {
        if ((ost || !e) && (typeof e > "u" || typeof e == "object")) try {
            var r = ID.call(e);
            return (r === rst || r === nst || r === ist || r === Jot) && e("") == null
        } catch {
        }
        return !1
    })
}
var cst = Tx ? function (e) {
        if (zq(e)) return !0;
        if (!e || typeof e != "function" && typeof e != "object") return !1;
        try {
            Tx(e, null, Uq)
        } catch (r) {
            if (r !== AD) return !1
        }
        return !jq(e) && Dz(e)
    } : function (e) {
        if (zq(e)) return !0;
        if (!e || typeof e != "function" && typeof e != "object") return !1;
        if (ast) return Dz(e);
        if (jq(e)) return !1;
        var r = ID.call(e);
        return r !== est && r !== tst && !/^\[object HTML/.test(r) ? !1 : Dz(e)
    }, lst = cst, ust = Object.prototype.toString, $Se = Object.prototype.hasOwnProperty, fst = function (e, r, n) {
        for (var i = 0, a = e.length; i < a; i++) $Se.call(e, i) && (n == null ? r(e[i], i, e) : r.call(n, e[i], i, e))
    }, dst = function (e, r, n) {
        for (var i = 0, a = e.length; i < a; i++) n == null ? r(e.charAt(i), i, e) : r.call(n, e.charAt(i), i, e)
    }, hst = function (e, r, n) {
        for (var i in e) $Se.call(e, i) && (n == null ? r(e[i], i, e) : r.call(n, e[i], i, e))
    }, pst = function (e, r, n) {
        if (!lst(r)) throw new TypeError("iterator must be a function");
        var i;
        arguments.length >= 3 && (i = n), ust.call(e) === "[object Array]" ? fst(e, r, i) : typeof e == "string" ? dst(e, r, i) : hst(e, r, i)
    }, mst = pst,
    vst = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"],
    Mz = vst, gst = typeof globalThis > "u" ? tn : globalThis, yst = function () {
        for (var e = [], r = 0; r < Mz.length; r++) typeof gst[Mz[r]] == "function" && (e[e.length] = Mz[r]);
        return e
    }, sO = mst, bst = yst, Tle = Mge, $Q = cX, kD = sX, wst = $Q("Object.prototype.toString"), FSe = BQ(),
    Cle = typeof globalThis > "u" ? tn : globalThis, Vq = bst(), FQ = $Q("String.prototype.slice"),
    Oz = Object.getPrototypeOf, Sst = $Q("Array.prototype.indexOf", !0) || function (e, r) {
        for (var n = 0; n < e.length; n += 1) if (e[n] === r) return n;
        return -1
    }, cO = {__proto__: null};
FSe && kD && Oz ? sO(Vq, function (t) {
    var e = new Cle[t];
    if (Symbol.toStringTag in e) {
        var r = Oz(e), n = kD(r, Symbol.toStringTag);
        if (!n) {
            var i = Oz(r);
            n = kD(i, Symbol.toStringTag)
        }
        cO["$" + t] = Tle(n.get)
    }
}) : sO(Vq, function (t) {
    var e = new Cle[t], r = e.slice || e.set;
    r && (cO["$" + t] = Tle(r))
});
var _st = function (e) {
    var r = !1;
    return sO(cO, function (n, i) {
        if (!r) try {
            "$" + n(e) === i && (r = FQ(i, 1))
        } catch {
        }
    }), r
}, xst = function (e) {
    var r = !1;
    return sO(cO, function (n, i) {
        if (!r) try {
            n(e), r = FQ(i, 1)
        } catch {
        }
    }), r
}, USe = function (e) {
    if (!e || typeof e != "object") return !1;
    if (!FSe) {
        var r = FQ(wst(e), 8, -1);
        return Sst(Vq, r) > -1 ? r : r !== "Object" ? !1 : xst(e)
    }
    return kD ? _st(e) : null
}, Est = USe, Tst = function (e) {
    return !!Est(e)
};
(function (t) {
    var e = qot, r = Qot, n = USe, i = Tst;

    function a(Ue) {
        return Ue.call.bind(Ue)
    }

    var o = typeof BigInt < "u", s = typeof Symbol < "u", l = a(Object.prototype.toString),
        f = a(Number.prototype.valueOf), d = a(String.prototype.valueOf), p = a(Boolean.prototype.valueOf);
    if (o) var g = a(BigInt.prototype.valueOf);
    if (s) var b = a(Symbol.prototype.valueOf);

    function S(Ue, bt) {
        if (typeof Ue != "object") return !1;
        try {
            return bt(Ue), !0
        } catch {
            return !1
        }
    }

    t.isArgumentsObject = e, t.isGeneratorFunction = r, t.isTypedArray = i;

    function T(Ue) {
        return typeof Promise < "u" && Ue instanceof Promise || Ue !== null && typeof Ue == "object" && typeof Ue.then == "function" && typeof Ue.catch == "function"
    }

    t.isPromise = T;

    function I(Ue) {
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ue) : i(Ue) || Q(Ue)
    }

    t.isArrayBufferView = I;

    function N(Ue) {
        return n(Ue) === "Uint8Array"
    }

    t.isUint8Array = N;

    function P(Ue) {
        return n(Ue) === "Uint8ClampedArray"
    }

    t.isUint8ClampedArray = P;

    function F(Ue) {
        return n(Ue) === "Uint16Array"
    }

    t.isUint16Array = F;

    function V(Ue) {
        return n(Ue) === "Uint32Array"
    }

    t.isUint32Array = V;

    function Y(Ue) {
        return n(Ue) === "Int8Array"
    }

    t.isInt8Array = Y;

    function ee(Ue) {
        return n(Ue) === "Int16Array"
    }

    t.isInt16Array = ee;

    function oe(Ue) {
        return n(Ue) === "Int32Array"
    }

    t.isInt32Array = oe;

    function G(Ue) {
        return n(Ue) === "Float32Array"
    }

    t.isFloat32Array = G;

    function J(Ue) {
        return n(Ue) === "Float64Array"
    }

    t.isFloat64Array = J;

    function ce(Ue) {
        return n(Ue) === "BigInt64Array"
    }

    t.isBigInt64Array = ce;

    function re(Ue) {
        return n(Ue) === "BigUint64Array"
    }

    t.isBigUint64Array = re;

    function M(Ue) {
        return l(Ue) === "[object Map]"
    }

    M.working = typeof Map < "u" && M(new Map);

    function D(Ue) {
        return typeof Map > "u" ? !1 : M.working ? M(Ue) : Ue instanceof Map
    }

    t.isMap = D;

    function x(Ue) {
        return l(Ue) === "[object Set]"
    }

    x.working = typeof Set < "u" && x(new Set);

    function A(Ue) {
        return typeof Set > "u" ? !1 : x.working ? x(Ue) : Ue instanceof Set
    }

    t.isSet = A;

    function B(Ue) {
        return l(Ue) === "[object WeakMap]"
    }

    B.working = typeof WeakMap < "u" && B(new WeakMap);

    function z(Ue) {
        return typeof WeakMap > "u" ? !1 : B.working ? B(Ue) : Ue instanceof WeakMap
    }

    t.isWeakMap = z;

    function j(Ue) {
        return l(Ue) === "[object WeakSet]"
    }

    j.working = typeof WeakSet < "u" && j(new WeakSet);

    function $(Ue) {
        return j(Ue)
    }

    t.isWeakSet = $;

    function C(Ue) {
        return l(Ue) === "[object ArrayBuffer]"
    }

    C.working = typeof ArrayBuffer < "u" && C(new ArrayBuffer);

    function R(Ue) {
        return typeof ArrayBuffer > "u" ? !1 : C.working ? C(Ue) : Ue instanceof ArrayBuffer
    }

    t.isArrayBuffer = R;

    function k(Ue) {
        return l(Ue) === "[object DataView]"
    }

    k.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && k(new DataView(new ArrayBuffer(1), 0, 1));

    function Q(Ue) {
        return typeof DataView > "u" ? !1 : k.working ? k(Ue) : Ue instanceof DataView
    }

    t.isDataView = Q;
    var fe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;

    function ye(Ue) {
        return l(Ue) === "[object SharedArrayBuffer]"
    }

    function ue(Ue) {
        return typeof fe > "u" ? !1 : (typeof ye.working > "u" && (ye.working = ye(new fe)), ye.working ? ye(Ue) : Ue instanceof fe)
    }

    t.isSharedArrayBuffer = ue;

    function me(Ue) {
        return l(Ue) === "[object AsyncFunction]"
    }

    t.isAsyncFunction = me;

    function Se(Ue) {
        return l(Ue) === "[object Map Iterator]"
    }

    t.isMapIterator = Se;

    function Ce(Ue) {
        return l(Ue) === "[object Set Iterator]"
    }

    t.isSetIterator = Ce;

    function Me(Ue) {
        return l(Ue) === "[object Generator]"
    }

    t.isGeneratorObject = Me;

    function ve(Ue) {
        return l(Ue) === "[object WebAssembly.Module]"
    }

    t.isWebAssemblyCompiledModule = ve;

    function ne(Ue) {
        return S(Ue, f)
    }

    t.isNumberObject = ne;

    function be(Ue) {
        return S(Ue, d)
    }

    t.isStringObject = be;

    function Ee(Ue) {
        return S(Ue, p)
    }

    t.isBooleanObject = Ee;

    function Oe(Ue) {
        return o && S(Ue, g)
    }

    t.isBigIntObject = Oe;

    function ze(Ue) {
        return s && S(Ue, b)
    }

    t.isSymbolObject = ze;

    function Be(Ue) {
        return ne(Ue) || be(Ue) || Ee(Ue) || Oe(Ue) || ze(Ue)
    }

    t.isBoxedPrimitive = Be;

    function it(Ue) {
        return typeof Uint8Array < "u" && (R(Ue) || ue(Ue))
    }

    t.isAnyArrayBuffer = it, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (Ue) {
        Object.defineProperty(t, Ue, {
            enumerable: !1, value: function () {
                throw new Error(Ue + " is not supported in userland")
            }
        })
    })
})(PSe);
var Cst = function (e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function"
};
(function (t) {
    var e = Object.getOwnPropertyDescriptors || function (Q) {
        for (var fe = Object.keys(Q), ye = {}, ue = 0; ue < fe.length; ue++) ye[fe[ue]] = Object.getOwnPropertyDescriptor(Q, fe[ue]);
        return ye
    }, r = /%[sdj%]/g;
    t.format = function (k) {
        if (!Y(k)) {
            for (var Q = [], fe = 0; fe < arguments.length; fe++) Q.push(o(arguments[fe]));
            return Q.join(" ")
        }
        for (var fe = 1, ye = arguments, ue = ye.length, me = String(k).replace(r, function (Ce) {
            if (Ce === "%%") return "%";
            if (fe >= ue) return Ce;
            switch (Ce) {
                case"%s":
                    return String(ye[fe++]);
                case"%d":
                    return Number(ye[fe++]);
                case"%j":
                    try {
                        return JSON.stringify(ye[fe++])
                    } catch {
                        return "[Circular]"
                    }
                default:
                    return Ce
            }
        }), Se = ye[fe]; fe < ue; Se = ye[++fe]) P(Se) || !J(Se) ? me += " " + Se : me += " " + o(Se);
        return me
    }, t.deprecate = function (k, Q) {
        if (typeof Ve < "u" && Ve.noDeprecation === !0) return k;
        if (typeof Ve > "u") return function () {
            return t.deprecate(k, Q).apply(this, arguments)
        };
        var fe = !1;

        function ye() {
            if (!fe) {
                if (Ve.throwDeprecation) throw new Error(Q);
                Ve.traceDeprecation ? console.trace(Q) : console.error(Q), fe = !0
            }
            return k.apply(this, arguments)
        }

        return ye
    };
    var n = {}, i = /^$/;
    if (Ve.env.NODE_DEBUG) {
        var a = Ve.env.NODE_DEBUG;
        a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + a + "$", "i")
    }
    t.debuglog = function (k) {
        if (k = k.toUpperCase(), !n[k]) if (i.test(k)) {
            var Q = Ve.pid;
            n[k] = function () {
                var fe = t.format.apply(t, arguments);
                console.error("%s %d: %s", k, Q, fe)
            }
        } else n[k] = function () {
        };
        return n[k]
    };

    function o(k, Q) {
        var fe = {seen: [], stylize: l};
        return arguments.length >= 3 && (fe.depth = arguments[2]), arguments.length >= 4 && (fe.colors = arguments[3]), N(Q) ? fe.showHidden = Q : Q && t._extend(fe, Q), oe(fe.showHidden) && (fe.showHidden = !1), oe(fe.depth) && (fe.depth = 2), oe(fe.colors) && (fe.colors = !1), oe(fe.customInspect) && (fe.customInspect = !0), fe.colors && (fe.stylize = s), d(fe, k, fe.depth)
    }

    t.inspect = o, o.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39]
    }, o.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
    };

    function s(k, Q) {
        var fe = o.styles[Q];
        return fe ? "\x1B[" + o.colors[fe][0] + "m" + k + "\x1B[" + o.colors[fe][1] + "m" : k
    }

    function l(k, Q) {
        return k
    }

    function f(k) {
        var Q = {};
        return k.forEach(function (fe, ye) {
            Q[fe] = !0
        }), Q
    }

    function d(k, Q, fe) {
        if (k.customInspect && Q && M(Q.inspect) && Q.inspect !== t.inspect && !(Q.constructor && Q.constructor.prototype === Q)) {
            var ye = Q.inspect(fe, k);
            return Y(ye) || (ye = d(k, ye, fe)), ye
        }
        var ue = p(k, Q);
        if (ue) return ue;
        var me = Object.keys(Q), Se = f(me);
        if (k.showHidden && (me = Object.getOwnPropertyNames(Q)), re(Q) && (me.indexOf("message") >= 0 || me.indexOf("description") >= 0)) return g(Q);
        if (me.length === 0) {
            if (M(Q)) {
                var Ce = Q.name ? ": " + Q.name : "";
                return k.stylize("[Function" + Ce + "]", "special")
            }
            if (G(Q)) return k.stylize(RegExp.prototype.toString.call(Q), "regexp");
            if (ce(Q)) return k.stylize(Date.prototype.toString.call(Q), "date");
            if (re(Q)) return g(Q)
        }
        var Me = "", ve = !1, ne = ["{", "}"];
        if (I(Q) && (ve = !0, ne = ["[", "]"]), M(Q)) {
            var be = Q.name ? ": " + Q.name : "";
            Me = " [Function" + be + "]"
        }
        if (G(Q) && (Me = " " + RegExp.prototype.toString.call(Q)), ce(Q) && (Me = " " + Date.prototype.toUTCString.call(Q)), re(Q) && (Me = " " + g(Q)), me.length === 0 && (!ve || Q.length == 0)) return ne[0] + Me + ne[1];
        if (fe < 0) return G(Q) ? k.stylize(RegExp.prototype.toString.call(Q), "regexp") : k.stylize("[Object]", "special");
        k.seen.push(Q);
        var Ee;
        return ve ? Ee = b(k, Q, fe, Se, me) : Ee = me.map(function (Oe) {
            return S(k, Q, fe, Se, Oe, ve)
        }), k.seen.pop(), T(Ee, Me, ne)
    }

    function p(k, Q) {
        if (oe(Q)) return k.stylize("undefined", "undefined");
        if (Y(Q)) {
            var fe = "'" + JSON.stringify(Q).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return k.stylize(fe, "string")
        }
        if (V(Q)) return k.stylize("" + Q, "number");
        if (N(Q)) return k.stylize("" + Q, "boolean");
        if (P(Q)) return k.stylize("null", "null")
    }

    function g(k) {
        return "[" + Error.prototype.toString.call(k) + "]"
    }

    function b(k, Q, fe, ye, ue) {
        for (var me = [], Se = 0, Ce = Q.length; Se < Ce; ++Se) j(Q, String(Se)) ? me.push(S(k, Q, fe, ye, String(Se), !0)) : me.push("");
        return ue.forEach(function (Me) {
            Me.match(/^\d+$/) || me.push(S(k, Q, fe, ye, Me, !0))
        }), me
    }

    function S(k, Q, fe, ye, ue, me) {
        var Se, Ce, Me;
        if (Me = Object.getOwnPropertyDescriptor(Q, ue) || {value: Q[ue]}, Me.get ? Me.set ? Ce = k.stylize("[Getter/Setter]", "special") : Ce = k.stylize("[Getter]", "special") : Me.set && (Ce = k.stylize("[Setter]", "special")), j(ye, ue) || (Se = "[" + ue + "]"), Ce || (k.seen.indexOf(Me.value) < 0 ? (P(fe) ? Ce = d(k, Me.value, null) : Ce = d(k, Me.value, fe - 1), Ce.indexOf(`
`) > -1 && (me ? Ce = Ce.split(`
`).map(function (ve) {
            return "  " + ve
        }).join(`
`).slice(2) : Ce = `
` + Ce.split(`
`).map(function (ve) {
            return "   " + ve
        }).join(`
`))) : Ce = k.stylize("[Circular]", "special")), oe(Se)) {
            if (me && ue.match(/^\d+$/)) return Ce;
            Se = JSON.stringify("" + ue), Se.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Se = Se.slice(1, -1), Se = k.stylize(Se, "name")) : (Se = Se.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Se = k.stylize(Se, "string"))
        }
        return Se + ": " + Ce
    }

    function T(k, Q, fe) {
        var ye = k.reduce(function (ue, me) {
            return me.indexOf(`
`) >= 0, ue + me.replace(/\u001b\[\d\d?m/g, "").length + 1
        }, 0);
        return ye > 60 ? fe[0] + (Q === "" ? "" : Q + `
 `) + " " + k.join(`,
  `) + " " + fe[1] : fe[0] + Q + " " + k.join(", ") + " " + fe[1]
    }

    t.types = PSe;

    function I(k) {
        return Array.isArray(k)
    }

    t.isArray = I;

    function N(k) {
        return typeof k == "boolean"
    }

    t.isBoolean = N;

    function P(k) {
        return k === null
    }

    t.isNull = P;

    function F(k) {
        return k == null
    }

    t.isNullOrUndefined = F;

    function V(k) {
        return typeof k == "number"
    }

    t.isNumber = V;

    function Y(k) {
        return typeof k == "string"
    }

    t.isString = Y;

    function ee(k) {
        return typeof k == "symbol"
    }

    t.isSymbol = ee;

    function oe(k) {
        return k === void 0
    }

    t.isUndefined = oe;

    function G(k) {
        return J(k) && x(k) === "[object RegExp]"
    }

    t.isRegExp = G, t.types.isRegExp = G;

    function J(k) {
        return typeof k == "object" && k !== null
    }

    t.isObject = J;

    function ce(k) {
        return J(k) && x(k) === "[object Date]"
    }

    t.isDate = ce, t.types.isDate = ce;

    function re(k) {
        return J(k) && (x(k) === "[object Error]" || k instanceof Error)
    }

    t.isError = re, t.types.isNativeError = re;

    function M(k) {
        return typeof k == "function"
    }

    t.isFunction = M;

    function D(k) {
        return k === null || typeof k == "boolean" || typeof k == "number" || typeof k == "string" || typeof k == "symbol" || typeof k > "u"
    }

    t.isPrimitive = D, t.isBuffer = Cst;

    function x(k) {
        return Object.prototype.toString.call(k)
    }

    function A(k) {
        return k < 10 ? "0" + k.toString(10) : k.toString(10)
    }

    var B = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    function z() {
        var k = new Date, Q = [A(k.getHours()), A(k.getMinutes()), A(k.getSeconds())].join(":");
        return [k.getDate(), B[k.getMonth()], Q].join(" ")
    }

    t.log = function () {
        console.log("%s - %s", z(), t.format.apply(t, arguments))
    }, t.inherits = Xn, t._extend = function (k, Q) {
        if (!Q || !J(Q)) return k;
        for (var fe = Object.keys(Q), ye = fe.length; ye--;) k[fe[ye]] = Q[fe[ye]];
        return k
    };

    function j(k, Q) {
        return Object.prototype.hasOwnProperty.call(k, Q)
    }

    var $ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    t.promisify = function (Q) {
        if (typeof Q != "function") throw new TypeError('The "original" argument must be of type Function');
        if ($ && Q[$]) {
            var fe = Q[$];
            if (typeof fe != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(fe, $, {value: fe, enumerable: !1, writable: !1, configurable: !0}), fe
        }

        function fe() {
            for (var ye, ue, me = new Promise(function (Me, ve) {
                ye = Me, ue = ve
            }), Se = [], Ce = 0; Ce < arguments.length; Ce++) Se.push(arguments[Ce]);
            Se.push(function (Me, ve) {
                Me ? ue(Me) : ye(ve)
            });
            try {
                Q.apply(this, Se)
            } catch (Me) {
                ue(Me)
            }
            return me
        }

        return Object.setPrototypeOf(fe, Object.getPrototypeOf(Q)), $ && Object.defineProperty(fe, $, {
            value: fe,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }), Object.defineProperties(fe, e(Q))
    }, t.promisify.custom = $;

    function C(k, Q) {
        if (!k) {
            var fe = new Error("Promise was rejected with a falsy value");
            fe.reason = k, k = fe
        }
        return Q(k)
    }

    function R(k) {
        if (typeof k != "function") throw new TypeError('The "original" argument must be of type Function');

        function Q() {
            for (var fe = [], ye = 0; ye < arguments.length; ye++) fe.push(arguments[ye]);
            var ue = fe.pop();
            if (typeof ue != "function") throw new TypeError("The last argument must be of type Function");
            var me = this, Se = function () {
                return ue.apply(me, arguments)
            };
            k.apply(this, fe).then(function (Ce) {
                Ve.nextTick(Se.bind(null, null, Ce))
            }, function (Ce) {
                Ve.nextTick(C.bind(null, Ce, Se))
            })
        }

        return Object.setPrototypeOf(Q, Object.getPrototypeOf(k)), Object.defineProperties(Q, e(k)), Q
    }

    t.callbackify = R
})(OSe);
var Ast = qr, Ist = LQ(), jSe = OSe, cp = Ast.Buffer, kst = new UQ(4096), Rst = /^[A-Za-z_][A-Za-z0-9_]*$/,
    Dst = jSe.format;

function dA(t) {
    return typeof cp.alloc == "function" ? cp.alloc(t) : new cp(t)
}

function zSe(t, e) {
    return typeof cp.from == "function" ? cp.from(t, e) : new cp(t, e)
}

function VSe(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}

function Mst(t, e) {
    return t === e ? 0 : t < e ? -1 : 1
}

function Ost(t, e, r) {
    var n = t[e];
    return n === void 0 ? r : n
}

function Pst(t, e) {
    e = e || "md5";
    var r = Ist.createHash(e);
    return r.end(t), r.read()
}

function Nst(t, e) {
    var r = -1, n, i;
    if (!t) return -1;
    for (n = 0, i = t.length; n < i; n++) if (t[n] === e) {
        if (r >= 0) return -2;
        r = n
    }
    return r
}

function Lst(t, e) {
    var r = {}, n, i;
    for (n = 0; n < t.length; n++) i = t[n], r[e(i)] = i;
    return r
}

function Bst(t) {
    return Object.keys(t).map(function (e) {
        return t[e]
    })
}

function $st(t, e) {
    var r = Object.create(null), n, i, a;
    for (n = 0, i = t.length; n < i; n++) {
        if (a = t[n], e && (a = e(a)), r[a]) return !0;
        r[a] = !0
    }
    return !1
}

function Fst(t, e, r) {
    var n = Object.getOwnPropertyNames(t), i, a, o;
    for (i = 0, a = n.length; i < a; i++) if (o = n[i], !e.hasOwnProperty(o) || r) {
        var s = Object.getOwnPropertyDescriptor(t, o);
        Object.defineProperty(e, o, s)
    }
    return e
}

function HSe(t) {
    return Rst.test(t)
}

function Ust(t, e) {
    return ~t.indexOf(".") ? t = t.replace(/^\./, "") : e && (t = e + "." + t), t.split(".").forEach(function (r) {
        if (!HSe(r)) throw new Error(Dst("invalid name: %j", t))
    }), t
}

function jst(t) {
    var e = t.split(".");
    return e[e.length - 1]
}

function zst(t) {
    var e = /^(.*)\.[^.]+$/.exec(t);
    return e ? e[1] : void 0
}

function Vst(t, e) {
    e = e | 0;
    var r = t.charAt(e++);
    if (/[\d-]/.test(r)) {
        for (; /[eE\d.+-]/.test(t.charAt(e));) e++;
        return e
    } else {
        if (/true|null/.test(t.slice(e - 1, e + 3))) return e + 3;
        if (/false/.test(t.slice(e - 1, e + 4))) return e + 4
    }
    var n = 0, i = !1;
    do switch (r) {
        case"{":
        case"[":
            i || n++;
            break;
        case"}":
        case"]":
            if (!i && !--n) return e;
            break;
        case'"':
            if (i = !i, !n && !i) return e;
            break;
        case"\\":
            e++
    } while (r = t.charAt(e++));
    return -1
}

function Hst() {
    throw new Error("abstract")
}

function Wst(t, e) {
    var r = t.prototype, n, i, a, o;
    for (n = 0, i = e.length; n < i; n++) a = e[n], o = "get" + VSe(a), r[o] = jSe.deprecate(s(a), "use `." + a + "` instead of `." + o + "()`");

    function s(l) {
        return function () {
            var f = this[l];
            return typeof f == "function" ? f.apply(this, arguments) : f
        }
    }
}

function UQ(t) {
    this._len = t | 0, this._pos = 0, this._slab = dA(this._len)
}

UQ.prototype.alloc = function (t) {
    if (t < 0) throw new Error("negative length");
    var e = this._len;
    return t > e ? dA(t) : (this._pos + t > e && (this._slab = dA(e), this._pos = 0), this._slab.slice(this._pos, this._pos += t))
};

function FS(t) {
    var e = 1103515245, r = 12345, n = Math.pow(2, 31), i = Math.floor(t || Math.random() * (n - 1));
    this._max = n, this._nextInt = function () {
        return i = (e * i + r) % n
    }
}

FS.prototype.nextBoolean = function () {
    return !!(this._nextInt() % 2)
};
FS.prototype.nextInt = function (t, e) {
    return e === void 0 && (e = t, t = 0), e = e === void 0 ? this._max : e, t + Math.floor(this.nextFloat() * (e - t))
};
FS.prototype.nextFloat = function (t, e) {
    return e === void 0 && (e = t, t = 0), e = e === void 0 ? 1 : e, t + (e - t) * this._nextInt() / this._max
};
FS.prototype.nextString = function (t, e) {
    t |= 0, e = e || "aA";
    var r = "";
    e.indexOf("a") > -1 && (r += "abcdefghijklmnopqrstuvwxyz"), e.indexOf("A") > -1 && (r += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), e.indexOf("#") > -1 && (r += "0123456789"), e.indexOf("!") > -1 && (r += "~`!@#$%^&*()_+-={}[]:\";'<>?,./|\\");
    for (var n = [], i = 0; i < t; i++) n.push(this.choice(r));
    return n.join("")
};
FS.prototype.nextBuffer = function (t) {
    var e = [], r;
    for (r = 0; r < t; r++) e.push(this.nextInt(256));
    return zSe(e)
};
FS.prototype.choice = function (t) {
    var e = t.length;
    if (!e) throw new Error("choosing from empty array");
    return t[this.nextInt(e)]
};

function jQ() {
    this._index = 0, this._items = []
}

jQ.prototype.push = function (t) {
    var e = this._items, r = e.length | 0, n;
    for (e.push(t); r > 0 && e[r].index < e[n = r - 1 >> 1].index;) t = e[r], e[r] = e[n], e[n] = t, r = n
};
jQ.prototype.pop = function () {
    var t = this._items, e = t.length - 1 | 0, r = t[0];
    if (!r || r.index > this._index) return null;
    if (this._index++, !e) return t.pop(), r;
    t[0] = t.pop();
    for (var n = e >> 1, i = 0, a, o, s, l, f, d, p; i < n && (l = t[i], a = (i << 1) + 1, o = i + 1 << 1, d = t[a], p = t[o], !p || d.index <= p.index ? (f = d, s = a) : (f = p, s = o), !(f.index >= l.index));) t[s] = l, t[i] = f, i = s;
    return r
};

function Ln(t, e) {
    if (this.buf = t, this.pos = e | 0, this.pos < 0) throw new Error("negative offset")
}

Ln.prototype.isValid = function () {
    return this.pos <= this.buf.length
};
Ln.prototype._invalidate = function () {
    this.pos = this.buf.length + 1
};
Ln.prototype.readBoolean = function () {
    return !!this.buf[this.pos++]
};
Ln.prototype.skipBoolean = function () {
    this.pos++
};
Ln.prototype.writeBoolean = function (t) {
    this.buf[this.pos++] = !!t
};
Ln.prototype.readInt = Ln.prototype.readLong = function () {
    var t = 0, e = 0, r = this.buf, n, i, a, o;
    do n = r[this.pos++], i = n & 128, t |= (n & 127) << e, e += 7; while (i && e < 28);
    if (i) {
        a = t, o = 268435456;
        do n = r[this.pos++], a += (n & 127) * o, o *= 128; while (n & 128);
        return (a % 2 ? -(a + 1) : a) / 2
    }
    return t >> 1 ^ -(t & 1)
};
Ln.prototype.skipInt = Ln.prototype.skipLong = function () {
    for (var t = this.buf; t[this.pos++] & 128;) ;
};
Ln.prototype.writeInt = Ln.prototype.writeLong = function (t) {
    var e = this.buf, r, n;
    if (t >= -1073741824 && t < 1073741824) {
        n = t >= 0 ? t << 1 : ~t << 1 | 1;
        do e[this.pos] = n & 127, n >>= 7; while (n && (e[this.pos++] |= 128))
    } else {
        r = t >= 0 ? t * 2 : -t * 2 - 1;
        do e[this.pos] = r & 127, r /= 128; while (r >= 1 && (e[this.pos++] |= 128))
    }
    this.pos++
};
Ln.prototype.readFloat = function () {
    var t = this.buf, e = this.pos;
    return this.pos += 4, this.pos > t.length ? 0 : this.buf.readFloatLE(e)
};
Ln.prototype.skipFloat = function () {
    this.pos += 4
};
Ln.prototype.writeFloat = function (t) {
    var e = this.buf, r = this.pos;
    if (this.pos += 4, !(this.pos > e.length)) return this.buf.writeFloatLE(t, r)
};
Ln.prototype.readDouble = function () {
    var t = this.buf, e = this.pos;
    return this.pos += 8, this.pos > t.length ? 0 : this.buf.readDoubleLE(e)
};
Ln.prototype.skipDouble = function () {
    this.pos += 8
};
Ln.prototype.writeDouble = function (t) {
    var e = this.buf, r = this.pos;
    if (this.pos += 8, !(this.pos > e.length)) return this.buf.writeDoubleLE(t, r)
};
Ln.prototype.readFixed = function (t) {
    var e = this.pos;
    if (this.pos += t, !(this.pos > this.buf.length)) {
        var r = kst.alloc(t);
        return this.buf.copy(r, 0, e, e + t), r
    }
};
Ln.prototype.skipFixed = function (t) {
    this.pos += t
};
Ln.prototype.writeFixed = function (t, e) {
    e = e || t.length;
    var r = this.pos;
    this.pos += e, !(this.pos > this.buf.length) && t.copy(this.buf, r, 0, e)
};
Ln.prototype.readBytes = function () {
    var t = this.readLong();
    if (t < 0) {
        this._invalidate();
        return
    }
    return this.readFixed(t)
};
Ln.prototype.skipBytes = function () {
    var t = this.readLong();
    if (t < 0) {
        this._invalidate();
        return
    }
    this.pos += t
};
Ln.prototype.writeBytes = function (t) {
    var e = t.length;
    this.writeLong(e), this.writeFixed(t, e)
};
typeof cp.prototype.utf8Slice == "function" ? Ln.prototype.readString = function () {
    var t = this.readLong();
    if (t < 0) return this._invalidate(), "";
    var e = this.pos, r = this.buf;
    if (this.pos += t, !(this.pos > r.length)) return this.buf.utf8Slice(e, e + t)
} : Ln.prototype.readString = function () {
    var t = this.readLong();
    if (t < 0) return this._invalidate(), "";
    var e = this.pos, r = this.buf;
    if (this.pos += t, !(this.pos > r.length)) return this.buf.slice(e, e + t).toString()
};
Ln.prototype.skipString = function () {
    var t = this.readLong();
    if (t < 0) {
        this._invalidate();
        return
    }
    this.pos += t
};
Ln.prototype.writeString = function (t) {
    var e = cp.byteLength(t), r = this.buf;
    this.writeLong(e);
    var n = this.pos;
    if (this.pos += e, !(this.pos > r.length)) if (e > 64 && typeof cp.prototype.utf8Write == "function") r.utf8Write(t, n, e); else {
        var i, a, o, s;
        for (i = 0, a = e; i < a; i++) o = t.charCodeAt(i), o < 128 ? r[n++] = o : o < 2048 ? (r[n++] = o >> 6 | 192, r[n++] = o & 63 | 128) : (o & 64512) === 55296 && ((s = t.charCodeAt(i + 1)) & 64512) === 56320 ? (o = 65536 + ((o & 1023) << 10) + (s & 1023), i++, r[n++] = o >> 18 | 240, r[n++] = o >> 12 & 63 | 128, r[n++] = o >> 6 & 63 | 128, r[n++] = o & 63 | 128) : (r[n++] = o >> 12 | 224, r[n++] = o >> 6 & 63 | 128, r[n++] = o & 63 | 128)
    }
};
typeof cp.prototype.latin1Write == "function" ? Ln.prototype.writeBinary = function (t, e) {
    var r = this.pos;
    this.pos += e, !(this.pos > this.buf.length) && this.buf.latin1Write(t, r, e)
} : typeof cp.prototype.binaryWrite == "function" ? Ln.prototype.writeBinary = function (t, e) {
    var r = this.pos;
    this.pos += e, !(this.pos > this.buf.length) && this.buf.binaryWrite(t, r, e)
} : Ln.prototype.writeBinary = function (t, e) {
    var r = this.pos;
    this.pos += e, !(this.pos > this.buf.length) && this.buf.write(t, r, e, "binary")
};
Ln.prototype.matchBoolean = function (t) {
    return this.buf[this.pos++] - t.buf[t.pos++]
};
Ln.prototype.matchInt = Ln.prototype.matchLong = function (t) {
    var e = this.readLong(), r = t.readLong();
    return e === r ? 0 : e < r ? -1 : 1
};
Ln.prototype.matchFloat = function (t) {
    var e = this.readFloat(), r = t.readFloat();
    return e === r ? 0 : e < r ? -1 : 1
};
Ln.prototype.matchDouble = function (t) {
    var e = this.readDouble(), r = t.readDouble();
    return e === r ? 0 : e < r ? -1 : 1
};
Ln.prototype.matchFixed = function (t, e) {
    return this.readFixed(e).compare(t.readFixed(e))
};
Ln.prototype.matchBytes = Ln.prototype.matchString = function (t) {
    var e = this.readLong(), r = this.pos;
    this.pos += e;
    var n = t.readLong(), i = t.pos;
    t.pos += n;
    var a = this.buf.slice(r, this.pos), o = t.buf.slice(i, t.pos);
    return a.compare(o)
};
Ln.prototype.unpackLongBytes = function () {
    var t = dA(8), e = 0, r = 0, n = 6, i = this.buf, a, o;
    for (a = i[this.pos++], o = a & 1, t.fill(0), e |= (a & 127) >> 1; a & 128;) a = i[this.pos++], e |= (a & 127) << n, n += 7, n >= 8 && (n -= 8, t[r++] = e, e >>= 8);
    return t[r] = e, o && Hq(t, 8), t
};
Ln.prototype.packLongBytes = function (t) {
    var e = (t[7] & 128) >> 7, r = this.buf, n = 1, i = 0, a = 3, o;
    e ? (Hq(t, 8), o = 1) : o = 0;
    for (var s = [t.readUIntLE(0, 3), t.readUIntLE(3, 3), t.readUIntLE(6, 2)]; a && !s[--a];) ;
    for (; i < a;) for (o |= s[i++] << n, n += 24; n > 7;) r[this.pos++] = o & 127 | 128, o >>= 7, n -= 7;
    o |= s[a] << n;
    do r[this.pos] = o & 127, o >>= 7; while (o && (r[this.pos++] |= 128));
    this.pos++, e && Hq(t, 8)
};

function Hq(t, e) {
    for (; e--;) t[e] = ~t[e]
}

var CT = {
    abstractFunction: Hst,
    addDeprecatedGetters: Wst,
    bufferFrom: zSe,
    capitalize: VSe,
    copyOwnProperties: Fst,
    getHash: Pst,
    compare: Mst,
    getOption: Ost,
    impliedNamespace: zst,
    isValidName: HSe,
    jsonEnd: Vst,
    newBuffer: dA,
    objectValues: Bst,
    qualify: Ust,
    toMap: Lst,
    singleIndexOf: Nst,
    hasDuplicates: $st,
    unqualify: jst,
    BufferPool: UQ,
    Lcg: FS,
    OrderedQueue: jQ,
    Tap: Ln
};

function hA(t, e) {
    if (t === e) return {ok: !0, result: e};
    if (Dv(t) && Dv(e)) {
        const r = Object.keys(e), n = Object.keys(t).filter(a => r.includes(a)), i = {...t, ...e};
        for (const a of n) {
            const o = hA(t[a], e[a]);
            if (!o.ok) return {ok: !1};
            i[a] = o.result
        }
        return {ok: !0, result: i}
    }
    if (Rv(t) && Rv(e)) {
        if (t.length !== e.length) return {ok: !1};
        const r = [];
        for (let n = 0; n < t.length; n++) {
            const i = hA(t[n], e[n]);
            if (!i.ok) return {ok: !1};
            r.push(i.result)
        }
        return {ok: !0, result: r}
    }
    return t instanceof Date && e instanceof Date && t.toISOString() === e.toISOString() ? {
        ok: !0,
        result: t
    } : {ok: !1}
}

const Q_ = new CT.Tap(qr.Buffer.allocUnsafeSlow(1024));

class ef extends Error {
    constructor(r) {
        super();
        Ft(this, "issues");
        this.name = "AVSCError", Object.setPrototypeOf(this, ef.prototype), this.issues = Rv(r.issues) ? r.issues : [r.issues]
    }
}

function qst(t, e) {
    return t instanceof ef ? t : new ef({issues: {type: "error", cause: t, path: e}})
}

let bu = class {
    constructor() {
        Ft(this, "_decoded")
    }

    toBuffer(e) {
        Q_.pos = 0, this.write(Q_, e, []);
        const r = CT.newBuffer(Q_.pos);
        return Q_.isValid() ? Q_.buf.copy(r, 0, 0, Q_.pos) : this.write(new CT.Tap(r), e, []), r
    }

    fromBuffer(e) {
        const r = new CT.Tap(e), n = this.read(r, []);
        if (r.pos !== e.length) throw new ef({issues: {type: "mismatch", message: "Buffer and tap lengths mismatch"}});
        return n
    }

    safeFromBuffer(e) {
        try {
            return {ok: !0, value: this.fromBuffer(e)}
        } catch (r) {
            return {ok: !1, error: $f(r)}
        }
    }

    encode(e, r) {
        return this.toBuffer(e).toString(r)
    }

    decode(e, r) {
        return this.fromBuffer(CT.bufferFrom(e, r))
    }

    transform(e, r, n) {
        return new Gst(this, e, r, n)
    }

    optional() {
        return cct(this)
    }

    nullable() {
        return lct(this)
    }

    or(e) {
        return US([this, e])
    }

    extend(e) {
        return new RD({...this.fields, ...e})
    }

    pick(e) {
        const r = {};
        for (const [n, i] of Object.entries(this.fields)) e[n] === !0 && (r[n] = i);
        return new RD(r)
    }

    omit(e) {
        const r = {};
        for (const [n, i] of Object.entries(this.fields)) e[n] !== !0 && (r[n] = i);
        return new RD(r)
    }
}, Gst = class extends bu {
    constructor(e, r, n, i) {
        super(), this.source = e, this.deserialize = r, this.serialize = n, this.is = i
    }

    read(e, r) {
        try {
            return this.deserialize(this.source.read(e, r), r)
        } catch (n) {
            throw qst(n, r)
        }
    }

    write(e, r, n) {
        this.source.write(e, this.serialize(r, n), n)
    }
}, Kst = class extends bu {
    read() {
        return null
    }

    write() {
    }

    is(e) {
        return e === null
    }
};
const WSe = () => new Kst;
let Yst = class extends bu {
    read() {
    }

    write() {
    }

    is(e) {
        return e === void 0
    }
};

function zQ() {
    return new Yst
}

let Xst = class extends bu {
    read(e) {
        return e.readDouble()
    }

    write(e, r) {
        e.writeDouble(r)
    }

    is(e) {
        return typeof e == "number"
    }
};
const Xt = () => new Xst;

class Qst extends bu {
    read(e) {
        return e.readBoolean()
    }

    write(e, r) {
        e.writeBoolean(r)
    }

    is(e) {
        return typeof e == "boolean"
    }
}

const Gu = () => new Qst;
let Zst = class Wq extends bu {
    constructor(r) {
        super();
        Ft(this, "minLengthValue");
        Ft(this, "maxLengthValue");
        this.minLengthValue = r == null ? void 0 : r.minLength, this.maxLengthValue = r == null ? void 0 : r.maxLength
    }

    read(r, n) {
        const i = r.readString();
        return this.assert(i, n), i
    }

    write(r, n, i) {
        this.assert(n, i), r.writeString(n)
    }

    is(r) {
        try {
            return this.assert(r, []), !0
        } catch {
            return !1
        }
    }

    minLength(r) {
        return new Wq({minLength: r})
    }

    maxLength(r) {
        return new Wq({maxLength: r})
    }

    assert(r, n) {
        if (typeof r != "string") throw new ef({issues: {type: "string", received: r, path: n}});
        const i = [];
        if (this.minLengthValue !== void 0 && r.length < this.minLengthValue && i.push({
            type: "validation",
            received: r,
            message: `String length is less than ${this.minLengthValue}`,
            path: n
        }), this.maxLengthValue !== void 0 && r.length > this.maxLengthValue && i.push({
            type: "validation",
            received: r,
            message: `String length is greater than ${this.maxLengthValue}`,
            path: n
        }), au(i)) throw new ef({issues: i})
    }
};
const kt = () => new Zst, V4 = () => kt().transform(t => new URL(t), t => t.toString(), t => t instanceof URL);
let Jst = class extends bu {
    constructor(e) {
        super(), this.value = e
    }

    read(e) {
        let r;
        switch (typeof this.value) {
            case"string": {
                r = e.readString();
                break
            }
            case"number": {
                r = e.readDouble();
                break
            }
            case"boolean": {
                r = e.readBoolean();
                break
            }
        }
        if (this.is(r)) return r;
        throw new ef({issues: {type: "literal", expected: this.value, received: r, path: []}})
    }

    write(e, r) {
        switch (typeof r) {
            case"string":
                return e.writeString(r);
            case"number":
                return e.writeDouble(r);
            case"boolean":
                return e.writeBoolean(r)
        }
    }

    is(e) {
        return e === this.value
    }
};
const Bs = t => new Jst(t);
let ect = class extends bu {
    constructor(e) {
        super(), this.values = e
    }

    read(e, r) {
        const n = e.readString();
        if (this.is(n)) return n;
        throw new ef({issues: {type: "enum", expected: this.values, received: n, path: r}})
    }

    write(e, r) {
        e.writeString(r)
    }

    is(e) {
        return this.values.includes(e)
    }
};
const KE = t => new ect(t);
let RD = class extends bu {
    constructor(r) {
        super();
        Ft(this, "keys");
        this.fields = r, this.keys = Object.keys(r)
    }

    write(r, n, i) {
        var a;
        for (const o of this.keys) {
            const s = n;
            (a = this.fields[o]) == null || a.write(r, s[o], [...i, o])
        }
    }

    read(r, n) {
        const i = {};
        for (const a of this.keys) {
            const o = this.fields[a];
            o !== void 0 && (i[a] = o.read(r, [...n, a]))
        }
        return i
    }

    is(r) {
        var n;
        if (Dv(r)) {
            for (const i of this.keys) if (!((n = this.fields[i]) != null && n.is(r[i]))) return !1;
            return !0
        }
        return !1
    }
};
const Gr = t => new RD(t);

class qSe extends bu {
    constructor(e) {
        super(), this.schemas = e
    }

    is(e) {
        for (const r of this.schemas) if (r.is(e)) return !0;
        return !1
    }

    read(e, r) {
        const n = e.readLong(), i = this.schemas[n];
        if (!i) throw new ef({
            issues: {
                type: "error",
                cause: `Cannot read union "${this.toString()}" - schema with index "${n}" not found`,
                path: r
            }
        });
        const a = i.read(e, r);
        if (this.is(a)) return a;
        throw new ef({
            issues: {
                type: "error",
                cause: `Cannot read union "${this.toString()}" for value "${a}"`,
                path: r
            }
        })
    }

    write(e, r, n) {
        var a;
        const i = this.schemas.findIndex(o => o.is(r));
        if (i === -1) throw new ef({
            issues: {
                type: "error",
                cause: `Cannot write union "${this.toString()}" for value "${r}"`,
                path: n
            }
        });
        e.writeLong(i), (a = this.schemas[i]) == null || a.write(e, r, n)
    }
}

const tct = t => t instanceof qSe;

function US(t) {
    const e = [];
    for (const r of t) tct(r) ? e.push(...r.schemas) : e.push(r);
    return new qSe(e)
}

class rct extends bu {
    constructor(e) {
        super(), this.schemas = e
    }

    is(e) {
        for (const r of this.schemas) if (!r.is(e)) return !1;
        return !0
    }

    read(e, r) {
        let n;
        for (const i of this.schemas) {
            const a = i.read(e, r);
            if (n === void 0) n = a; else {
                const o = hA(n, a);
                if (o.ok) n = o.result; else throw new ef({
                    issues: {
                        type: "error",
                        cause: "Cannot read intersection part",
                        path: r
                    }
                })
            }
        }
        return n
    }

    write(e, r, n) {
        for (const i of this.schemas) i.write(e, r, n)
    }
}

const nct = t => new rct(t);
let ict = class GSe extends bu {
    constructor(e, r) {
        super(), this.item = e, this.cardinality = r
    }

    write(e, r, n) {
        e.writeLong(r.length), r.forEach((i, a) => this.item.write(e, i, [...n, `${a}`]))
    }

    read(e, r) {
        const n = [], i = e.readLong();
        for (let a = 0; a < i; a++) n.push(this.item.read(e, [...r, `${a}`]));
        if (this.cardinality === "single") return n;
        if (au(n)) return n;
        throw new ef({
            issues: {
                type: "error",
                cause: `Cannot read array with cardinality "${this.cardinality}"`,
                path: r
            }
        })
    }

    is(e) {
        if (!Array.isArray(e)) return !1;
        for (let r = 0; r < e.length; r++) if (!this.item.is(e[r])) return !1;
        return this.cardinality === "single" ? !0 : !!au(e)
    }

    nonempty() {
        return this.cardinality === "at-least-one" ? this : new GSe(this.item, "at-least-one")
    }
};
const Ci = t => new ict(t, "single");

class act extends bu {
    constructor(e, r) {
        super(), this.key = e, this.value = r
    }

    write(e, r, n) {
        const i = VP(r);
        e.writeLong(i.length);
        for (const a of i) {
            const o = [...n, a];
            this.key.write(e, a, o), this.value.write(e, r[a], [...n, a])
        }
    }

    read(e, r) {
        const n = {}, i = e.readLong();
        for (let a = 0; a < i; a++) {
            const o = this.key.read(e, [...r, `key_${a}`]), s = this.value.read(e, [...r, o]);
            n[o] = s
        }
        return n
    }

    is(e) {
        if (Dv(e)) {
            for (const r of Object.keys(e)) if (!this.key.is(r) || !this.value.is(e[r])) return !1;
            return !0
        }
        return !1
    }
}

const qq = (t, e) => new act(t, e);

class oct extends bu {
    write(e, r) {
        e.writeLong(r.getTime())
    }

    read(e) {
        return new Date(e.readLong())
    }

    is(e) {
        return e instanceof Date
    }
}

const Ns = () => new oct;

class sct extends bu {
    write(e, r) {
        e.writeBytes(r)
    }

    read(e) {
        return e.readBytes()
    }

    is(e) {
        return qr.Buffer.isBuffer(e)
    }
}

const Gq = () => new sct;

function cct(t) {
    return US([zQ(), t])
}

function lct(t) {
    return US([WSe(), t])
}

class ya extends Error {
    constructor(r) {
        super();
        Ft(this, "issues");
        this.name = "JSONError", Object.setPrototypeOf(this, ya.prototype), this.issues = Rv(r.issues) ? r.issues : [r.issues]
    }
}

class wu {
    constructor() {
        Ft(this, "_encoded");
        Ft(this, "_decoded")
    }

    encode(e) {
        return this.write(e, [])
    }

    decode(e) {
        return this.read(e, [])
    }

    safeDecode(e) {
        try {
            return {ok: !0, value: this.decode(e)}
        } catch (r) {
            if (r instanceof Error) return {ok: !1, error: r};
            throw r
        }
    }

    transform(e, r, n) {
        return typeof n == "function" ? new Ale(this, e, r, n) : new Ale(this, e, r, i => n.is(i))
    }

    migrate(e, r) {
        return new dct(this, typeof e == "function" ? e(this) : e, r)
    }

    pipe(e) {
        return this.transform(r => e.decode(r), r => e.encode(r), e)
    }

    or(e) {
        return t4([this, e])
    }

    optional() {
        return t4([YSe(), this])
    }

    nullable() {
        return t4([KSe(), this])
    }

    catchDecode(e) {
        return new uct(this, e)
    }

    catchEncode(e) {
        return new fct(this, e)
    }

    catch(e) {
        return this.catchEncode(e).catchDecode(e)
    }
}

class uct extends wu {
    constructor(r, n) {
        super();
        Ft(this, "is", r => this.source.is(r));
        this.source = r, this.fallback = n
    }

    read(r, n) {
        try {
            return this.source.read(r, n)
        } catch (i) {
            return this.fallback({error: i, input: r})
        }
    }

    write(r, n) {
        return this.source.write(r, n)
    }
}

class fct extends wu {
    constructor(r, n) {
        super();
        Ft(this, "is", r => this.source.is(r));
        this.source = r, this.fallback = n
    }

    read(r, n) {
        return this.source.read(r, n)
    }

    write(r, n) {
        try {
            return this.source.write(r, n)
        } catch (i) {
            return this.fallback({error: i, input: r})
        }
    }
}

class Ale extends wu {
    constructor(e, r, n, i) {
        super(), this.source = e, this.transformDecode = r, this.transformEncode = n, this.is = i
    }

    read(e, r) {
        try {
            return this.transformDecode(this.source.read(e, r))
        } catch (n) {
            throw Tct(n, r)
        }
    }

    write(e, r) {
        return this.source.write(this.transformEncode(e), r)
    }
}

class dct extends wu {
    constructor(e, r, n) {
        super(), this.source = e, this.to = r, this.transformDecode = n
    }

    read(e, r) {
        const n = [];
        try {
            return this.to.read(e, r)
        } catch (i) {
            n.push(...mA(i, r));
            try {
                const a = this.source.read(e, r);
                return this.transformDecode(a)
            } catch (a) {
                n.push(...mA(a, r))
            }
        }
        throw au(n) ? new ya({issues: {type: "union", issues: n, path: r}}) : new ya({
            issues: {
                type: "error",
                cause: "Unexpected empty array of union errors!",
                path: r
            }
        })
    }

    write(e, r) {
        return this.to.write(e, r)
    }

    is(e) {
        return this.to.is(e)
    }
}

class hct extends wu {
    read(e, r) {
        if (this.is(e)) return e;
        throw new ya({issues: {type: "null", received: e, path: r}})
    }

    write() {
        return null
    }

    is(e) {
        return e === null
    }
}

function KSe() {
    return new hct
}

class pct extends wu {
    read(e, r) {
        if (this.is(e)) return e;
        throw new ya({issues: {type: "undefined", received: e, path: r}})
    }

    write() {
    }

    is(e) {
        return e === void 0
    }
}

function YSe() {
    return new pct
}

class mct extends wu {
    read(e, r) {
        if (this.is(e)) return e;
        throw new ya({issues: {type: "number", received: e, path: r}})
    }

    write(e) {
        return e
    }

    is(e) {
        return typeof e == "number"
    }
}

const Gh = () => new mct;

class lO extends wu {
    constructor(r) {
        super();
        Ft(this, "minLengthValue");
        Ft(this, "maxLengthValue");
        Ft(this, "is", r => {
            try {
                return this.assert(r, []), !0
            } catch {
                return !1
            }
        });
        this.minLengthValue = r == null ? void 0 : r.minLength, this.maxLengthValue = r == null ? void 0 : r.maxLength
    }

    assert(r, n) {
        if (typeof r != "string") throw new ya({issues: {type: "string", received: r, path: n}});
        const i = [];
        if (this.minLengthValue !== void 0 && r.length < this.minLengthValue && i.push({
            type: "validation",
            received: r,
            message: `String length is less than ${this.minLengthValue}`,
            path: n
        }), this.maxLengthValue !== void 0 && r.length > this.maxLengthValue && i.push({
            type: "validation",
            received: r,
            message: `String length is greater than ${this.maxLengthValue}`,
            path: n
        }), au(i)) throw new ya({issues: i})
    }

    write(r, n) {
        return this.assert(r, n), r
    }

    read(r, n) {
        return this.assert(r, n), r
    }

    minLength(r) {
        return new lO({minLength: r})
    }

    maxLength(r) {
        return new lO({maxLength: r})
    }
}

const as = () => new lO({});

class vct extends wu {
    constructor(r) {
        super();
        Ft(this, "is", r => r === this.value);
        this.value = r
    }

    write(r) {
        return r
    }

    read(r, n) {
        if (this.is(r)) return r;
        throw new ya({issues: {type: "literal", expected: this.value, received: r, path: n}})
    }
}

const pA = t => new vct(t);

class gct extends wu {
    constructor(r) {
        super();
        Ft(this, "is", r => {
            for (const n of this.values) if (n === r) return !0;
            return !1
        });
        this.values = r
    }

    write(r) {
        return r
    }

    read(r, n) {
        if (this.is(r)) return r;
        throw new ya({issues: {type: "enum", expected: this.values, received: r, path: n}})
    }
}

const XSe = t => new gct(t);

class eC extends wu {
    constructor(r) {
        super();
        Ft(this, "keys");
        Ft(this, "is", r => {
            var n;
            if (Dv(r)) {
                for (const i of this.keys) if (!((n = this.fields[i]) != null && n.is(r[i]))) return !1;
                return !0
            }
            return !1
        });
        this.fields = r, this.keys = Object.keys(r)
    }

    write(r, n) {
        const i = {};
        for (const a of this.keys) {
            const o = this.fields[a];
            o !== void 0 && (i[a] = o.write(r[a], [...n, a]))
        }
        return i
    }

    read(r, n) {
        if (Dv(r)) {
            const i = {};
            for (const a of this.keys) {
                const o = this.fields[a];
                o !== void 0 && (i[a] = o.read(r[a], [...n, a]))
            }
            return i
        }
        throw new ya({issues: {type: "object", received: r, path: n}})
    }

    extend(r) {
        return new eC({...this.fields, ...r})
    }

    pick(r) {
        const n = {};
        for (const [i, a] of Object.entries(this.fields)) r[i] === !0 && (n[i] = a);
        return new eC(n)
    }

    omit(r) {
        const n = {};
        for (const [i, a] of Object.entries(this.fields)) r[i] !== !0 && (n[i] = a);
        return new eC(n)
    }
}

const Ff = t => new eC(t);

class yct extends wu {
    constructor(r) {
        super();
        Ft(this, "is", r => {
            for (const n of this.schemas) if (n.is(r)) return !0;
            return !1
        });
        this.schemas = r
    }

    write(r, n) {
        const i = this.schemas.find(a => a.is(r));
        if (!i) throw new ya({
            issues: {
                type: "unknown-union-part",
                message: "Cannot write union value",
                received: r,
                path: n
            }
        });
        return i.write(r, n)
    }

    read(r, n) {
        const i = [];
        for (const a of this.schemas) try {
            return a.read(r, n)
        } catch (o) {
            i.push(...mA(o, n))
        }
        throw au(i) ? new ya({issues: {type: "union", issues: i, path: n}}) : new ya({
            issues: {
                type: "error",
                cause: "Unexpected empty array of union errors!",
                path: n
            }
        })
    }
}

function t4(t) {
    return new yct(t)
}

class bct extends wu {
    constructor(r) {
        super();
        Ft(this, "is", r => {
            for (const n of this.schemas) if (!n.is(r)) return !1;
            return !0
        });
        this.schemas = r
    }

    write(r, n) {
        if (!Dv(r)) throw new ya({
            issues: {
                type: "error",
                cause: "Cannot write intersection - value is not an object",
                path: n
            }
        });
        let i;
        for (const a of this.schemas) {
            const o = a.write(r, n);
            if (i === void 0) i = o; else {
                const s = hA(i, o);
                if (s.ok) i = s.result; else throw new ya({
                    issues: {
                        type: "error",
                        cause: "Cannot write intersection child - value is not an object",
                        path: n
                    }
                })
            }
        }
        return i
    }

    read(r, n) {
        if (!Dv(r)) throw new ya({issues: {type: "object", received: r, path: n}});
        const i = [];
        let a;
        for (const o of this.schemas) try {
            const s = o.read(r, n);
            if (a === void 0) a = s; else {
                const l = hA(a, s);
                l.ok ? a = l.result : i.push({type: "error", cause: "Invalid intersection types", path: n})
            }
        } catch (s) {
            i.push(...mA(s, n))
        }
        if (au(i)) throw new ya({issues: i});
        return a
    }
}

function wct(t) {
    return new bct(t)
}

class Sct extends wu {
    constructor(r) {
        super();
        Ft(this, "is", r => r instanceof this.newable);
        this.newable = r
    }

    write(r) {
        return r
    }

    read(r, n) {
        if (this.is(r)) return r;
        throw new ya({issues: {type: "instanceof", expected: this.newable, received: r, path: n}})
    }
}

function VQ(t) {
    return new Sct(t)
}

class tC extends wu {
    constructor(r, n, i, a) {
        super();
        Ft(this, "is", r => {
            if (!Rv(r)) return !1;
            for (const n of r) if (!this.item.is(n)) return !1;
            switch (this.cardinality) {
                case"single":
                    return !0;
                case"at-least-one":
                    return au(r)
            }
        });
        this.item = r, this.cardinality = n, this.onItemDecodeError = i, this.onItemEncodeError = a
    }

    write(r, n) {
        const i = [];
        for (let a = 0; a < r.length; a++) {
            const o = [...n, `${a}`], s = r[a];
            try {
                i.push(this.item.write(s, o))
            } catch (l) {
                if (this.onItemEncodeError) this.onItemEncodeError({item: s, index: a, error: l}); else throw l
            }
        }
        switch (this.cardinality) {
            case"single":
                return i;
            case"at-least-one": {
                if (au(i)) return i;
                throw new ya({issues: {type: "array", cardinality: "at-least-one", received: r, path: n}})
            }
        }
    }

    read(r, n) {
        if (!Rv(r)) throw new ya({issues: {type: "array", cardinality: this.cardinality, received: r, path: n}});
        const i = [], a = [];
        for (let o = 0; o < r.length; o++) {
            const s = [...n, `${o}`], l = r[o];
            try {
                a.push(this.item.read(l, s))
            } catch (f) {
                this.onItemDecodeError ? this.onItemDecodeError({item: l, index: o, error: f}) : i.push(...mA(f, s))
            }
        }
        if (!this.onItemDecodeError && au(i)) throw new ya({issues: i});
        switch (this.cardinality) {
            case"single":
                return a;
            case"at-least-one": {
                if (au(a)) return a;
                throw new ya({issues: {type: "array", cardinality: this.cardinality, received: r, path: n}})
            }
        }
    }

    nonempty() {
        return new tC(this.item, "at-least-one")
    }

    ignoreItemDecodeError(r) {
        return new tC(this.item, this.cardinality, r, this.onItemEncodeError)
    }

    ignoreItemEncodeError(r) {
        return new tC(this.item, this.cardinality, this.onItemDecodeError, r)
    }
}

const Kq = t => new tC(t, "single"), QSe = () => VQ(Date),
    _ct = () => as().transform(t => new Date(t), t => t.toISOString(), QSe()),
    xct = () => Gh().transform(t => new Date(t), t => t.getTime(), QSe()),
    Ect = () => as().transform(t => new URL(t), t => t.toString(), VQ(URL));

function mA(t, e = []) {
    const r = [];
    return t instanceof ya ? r.push(...t.issues) : t instanceof Error ? r.push({
        type: "error",
        cause: t.cause ?? t,
        path: e
    }) : r.push({type: "error", cause: t, path: e}), r
}

function Tct(t, e) {
    return t instanceof ya ? t : new ya({issues: {type: "error", cause: t, path: e}})
}

class $8 {
    constructor() {
        Ft(this, "_decoded");
        Ft(this, "_encoded")
    }

    is(e) {
        return this.json.is(e)
    }

    optional() {
        return nC([Act(), this])
    }

    nullable() {
        return nC([Cct(), this])
    }

    or(e) {
        return nC([this, e])
    }

    and(e) {
        return Mct([this, e])
    }

    transform(e, r, n) {
        return Ile(typeof n == "function" ? {source: this, decode: e, encode: r, is: n} : {
            source: this,
            decode: e,
            encode: r,
            is: i => n.is(i)
        })
    }
}

function Cct() {
    return YE({avsc: WSe(), json: KSe()})
}

function Act() {
    return YE({avsc: zQ(), json: YSe()})
}

const Ict = () => YE({avsc: Xt(), json: Gh()}), bJt = () => IN().transform(Number, t => t.toString(), Ict());

class uO extends $8 {
    constructor(r) {
        super();
        Ft(this, "avsc");
        Ft(this, "json");
        this.avsc = r.avsc, this.json = r.json
    }

    minLength(r) {
        return new uO({avsc: this.avsc.minLength(r), json: this.json.minLength(r)})
    }

    maxLength(r) {
        return new uO({avsc: this.avsc.maxLength(r), json: this.json.maxLength(r)})
    }
}

function IN() {
    return new uO({avsc: kt(), json: as()})
}

class kct extends $8 {
    constructor(r) {
        super();
        Ft(this, "avsc");
        Ft(this, "json");
        this.value = r, this.avsc = Bs(this.value), this.json = pA(this.value)
    }
}

const Pz = t => new kct(t);

class Rct extends $8 {
    constructor(r) {
        super();
        Ft(this, "avsc");
        Ft(this, "json");
        this.values = r, this.avsc = KE(r), this.json = XSe(r)
    }
}

const Dct = t => new Rct(t);

class rC extends $8 {
    constructor(r) {
        super();
        Ft(this, "avsc");
        Ft(this, "json");
        this.fields = r, this.avsc = Gr(Object.fromEntries(Object.entries(r).map(([n, i]) => [n, i.avsc]))), this.json = Ff(Object.fromEntries(Object.entries(r).map(([n, i]) => [n, i.json])))
    }

    extend(r) {
        return new rC({...this.fields, ...r})
    }

    pick(r) {
        const n = {};
        for (const [i, a] of Object.entries(this.fields)) r[i] === !0 && (n[i] = a);
        return new rC(n)
    }

    omit(r) {
        const n = {};
        for (const [i, a] of Object.entries(this.fields)) r[i] !== !0 && (n[i] = a);
        return new rC(n)
    }
}

const HQ = t => new rC(t);

function nC(t) {
    return YE({avsc: US(BM(t, e => e.avsc)), json: t4(BM(t, e => e.json))})
}

function Mct(t) {
    return YE({avsc: nct(BM(t, e => e.avsc)), json: wct(BM(t, e => e.json))})
}

class Oct extends $8 {
    constructor(r) {
        super();
        Ft(this, "avsc");
        Ft(this, "json");
        this.avsc = r.avsc, this.json = r.json
    }
}

function YE(t) {
    return new Oct(t)
}

function Ile(t) {
    return YE({
        avsc: t.source.avsc.transform(t.decode, t.encode, t.is),
        json: t.source.json.transform(t.decode, t.encode, t.is)
    })
}

class Pct extends _.ZodType {
    constructor(e, r) {
        super(e._def), this.schema = e, this.fallback = r
    }

    _parse(e) {
        const r = this.schema._parse(e);
        return _.isAsync(r) ? r.then(n => this.handleResult(n)) : this.handleResult(r)
    }

    handleResult(e) {
        return _.isValid(e) || _.isDirty(e) ? e : _.OK(this.fallback)
    }
}

function O0(t, e) {
    return new Pct(t, e)
}

const ur = t => _.preprocess(e => e ?? void 0, t.optional()), fO = {
    stringToBoolean: t => t === !0 || t === "true" || t === "1",
    stringToNumber: t => typeof t == "string" ? Number.parseInt(t, 10) : t,
    stringToFloat: t => typeof t == "string" ? Number.parseFloat(t) : t,
    stringToNull: t => t === null || t === "null" || t == "" ? null : t,
    undefinedToNull: t => typeof t > "u" ? null : t,
    compactArray: t => Rv(t) ? t.filter(e => e != null) : t,
    firstArrayValue: t => Rv(t) ? t[0] : t
};

class Nct extends _.ZodType {
    _parse(e) {
        return _.ZodArray.prototype._parse.call(this, e)
    }

    static create(e, r) {
        return _.ZodArray.create(e, r)
    }
}

const Cn = Nct.create, Lct = [t => aye(t), {message: "Invalid number"}], Bct = [t => tHe(t), {message: "Invalid date"}],
    $ct = [t => nHe(t), {message: "Invalid time"}], Fct = t => [e => HZe(e) <= t, {message: `Max ${t} bytes`}],
    kle = {isValidNumber: Lct, isValidDate: Bct, isValidTime: $ct, maxSizeInBytes: Fct};

class Rle {
    constructor(e, r, n, i) {
        Ft(this, "parent");
        Ft(this, "data");
        Ft(this, "_path");
        Ft(this, "_key");
        Ft(this, "_cachedPath", []);
        this.parent = e, this.data = r, this._path = n, this._key = i
    }

    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
    }
}

class WQ extends _.ZodType {
    _parse(e) {
        const {ctx: r, status: n} = this._processInputParams(e);
        if (r.parsedType !== _.ZodParsedType.array || !Array.isArray(r.data)) return _.INVALID;
        const i = r.data;
        if (r.common.async) return Promise.resolve([]).then(a => Promise.all(i.map((o, s) => {
            const l = new Rle(r, o, r.path, s);
            return this._def.type._parseAsync(l).then(f => {
                (_.isValid(f) || _.isDirty(f)) && a.push(f)
            })
        })).then(() => _.ParseStatus.mergeArray(n, a)));
        {
            const a = [];
            for (let o = 0; o < i.length; o++) {
                const s = i[o], l = new Rle(r, s, r.path, o), f = this._def.type._parseSync(l);
                (_.isValid(f) || _.isDirty(f)) && a.push(f)
            }
            return _.ParseStatus.mergeArray(n, a)
        }
    }

    static create(e, r) {
        return new WQ({
            type: e,
            minLength: null,
            maxLength: null,
            exactLength: null,
            typeName: _.ZodFirstPartyTypeKind.ZodArray,
            description: r == null ? void 0 : r.description
        })
    }
}

const qQ = WQ.create, Cx = {
        stringToNumber: t => Number.parseInt(t, 10),
        stringToFloat: t => Number.parseFloat(t),
        stringToUTCDate: t => new Date(`${t}.000Z`),
        stringToDate: t => new Date(t),
        stringToBoolean: t => t === "true",
        stringListToArray: t => t.split(",").map(e => e.trim()),
        dateToUnixTimestamp: t => Math.floor(t.getTime() / 1e3),
        toDate: t => new Date(typeof t == "string" ? Number.parseInt(t, 10) : t),
        decimalizeNumber: t => e => qW(e, t).toFixed(),
        undecimalizeNumber: t => e => eHe(e, t).toFixed()
    }, vA = {
        stringNotEmpty: _.string().refine(t => t.trim() !== ""),
        stringAsValidNumber: _.string().transform(Cx.stringToNumber).refine(...kle.isValidNumber),
        stringAsValidDate: _.string().transform(Cx.toDate).refine(...kle.isValidDate),
        stringAsNumberGte1: _.string().transform(Cx.stringToNumber).refine(t => t >= 1, {message: "Invalid number, must be >= 1"}),
        stringAsFloatGte0: _.string().transform(Cx.stringToFloat).refine(t => t >= 0, {message: "Invalid float, must be >= 0"}),
        stringAsBoolean: _.literal("0").or(_.literal("1")).transform(t => t !== "0"),
        optionalStringAsBooleanDefaultTrue: _.literal("0").or(_.literal("1")).optional().transform(t => t !== "0"),
        optionalStringAsBooleanDefaultFalse: _.literal("0").or(_.literal("1")).optional().transform(t => t === "1"),
        stringAsURL: _.string().url().transform(t => new URL(t)),
        stringHttpURL: _.string().url({message: "Invalid URL"}).refine(t => t.startsWith("http://") || t.startsWith("https://"), {message: "Invalid URL"})
    }, Uct = _.object({label: _.string(), url: _.string()}),
    jct = _.object({type: _.enum(["Telegram", "Twitter", "Facebook", "Discord"]), url: _.string()}), zct = _.object({
        id: _.string(),
        url: _.string(),
        description: _.string().optional(),
        maxSupply: _.number().optional(),
        totalSupply: _.number().optional(),
        circulatingSupply: _.number().optional(),
        websites: _.array(Uct),
        social: _.array(jct),
        imageUrl: _.string().optional(),
        categories: _.array(_.string()).optional()
    }), Vct = _.object({slug: _.string(), name: _.string(), group: _.string()}), Hct = _.object({
        id: _.number(),
        name: _.string(),
        symbol: _.string(),
        description: _.string(),
        logo: _.string().url(),
        tags: _.array(Vct).optional(),
        urls: _.object({
            website: _.array(_.string()).optional(),
            twitter: _.array(_.string()).optional(),
            message_board: _.array(_.string()).optional(),
            chat: _.array(_.string()).optional(),
            facebook: _.array(_.string()).optional(),
            explorer: _.array(_.string()).optional(),
            reddit: _.array(_.string()).optional(),
            technicalDoc: _.array(_.string()).optional(),
            sourceCode: _.array(_.string()).optional(),
            announcement: _.array(_.string()).optional()
        }),
        dateLaunched: _.number().optional(),
        contractAddresses: _.array(_.object({chainId: _.string(), tokenAddress: _.string()})),
        selfReportedCirculatingSupply: _.number().optional(),
        selfReportedMarketCap: _.number().optional(),
        selfReportedTags: _.array(_.string()).optional(),
        infiniteSupply: _.boolean().optional(),
        updatedAt: _.number()
    }), Dle = _.object({
        address: _.string(),
        isLocked: _.boolean(),
        tag: _.string().optional(),
        isContract: _.boolean(),
        balance: _.string(),
        percent: _.string()
    }), Wct = _.object({
        dataStatus: _.enum(["complete", "partial"]),
        isInDex: _.boolean(),
        isOpenSource: _.boolean(),
        isProxy: _.boolean(),
        isTrueToken: _.boolean().optional(),
        buyTax: _.string().optional().nullable(),
        canTakeBackOwnership: _.boolean().optional(),
        cannotSellAll: _.boolean().optional(),
        creatorAddress: _.string().optional(),
        creatorBalance: _.string().optional(),
        creatorPercent: _.string().optional(),
        dex: _.array(_.object({name: _.string(), liquidity: _.string(), pair: _.string()})).optional(),
        externalCall: _.boolean().optional(),
        holderCount: _.number().optional(),
        holders: _.array(Dle).optional(),
        isAntiWhale: _.boolean().optional(),
        antiWhaleModifiable: _.boolean().optional(),
        isBlacklisted: _.boolean().optional(),
        isHoneypot: _.boolean().optional(),
        isMintable: _.boolean(),
        isWhitelisted: _.boolean().optional(),
        lpHolderCount: _.number().optional(),
        lpTotalSupply: _.string().optional(),
        lpHolders: _.array(Dle).optional(),
        ownerAddress: _.string().optional(),
        ownerBalance: _.string().optional(),
        ownerChangeBalance: _.boolean().optional(),
        ownerPercent: _.string().optional(),
        hiddenOwner: _.boolean().optional(),
        sellTax: _.string().optional().nullable(),
        slippageModifiable: _.boolean().optional(),
        totalSupply: _.string().optional(),
        transferPausable: _.boolean(),
        tradingCooldown: _.boolean().optional(),
        tokenName: _.string().optional(),
        tokenSymbol: _.string().optional(),
        trustList: _.boolean().optional(),
        otherPotentialRisks: _.string().optional(),
        note: _.string().optional(),
        updatedAt: _.number().optional()
    }), ZSe = _.object({label: _.string().optional(), url: _.string().url()}),
    qct = _.enum(["telegram", "twitter", "discord", "facebook", "tiktok"]), JSe = ZSe.extend({type: qct.optional()}),
    H4 = _.object({id: _.string()}), e2e = _.object({id: _.string(), issuer: _.enum(["helio"])}),
    Gct = _.enum(["pending", "approved"]),
    Kct = _.object({status: Gct, reviewedAt: _.coerce.date().optional(), reviewerId: _.string().optional()}),
    Yct = _.enum(["pending", "finalized", "failed"]),
    Xct = _.object({status: Yct, migratedAt: _.coerce.date().optional()}), Qct = _.object({
        totalSupply: _.number(),
        burnedSupply: _.number(),
        lockedSupply: _.number(),
        circulatingSupply: _.number(),
        updatedAt: _.coerce.date()
    }), Zct = _.object({
        id: _.string(),
        icon: H4,
        header: ur(H4),
        description: ur(_.string()),
        claimDescription: ur(_.string()),
        claimDate: _.coerce.date(),
        links: ur(Cn(JSe))
    }), Jct = _.object({address: _.string()}), elt = _.object({dexId: _.string(), address: _.string()}), kN = _.object({
        id: _.string(),
        chainId: _.string(),
        creatorId: _.string(),
        mint: e2e,
        tokenDraftId: _.string(),
        review: Kct,
        migration: Xct.optional(),
        name: _.string(),
        symbol: _.string(),
        address: _.string(),
        pairAddresses: Cn(elt).nullable().optional(),
        description: _.string().optional(),
        links: ur(Cn(JSe)),
        lockedAddresses: ur(Cn(Jct)),
        supplies: ur(Qct),
        claims: ur(Cn(Zct)),
        icon: H4,
        header: H4.optional(),
        createdAt: _.coerce.date(),
        updatedAt: _.coerce.date(),
        sortByDate: ur(_.coerce.date())
    });
_.object({
    id: _.string(),
    chainId: _.string(),
    creatorId: _.string(),
    name: _.string(),
    symbol: _.string(),
    description: _.string().optional(),
    links: ur(Cn(ZSe)),
    icon: H4,
    header: H4.optional(),
    mint: e2e.optional(),
    createdAt: _.coerce.date(),
    updatedAt: _.coerce.date()
});
const tlt = _.object({
        DS_DEX_API_PUBLIC_ORIGIN: _.string().nonempty(),
        DS_DEX_API_FULL_ACCESS_TOKEN: _.string().optional()
    }), rlt = _.object({
        DS_DEX_CHART_AMM_HOST: _.string().nonempty(),
        DS_DEX_CHART_BALANCER_HOST: _.string().nonempty(),
        DS_DEX_CHART_OSMOSIS_HOST: _.string().nonempty(),
        DS_DEX_CHART_UNISWAP_HOST: _.string().nonempty()
    }), nlt = _.object({
        DS_DEX_LOG_AMM_HOST: _.string().nonempty(),
        DS_DEX_LOG_BALANCER_HOST: _.string().nonempty(),
        DS_DEX_LOG_OSMOSIS_HOST: _.string().nonempty(),
        DS_DEX_LOG_UNISWAP_HOST: _.string().nonempty()
    }), ilt = _.object({DS_DEX_SCREENER_SEARCH_PUBLIC_ORIGIN: _.string().nonempty()}), alt = _.object({
        DS_DATA_SERVER_PUBLIC_ORIGIN: _.string().nonempty(),
        DS_DATA_TIME_TO_STALE_IN_MS: _.coerce.number(),
        DS_DATA_LOG_SAMPLING_THRESHOLD: _.coerce.number(),
        DS_DATA_RETRY_MAX_ATTEMPTS: _.coerce.number(),
        DS_DATA_RETRY_TIMEOUT_IN_MS: _.coerce.number(),
        DS_DATA_RETRY_DELAY_IN_MS: _.coerce.number()
    }), olt = _.object({DS_MOONSHOT_API_PUBLIC_ORIGIN: _.string().min(1)}), slt = _.object({
        DS_MOONSHOT_CREATOR_PUBLIC_KEYS: _.string().nonempty().transform(Cx.stringListToArray),
        DS_MOONSHOT_TOKEN_NAME_SIZE_IN_BYTES: _.coerce.number(),
        DS_MOONSHOT_TOKEN_SYMBOL_SIZE_IN_BYTES: _.coerce.number(),
        DS_MOONSHOT_TOKEN_DESCRIPTION_LENGTH: _.coerce.number(),
        DS_MOONSHOT_DEFAULT_CHAIN_ID: _.string(),
        DS_MOONSHOT_DEX_IDS: _.string().nonempty().transform(Cx.stringListToArray),
        DS_MOONSHOT_TOKEN_ICON_MAX_SIZE_IN_BYTES: _.coerce.number(),
        DS_MOONSHOT_TOKEN_HEADER_MAX_SIZE_IN_BYTES: _.coerce.number()
    }), clt = _.object({DS_TENOR_API_KEY: _.string().nonempty()}), dO = t => t === !0 || t === "true",
    llt = t => typeof t == "string" ? Number.parseInt(t, 10) : t, ult = nlt.pick({
        DS_DEX_LOG_AMM_HOST: !0,
        DS_DEX_LOG_BALANCER_HOST: !0,
        DS_DEX_LOG_OSMOSIS_HOST: !0,
        DS_DEX_LOG_UNISWAP_HOST: !0
    }), flt = rlt.pick({
        DS_DEX_CHART_AMM_HOST: !0,
        DS_DEX_CHART_BALANCER_HOST: !0,
        DS_DEX_CHART_OSMOSIS_HOST: !0,
        DS_DEX_CHART_UNISWAP_HOST: !0
    }), dlt = ilt.pick({DS_DEX_SCREENER_SEARCH_PUBLIC_ORIGIN: !0}), hlt = alt.pick({DS_DATA_TIME_TO_STALE_IN_MS: !0}),
    plt = slt.pick({
        DS_MOONSHOT_TOKEN_NAME_SIZE_IN_BYTES: !0,
        DS_MOONSHOT_TOKEN_SYMBOL_SIZE_IN_BYTES: !0,
        DS_MOONSHOT_TOKEN_DESCRIPTION_LENGTH: !0,
        DS_MOONSHOT_DEFAULT_CHAIN_ID: !0,
        DS_MOONSHOT_TOKEN_HEADER_MAX_SIZE_IN_BYTES: !0,
        DS_MOONSHOT_TOKEN_ICON_MAX_SIZE_IN_BYTES: !0
    }), mlt = tlt.pick({DS_DEX_API_PUBLIC_ORIGIN: !0}), vlt = clt.pick({DS_TENOR_API_KEY: !0}), glt = _.object({
        DS_WEB_FIREBASE_ENABLED: _.preprocess(dO, _.boolean()),
        DS_WEB_FIREBASE_API_KEY: _.string(),
        DS_WEB_FIREBASE_APP_ID: _.string(),
        DS_WEB_FIREBASE_AUTH_DOMAIN: _.string(),
        DS_WEB_FIREBASE_MESSAGING_SENDER_ID: _.string(),
        DS_WEB_FIREBASE_PROJECT_ID: _.string(),
        DS_WEB_FIREBASE_STORAGE_BUCKET: _.string(),
        DS_WEB_FIREBASE_ANALYTICS_ENABLED: _.preprocess(dO, _.boolean()),
        DS_WEB_FIREBASE_MEASUREMENT_ID: _.string()
    }), ylt = _.object({DS_WEB_UNISWAP_SCREENER_HOST: _.string()}), blt = _.object({
        DS_WEB_URL: _.string(),
        DS_WEB_PAIR_DETAILS_SERVER_HOST: _.string(),
        DS_WEB_DEX_TRENDING_SERVER_HOST: _.string(),
        DS_WEB_DEX_SCREENER_WSS_HOST: _.string(),
        DS_WEB_PLAUSIBLE_ENABLED: _.preprocess(dO, _.boolean()),
        DS_WEB_PLAUSIBLE_DOMAIN: _.string(),
        DS_WEB_PLAUSIBLE_HOST: _.string(),
        DS_WEB_WORKER_LOG_APP_NAME: _.string(),
        DS_WEB_WORKER_LOG_ENDPOINT: _.string(),
        DS_WEB_WORKER_LOG_STDOUT_ENABLED: _.preprocess(dO, _.boolean()),
        DS_WEB_CFW_ADS_HOST: _.string(),
        DS_WEB_SCREENSHOTS_HOST: _.string(),
        DS_DATA_SERVER_PUBLIC_ORIGIN: _.string(),
        DS_WEB_ASSETS_HOST: _.string(),
        DS_WEB_NEWS_SERVER_HOST: _.string(),
        DS_WEB_HYPE_SERVER_HOST: _.string(),
        DS_WEB_BALANCE_SERVER_HOST: _.string(),
        DS_WEB_ADS_PAGES_PUBLIC_ORIGIN: _.string(),
        DS_WEB_MOONSHOT_SERVER_HOST: _.string(),
        DS_WEB_MAX_TRENDING_BAR_ADS_AMOUNT: _.preprocess(llt, _.number()),
        DS_WEB_SOLANA_WALLET_ADAPTER_NETWORK: _.literal("mainnet-beta").or(_.literal("devnet")),
        DS_WEB_SOLANA_WALLET_ADAPTER_RPC_URL: _.preprocess(fO.stringToNull, _.string().nullable()),
        DS_WEB_RECAPTCHA_ENTERPRISE_SCORE_SITE_KEY: _.string().nonempty(),
        DS_WEB_RECAPTCHA_ENTERPRISE_CHECKBOX_SITE_KEY: _.string().nonempty()
    }).merge(glt).merge(ylt).merge(ult).merge(flt).merge(dlt).merge(hlt).merge(plt).merge(mlt).merge(vlt).merge(olt),
    wlt = blt, t2e = (t, e) => t.getChildLogger({name: `${t.settings.name ?? "unnamed-logger"}/${e}`}),
    Mle = ["silly", "debug", "info", "warn", "error", "fatal"], sr = mn("@dexscreener/util-logger/Logger")(),
    Slt = t => {
        switch (t) {
            case"silly":
            case"debug":
                return "debug";
            case"info":
                return "info";
            case"warn":
                return "warn";
            case"error":
            case"fatal":
                return "error"
        }
    }, _lt = (...t) => {
        const e = {args: {}};
        let r = 1;
        return typeof t[0] == "string" ? e.message = t[0] : r = 0, (r === 0 || t.length > 1) && t.slice(r).forEach(n => {
            e.args || (e.args = {}), typeof n == "string" ? (e.args.strings || (e.args.strings = []), e.args.strings.push(n)) : typeof n == "object" && n instanceof Error ? (e.args.errors || (e.args.errors = []), e.args.errors.push(n.message)) : Dv(n) && (e.args.params || (e.args.params = {}), e.args.params = {...e.args.params, ...n})
        }), e
    }, Yq = t => JSON.stringify(t, (e, r) => r instanceof Error ? {
        ...r,
        name: r.name,
        message: r.message,
        stack: r.stack
    } : r);

class GQ {
    constructor(e) {
        Ft(this, "params");
        Ft(this, "settings");
        this.params = e, this.settings = e.settings
    }

    silly(...e) {
        this.write("silly", ...e)
    }

    debug(...e) {
        this.write("debug", ...e)
    }

    info(...e) {
        this.write("info", ...e)
    }

    warn(...e) {
        this.write("warn", ...e)
    }

    error(...e) {
        this.write("error", ...e)
    }

    fatal(...e) {
        this.write("fatal", ...e)
    }

    async writeAsync(e, ...r) {
        await this.write(e, ...r)
    }

    setSettings(e) {
        this.settings = e
    }

    getChildLogger(e) {
        return new GQ({...this.params, settings: {...this.settings, ...e}})
    }

    isLevelEnabled(e) {
        const r = Mle.findIndex(i => i === this.params.maxLevel);
        if (r === -1) return console.log(`Max log level is invalid: ${this.params.maxLevel}`), !1;
        const n = Mle.indexOf(e);
        return n === -1 ? (console.log(`Log level is invalid: ${e}`), !1) : n >= r
    }

    async write(e, ...r) {
        if (!this.isLevelEnabled(e)) return;
        const n = this.parseLog.apply(this, [e, ...r]);
        this.params.stdoutEnabled && console[Slt(e)](Yq(n)), this.params.transport && await this.params.transport(n).catch(i => console.error(i))
    }

    async raw(e) {
        this.params.stdoutEnabled && console.log(Yq(e)), this.params.transport && await this.params.transport(e).catch(r => console.error(r))
    }

    parseLog(e, ...r) {
        const n = _lt(...r);
        return {log: {level: e, name: this.params.name, ...n}}
    }
}

const xlt = t => new GQ(t),
    Elt = {staging: "https://cfw.dexscreener.dev/l/nr", production: "https://cfw.dexscreener.com/l/nr"}, Tlt = t => {
        const e = t.endpoint ?? Elt.production, r = {
            name: t.name,
            maxLevel: t.maxLevel,
            stdoutEnabled: t.stdoutEnabled,
            transport: async n => t.httpClient.fetch.apply(null, [e, {
                method: "POST",
                credentials: "include",
                body: Yq(n)
            }]),
            settings: {name: t.name}
        };
        return xlt(r)
    }, r2e = "@dexscreener/data-access-env/env", Clt = mn(r2e);

function $i() {
    return Clt()
}

$i.key = r2e;

function Alt(t) {
    return new Promise(e => setTimeout(e, t))
}

class n2e extends Error {
    constructor(e) {
        super(`Timeout after ${e.toLocaleString()}ms`), this.name = "TimeoutError"
    }
}

const Ilt = t => new n2e(t), iC = async t => {
    let e;
    const r = t.newTimeoutError ?? Ilt, n = await Promise.race([t.callback(), new Promise((i, a) => {
        if (t.timeoutInMs !== void 0) {
            const o = setTimeout(() => {
                t.timeoutInMs !== void 0 && a(r(t.timeoutInMs))
            }, t.timeoutInMs);
            e = () => {
                clearTimeout(o), e = void 0
            }
        }
    })]).catch(i => {
        throw e && e(), i
    });
    return e && e(), n
};
var Xq = {exports: {}}, Qq = {exports: {}}, Zq = {exports: {}}, Jq = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n, i) {
        if (i.length < n) throw new TypeError(n + " argument" + (n > 1 ? "s" : "") + " required, but only " + i.length + " present")
    }

    t.exports = e.default
})(Jq, Jq.exports);
var Su = Jq.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = a;
    var r = n(Su);

    function n(o) {
        return o && o.__esModule ? o : {default: o}
    }

    function i(o) {
        "@babel/helpers - typeof";
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i = function (l) {
            return typeof l
        } : i = function (l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l
        }, i(o)
    }

    function a(o) {
        return (0, r.default)(1, arguments), o instanceof Date || i(o) === "object" && Object.prototype.toString.call(o) === "[object Date]"
    }

    t.exports = e.default
})(Zq, Zq.exports);
var klt = Zq.exports, eG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = a;
    var r = n(Su);

    function n(o) {
        return o && o.__esModule ? o : {default: o}
    }

    function i(o) {
        "@babel/helpers - typeof";
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i = function (l) {
            return typeof l
        } : i = function (l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l
        }, i(o)
    }

    function a(o) {
        (0, r.default)(1, arguments);
        var s = Object.prototype.toString.call(o);
        return o instanceof Date || i(o) === "object" && s === "[object Date]" ? new Date(o.getTime()) : typeof o == "number" || s === "[object Number]" ? new Date(o) : ((typeof o == "string" || s === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN))
    }

    t.exports = e.default
})(eG, eG.exports);
var J0 = eG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = o;
    var r = a(klt), n = a(J0), i = a(Su);

    function a(s) {
        return s && s.__esModule ? s : {default: s}
    }

    function o(s) {
        if ((0, i.default)(1, arguments), !(0, r.default)(s) && typeof s != "number") return !1;
        var l = (0, n.default)(s);
        return !isNaN(Number(l))
    }

    t.exports = e.default
})(Qq, Qq.exports);
var Rlt = Qq.exports, tG = {exports: {}}, rG = {exports: {}}, nG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n) {
        if (n === null || n === !0 || n === !1) return NaN;
        var i = Number(n);
        return isNaN(i) ? i : i < 0 ? Math.ceil(i) : Math.floor(i)
    }

    t.exports = e.default
})(nG, nG.exports);
var jS = nG.exports;
const Dlt = za(jS);
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = o;
    var r = a(jS), n = a(J0), i = a(Su);

    function a(s) {
        return s && s.__esModule ? s : {default: s}
    }

    function o(s, l) {
        (0, i.default)(2, arguments);
        var f = (0, n.default)(s).getTime(), d = (0, r.default)(l);
        return new Date(f + d)
    }

    t.exports = e.default
})(rG, rG.exports);
var Mlt = rG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = o;
    var r = a(Mlt), n = a(Su), i = a(jS);

    function a(s) {
        return s && s.__esModule ? s : {default: s}
    }

    function o(s, l) {
        (0, n.default)(2, arguments);
        var f = (0, i.default)(l);
        return (0, r.default)(s, -f)
    }

    t.exports = e.default
})(tG, tG.exports);
var Olt = tG.exports, iG = {exports: {}}, aG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = o;
    var r = i(J0), n = i(Su);

    function i(s) {
        return s && s.__esModule ? s : {default: s}
    }

    var a = 864e5;

    function o(s) {
        (0, n.default)(1, arguments);
        var l = (0, r.default)(s), f = l.getTime();
        l.setUTCMonth(0, 1), l.setUTCHours(0, 0, 0, 0);
        var d = l.getTime(), p = f - d;
        return Math.floor(p / a) + 1
    }

    t.exports = e.default
})(aG, aG.exports);
var Plt = aG.exports, oG = {exports: {}}, sG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = a;
    var r = i(J0), n = i(Su);

    function i(o) {
        return o && o.__esModule ? o : {default: o}
    }

    function a(o) {
        (0, n.default)(1, arguments);
        var s = 1, l = (0, r.default)(o), f = l.getUTCDay(), d = (f < s ? 7 : 0) + f - s;
        return l.setUTCDate(l.getUTCDate() - d), l.setUTCHours(0, 0, 0, 0), l
    }

    t.exports = e.default
})(sG, sG.exports);
var KQ = sG.exports, cG = {exports: {}}, lG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = o;
    var r = a(J0), n = a(Su), i = a(KQ);

    function a(s) {
        return s && s.__esModule ? s : {default: s}
    }

    function o(s) {
        (0, n.default)(1, arguments);
        var l = (0, r.default)(s), f = l.getUTCFullYear(), d = new Date(0);
        d.setUTCFullYear(f + 1, 0, 4), d.setUTCHours(0, 0, 0, 0);
        var p = (0, i.default)(d), g = new Date(0);
        g.setUTCFullYear(f, 0, 4), g.setUTCHours(0, 0, 0, 0);
        var b = (0, i.default)(g);
        return l.getTime() >= p.getTime() ? f + 1 : l.getTime() >= b.getTime() ? f : f - 1
    }

    t.exports = e.default
})(lG, lG.exports);
var i2e = lG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = o;
    var r = a(i2e), n = a(KQ), i = a(Su);

    function a(s) {
        return s && s.__esModule ? s : {default: s}
    }

    function o(s) {
        (0, i.default)(1, arguments);
        var l = (0, r.default)(s), f = new Date(0);
        f.setUTCFullYear(l, 0, 4), f.setUTCHours(0, 0, 0, 0);
        var d = (0, n.default)(f);
        return d
    }

    t.exports = e.default
})(cG, cG.exports);
var Nlt = cG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = l;
    var r = o(J0), n = o(KQ), i = o(Nlt), a = o(Su);

    function o(f) {
        return f && f.__esModule ? f : {default: f}
    }

    var s = 6048e5;

    function l(f) {
        (0, a.default)(1, arguments);
        var d = (0, r.default)(f), p = (0, n.default)(d).getTime() - (0, i.default)(d).getTime();
        return Math.round(p / s) + 1
    }

    t.exports = e.default
})(oG, oG.exports);
var Llt = oG.exports, uG = {exports: {}}, fG = {exports: {}}, zS = {};
Object.defineProperty(zS, "__esModule", {value: !0});
zS.getDefaultOptions = Blt;
zS.setDefaultOptions = $lt;
var a2e = {};

function Blt() {
    return a2e
}

function $lt(t) {
    a2e = t
}

(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = s;
    var r = o(J0), n = o(Su), i = o(jS), a = zS;

    function o(l) {
        return l && l.__esModule ? l : {default: l}
    }

    function s(l, f) {
        var d, p, g, b, S, T, I, N;
        (0, n.default)(1, arguments);
        var P = (0, a.getDefaultOptions)(),
            F = (0, i.default)((d = (p = (g = (b = f == null ? void 0 : f.weekStartsOn) !== null && b !== void 0 ? b : f == null || (S = f.locale) === null || S === void 0 || (T = S.options) === null || T === void 0 ? void 0 : T.weekStartsOn) !== null && g !== void 0 ? g : P.weekStartsOn) !== null && p !== void 0 ? p : (I = P.locale) === null || I === void 0 || (N = I.options) === null || N === void 0 ? void 0 : N.weekStartsOn) !== null && d !== void 0 ? d : 0);
        if (!(F >= 0 && F <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        var V = (0, r.default)(l), Y = V.getUTCDay(), ee = (Y < F ? 7 : 0) + Y - F;
        return V.setUTCDate(V.getUTCDate() - ee), V.setUTCHours(0, 0, 0, 0), V
    }

    t.exports = e.default
})(fG, fG.exports);
var YQ = fG.exports, dG = {exports: {}}, hG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = l;
    var r = s(J0), n = s(Su), i = s(YQ), a = s(jS), o = zS;

    function s(f) {
        return f && f.__esModule ? f : {default: f}
    }

    function l(f, d) {
        var p, g, b, S, T, I, N, P;
        (0, n.default)(1, arguments);
        var F = (0, r.default)(f), V = F.getUTCFullYear(), Y = (0, o.getDefaultOptions)(),
            ee = (0, a.default)((p = (g = (b = (S = d == null ? void 0 : d.firstWeekContainsDate) !== null && S !== void 0 ? S : d == null || (T = d.locale) === null || T === void 0 || (I = T.options) === null || I === void 0 ? void 0 : I.firstWeekContainsDate) !== null && b !== void 0 ? b : Y.firstWeekContainsDate) !== null && g !== void 0 ? g : (N = Y.locale) === null || N === void 0 || (P = N.options) === null || P === void 0 ? void 0 : P.firstWeekContainsDate) !== null && p !== void 0 ? p : 1);
        if (!(ee >= 1 && ee <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        var oe = new Date(0);
        oe.setUTCFullYear(V + 1, 0, ee), oe.setUTCHours(0, 0, 0, 0);
        var G = (0, i.default)(oe, d), J = new Date(0);
        J.setUTCFullYear(V, 0, ee), J.setUTCHours(0, 0, 0, 0);
        var ce = (0, i.default)(J, d);
        return F.getTime() >= G.getTime() ? V + 1 : F.getTime() >= ce.getTime() ? V : V - 1
    }

    t.exports = e.default
})(hG, hG.exports);
var o2e = hG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = l;
    var r = s(o2e), n = s(Su), i = s(YQ), a = s(jS), o = zS;

    function s(f) {
        return f && f.__esModule ? f : {default: f}
    }

    function l(f, d) {
        var p, g, b, S, T, I, N, P;
        (0, n.default)(1, arguments);
        var F = (0, o.getDefaultOptions)(),
            V = (0, a.default)((p = (g = (b = (S = d == null ? void 0 : d.firstWeekContainsDate) !== null && S !== void 0 ? S : d == null || (T = d.locale) === null || T === void 0 || (I = T.options) === null || I === void 0 ? void 0 : I.firstWeekContainsDate) !== null && b !== void 0 ? b : F.firstWeekContainsDate) !== null && g !== void 0 ? g : (N = F.locale) === null || N === void 0 || (P = N.options) === null || P === void 0 ? void 0 : P.firstWeekContainsDate) !== null && p !== void 0 ? p : 1),
            Y = (0, r.default)(f, d), ee = new Date(0);
        ee.setUTCFullYear(Y, 0, V), ee.setUTCHours(0, 0, 0, 0);
        var oe = (0, i.default)(ee, d);
        return oe
    }

    t.exports = e.default
})(dG, dG.exports);
var Flt = dG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = l;
    var r = o(J0), n = o(YQ), i = o(Flt), a = o(Su);

    function o(f) {
        return f && f.__esModule ? f : {default: f}
    }

    var s = 6048e5;

    function l(f, d) {
        (0, a.default)(1, arguments);
        var p = (0, r.default)(f), g = (0, n.default)(p, d).getTime() - (0, i.default)(p, d).getTime();
        return Math.round(g / s) + 1
    }

    t.exports = e.default
})(uG, uG.exports);
var Ult = uG.exports, pG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n, i) {
        for (var a = n < 0 ? "-" : "", o = Math.abs(n).toString(); o.length < i;) o = "0" + o;
        return a + o
    }

    t.exports = e.default
})(pG, pG.exports);
var s2e = pG.exports, mG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = n(s2e);

    function n(o) {
        return o && o.__esModule ? o : {default: o}
    }

    var i = {
        y: function (s, l) {
            var f = s.getUTCFullYear(), d = f > 0 ? f : 1 - f;
            return (0, r.default)(l === "yy" ? d % 100 : d, l.length)
        }, M: function (s, l) {
            var f = s.getUTCMonth();
            return l === "M" ? String(f + 1) : (0, r.default)(f + 1, 2)
        }, d: function (s, l) {
            return (0, r.default)(s.getUTCDate(), l.length)
        }, a: function (s, l) {
            var f = s.getUTCHours() / 12 >= 1 ? "pm" : "am";
            switch (l) {
                case"a":
                case"aa":
                    return f.toUpperCase();
                case"aaa":
                    return f;
                case"aaaaa":
                    return f[0];
                case"aaaa":
                default:
                    return f === "am" ? "a.m." : "p.m."
            }
        }, h: function (s, l) {
            return (0, r.default)(s.getUTCHours() % 12 || 12, l.length)
        }, H: function (s, l) {
            return (0, r.default)(s.getUTCHours(), l.length)
        }, m: function (s, l) {
            return (0, r.default)(s.getUTCMinutes(), l.length)
        }, s: function (s, l) {
            return (0, r.default)(s.getUTCSeconds(), l.length)
        }, S: function (s, l) {
            var f = l.length, d = s.getUTCMilliseconds(), p = Math.floor(d * Math.pow(10, f - 3));
            return (0, r.default)(p, l.length)
        }
    }, a = i;
    e.default = a, t.exports = e.default
})(mG, mG.exports);
var jlt = mG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = f(Plt), n = f(Llt), i = f(i2e), a = f(Ult), o = f(o2e), s = f(s2e), l = f(jlt);

    function f(I) {
        return I && I.__esModule ? I : {default: I}
    }

    var d = {
        am: "am",
        pm: "pm",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }, p = {
        G: function (N, P, F) {
            var V = N.getUTCFullYear() > 0 ? 1 : 0;
            switch (P) {
                case"G":
                case"GG":
                case"GGG":
                    return F.era(V, {width: "abbreviated"});
                case"GGGGG":
                    return F.era(V, {width: "narrow"});
                case"GGGG":
                default:
                    return F.era(V, {width: "wide"})
            }
        }, y: function (N, P, F) {
            if (P === "yo") {
                var V = N.getUTCFullYear(), Y = V > 0 ? V : 1 - V;
                return F.ordinalNumber(Y, {unit: "year"})
            }
            return l.default.y(N, P)
        }, Y: function (N, P, F, V) {
            var Y = (0, o.default)(N, V), ee = Y > 0 ? Y : 1 - Y;
            if (P === "YY") {
                var oe = ee % 100;
                return (0, s.default)(oe, 2)
            }
            return P === "Yo" ? F.ordinalNumber(ee, {unit: "year"}) : (0, s.default)(ee, P.length)
        }, R: function (N, P) {
            var F = (0, i.default)(N);
            return (0, s.default)(F, P.length)
        }, u: function (N, P) {
            var F = N.getUTCFullYear();
            return (0, s.default)(F, P.length)
        }, Q: function (N, P, F) {
            var V = Math.ceil((N.getUTCMonth() + 1) / 3);
            switch (P) {
                case"Q":
                    return String(V);
                case"QQ":
                    return (0, s.default)(V, 2);
                case"Qo":
                    return F.ordinalNumber(V, {unit: "quarter"});
                case"QQQ":
                    return F.quarter(V, {width: "abbreviated", context: "formatting"});
                case"QQQQQ":
                    return F.quarter(V, {width: "narrow", context: "formatting"});
                case"QQQQ":
                default:
                    return F.quarter(V, {width: "wide", context: "formatting"})
            }
        }, q: function (N, P, F) {
            var V = Math.ceil((N.getUTCMonth() + 1) / 3);
            switch (P) {
                case"q":
                    return String(V);
                case"qq":
                    return (0, s.default)(V, 2);
                case"qo":
                    return F.ordinalNumber(V, {unit: "quarter"});
                case"qqq":
                    return F.quarter(V, {width: "abbreviated", context: "standalone"});
                case"qqqqq":
                    return F.quarter(V, {width: "narrow", context: "standalone"});
                case"qqqq":
                default:
                    return F.quarter(V, {width: "wide", context: "standalone"})
            }
        }, M: function (N, P, F) {
            var V = N.getUTCMonth();
            switch (P) {
                case"M":
                case"MM":
                    return l.default.M(N, P);
                case"Mo":
                    return F.ordinalNumber(V + 1, {unit: "month"});
                case"MMM":
                    return F.month(V, {width: "abbreviated", context: "formatting"});
                case"MMMMM":
                    return F.month(V, {width: "narrow", context: "formatting"});
                case"MMMM":
                default:
                    return F.month(V, {width: "wide", context: "formatting"})
            }
        }, L: function (N, P, F) {
            var V = N.getUTCMonth();
            switch (P) {
                case"L":
                    return String(V + 1);
                case"LL":
                    return (0, s.default)(V + 1, 2);
                case"Lo":
                    return F.ordinalNumber(V + 1, {unit: "month"});
                case"LLL":
                    return F.month(V, {width: "abbreviated", context: "standalone"});
                case"LLLLL":
                    return F.month(V, {width: "narrow", context: "standalone"});
                case"LLLL":
                default:
                    return F.month(V, {width: "wide", context: "standalone"})
            }
        }, w: function (N, P, F, V) {
            var Y = (0, a.default)(N, V);
            return P === "wo" ? F.ordinalNumber(Y, {unit: "week"}) : (0, s.default)(Y, P.length)
        }, I: function (N, P, F) {
            var V = (0, n.default)(N);
            return P === "Io" ? F.ordinalNumber(V, {unit: "week"}) : (0, s.default)(V, P.length)
        }, d: function (N, P, F) {
            return P === "do" ? F.ordinalNumber(N.getUTCDate(), {unit: "date"}) : l.default.d(N, P)
        }, D: function (N, P, F) {
            var V = (0, r.default)(N);
            return P === "Do" ? F.ordinalNumber(V, {unit: "dayOfYear"}) : (0, s.default)(V, P.length)
        }, E: function (N, P, F) {
            var V = N.getUTCDay();
            switch (P) {
                case"E":
                case"EE":
                case"EEE":
                    return F.day(V, {width: "abbreviated", context: "formatting"});
                case"EEEEE":
                    return F.day(V, {width: "narrow", context: "formatting"});
                case"EEEEEE":
                    return F.day(V, {width: "short", context: "formatting"});
                case"EEEE":
                default:
                    return F.day(V, {width: "wide", context: "formatting"})
            }
        }, e: function (N, P, F, V) {
            var Y = N.getUTCDay(), ee = (Y - V.weekStartsOn + 8) % 7 || 7;
            switch (P) {
                case"e":
                    return String(ee);
                case"ee":
                    return (0, s.default)(ee, 2);
                case"eo":
                    return F.ordinalNumber(ee, {unit: "day"});
                case"eee":
                    return F.day(Y, {width: "abbreviated", context: "formatting"});
                case"eeeee":
                    return F.day(Y, {width: "narrow", context: "formatting"});
                case"eeeeee":
                    return F.day(Y, {width: "short", context: "formatting"});
                case"eeee":
                default:
                    return F.day(Y, {width: "wide", context: "formatting"})
            }
        }, c: function (N, P, F, V) {
            var Y = N.getUTCDay(), ee = (Y - V.weekStartsOn + 8) % 7 || 7;
            switch (P) {
                case"c":
                    return String(ee);
                case"cc":
                    return (0, s.default)(ee, P.length);
                case"co":
                    return F.ordinalNumber(ee, {unit: "day"});
                case"ccc":
                    return F.day(Y, {width: "abbreviated", context: "standalone"});
                case"ccccc":
                    return F.day(Y, {width: "narrow", context: "standalone"});
                case"cccccc":
                    return F.day(Y, {width: "short", context: "standalone"});
                case"cccc":
                default:
                    return F.day(Y, {width: "wide", context: "standalone"})
            }
        }, i: function (N, P, F) {
            var V = N.getUTCDay(), Y = V === 0 ? 7 : V;
            switch (P) {
                case"i":
                    return String(Y);
                case"ii":
                    return (0, s.default)(Y, P.length);
                case"io":
                    return F.ordinalNumber(Y, {unit: "day"});
                case"iii":
                    return F.day(V, {width: "abbreviated", context: "formatting"});
                case"iiiii":
                    return F.day(V, {width: "narrow", context: "formatting"});
                case"iiiiii":
                    return F.day(V, {width: "short", context: "formatting"});
                case"iiii":
                default:
                    return F.day(V, {width: "wide", context: "formatting"})
            }
        }, a: function (N, P, F) {
            var V = N.getUTCHours(), Y = V / 12 >= 1 ? "pm" : "am";
            switch (P) {
                case"a":
                case"aa":
                    return F.dayPeriod(Y, {width: "abbreviated", context: "formatting"});
                case"aaa":
                    return F.dayPeriod(Y, {width: "abbreviated", context: "formatting"}).toLowerCase();
                case"aaaaa":
                    return F.dayPeriod(Y, {width: "narrow", context: "formatting"});
                case"aaaa":
                default:
                    return F.dayPeriod(Y, {width: "wide", context: "formatting"})
            }
        }, b: function (N, P, F) {
            var V = N.getUTCHours(), Y;
            switch (V === 12 ? Y = d.noon : V === 0 ? Y = d.midnight : Y = V / 12 >= 1 ? "pm" : "am", P) {
                case"b":
                case"bb":
                    return F.dayPeriod(Y, {width: "abbreviated", context: "formatting"});
                case"bbb":
                    return F.dayPeriod(Y, {width: "abbreviated", context: "formatting"}).toLowerCase();
                case"bbbbb":
                    return F.dayPeriod(Y, {width: "narrow", context: "formatting"});
                case"bbbb":
                default:
                    return F.dayPeriod(Y, {width: "wide", context: "formatting"})
            }
        }, B: function (N, P, F) {
            var V = N.getUTCHours(), Y;
            switch (V >= 17 ? Y = d.evening : V >= 12 ? Y = d.afternoon : V >= 4 ? Y = d.morning : Y = d.night, P) {
                case"B":
                case"BB":
                case"BBB":
                    return F.dayPeriod(Y, {width: "abbreviated", context: "formatting"});
                case"BBBBB":
                    return F.dayPeriod(Y, {width: "narrow", context: "formatting"});
                case"BBBB":
                default:
                    return F.dayPeriod(Y, {width: "wide", context: "formatting"})
            }
        }, h: function (N, P, F) {
            if (P === "ho") {
                var V = N.getUTCHours() % 12;
                return V === 0 && (V = 12), F.ordinalNumber(V, {unit: "hour"})
            }
            return l.default.h(N, P)
        }, H: function (N, P, F) {
            return P === "Ho" ? F.ordinalNumber(N.getUTCHours(), {unit: "hour"}) : l.default.H(N, P)
        }, K: function (N, P, F) {
            var V = N.getUTCHours() % 12;
            return P === "Ko" ? F.ordinalNumber(V, {unit: "hour"}) : (0, s.default)(V, P.length)
        }, k: function (N, P, F) {
            var V = N.getUTCHours();
            return V === 0 && (V = 24), P === "ko" ? F.ordinalNumber(V, {unit: "hour"}) : (0, s.default)(V, P.length)
        }, m: function (N, P, F) {
            return P === "mo" ? F.ordinalNumber(N.getUTCMinutes(), {unit: "minute"}) : l.default.m(N, P)
        }, s: function (N, P, F) {
            return P === "so" ? F.ordinalNumber(N.getUTCSeconds(), {unit: "second"}) : l.default.s(N, P)
        }, S: function (N, P) {
            return l.default.S(N, P)
        }, X: function (N, P, F, V) {
            var Y = V._originalDate || N, ee = Y.getTimezoneOffset();
            if (ee === 0) return "Z";
            switch (P) {
                case"X":
                    return b(ee);
                case"XXXX":
                case"XX":
                    return S(ee);
                case"XXXXX":
                case"XXX":
                default:
                    return S(ee, ":")
            }
        }, x: function (N, P, F, V) {
            var Y = V._originalDate || N, ee = Y.getTimezoneOffset();
            switch (P) {
                case"x":
                    return b(ee);
                case"xxxx":
                case"xx":
                    return S(ee);
                case"xxxxx":
                case"xxx":
                default:
                    return S(ee, ":")
            }
        }, O: function (N, P, F, V) {
            var Y = V._originalDate || N, ee = Y.getTimezoneOffset();
            switch (P) {
                case"O":
                case"OO":
                case"OOO":
                    return "GMT" + g(ee, ":");
                case"OOOO":
                default:
                    return "GMT" + S(ee, ":")
            }
        }, z: function (N, P, F, V) {
            var Y = V._originalDate || N, ee = Y.getTimezoneOffset();
            switch (P) {
                case"z":
                case"zz":
                case"zzz":
                    return "GMT" + g(ee, ":");
                case"zzzz":
                default:
                    return "GMT" + S(ee, ":")
            }
        }, t: function (N, P, F, V) {
            var Y = V._originalDate || N, ee = Math.floor(Y.getTime() / 1e3);
            return (0, s.default)(ee, P.length)
        }, T: function (N, P, F, V) {
            var Y = V._originalDate || N, ee = Y.getTime();
            return (0, s.default)(ee, P.length)
        }
    };

    function g(I, N) {
        var P = I > 0 ? "-" : "+", F = Math.abs(I), V = Math.floor(F / 60), Y = F % 60;
        if (Y === 0) return P + String(V);
        var ee = N || "";
        return P + String(V) + ee + (0, s.default)(Y, 2)
    }

    function b(I, N) {
        if (I % 60 === 0) {
            var P = I > 0 ? "-" : "+";
            return P + (0, s.default)(Math.abs(I) / 60, 2)
        }
        return S(I, N)
    }

    function S(I, N) {
        var P = N || "", F = I > 0 ? "-" : "+", V = Math.abs(I), Y = (0, s.default)(Math.floor(V / 60), 2),
            ee = (0, s.default)(V % 60, 2);
        return F + Y + P + ee
    }

    var T = p;
    e.default = T, t.exports = e.default
})(iG, iG.exports);
var zlt = iG.exports, vG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = function (l, f) {
        switch (l) {
            case"P":
                return f.date({width: "short"});
            case"PP":
                return f.date({width: "medium"});
            case"PPP":
                return f.date({width: "long"});
            case"PPPP":
            default:
                return f.date({width: "full"})
        }
    }, n = function (l, f) {
        switch (l) {
            case"p":
                return f.time({width: "short"});
            case"pp":
                return f.time({width: "medium"});
            case"ppp":
                return f.time({width: "long"});
            case"pppp":
            default:
                return f.time({width: "full"})
        }
    }, i = function (l, f) {
        var d = l.match(/(P+)(p+)?/) || [], p = d[1], g = d[2];
        if (!g) return r(l, f);
        var b;
        switch (p) {
            case"P":
                b = f.dateTime({width: "short"});
                break;
            case"PP":
                b = f.dateTime({width: "medium"});
                break;
            case"PPP":
                b = f.dateTime({width: "long"});
                break;
            case"PPPP":
            default:
                b = f.dateTime({width: "full"});
                break
        }
        return b.replace("{{date}}", r(p, f)).replace("{{time}}", n(g, f))
    }, a = {p: n, P: i}, o = a;
    e.default = o, t.exports = e.default
})(vG, vG.exports);
var Vlt = vG.exports, gG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n) {
        var i = new Date(Date.UTC(n.getFullYear(), n.getMonth(), n.getDate(), n.getHours(), n.getMinutes(), n.getSeconds(), n.getMilliseconds()));
        return i.setUTCFullYear(n.getFullYear()), n.getTime() - i.getTime()
    }

    t.exports = e.default
})(gG, gG.exports);
var c2e = gG.exports;
const Ole = za(c2e);
var F8 = {};
Object.defineProperty(F8, "__esModule", {value: !0});
F8.isProtectedDayOfYearToken = qlt;
F8.isProtectedWeekYearToken = Glt;
F8.throwProtectedError = Klt;
var Hlt = ["D", "DD"], Wlt = ["YY", "YYYY"];

function qlt(t) {
    return Hlt.indexOf(t) !== -1
}

function Glt(t) {
    return Wlt.indexOf(t) !== -1
}

function Klt(t, e, r) {
    if (t === "YYYY") throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(e, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "YY") throw new RangeError("Use `yy` instead of `YY` (in `".concat(e, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "D") throw new RangeError("Use `d` instead of `D` (in `".concat(e, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "DD") throw new RangeError("Use `dd` instead of `DD` (in `".concat(e, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}

var yG = {exports: {}}, bG = {exports: {}}, wG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = {
        lessThanXSeconds: {one: "less than a second", other: "less than {{count}} seconds"},
        xSeconds: {one: "1 second", other: "{{count}} seconds"},
        halfAMinute: "half a minute",
        lessThanXMinutes: {one: "less than a minute", other: "less than {{count}} minutes"},
        xMinutes: {one: "1 minute", other: "{{count}} minutes"},
        aboutXHours: {one: "about 1 hour", other: "about {{count}} hours"},
        xHours: {one: "1 hour", other: "{{count}} hours"},
        xDays: {one: "1 day", other: "{{count}} days"},
        aboutXWeeks: {one: "about 1 week", other: "about {{count}} weeks"},
        xWeeks: {one: "1 week", other: "{{count}} weeks"},
        aboutXMonths: {one: "about 1 month", other: "about {{count}} months"},
        xMonths: {one: "1 month", other: "{{count}} months"},
        aboutXYears: {one: "about 1 year", other: "about {{count}} years"},
        xYears: {one: "1 year", other: "{{count}} years"},
        overXYears: {one: "over 1 year", other: "over {{count}} years"},
        almostXYears: {one: "almost 1 year", other: "almost {{count}} years"}
    }, n = function (o, s, l) {
        var f, d = r[o];
        return typeof d == "string" ? f = d : s === 1 ? f = d.one : f = d.other.replace("{{count}}", s.toString()), l != null && l.addSuffix ? l.comparison && l.comparison > 0 ? "in " + f : f + " ago" : f
    }, i = n;
    e.default = i, t.exports = e.default
})(wG, wG.exports);
var Ylt = wG.exports, SG = {exports: {}}, _G = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n) {
        return function () {
            var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                a = i.width ? String(i.width) : n.defaultWidth, o = n.formats[a] || n.formats[n.defaultWidth];
            return o
        }
    }

    t.exports = e.default
})(_G, _G.exports);
var Xlt = _G.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = n(Xlt);

    function n(f) {
        return f && f.__esModule ? f : {default: f}
    }

    var i = {full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy"},
        a = {full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a"}, o = {
            full: "{{date}} 'at' {{time}}",
            long: "{{date}} 'at' {{time}}",
            medium: "{{date}}, {{time}}",
            short: "{{date}}, {{time}}"
        }, s = {
            date: (0, r.default)({formats: i, defaultWidth: "full"}),
            time: (0, r.default)({formats: a, defaultWidth: "full"}),
            dateTime: (0, r.default)({formats: o, defaultWidth: "full"})
        }, l = s;
    e.default = l, t.exports = e.default
})(SG, SG.exports);
var Qlt = SG.exports, xG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
    }, n = function (o, s, l, f) {
        return r[o]
    }, i = n;
    e.default = i, t.exports = e.default
})(xG, xG.exports);
var Zlt = xG.exports, EG = {exports: {}}, TG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n) {
        return function (i, a) {
            var o = a != null && a.context ? String(a.context) : "standalone", s;
            if (o === "formatting" && n.formattingValues) {
                var l = n.defaultFormattingWidth || n.defaultWidth, f = a != null && a.width ? String(a.width) : l;
                s = n.formattingValues[f] || n.formattingValues[l]
            } else {
                var d = n.defaultWidth, p = a != null && a.width ? String(a.width) : n.defaultWidth;
                s = n.values[p] || n.values[d]
            }
            var g = n.argumentCallback ? n.argumentCallback(i) : i;
            return s[g]
        }
    }

    t.exports = e.default
})(TG, TG.exports);
var Jlt = TG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = n(Jlt);

    function n(b) {
        return b && b.__esModule ? b : {default: b}
    }

    var i = {narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"]}, a = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    }, o = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    }, s = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    }, l = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        }
    }, f = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        }
    }, d = function (S, T) {
        var I = Number(S), N = I % 100;
        if (N > 20 || N < 10) switch (N % 10) {
            case 1:
                return I + "st";
            case 2:
                return I + "nd";
            case 3:
                return I + "rd"
        }
        return I + "th"
    }, p = {
        ordinalNumber: d,
        era: (0, r.default)({values: i, defaultWidth: "wide"}),
        quarter: (0, r.default)({
            values: a, defaultWidth: "wide", argumentCallback: function (S) {
                return S - 1
            }
        }),
        month: (0, r.default)({values: o, defaultWidth: "wide"}),
        day: (0, r.default)({values: s, defaultWidth: "wide"}),
        dayPeriod: (0, r.default)({
            values: l,
            defaultWidth: "wide",
            formattingValues: f,
            defaultFormattingWidth: "wide"
        })
    }, g = p;
    e.default = g, t.exports = e.default
})(EG, EG.exports);
var eut = EG.exports, CG = {exports: {}}, AG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(a) {
        return function (o) {
            var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = s.width,
                f = l && a.matchPatterns[l] || a.matchPatterns[a.defaultMatchWidth], d = o.match(f);
            if (!d) return null;
            var p = d[0], g = l && a.parsePatterns[l] || a.parsePatterns[a.defaultParseWidth],
                b = Array.isArray(g) ? i(g, function (I) {
                    return I.test(p)
                }) : n(g, function (I) {
                    return I.test(p)
                }), S;
            S = a.valueCallback ? a.valueCallback(b) : b, S = s.valueCallback ? s.valueCallback(S) : S;
            var T = o.slice(p.length);
            return {value: S, rest: T}
        }
    }

    function n(a, o) {
        for (var s in a) if (a.hasOwnProperty(s) && o(a[s])) return s
    }

    function i(a, o) {
        for (var s = 0; s < a.length; s++) if (o(a[s])) return s
    }

    t.exports = e.default
})(AG, AG.exports);
var tut = AG.exports, IG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n) {
        return function (i) {
            var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = i.match(n.matchPattern);
            if (!o) return null;
            var s = o[0], l = i.match(n.parsePattern);
            if (!l) return null;
            var f = n.valueCallback ? n.valueCallback(l[0]) : l[0];
            f = a.valueCallback ? a.valueCallback(f) : f;
            var d = i.slice(s.length);
            return {value: f, rest: d}
        }
    }

    t.exports = e.default
})(IG, IG.exports);
var rut = IG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = i(tut), n = i(rut);

    function i(F) {
        return F && F.__esModule ? F : {default: F}
    }

    var a = /^(\d+)(th|st|nd|rd)?/i, o = /\d+/i, s = {
            narrow: /^(b|a)/i,
            abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
            wide: /^(before christ|before common era|anno domini|common era)/i
        }, l = {any: [/^b/i, /^(a|c)/i]},
        f = {narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i},
        d = {any: [/1/i, /2/i, /3/i, /4/i]}, p = {
            narrow: /^[jfmasond]/i,
            abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
            wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
        }, g = {
            narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
            any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
        }, b = {
            narrow: /^[smtwf]/i,
            short: /^(su|mo|tu|we|th|fr|sa)/i,
            abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
            wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
        }, S = {
            narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
            any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
        }, T = {
            narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
            any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
        }, I = {
            any: {
                am: /^a/i,
                pm: /^p/i,
                midnight: /^mi/i,
                noon: /^no/i,
                morning: /morning/i,
                afternoon: /afternoon/i,
                evening: /evening/i,
                night: /night/i
            }
        }, N = {
            ordinalNumber: (0, n.default)({
                matchPattern: a, parsePattern: o, valueCallback: function (V) {
                    return parseInt(V, 10)
                }
            }),
            era: (0, r.default)({matchPatterns: s, defaultMatchWidth: "wide", parsePatterns: l, defaultParseWidth: "any"}),
            quarter: (0, r.default)({
                matchPatterns: f,
                defaultMatchWidth: "wide",
                parsePatterns: d,
                defaultParseWidth: "any",
                valueCallback: function (V) {
                    return V + 1
                }
            }),
            month: (0, r.default)({
                matchPatterns: p,
                defaultMatchWidth: "wide",
                parsePatterns: g,
                defaultParseWidth: "any"
            }),
            day: (0, r.default)({matchPatterns: b, defaultMatchWidth: "wide", parsePatterns: S, defaultParseWidth: "any"}),
            dayPeriod: (0, r.default)({
                matchPatterns: T,
                defaultMatchWidth: "any",
                parsePatterns: I,
                defaultParseWidth: "any"
            })
        }, P = N;
    e.default = P, t.exports = e.default
})(CG, CG.exports);
var nut = CG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = s(Ylt), n = s(Qlt), i = s(Zlt), a = s(eut), o = s(nut);

    function s(d) {
        return d && d.__esModule ? d : {default: d}
    }

    var l = {
        code: "en-US",
        formatDistance: r.default,
        formatLong: n.default,
        formatRelative: i.default,
        localize: a.default,
        match: o.default,
        options: {weekStartsOn: 0, firstWeekContainsDate: 1}
    }, f = l;
    e.default = f, t.exports = e.default
})(bG, bG.exports);
var iut = bG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
    var r = n(iut);

    function n(a) {
        return a && a.__esModule ? a : {default: a}
    }

    var i = r.default;
    e.default = i, t.exports = e.default
})(yG, yG.exports);
var aut = yG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = F;
    var r = b(Rlt), n = b(Olt), i = b(J0), a = b(zlt), o = b(Vlt), s = b(c2e), l = F8, f = b(jS), d = b(Su), p = zS,
        g = b(aut);

    function b(Y) {
        return Y && Y.__esModule ? Y : {default: Y}
    }

    var S = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, T = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
        I = /^'([^]*?)'?$/, N = /''/g, P = /[a-zA-Z]/;

    function F(Y, ee, oe) {
        var G, J, ce, re, M, D, x, A, B, z, j, $, C, R, k, Q, fe, ye;
        (0, d.default)(2, arguments);
        var ue = String(ee), me = (0, p.getDefaultOptions)(),
            Se = (G = (J = oe == null ? void 0 : oe.locale) !== null && J !== void 0 ? J : me.locale) !== null && G !== void 0 ? G : g.default,
            Ce = (0, f.default)((ce = (re = (M = (D = oe == null ? void 0 : oe.firstWeekContainsDate) !== null && D !== void 0 ? D : oe == null || (x = oe.locale) === null || x === void 0 || (A = x.options) === null || A === void 0 ? void 0 : A.firstWeekContainsDate) !== null && M !== void 0 ? M : me.firstWeekContainsDate) !== null && re !== void 0 ? re : (B = me.locale) === null || B === void 0 || (z = B.options) === null || z === void 0 ? void 0 : z.firstWeekContainsDate) !== null && ce !== void 0 ? ce : 1);
        if (!(Ce >= 1 && Ce <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        var Me = (0, f.default)((j = ($ = (C = (R = oe == null ? void 0 : oe.weekStartsOn) !== null && R !== void 0 ? R : oe == null || (k = oe.locale) === null || k === void 0 || (Q = k.options) === null || Q === void 0 ? void 0 : Q.weekStartsOn) !== null && C !== void 0 ? C : me.weekStartsOn) !== null && $ !== void 0 ? $ : (fe = me.locale) === null || fe === void 0 || (ye = fe.options) === null || ye === void 0 ? void 0 : ye.weekStartsOn) !== null && j !== void 0 ? j : 0);
        if (!(Me >= 0 && Me <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        if (!Se.localize) throw new RangeError("locale must contain localize property");
        if (!Se.formatLong) throw new RangeError("locale must contain formatLong property");
        var ve = (0, i.default)(Y);
        if (!(0, r.default)(ve)) throw new RangeError("Invalid time value");
        var ne = (0, s.default)(ve), be = (0, n.default)(ve, ne),
            Ee = {firstWeekContainsDate: Ce, weekStartsOn: Me, locale: Se, _originalDate: ve},
            Oe = ue.match(T).map(function (ze) {
                var Be = ze[0];
                if (Be === "p" || Be === "P") {
                    var it = o.default[Be];
                    return it(ze, Se.formatLong)
                }
                return ze
            }).join("").match(S).map(function (ze) {
                if (ze === "''") return "'";
                var Be = ze[0];
                if (Be === "'") return V(ze);
                var it = a.default[Be];
                if (it) return !(oe != null && oe.useAdditionalWeekYearTokens) && (0, l.isProtectedWeekYearToken)(ze) && (0, l.throwProtectedError)(ze, ee, String(Y)), !(oe != null && oe.useAdditionalDayOfYearTokens) && (0, l.isProtectedDayOfYearToken)(ze) && (0, l.throwProtectedError)(ze, ee, String(Y)), it(be, ze, Se.localize, Ee);
                if (Be.match(P)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + Be + "`");
                return ze
            }).join("");
        return Oe
    }

    function V(Y) {
        var ee = Y.match(I);
        return ee ? ee[1].replace(N, "'") : Y
    }

    t.exports = e.default
})(Xq, Xq.exports);
var out = Xq.exports;
const sut = za(out);

function Ple(t, e, r) {
    var n = uut(t, r.timeZone, r.locale);
    return n.formatToParts ? cut(n, e) : lut(n, e)
}

function cut(t, e) {
    for (var r = t.formatToParts(e), n = r.length - 1; n >= 0; --n) if (r[n].type === "timeZoneName") return r[n].value
}

function lut(t, e) {
    var r = t.format(e).replace(/\u200E/g, ""), n = / [\w-+ ]+$/.exec(r);
    return n ? n[0].substr(1) : ""
}

function uut(t, e, r) {
    if (r && !r.code) throw new Error("date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`");
    return new Intl.DateTimeFormat(r ? [r.code, "en-US"] : void 0, {timeZone: e, timeZoneName: t})
}

function fut(t, e) {
    var r = mut(e);
    return r.formatToParts ? hut(r, t) : put(r, t)
}

var dut = {year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5};

function hut(t, e) {
    try {
        for (var r = t.formatToParts(e), n = [], i = 0; i < r.length; i++) {
            var a = dut[r[i].type];
            a >= 0 && (n[a] = parseInt(r[i].value, 10))
        }
        return n
    } catch (o) {
        if (o instanceof RangeError) return [NaN];
        throw o
    }
}

function put(t, e) {
    var r = t.format(e), n = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(r);
    return [n[3], n[1], n[2], n[4], n[5], n[6]]
}

var Nz = {};

function mut(t) {
    if (!Nz[t]) {
        var e = new Intl.DateTimeFormat("en-US", {
                hourCycle: "h23",
                timeZone: "America/New_York",
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit"
            }).format(new Date("2014-06-25T04:00:00.123Z")),
            r = e === "06/25/2014, 00:00:00" || e === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
        Nz[t] = r ? new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone: t,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }) : new Intl.DateTimeFormat("en-US", {
            hour12: !1,
            timeZone: t,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        })
    }
    return Nz[t]
}

function l2e(t, e, r, n, i, a, o) {
    var s = new Date(0);
    return s.setUTCFullYear(t, e, r), s.setUTCHours(n, i, a, o), s
}

var Nle = 36e5, vut = 6e4, Lz = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};

function XQ(t, e, r) {
    var n, i;
    if (!t || (n = Lz.timezoneZ.exec(t), n)) return 0;
    var a;
    if (n = Lz.timezoneHH.exec(t), n) return a = parseInt(n[1], 10), Lle(a) ? -(a * Nle) : NaN;
    if (n = Lz.timezoneHHMM.exec(t), n) {
        a = parseInt(n[2], 10);
        var o = parseInt(n[3], 10);
        return Lle(a, o) ? (i = Math.abs(a) * Nle + o * vut, n[1] === "+" ? -i : i) : NaN
    }
    if (but(t)) {
        e = new Date(e || Date.now());
        var s = r ? e : gut(e), l = kG(s, t), f = r ? l : yut(e, l, t);
        return -f
    }
    return NaN
}

function gut(t) {
    return l2e(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds())
}

function kG(t, e) {
    var r = fut(t, e), n = l2e(r[0], r[1] - 1, r[2], r[3] % 24, r[4], r[5], 0).getTime(), i = t.getTime(), a = i % 1e3;
    return i -= a >= 0 ? a : 1e3 + a, n - i
}

function yut(t, e, r) {
    var n = t.getTime(), i = n - e, a = kG(new Date(i), r);
    if (e === a) return e;
    i -= a - e;
    var o = kG(new Date(i), r);
    return a === o ? a : Math.max(a, o)
}

function Lle(t, e) {
    return -23 <= t && t <= 23 && (e == null || 0 <= e && e <= 59)
}

var Ble = {};

function but(t) {
    if (Ble[t]) return !0;
    try {
        return Ble[t] = !0, !0
    } catch {
        return !1
    }
}

var wut = 60 * 1e3, Sut = {
    X: function (t, e, r, n) {
        var i = Bz(n.timeZone, t);
        if (i === 0) return "Z";
        switch (e) {
            case"X":
                return $le(i);
            case"XXXX":
            case"XX":
                return mx(i);
            case"XXXXX":
            case"XXX":
            default:
                return mx(i, ":")
        }
    }, x: function (t, e, r, n) {
        var i = Bz(n.timeZone, t);
        switch (e) {
            case"x":
                return $le(i);
            case"xxxx":
            case"xx":
                return mx(i);
            case"xxxxx":
            case"xxx":
            default:
                return mx(i, ":")
        }
    }, O: function (t, e, r, n) {
        var i = Bz(n.timeZone, t);
        switch (e) {
            case"O":
            case"OO":
            case"OOO":
                return "GMT" + _ut(i, ":");
            case"OOOO":
            default:
                return "GMT" + mx(i, ":")
        }
    }, z: function (t, e, r, n) {
        switch (e) {
            case"z":
            case"zz":
            case"zzz":
                return Ple("short", t, n);
            case"zzzz":
            default:
                return Ple("long", t, n)
        }
    }
};

function Bz(t, e) {
    var r = t ? XQ(t, e, !0) / wut : e.getTimezoneOffset();
    if (Number.isNaN(r)) throw new RangeError("Invalid time zone specified: " + t);
    return r
}

function hO(t, e) {
    for (var r = t < 0 ? "-" : "", n = Math.abs(t).toString(); n.length < e;) n = "0" + n;
    return r + n
}

function mx(t, e) {
    var r = e || "", n = t > 0 ? "-" : "+", i = Math.abs(t), a = hO(Math.floor(i / 60), 2),
        o = hO(Math.floor(i % 60), 2);
    return n + a + r + o
}

function $le(t, e) {
    if (t % 60 === 0) {
        var r = t > 0 ? "-" : "+";
        return r + hO(Math.abs(t) / 60, 2)
    }
    return mx(t, e)
}

function _ut(t, e) {
    var r = t > 0 ? "-" : "+", n = Math.abs(t), i = Math.floor(n / 60), a = n % 60;
    if (a === 0) return r + String(i);
    var o = e || "";
    return r + String(i) + o + hO(a, 2)
}

var xut = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, $z = 36e5, Fle = 6e4, Eut = 2,
    nu = {
        dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
        datePattern: /^([0-9W+-]+)(.*)/,
        plainTime: /:/,
        YY: /^(\d{2})$/,
        YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
        YYYY: /^(\d{4})/,
        YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        timeZone: xut
    };

function u2e(t, e) {
    if (arguments.length < 1) throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if (t === null) return new Date(NaN);
    var r = e || {}, n = r.additionalDigits == null ? Eut : Dlt(r.additionalDigits);
    if (n !== 2 && n !== 1 && n !== 0) throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]") return new Date(t.getTime());
    if (typeof t == "number" || Object.prototype.toString.call(t) === "[object Number]") return new Date(t);
    if (!(typeof t == "string" || Object.prototype.toString.call(t) === "[object String]")) return new Date(NaN);
    var i = Tut(t), a = Cut(i.date, n), o = a.year, s = a.restDateString, l = Aut(s, o);
    if (isNaN(l)) return new Date(NaN);
    if (l) {
        var f = l.getTime(), d = 0, p;
        if (i.time && (d = Iut(i.time), isNaN(d))) return new Date(NaN);
        if (i.timeZone || r.timeZone) {
            if (p = XQ(i.timeZone || r.timeZone, new Date(f + d)), isNaN(p)) return new Date(NaN)
        } else p = Ole(new Date(f + d)), p = Ole(new Date(f + d + p));
        return new Date(f + d + p)
    } else return new Date(NaN)
}

function Tut(t) {
    var e = {}, r = nu.dateTimePattern.exec(t), n;
    if (r ? (e.date = r[1], n = r[3]) : (r = nu.datePattern.exec(t), r ? (e.date = r[1], n = r[2]) : (e.date = null, n = t)), n) {
        var i = nu.timeZone.exec(n);
        i ? (e.time = n.replace(i[1], ""), e.timeZone = i[1].trim()) : e.time = n
    }
    return e
}

function Cut(t, e) {
    var r = nu.YYY[e], n = nu.YYYYY[e], i;
    if (i = nu.YYYY.exec(t) || n.exec(t), i) {
        var a = i[1];
        return {year: parseInt(a, 10), restDateString: t.slice(a.length)}
    }
    if (i = nu.YY.exec(t) || r.exec(t), i) {
        var o = i[1];
        return {year: parseInt(o, 10) * 100, restDateString: t.slice(o.length)}
    }
    return {year: null}
}

function Aut(t, e) {
    if (e === null) return null;
    var r, n, i, a;
    if (t.length === 0) return n = new Date(0), n.setUTCFullYear(e), n;
    if (r = nu.MM.exec(t), r) return n = new Date(0), i = parseInt(r[1], 10) - 1, jle(e, i) ? (n.setUTCFullYear(e, i), n) : new Date(NaN);
    if (r = nu.DDD.exec(t), r) {
        n = new Date(0);
        var o = parseInt(r[1], 10);
        return Dut(e, o) ? (n.setUTCFullYear(e, 0, o), n) : new Date(NaN)
    }
    if (r = nu.MMDD.exec(t), r) {
        n = new Date(0), i = parseInt(r[1], 10) - 1;
        var s = parseInt(r[2], 10);
        return jle(e, i, s) ? (n.setUTCFullYear(e, i, s), n) : new Date(NaN)
    }
    if (r = nu.Www.exec(t), r) return a = parseInt(r[1], 10) - 1, zle(e, a) ? Ule(e, a) : new Date(NaN);
    if (r = nu.WwwD.exec(t), r) {
        a = parseInt(r[1], 10) - 1;
        var l = parseInt(r[2], 10) - 1;
        return zle(e, a, l) ? Ule(e, a, l) : new Date(NaN)
    }
    return null
}

function Iut(t) {
    var e, r, n;
    if (e = nu.HH.exec(t), e) return r = parseFloat(e[1].replace(",", ".")), Fz(r) ? r % 24 * $z : NaN;
    if (e = nu.HHMM.exec(t), e) return r = parseInt(e[1], 10), n = parseFloat(e[2].replace(",", ".")), Fz(r, n) ? r % 24 * $z + n * Fle : NaN;
    if (e = nu.HHMMSS.exec(t), e) {
        r = parseInt(e[1], 10), n = parseInt(e[2], 10);
        var i = parseFloat(e[3].replace(",", "."));
        return Fz(r, n, i) ? r % 24 * $z + n * Fle + i * 1e3 : NaN
    }
    return null
}

function Ule(t, e, r) {
    e = e || 0, r = r || 0;
    var n = new Date(0);
    n.setUTCFullYear(t, 0, 4);
    var i = n.getUTCDay() || 7, a = e * 7 + r + 1 - i;
    return n.setUTCDate(n.getUTCDate() + a), n
}

var kut = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Rut = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function f2e(t) {
    return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0
}

function jle(t, e, r) {
    if (e < 0 || e > 11) return !1;
    if (r != null) {
        if (r < 1) return !1;
        var n = f2e(t);
        if (n && r > Rut[e] || !n && r > kut[e]) return !1
    }
    return !0
}

function Dut(t, e) {
    if (e < 1) return !1;
    var r = f2e(t);
    return !(r && e > 366 || !r && e > 365)
}

function zle(t, e, r) {
    return !(e < 0 || e > 52 || r != null && (r < 0 || r > 6))
}

function Fz(t, e, r) {
    return !(t != null && (t < 0 || t >= 25) || e != null && (e < 0 || e >= 60) || r != null && (r < 0 || r >= 60))
}

var Mut = /([xXOz]+)|''|'(''|[^'])+('|$)/g;

function Out(t, e, r) {
    var n = String(e), i = r || {}, a = n.match(Mut);
    if (a) {
        var o = u2e(i.originalDate || t, i);
        n = a.reduce(function (s, l) {
            if (l[0] === "'") return s;
            var f = s.indexOf(l), d = s[f - 1] === "'", p = s.replace(l, "'" + Sut[l[0]](o, l, null, i) + "'");
            return d ? p.substring(0, f - 1) + p.substring(f + 1) : p
        }, n)
    }
    return sut(t, n, i)
}

var RG = {exports: {}}, DG = {exports: {}};
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = r;

    function r(n, i) {
        if (n == null) throw new TypeError("assign requires that input parameter not be null or undefined");
        for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]);
        return n
    }

    t.exports = e.default
})(DG, DG.exports);
var Put = DG.exports;
(function (t, e) {
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = i;
    var r = n(Put);

    function n(a) {
        return a && a.__esModule ? a : {default: a}
    }

    function i(a) {
        return (0, r.default)({}, a)
    }

    t.exports = e.default
})(RG, RG.exports);
var Nut = RG.exports;
const Lut = za(Nut);

function But(t, e, r) {
    var n = u2e(t, r), i = XQ(e, n, !0), a = new Date(n.getTime() - i), o = new Date(0);
    return o.setFullYear(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate()), o.setHours(a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(), a.getUTCMilliseconds()), o
}

function $ut(t, e, r, n) {
    var i = Lut(n);
    return i.timeZone = e, i.originalDate = t, Out(But(t, e), r, i)
}

const Vle = t => ({
        seconds: Number.parseFloat(new Kn(t / 1e3).toFixed(1, 3).toString()),
        milliseconds: Number.parseFloat(new Kn(t).decimalPlaces(0, 3).toString())
    }), d2e = "MMM do kk:mm", Fut = (t, e = d2e) => VVe(t, e), wJt = (t, e = d2e) => $ut(t, "UTC", e),
    Hle = (t, e = {}) => {
        const r = e.now ?? Date.now();
        if (QVe(t, r)) return null;
        const n = XVe({start: t, end: r}), i = [];
        return n.days && n.days >= 1 || n.months && n.months > 0 || n.years && n.years > 0 ? (n.years && n.years > 0 && i.push(`${n.years}y`), n.months && n.months > 0 && i.push(`${n.months}mo`), n.days && n.days > 0 && i.push(`${n.days}d`), !n.years && !n.months && n.hours && n.hours > 0 && i.push(`${n.hours}h`)) : (n.hours && n.hours > 0 && i.push(`${n.hours}h`), n.minutes && n.minutes > 0 && i.push(`${n.minutes}m`), (n.hours === void 0 || n.hours === 0) && (n.minutes === void 0 || n.minutes === 0) && n.seconds !== void 0 && i.push(`${n.seconds}s`)), au(i) ? e.singleUnit ? i[0] : i.join(" ") : ""
    }, h2e = t => typeof t == "number" ? new Kn(t) : typeof t == "string" ? new Kn(t.replace(/,/g, "")) : t, Jv = t => {
        var o, s;
        let e = h2e(t.number), r;
        if (t.min001 && e.lt(.01)) return `<${t.prefix ?? ""}0.01${t.suffix ?? ""}`;
        if (t.min01 && e.lt(.1)) return `<${t.prefix ?? ""}0.1${t.suffix ?? ""}`;
        if (t.min1 && e.lt(1)) return `<${t.prefix ?? ""}1${t.suffix ?? ""}`;
        let n;
        if (t.largeNumberSuffix) {
            let l;
            if (t.largeNumberSuffix.threshold === "thousand" ? l = 1e3 : t.largeNumberSuffix.threshold === "ten-thousand" ? l = 1e4 : t.largeNumberSuffix.threshold === "hundred-thousand" ? l = 1e5 : t.largeNumberSuffix.threshold === "million" ? l = 1e6 : t.largeNumberSuffix.threshold === "billion" ? l = 1e9 : t.largeNumberSuffix.threshold === "trillion" ? l = 1e12 : t.largeNumberSuffix.threshold === "quadrillion" ? l = 1e15 : l = Number.POSITIVE_INFINITY, e.abs().gte(l)) {
                const f = e;
                if (e.abs().lt(1e6)) e = e.dividedBy(1e3), r = "K"; else if (e.abs().lt(1e9)) e = e.dividedBy(1e6), r = "M"; else if (e.abs().lt(1e12)) e = e.dividedBy(1e9), r = "B"; else if (e.abs().lt(1e15)) e = e.dividedBy(1e12), r = "T"; else {
                    if (e = e.dividedBy(1e15), r = "Q", e.gte(1e3)) return `>${t.prefix ?? ""}999Q${t.suffix ?? ""}`;
                    if (e.lte(-1e3)) return `<${t.prefix ?? ""}-999Q${t.suffix ?? ""}`
                }
                n = typeof t.largeNumberSuffix.significantDigits == "function" ? t.largeNumberSuffix.significantDigits(f, e) : t.largeNumberSuffix.significantDigits
            }
        }
        n === void 0 && (typeof t.significantDigits == "number" ? n = t.significantDigits : typeof t.significantDigits == "function" ? n = t.significantDigits(e) : e.lt(1) ? n = t.significantDigits.lt1 : n = t.significantDigits.gte1), e.abs().lt(1) ? n > 0 && (e = e.precision(n, e.gte(0) ? 3 : 2)) : e = new Kn(e.toFixed(n, e.gte(1) ? 3 : 2));
        let i = e.toFixed();
        const a = i.match(/\.0*(\d+)$/);
        if (a ? a[1] !== void 0 && a[1].length < n && (i = i + "0".repeat(n - a[1].length)) : n > 0 && (i = i + "." + "0".repeat(n)), t.maxDecimalPrecision) {
            let l;
            if (typeof t.maxDecimalPrecision == "number" ? l = t.maxDecimalPrecision : typeof t.maxDecimalPrecision == "function" ? l = t.maxDecimalPrecision(e) : e.lt(1) ? l = t.maxDecimalPrecision.lt1 : l = t.maxDecimalPrecision.gte1, l !== void 0) {
                const f = (s = (o = i.match(/\.(\d+)$/)) == null ? void 0 : o[1]) == null ? void 0 : s.length;
                f !== void 0 && (l === 0 ? i = i.slice(0, i.indexOf(".")) : f > l && (i = i.slice(0, i.length - (f - l))))
            }
        }
        if (t.addCommas) {
            const l = i.split(".");
            l[0] !== void 0 && (l[0] = l[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",")), i = l.join(".")
        }
        return r && (i = i + r), t.prefix && (i = t.prefix + i), t.suffix && (i = i + t.suffix), i
    }, SJt = (t, e) => {
        let r;
        e ? r = new Kn(t).toFixed(e, 3) : r = new Kn(t).toFixed();
        const n = r.split(".");
        return n[0] !== void 0 && (n[0] = n[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",")), n.join(".")
    }, Uut = t => Array.from(String(t), Number).map(e => {
        const r = 2080 + e;
        return String.fromCharCode(parseInt(r.toString(), 16))
    }).join(""), pO = {
        significantDigits: {lt1: 4, gte1: 2},
        maxDecimalPrecision: {gte1: 2},
        largeNumberSuffix: {threshold: "hundred-thousand", significantDigits: 2},
        addCommas: !0,
        maxZeroes: 5,
        prefix: "$"
    }, p2e = t => {
        const e = t.number.match(new RegExp(`0\\.(0{${t.maxZeroes},})(\\d+)`));
        if (!e || !e[1] || !e[2]) return t.number;
        const r = h2e(t.number), n = Uut(e[1].length), i = e[2], a = `0.0${n}${i}`;
        return r.lt(0) ? `-${a}` : a
    }, _Jt = (t, e) => Jv({number: t, ...pO, ...e}), jut = t => {
        if (!t.lt(1)) return t.lt(1e3) ? 4 : 2
    }, MG = {
        significantDigits: 4,
        maxDecimalPrecision: jut,
        largeNumberSuffix: {threshold: "hundred-thousand", significantDigits: 2},
        addCommas: !0,
        maxZeroes: 5
    }, xJt = t => {
        let e = Jv({number: t, ...pO, prefix: void 0});
        const r = "$", n = pO.maxZeroes;
        return e = p2e({
            number: e,
            maxZeroes: n
        }), e === "<0.01" ? `${r}0.01` : e === "<0.1" ? `${r}0.1` : e === "<1" ? `${r}1` : `${r}${e}`
    }, EJt = t => {
        var a, o;
        let e = Jv({number: t.price, ...MG});
        const r = ((a = t.options) == null ? void 0 : a.prefix) ?? "",
            n = ((o = t.options) == null ? void 0 : o.suffix) ?? "", i = MG.maxZeroes;
        return e = p2e({
            number: e,
            maxZeroes: i
        }), e === "<0.01" ? `${r}0.01${n}` : e === "<0.1" ? `${r}0.1${n}` : e === "<1" ? `${r}1${n}` : `${r}${e}${n}`
    }, zut = t => t.slice(0, 6) + "..." + t.slice(-4), TJt = t => t.replace(/,/g, "");

class Vut {
    constructor(e) {
        Ft(this, "time");
        Ft(this, "onStop");
        Ft(this, "timerResult", null);
        this.time = Date.now(), this.onStop = e
    }

    stop() {
        if (this.timerResult) throw new Error("Timer already stopped");
        return this.timerResult = Vle(Date.now() - this.time), this.onStop && this.onStop(this.timerResult), this.timerResult
    }

    current() {
        return this.timerResult ? this.timerResult : Vle(Date.now() - this.time)
    }
}

const Hut = t => new Vut(t);

class Wut {
    constructor(e) {
        Ft(this, "params");
        Ft(this, "isStarted", !1);
        Ft(this, "isRunning", !1);
        this.params = e
    }

    get status() {
        return {isStarted: this.isStarted, isRunning: this.isRunning, isStopped: !this.isRunning && !this.isStarted}
    }

    async start() {
        var e;
        if (this.isStarted) throw new Error("Already started");
        for (this.isStarted = !0, this.params.log && this.params.log.silly("Starting..."), this.params.delayInMs && ((e = this.params.log) == null || e.silly("Delaying first run..."), await Alt(this.params.delayInMs)); this.isStarted === !0;) {
            this.isRunning = !0;
            const r = Hut();
            if (await new Promise((i, a) => {
                let o = !1;
                this.params.timeoutInMs && setTimeout(() => {
                    o || (o = !0, a(new Error("Run timed out")))
                }, this.params.timeoutInMs), Promise.resolve(this.params.callback()).then(() => {
                    o || i(void 0)
                }).catch(s => {
                    o || a(s)
                }).finally(() => {
                    o = !0
                })
            }).catch(i => {
                this.params.onError && this.params.onError($f(i))
            }), this.isRunning = !1, !this.isStarted) {
                this.handleStopped();
                break
            }
            const n = r.stop();
            this.params.log && n.milliseconds > this.params.intervalInMs && this.params.log.warn(`Run took longer (${n.milliseconds.toLocaleString()}ms) than interval (${this.params.intervalInMs}ms)`), n.milliseconds < this.params.intervalInMs && await new Promise(i => {
                if (!this.params.intervalInMs) throw new Error("No interval set");
                setTimeout(() => i(void 0), this.params.intervalInMs - n.milliseconds)
            })
        }
    }

    stop() {
        if (!this.isStarted) throw new Error("Not running");
        this.params.log && this.params.log.silly("Stopping..."), this.isStarted = !1, this.isRunning || this.handleStopped()
    }

    handleStopped() {
        this.params.log && this.params.log.silly("Stopped!"), this.params.onStop && this.params.onStop()
    }
}

const m2e = t => new Wut(t);

class qut extends Error {
    constructor(r) {
        var n;
        super(r.message);
        Ft(this, "allErrors");
        this.allErrors = ((n = r.allErrors) == null ? void 0 : n.slice()) ?? [], this.name = "RetryError"
    }
}

const QQ = async t => {
        const e = new qut({message: `All ${t.retrySettings.tries} tries failed`});
        let r = 1, n = 0, i = !1;
        const a = () => {
            i = !0
        };
        for (; r <= t.retrySettings.tries && !i;) {
            let o = !1;
            const s = () => {
                o = !0
            };
            try {
                const l = await iC({
                    callback: () => t.callback({
                        tryNumber: r,
                        allErrors: e.allErrors,
                        totalSkips: n,
                        skip: s,
                        cancel: a
                    }), timeoutInMs: t.retrySettings.timeoutInMs ?? void 0
                });
                if (o) {
                    n += 1;
                    continue
                }
                return l
            } catch (l) {
                l instanceof Error && (e.allErrors.push(l), t.retrySettings.onTryError && t.retrySettings.onTryError({
                    error: l,
                    tryNumber: r
                }), t.retrySettings.delayInMs && r !== t.retrySettings.tries && await new Promise(f => setTimeout(() => f(void 0), t.retrySettings.delayInMs)), r += 1)
            }
        }
        throw e
    }, Gut = mn("@dexscreener/util-network//NewWebSocketClientFactory")(), ZQ = (t, e) => {
        let r = 0, n;
        return {
            reconnect: i => {
                r++, clearTimeout(n), r <= e && (n = setTimeout(i, t))
            }, reset: () => {
                r = 0, clearTimeout(n)
            }
        }
    }, Kut = pt("@dexscreener/util-network//timeoutWebSocketClientReconnectionStrategyTimeInMs", () => 5e3),
    Yut = pt("@dexscreener/util-network//timeoutWebSocketClientReconnectionStrategyMaxAttempts", () => 1 / 0),
    CJt = pt({timeInMs: Kut, maxAttempts: Yut}, ({timeInMs: t, maxAttempts: e}) => ZQ(t, e)), Wle = {
        encode: t => JSON.stringify(t),
        decode: t => JSON.parse(typeof t == "string" ? t : new TextDecoder().decode(t))
    }, v2e = t => ({encode: Wle.encode, decode: e => t.parse(Wle.decode(e))}), Xut = ({initialValue: t, target: e}) => {
        const r = new SX(t), n = () => r.next(!0), i = () => r.next(!1);
        return e.addEventListener("online", n), e.addEventListener("offline", i), {
            dispose: () => {
                e.removeEventListener("online", n), e.removeEventListener("offline", i)
            }, isConnected: r
        }
    }, Qut = pt("@dexscreener/util-network/network-connection-manager", () => Xut),
    Tp = mn("@dexscreener/util-network/HTTPClient")();

class JQ extends Error {
    constructor(r) {
        super(r.message);
        Ft(this, "url");
        this.name = "HTTPTransportError", this.url = r.url, Object.setPrototypeOf(this, JQ.prototype)
    }
}

class Kh extends Error {
    constructor(r) {
        super(r.message);
        Ft(this, "url");
        Ft(this, "status");
        Ft(this, "response");
        this.name = "HTTPError", this.url = r.url, this.status = r.status, this.response = r.response, Object.setPrototypeOf(this, Kh.prototype)
    }
}

class eZ extends Kh {
    constructor(r) {
        super({url: r.url, status: r.status, message: r.message});
        Ft(this, "validation");
        this.name = "HTTPZodValidationError", this.validation = r.error.format(), Object.setPrototypeOf(this, eZ.prototype)
    }
}

class mO extends Kh {
    constructor(r) {
        super({url: r.url, status: r.status, message: r.message});
        Ft(this, "cause");
        this.name = "HTTPValidationError", this.cause = r.cause, Object.setPrototypeOf(this, mO.prototype)
    }
}

class r4 extends n2e {
    constructor(r) {
        super(r.timeoutInMs);
        Ft(this, "timeoutInMs");
        Ft(this, "url");
        this.name = "HTTPTimeoutError", this.timeoutInMs = r.timeoutInMs, this.url = r.url, Object.setPrototypeOf(this, r4.prototype)
    }
}

const tZ = pt(Tp, t => {
    const e = r => new ia(n => {
        const i = new AbortController;
        return r({signal: i.signal}).then(a => {
            n.next(a), n.complete()
        }).catch(a => {
            (!(a instanceof Error) || a.name !== "AbortError") && n.error(a)
        }), () => i.abort()
    });
    return {
        get: (r, n, i) => e(({signal: a}) => t.get(r, n, {...i, signal: a})),
        post: (r, n, i) => e(({signal: a}) => t.post(r, n, {...i, signal: a})),
        text: (r, n) => e(({signal: i}) => t.text(r, {...n, signal: i})),
        head: (r, n) => e(({signal: i}) => t.head(r, {...n, signal: i})),
        avro: (r, n, i) => e(({signal: a}) => t.avro(r, n, {...i, signal: a}))
    }
}), RN = mn("@dexscreener/data-access-ds-data//dsDataPersistentCache")();
var Zut = function (e, r = JSON.stringify) {
    const n = new Map;
    return function () {
        const a = r(arguments);
        if (n.has(a)) return n.get(a);
        const o = e.apply(this, arguments).finally(() => {
            n.delete(a)
        });
        return n.set(a, o), o
    }
};
const tf = za(Zut), g2e = KE(["telegram", "twitter", "discord", "facebook", "tiktok"]), Jut = _.enum(g2e.values),
    DN = Gr({type: g2e, url: V4()}), y2e = _.object({type: Jut, url: vA.stringAsURL}),
    MN = Gr({label: kt(), url: kt()}), b2e = _.object({label: _.string(), url: _.string()}),
    w2e = Gr({date: Ns(), count: Xt()}), S2e = _.object({date: _.coerce.date(), count: _.number()}),
    _2e = Gr({date: Ns(), count: Xt()}), x2e = _.object({date: _.coerce.date(), count: _.number()}),
    rZ = KE(["pending", "running", "ended"]), E2e = _.enum(["pending", "running", "ended"]), eft = Gr({
        id: kt(),
        chainId: kt(),
        tokenAddress: kt(),
        title: kt(),
        description: kt(),
        image: V4(),
        websites: Ci(MN).optional(),
        socials: Ci(DN).optional(),
        status: rZ,
        startDate: Ns(),
        endDate: Ns().optional(),
        visits: Ci(_2e).optional(),
        totalVisits: Xt(),
        impressions: Ci(w2e).optional(),
        acquiredImpressions: Xt(),
        usedImpressions: Xt(),
        impressionURL: V4()
    }), tft = _.object({
        id: _.string(),
        chainId: _.string(),
        tokenAddress: _.string(),
        title: _.string(),
        description: _.string(),
        image: vA.stringAsURL,
        websites: Cn(b2e).optional(),
        socials: Cn(y2e).optional(),
        status: E2e,
        startDate: _.coerce.date(),
        endDate: _.coerce.date().optional(),
        visits: Cn(x2e).optional(),
        totalVisits: _.number(),
        impressions: Cn(S2e).optional(),
        acquiredImpressions: _.number(),
        usedImpressions: _.number(),
        impressionURL: vA.stringAsURL
    }), T2e = Gr({
        id: kt(),
        chainId: kt(),
        tokenAddress: kt(),
        title: kt(),
        image: V4(),
        status: rZ,
        startDate: Ns(),
        endDate: Ns().optional(),
        visits: Ci(_2e).optional(),
        totalVisits: Xt(),
        impressions: Ci(w2e).optional(),
        usedImpressions: Xt(),
        impressionURL: V4()
    }), C2e = _.object({
        id: _.string(),
        chainId: _.string(),
        tokenAddress: _.string(),
        title: _.string(),
        image: vA.stringAsURL,
        status: E2e,
        startDate: _.coerce.date(),
        endDate: _.coerce.date().optional(),
        visits: Cn(x2e).optional(),
        totalVisits: _.number(),
        impressions: Cn(S2e).optional(),
        usedImpressions: _.number(),
        impressionURL: vA.stringAsURL,
        createdAt: _.coerce.date(),
        updatedAt: _.coerce.date(),
        deleted: ur(_.boolean())
    }), rft = T2e.extend({
        kind: Bs("pair-details"),
        description: kt(),
        websites: Ci(MN).optional(),
        socials: Ci(DN).optional(),
        acquiredImpressions: Xt()
    }), nft = C2e.extend({
        kind: _.literal("pair-details"),
        description: _.string(),
        websites: Cn(b2e).optional(),
        socials: Cn(y2e).optional(),
        acquiredImpressions: _.number()
    }), ift = T2e.omit({endDate: !0}).extend({kind: Bs("trending-bar"), endDate: Ns()}),
    aft = C2e.omit({endDate: !0}).extend({kind: _.literal("trending-bar"), endDate: _.coerce.date()}), oft = rft.pick({
        kind: !0,
        id: !0,
        chainId: !0,
        tokenAddress: !0,
        title: !0,
        description: !0,
        image: !0,
        websites: !0,
        socials: !0,
        impressionURL: !0
    }), sft = ift.pick({kind: !0, id: !0, chainId: !0, tokenAddress: !0, title: !0, image: !0, impressionURL: !0}),
    cft = nft.pick({
        kind: !0,
        id: !0,
        chainId: !0,
        tokenAddress: !0,
        title: !0,
        description: !0,
        image: !0,
        websites: !0,
        socials: !0,
        impressionURL: !0
    }), lft = aft.pick({kind: !0, id: !0, chainId: !0, tokenAddress: !0, title: !0, image: !0, impressionURL: !0}),
    uft = eft.pick({
        id: !0,
        chainId: !0,
        tokenAddress: !0,
        title: !0,
        description: !0,
        image: !0,
        socials: !0,
        websites: !0,
        impressionURL: !0
    }).extend({weight: Xt()}), fft = tft.pick({
        id: !0,
        chainId: !0,
        tokenAddress: !0,
        title: !0,
        description: !0,
        image: !0,
        socials: !0,
        websites: !0,
        impressionURL: !0
    }).extend({weight: _.number()}), dft = oft.extend({weight: Xt()}), hft = sft.extend({weight: Xt()}),
    pft = US([dft, hft]), mft = _.union([cft.extend({weight: _.number()}), lft.extend({weight: _.number()})]),
    vft = pft, gft = mft;

function yft(t) {
    const {ads: e, chainId: r, tokenAddress: n, random: i} = t,
        a = e.filter(o => o.chainId === r && o.tokenAddress !== n);
    if (a.length !== 0) return uw({items: a, random: i})
}

const bft = Gr({chainId: kt(), tokenAddress: kt(), endDate: Ns().optional()}),
    wft = _.object({chainId: _.string(), tokenAddress: _.string(), endDate: _.coerce.date().optional()}),
    Sft = Gr({global: Xt(), byChain: qq(kt(), Xt())}),
    _ft = _.object({global: _.number(), byChain: _.record(_.string(), _.number())}),
    xft = Gr({ads: Ci(uft), threshold: Xt(), recent: Ci(bft)}),
    Eft = _.object({ads: Cn(fft), threshold: _.number(), recent: Cn(wft)}),
    Tft = xft.omit({threshold: !0}).extend({thresholds: Sft}),
    Cft = Eft.omit({threshold: !0}).extend({thresholds: _ft}), Aft = Tft.omit({ads: !0}).extend({ads: Ci(vft)}),
    Ift = Cft.omit({ads: !0}).extend({ads: Cn(gft)}), kft = Aft, Rft = Ift, A2e = Gr({start: Xt(), end: Xt()});
A2e.optional();
const Dft = pt("@dexscreener/data-access-ds-data/dsDataServerAdsDataSource", Tp, $i(), (t, e) => ({
    getActiveAds: tf(async r => QQ({
        callback: async () => {
            const n = new URL(e.DS_DATA_SERVER_PUBLIC_ORIGIN);
            return n.pathname = "/ds-data/ads/active/v4", t.avro(n.toString(), kft, {signal: r == null ? void 0 : r.signal})
        },
        retrySettings: {
            tries: e.DS_DATA_RETRY_MAX_ATTEMPTS,
            timeoutInMs: e.DS_DATA_RETRY_TIMEOUT_IN_MS,
            delayInMs: e.DS_DATA_RETRY_DELAY_IN_MS
        }
    })), getNextTrendingBarAdTimeInterval: async ({duration: r, chainId: n, signal: i}) => {
        const a = new URL(e.DS_DATA_SERVER_PUBLIC_ORIGIN);
        return a.pathname = "/ds-data/ads/trending-bar/next-time-interval", a.searchParams.set("duration", r.toString()), a.searchParams.set("chainId", n), t.avro(a.toString(), A2e, {
            method: "GET",
            signal: i
        })
    }
})), Mft = ["svm", "aptos", "sui", "cosmos", "evm"], Oft = _.object({
    shortName: ur(_.string()),
    name: _.string(),
    slug: _.string(),
    nativeChainId: ur(_.number()),
    order: ur(_.number()),
    blockExplorer: _.object({
        accountURL: _.string(),
        assetURL: ur(_.string()),
        txnsURL: ur(_.string()),
        holdersURL: ur(_.string())
    }),
    isHidden: ur(_.boolean()),
    rpcURL: ur(_.string()),
    wrappedNativeToken: ur(_.string()),
    screeners: _.array(_.string()),
    indexers: _.array(_.string()),
    integrations: ur(_.object({
        coinGecko: ur(_.object({isEnabled: ur(_.boolean()), chainId: ur(_.string())})),
        goPlus: ur(_.object({isEnabled: ur(_.boolean()), networkId: ur(_.number())})),
        tokenSniffer: ur(_.object({isEnabled: ur(_.boolean()), networkId: ur(_.number())})),
        deBank: ur(_.object({isEnabled: ur(_.boolean()), networkId: ur(_.string())})),
        coinMarketCap: ur(_.object({isEnabled: ur(_.boolean()), networkId: ur(_.string())})),
        quickIntel: ur(_.object({isEnabled: ur(_.boolean()), networkId: ur(_.string())})),
        covalent: ur(_.object({isEnabled: ur(_.boolean()), chainId: ur(_.string())}))
    })),
    isChainAndDEX: ur(_.boolean()),
    dexes: Cn(_.string()),
    architecture: ur(_.enum(Mft))
});

function Pft(t) {
    return hze(t, e => !e.isHidden)
}

const I2e = Oft.omit({screeners: !0, indexers: !0}),
    Nft = pt("@dexscreener/data-access-ds-data/buildChainImageURLFormat", () => {
    }), k2e = pt($i(), Nft, (t, e) => r => {
        const n = new URL(t.DS_DATA_SERVER_PUBLIC_ORIGIN);
        return n.pathname = `/ds-data/chains/${r}.png`, e && n.searchParams.append("format", e), n.toString()
    }), qle = "{{address}}", Lft = "{{token}}", Gle = "{{txns}}";

function Bft(t) {
    const {blockExplorer: {txnsURL: e, assetURL: r, holdersURL: n, accountURL: i}} = t;
    return {
        accountURL: a => i.replace(qle, a),
        assetURL: r ? a => r.replace(Lft, a) : void 0,
        txnsURL: e ? a => e.replace(Gle, a) : void 0,
        holdersURL: n ? a => n.replace(Gle, a).replace(qle, a) : void 0
    }
}

const $ft = pt("@dexscreener/data-acccess-ds-data//dsDataServerDsDataChainsDataSource", $i(), Tp, (t, e) => ({
    getAll: tf(async () => QQ({
        callback: async () => {
            const r = new URL(t.DS_DATA_SERVER_PUBLIC_ORIGIN);
            return r.pathname = "/ds-data/v2/chains/by-txns", (await e.get(r.toString(), _.array(I2e))).map(Fft)
        },
        retrySettings: {
            tries: t.DS_DATA_RETRY_MAX_ATTEMPTS,
            timeoutInMs: t.DS_DATA_RETRY_TIMEOUT_IN_MS,
            delayInMs: t.DS_DATA_RETRY_DELAY_IN_MS
        }
    }))
}));

function Fft(t) {
    return {
        ...t,
        blockExplorer: {
            ...t.blockExplorer,
            txnsURL: t.blockExplorer.txnsURL === "" ? void 0 : t.blockExplorer.txnsURL,
            assetURL: t.blockExplorer.assetURL === "" ? void 0 : t.blockExplorer.assetURL
        }
    }
}

const Uft = "{{chainSlug}}", jft = "{{nativeChainId}}", zft = "{{pairAddress}}", Vft = "{{baseTokenAddress}}",
    Hft = "{{inputCurrency}}", Wft = "{{wrappedNativeToken}}";

function R2e(t) {
    const {
        input: e,
        chainSlug: r,
        nativeChainId: n,
        pairAddress: i,
        baseTokenAddress: a,
        inputCurrency: o,
        wrappedNativeToken: s
    } = t;
    let l = e.replaceAll(Uft, r).replaceAll(zft, i).replaceAll(Vft, a);
    return o && (l = l.replaceAll(Hft, o)), n && (l = l.replaceAll(jft, n.toString())), s && (l = l.replaceAll(Wft, s)), l
}

const qft = _.object({name: _.string(), slug: _.string(), swapURL: _.string()});

function Gft(t) {
    const {
        dexAggregator: e,
        chainSlug: r,
        nativeChainId: n,
        baseTokenAddress: i,
        inputCurrency: a,
        pairAddress: o,
        wrappedNativeToken: s
    } = t;
    return R2e({
        input: e.swapURL,
        chainSlug: r,
        nativeChainId: n,
        pairAddress: o,
        baseTokenAddress: i,
        inputCurrency: a,
        wrappedNativeToken: s
    })
}

const D2e = _.object({
        key: _.string(),
        order: _.preprocess(t => t ?? void 0, _.number().optional()),
        chain: _.object({id: _.string()}),
        url: _.preprocess(t => t ?? void 0, _.string().optional()),
        swapURL: _.preprocess(t => t ?? void 0, _.string().optional()),
        additionalLinks: _.preprocess(t => t ?? void 0, _.array(_.object({title: _.string(), url: _.string()})).optional()),
        labels: _.preprocess(t => t ?? void 0, _.array(_.string()).optional()),
        aggregators: Cn(qft).optional()
    }), Kft = _.object({
        name: _.string(),
        slug: _.string(),
        defaultURL: _.string(),
        defaultSwapURL: _.string(),
        defaultAdditionalLinks: _.preprocess(t => t ?? void 0, _.array(_.object({
            title: _.string(),
            url: _.string()
        })).optional()),
        deployments: _.array(D2e)
    }), Yft = D2e.omit({key: !0}), M2e = Kft.omit({deployments: !0}).extend({deployments: _.array(Yft)}),
    Xft = pt("@dexscreener/data-access-ds-data/buildDEXImageURLFormat", () => {
    }), AJt = pt($i(), Xft, (t, e) => r => {
        const n = new URL(t.DS_DATA_SERVER_PUBLIC_ORIGIN);
        return n.pathname = `/ds-data/dexes/${r}.png`, e && n.searchParams.append("format", e), n.toString()
    });

function O2e(t) {
    for (const e of t.dex.deployments) if (e.chain.id === t.chain.slug) {
        const r = e.labels;
        if (t.labels === void 0 && r === void 0 || t.labels !== void 0 && r !== void 0 && t.labels.some(n => r.includes(n))) return e
    }
}

function Qft(t) {
    var l;
    const {chain: e, dex: r, labels: n, pairAddress: i, baseTokenAddress: a, inputCurrency: o} = t,
        s = ((l = O2e({chain: e, dex: r, labels: n})) == null ? void 0 : l.swapURL) ?? r.defaultSwapURL;
    return s ? R2e({
        input: s,
        chainSlug: e.slug,
        nativeChainId: e.nativeChainId,
        pairAddress: i,
        baseTokenAddress: a,
        inputCurrency: o,
        wrappedNativeToken: e.wrappedNativeToken
    }) : void 0
}

function Zft(t) {
    const e = [], {chain: r, dex: n, pairAddress: i, baseTokenAddress: a, labels: o, inputCurrency: s} = t,
        l = O2e({chain: r, dex: n, labels: o});
    if (l && l.aggregators) for (const f of l.aggregators) e.push({
        name: f.name,
        slug: f.slug,
        url: Gft({
            dexAggregator: f,
            chainSlug: r.slug,
            nativeChainId: r.nativeChainId,
            pairAddress: i,
            baseTokenAddress: a,
            inputCurrency: s,
            wrappedNativeToken: r.wrappedNativeToken
        })
    });
    return e
}

const Jft = pt("@dexscreener/data-access-ds-data//dsDataServerDSDataDEXesDataSource", $i(), Tp, (t, e) => ({
        getAll: tf(async () => QQ({
            callback: async () => {
                const r = new URL(t.DS_DATA_SERVER_PUBLIC_ORIGIN);
                return r.pathname = "/ds-data/dexes", e.get(r.toString(), _.array(M2e))
            },
            retrySettings: {
                tries: t.DS_DATA_RETRY_MAX_ATTEMPTS,
                timeoutInMs: t.DS_DATA_RETRY_TIMEOUT_IN_MS,
                delayInMs: t.DS_DATA_RETRY_DELAY_IN_MS
            }
        }))
    })), edt = t => t.chainId === "solana" ? t.tokenAddress : t.tokenAddress.toLowerCase(),
    P2e = t => ({chainId: t.chainId.toLowerCase(), tokenAddress: edt(t)}),
    N2e = _.object({label: _.string(), url: _.string().url()}), L2e = Gr({label: kt(), url: kt()}),
    B2e = _.enum(["telegram", "twitter", "discord", "facebook", "tiktok"]), tdt = KE(B2e.options),
    $2e = _.object({type: B2e, url: _.string().url()}), F2e = Gr({type: tdt, url: kt()}),
    rdt = _.object({address: _.string()}), ndt = Gr({address: kt()}), idt = _.object({
        totalSupply: _.number(),
        burnedSupply: _.number(),
        lockedSupply: _.number(),
        circulatingSupply: _.number(),
        updatedAt: _.coerce.date()
    }), adt = Gr({totalSupply: Xt(), burnedSupply: Xt(), lockedSupply: Xt(), circulatingSupply: Xt(), updatedAt: Ns()}),
    odt = _.object({
        id: _.string(),
        description: ur(_.string()),
        claimDescription: ur(_.string()),
        claimDate: _.coerce.date(),
        websites: ur(Cn(N2e)),
        socials: ur(Cn($2e)),
        image: _.string().url(),
        headerImage: _.string().url().optional()
    }), sdt = Gr({
        id: kt(),
        description: kt().optional(),
        claimDescription: kt().optional(),
        claimDate: Ns(),
        websites: Ci(L2e).optional(),
        socials: Ci(F2e).optional(),
        image: kt(),
        headerImage: kt().optional()
    }), cdt = _.object({
        header: _.boolean().optional(),
        website: _.boolean().optional(),
        twitter: _.boolean().optional(),
        discord: _.boolean().optional(),
        linkCount: _.number().optional(),
        imgKey: _.string().optional()
    }), ldt = Gr({
        header: Gu().optional(),
        website: Gu().optional(),
        twitter: Gu().optional(),
        discord: Gu().optional(),
        linkCount: Xt().optional(),
        imgKey: kt().optional()
    }), Kle = _.object({
        id: _.string(),
        chain: _.object({id: _.string()}),
        address: _.string(),
        name: ur(_.string()),
        symbol: ur(_.string()),
        description: ur(_.string()),
        websites: ur(Cn(N2e)),
        socials: ur(Cn($2e)),
        lockedAddresses: ur(Cn(rdt)),
        supplies: ur(idt),
        createdAt: ur(_.coerce.date()),
        updatedAt: ur(_.coerce.date()),
        sortByDate: ur(_.coerce.date()),
        image: _.string().url(),
        headerImage: _.string().url().optional(),
        claims: Cn(odt).optional(),
        profile: cdt.optional()
    }), U2e = Gr({
        id: kt(),
        chain: Gr({id: kt()}),
        address: kt(),
        name: kt().optional(),
        symbol: kt().optional(),
        description: kt().optional(),
        websites: Ci(L2e).optional(),
        socials: Ci(F2e).optional(),
        lockedAddresses: Ci(ndt).optional(),
        supplies: adt.optional(),
        createdAt: Ns().optional(),
        updatedAt: Ns().optional(),
        sortByDate: Ns().optional(),
        image: kt(),
        headerImage: kt().optional(),
        claims: Ci(sdt).optional(),
        profile: ldt.optional()
    });
U2e.pick({
    id: !0,
    chain: !0,
    address: !0,
    description: !0,
    websites: !0,
    socials: !0,
    name: !0,
    symbol: !0,
    createdAt: !0
});
const IJt = U2e.pick({
    id: !0,
    chain: !0,
    address: !0,
    description: !0,
    websites: !0,
    socials: !0,
    name: !0,
    symbol: !0,
    createdAt: !0,
    profile: !0
}), udt = pt("@dexscreener/data-access-ds-data/buildTokenImageUrlFormat", () => {
}), kJt = pt($i(), udt, (t, e) => r => {
    const {chainId: n, tokenAddress: i, size: a, cacheKey: o, claimId: s} = r, l = P2e({chainId: n, tokenAddress: i}),
        f = new URL(`${t.DS_DATA_SERVER_PUBLIC_ORIGIN}`);
    return f.pathname = `/ds-data/tokens/${l.chainId}/${l.tokenAddress}.png`, s && f.searchParams.set("claimId", s), a && f.searchParams.set("size", a), o && f.searchParams.set("key", o), e && f.searchParams.set("format", e), f.toString()
}), RJt = pt($i(), t => e => {
    const {chainId: r, tokenAddress: n, cacheKey: i, claimId: a, size: o} = e, s = P2e({chainId: r, tokenAddress: n}),
        l = new URL(`${t.DS_DATA_SERVER_PUBLIC_ORIGIN}`);
    return l.pathname = `/ds-data/tokens/${s.chainId}/${s.tokenAddress}/header.png`, a && l.searchParams.set("claimId", a), o && l.searchParams.set("size", o), i && l.searchParams.set("key", i), l.toString()
}), fdt = "Website", DJt = t => t.label === fdt;
Ci(MN).optional(), Ci(DN).optional();
Ci(MN).optional(), Ci(DN).optional();
_.object({name: _.string(), slug: _.string(), coinGeckoIDs: ur(Cn(_.string())), coinMarketCapIDs: ur(Cn(_.string()))});
_.object({
    id: _.string(),
    chainId: _.string(),
    tokenAddress: _.string(),
    trendingPenalty: ur(_.object({enable: _.literal(!1).optional()}).or(_.object({
        enable: _.literal(!0),
        level: _.enum(["low", "medium", "high"]),
        reason: _.string()
    }))),
    noSecuryPenalty: ur(_.object({enable: _.literal(!1).optional()}).or(_.object({
        enable: _.literal(!0),
        reason: _.string()
    }))),
    overrides: ur(_.object({enable: _.literal(!1).optional()}).or(_.object({
        enable: _.literal(!0),
        name: _.string().optional(),
        symbol: _.string().optional(),
        totalSupply: _.string().optional(),
        reason: _.string()
    }))),
    disallowEti: ur(_.object({enable: _.literal(!1).optional()}).or(_.object({
        enable: _.literal(!0),
        reason: _.string()
    }))),
    disallowAds: ur(_.object({enable: _.literal(!1).optional()}).or(_.object({
        enable: _.literal(!0),
        reason: _.string()
    }))),
    moonshot: ur(_.object({
        isMoonshotToken: _.boolean().optional(),
        reason: _.string().optional(),
        creator: _.string().optional()
    })),
    createdAt: _.coerce.date(),
    updatedAt: _.coerce.date(),
    deleted: ur(_.boolean())
});
const Uz = new Map, ddt = {
    get: async t => Uz.get(t) ?? null, set: async (t, e) => {
        Uz.set(t, e)
    }, delete: async t => {
        Uz.delete(t)
    }
};

class ON {
}

var E0;
(function (t) {
    t.EXPLICIT = "explicit", t.REPLACED = "replaced", t.SIZE = "size", t.EXPIRED = "expired"
})(E0 || (E0 = {}));
const Xl = Symbol("parent"), W4 = Symbol("onRemove"), Nf = Symbol("triggerRemove"), Cy = Symbol("onMaintenance"),
    tu = Symbol("maintenance"), ml = Symbol("parent"), Yle = Symbol("removalListener");

class j2e extends ON {
    constructor(e, r) {
        super(), this[ml] = e, this[Yle] = r, this[ml][W4] = this[Nf].bind(this)
    }

    get maxSize() {
        return this[ml].maxSize
    }

    get size() {
        return this[ml].size
    }

    get weightedSize() {
        return this[ml].weightedSize
    }

    set(e, r) {
        return this[ml].set(e, r)
    }

    getIfPresent(e) {
        return this[ml].getIfPresent(e)
    }

    peek(e) {
        return this[ml].peek(e)
    }

    has(e) {
        return this[ml].has(e)
    }

    delete(e) {
        return this[ml].delete(e)
    }

    clear() {
        this[ml].clear()
    }

    keys() {
        return this[ml].keys()
    }

    cleanUp() {
        this[ml].cleanUp()
    }

    get metrics() {
        return this[ml].metrics
    }

    get [Cy]() {
        return this[ml][Cy]
    }

    set [Cy](e) {
        this[ml][Cy] = e
    }

    [Nf](e, r, n) {
        const i = this[W4];
        i && i(e, r, n);
        const a = this[Yle];
        a && a(e, r, n)
    }
}

const a7 = Symbol("metrics");

class hdt extends j2e {
    constructor(e) {
        super(e.parent, e.removalListener || null), this[a7] = {
            hits: 0, misses: 0, get hitRate() {
                const r = this.hits + this.misses;
                return r === 0 ? 1 : this.hits / r
            }
        }
    }

    get metrics() {
        return this[a7]
    }

    getIfPresent(e) {
        const r = super.getIfPresent(e);
        return r === null ? this[a7].misses++ : this[a7].hits++, r
    }
}

const Xle = Symbol("loadingData");

class pdt extends j2e {
    constructor(e) {
        super(e.parent, e.removalListener || null), this[Xle] = {promises: new Map, loader: e.loader || null}
    }

    get(e, r) {
        const n = this.getIfPresent(e);
        if (n !== null) return Promise.resolve(n);
        const i = this[Xle];
        let a = i.promises.get(e);
        if (a) return a;
        if (typeof r < "u") {
            if (typeof r != "function") throw new Error("If loader is used it must be a function that returns a value or a Promise");
            a = Promise.resolve(r(e))
        } else i.loader && (a = Promise.resolve(i.loader(e)));
        if (!a) throw new Error("No way to load data for key: " + e);
        const o = () => i.promises.delete(e);
        return a = a.then(s => (this.set(e, s), o(), s)).catch(s => {
            throw o(), s
        }), i.promises.set(e, a), a
    }
}

class z2e {
    constructor(e, r) {
        this.key = e, this.value = r, this.previous = this, this.next = this
    }

    remove() {
        this.previous.next = this.next, this.next.previous = this.previous, this.next = this, this.previous = this
    }

    appendToTail(e) {
        const r = e.previous;
        e.previous = this, r.next = this, this.next = e, this.previous = r
    }

    moveToTail(e) {
        this.remove(), this.appendToTail(e)
    }
}

const jz = 3432918353, zz = 461845907;

function l0(t, e) {
    return (t & 65535) * e + (((t >>> 16) * e & 65535) << 16)
}

function mdt(t, e = 0) {
    switch (typeof t) {
        case"string": {
            let r = e;
            const n = t.length & -4;
            for (let i = 0; i < n; i += 4) {
                let a = t.charCodeAt(i) & 65535 | (t.charCodeAt(i + 1) & 65535) << 8 | (t.charCodeAt(i + 2) & 65535) << 16 | (t.charCodeAt(i + 3) & 65535) << 24;
                a = l0(a, jz), a = a << 15 | a >>> 17, a = l0(a, zz), r ^= a, r = r << 13 | r >>> 19, r = r * 5 + 3864292196
            }
            {
                let i = 0;
                switch (t.length & 3) {
                    case 3:
                        i ^= (t.charCodeAt(n + 2) & 65535) << 16;
                    case 2:
                        i ^= (t.charCodeAt(n + 1) & 65535) << 8;
                    case 1:
                        i ^= t.charCodeAt(n) & 65535, i = l0(i, jz), i = i << 15 | i >>> 17, i = l0(i, zz), r ^= i
                }
            }
            return r ^= t.length, r ^= r >>> 16, r = l0(r, 2246822507), r ^= r >>> 13, r = l0(r, 3266489909), r ^= r >>> 16, r >>> 0
        }
        case"number": {
            let r = t;
            return r = l0(r, jz), r = r << 15 | r >>> 17, r = l0(r, zz), r = r << 13 | r >>> 19, r = r * 5 + 3864292196, r ^= r >>> 16, r = l0(r, 2246822507), r ^= r >>> 13, r = l0(r, 3266489909), r ^= r >>> 16, r ^= 1, r >>> 0
        }
        case"boolean":
            return t ? 1231 : 1237;
        case"undefined":
            return 0;
        default:
            throw new Error("The given value can not be used as a key in a cache, value was: " + String(t))
    }
}

function vdt(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
}

function Qle(t) {
    let e = t ^ 61 ^ t >>> 16;
    return e = e + (e << 3), e = e ^ e >>> 4, e = V2e(e, 668265261), e = e ^ e >>> 15, e
}

function V2e(t, e) {
    return (t & 65535) * e + (((t >>> 16) * e & 65535) << 16)
}

class gA {
    constructor(e, r, n) {
        this.width = vdt(e), this.depth = r, this.maxSize = Math.pow(2, Uint8Array.BYTES_PER_ELEMENT * 8) - 1, this.halfMaxSize = this.maxSize / 2, this.slightlyLessThanHalfMaxSize = this.halfMaxSize - Math.max(this.halfMaxSize / 4, 1), this.additions = 0, this.resetAfter = n ? e * 10 : -1, this.table = new Uint8Array(this.width * r)
    }

    findIndex(e, r, n) {
        const i = e + V2e(r, n);
        return n * this.width + (i & this.width - 1)
    }

    update(e) {
        const r = this.table, n = this.maxSize, i = this.estimate(e), a = Qle(e);
        let o = !1;
        for (let s = 0, l = this.depth; s < l; s++) {
            const f = this.findIndex(e, a, s), d = r[f];
            d + 1 < n && d <= i && (r[f] = d + 1, o = !0)
        }
        o && ++this.additions === this.resetAfter && this.performReset()
    }

    estimate(e) {
        const r = this.table, n = Qle(e);
        let i = this.maxSize;
        for (let a = 0, o = this.depth; a < o; a++) {
            const s = r[this.findIndex(e, n, a)];
            s < i && (i = s)
        }
        return i
    }

    performReset() {
        const e = this.table;
        this.additions /= 2;
        for (let r = 0, n = e.length; r < n; r++) this.additions -= e[r] & 1, e[r] = Math.floor(e[r] >>> 1)
    }

    static hash(e) {
        return mdt(e)
    }

    static uint8(e, r, n = !0) {
        return new gA(e, r, n)
    }
}

const gdt = .99, ydt = .8, bdt = .01, wdt = .05, H2e = .0625, Sdt = .98, Cf = Symbol("boundedData");

class o7 extends z2e {
    constructor(e, r) {
        super(e, r), this.hashCode = e === null ? 0 : gA.hash(e), this.weight = 1, this.location = 0
    }
}

class OG extends ON {
    constructor(e) {
        super();
        const r = Math.floor(gdt * e.maxSize), n = e.weigher ? 256 : Math.max(e.maxSize, 128);
        this[tu] = this[tu].bind(this), this[Cf] = {
            maxSize: e.weigher ? -1 : e.maxSize,
            removalListener: e.removalListener || null,
            weigher: e.weigher || null,
            weightedMaxSize: e.maxSize,
            weightedSize: 0,
            sketch: gA.uint8(n, 4),
            sketchGrowLimit: n,
            values: new Map,
            adaptiveData: {hits: 0, misses: 0, adjustment: 0, previousHitRate: 0, stepSize: -H2e * e.maxSize},
            window: {head: new o7(null, null), size: 0, maxSize: e.maxSize - r},
            protected: {head: new o7(null, null), size: 0, maxSize: Math.floor(r * ydt)},
            probation: {head: new o7(null, null)},
            maintenanceTimeout: null,
            forceEvictionLimit: e.maxSize + Math.max(Math.floor(e.maxSize * bdt), 5),
            maintenanceInterval: 5e3
        }
    }

    get maxSize() {
        return this[Cf].maxSize
    }

    get size() {
        return this[Cf].values.size
    }

    get weightedSize() {
        return this[Cf].weightedSize
    }

    set(e, r) {
        const n = this[Cf], i = n.values.get(e), a = new o7(e, r);
        if (n.values.set(e, a), n.weigher && (a.weight = n.weigher(e, r)), n.weightedSize += a.weight, i) switch (i.remove(), n.weightedSize -= i.weight, i.location) {
            case 1:
                n.protected.size -= i.weight;
                break;
            case 0:
                n.window.size -= i.weight;
                break
        }
        if (n.weigher && n.values.size >= n.sketchGrowLimit) {
            const o = n.values.size * 2;
            n.sketch = gA.uint8(o, 4), n.sketchGrowLimit = o
        }
        return a.appendToTail(n.window.head), n.window.size += a.weight, n.sketch.update(a.hashCode), n.weightedSize >= n.forceEvictionLimit ? this[tu]() : n.maintenanceTimeout || (n.maintenanceTimeout = setTimeout(this[tu], n.maintenanceInterval)), i ? (this[Nf](e, i.value, E0.REPLACED), i.value) : null
    }

    getIfPresent(e) {
        const r = this[Cf], n = r.values.get(e);
        if (!n) return r.adaptiveData.misses++, null;
        switch (r.adaptiveData.hits++, r.sketch.update(n.hashCode), n.location) {
            case 0:
                n.moveToTail(r.window.head);
                break;
            case 2:
                for (n.location = 1, n.moveToTail(r.protected.head), r.protected.size += n.weight; r.protected.size > r.protected.maxSize;) {
                    const i = r.protected.head.next;
                    i.location = 2, i.moveToTail(r.probation.head), r.protected.size -= i.weight
                }
                break;
            case 1:
                n.moveToTail(r.protected.head);
                break
        }
        return n.value
    }

    peek(e) {
        const n = this[Cf].values.get(e);
        return n ? n.value : null
    }

    delete(e) {
        const r = this[Cf], n = r.values.get(e);
        if (n) {
            switch (n.remove(), n.location) {
                case 1:
                    r.protected.size -= n.weight;
                    break;
                case 0:
                    r.window.size -= n.weight;
                    break
            }
            return r.weightedSize -= n.weight, r.values.delete(e), this[Nf](e, n.value, E0.EXPLICIT), r.maintenanceTimeout || (r.maintenanceTimeout = setTimeout(this[tu], r.maintenanceInterval)), n.value
        }
        return null
    }

    has(e) {
        return this[Cf].values.has(e)
    }

    clear() {
        const e = this[Cf], r = e.values;
        e.values = new Map;
        for (const [n, i] of r) this[Nf](n, i.value, E0.EXPLICIT);
        e.weightedSize = 0, e.window.head.remove(), e.window.size = 0, e.probation.head.remove(), e.protected.head.remove(), e.protected.size = 0, e.maintenanceTimeout && (clearTimeout(e.maintenanceTimeout), e.maintenanceTimeout = null)
    }

    keys() {
        return this[tu](), Array.from(this[Cf].values.keys())
    }

    cleanUp() {
        this[tu]()
    }

    get metrics() {
        throw new Error("Metrics are not supported by this cache")
    }

    [Nf](e, r, n) {
        const i = this[Cf], a = this[W4];
        a && a(e, r, n), i.removalListener && i.removalListener(e, r, n)
    }

    [tu]() {
        const e = this[Cy];
        e && e();
        const r = this[Cf];
        let n = 0;
        for (; r.window.size > r.window.maxSize;) {
            const i = r.window.head.next;
            i.moveToTail(r.probation.head), i.location = 2, r.window.size -= i.weight, n++
        }
        for (; r.weightedSize > r.weightedMaxSize;) {
            const i = r.probation.head.next, a = n === 0 ? r.probation.head : r.probation.head.previous,
                o = i !== r.probation.head, s = a !== r.probation.head;
            let l;
            if (!o && !s) break;
            if (!s) l = i; else if (!o) l = a, n--; else {
                let f;
                const d = r.sketch.estimate(a.hashCode), p = r.sketch.estimate(i.hashCode);
                d > p ? f = !1 : d < r.sketch.slightlyLessThanHalfMaxSize ? f = !0 : f = Math.floor(Math.random() * 1e3) >= 1, l = f ? a : i, n--
            }
            if (l.key === null) throw new Error("Cache issue, problem with removal");
            r.values.delete(l.key), l.remove(), r.weightedSize -= l.weight, this[Nf](l.key, l.value, E0.SIZE)
        }
        _dt(r), r.maintenanceTimeout && (clearTimeout(r.maintenanceTimeout), r.maintenanceTimeout = null)
    }
}

function _dt(t) {
    Edt(t);
    const e = t.adaptiveData.adjustment;
    e > 0 ? Tdt(t) : e < 0 && Cdt(t)
}

function xdt(t) {
    let e = 0;
    for (; e++ < 1e3 && t.protected.size > t.protected.maxSize;) {
        const r = t.protected.head.next;
        if (r === t.protected.head) break;
        r.location = 2, r.moveToTail(t.probation.head), t.protected.size -= r.weight
    }
}

function Edt(t) {
    const e = t.adaptiveData, r = e.hits + e.misses;
    if (r < t.sketch.resetAfter) return !1;
    const n = e.hits / r, i = n - e.previousHitRate, a = i >= 0 ? e.stepSize : -e.stepSize;
    let o;
    return Math.abs(i) >= wdt ? o = H2e * t.weightedMaxSize * (a >= 0 ? 1 : -1) : o = Sdt * a, e.adjustment = Math.floor(a), e.stepSize = o, e.previousHitRate = n, e.misses = 0, e.hits = 0, !0
}

function Tdt(t) {
    if (t.protected.maxSize === 0) return;
    let e = Math.min(t.adaptiveData.adjustment, t.protected.maxSize);
    t.protected.maxSize -= e, t.window.maxSize += e, xdt(t);
    for (let r = 0; r < 1e3; r++) {
        let n = t.probation.head.next;
        if ((n === t.probation.head || n.weight > e) && (n = t.protected.head.next, n === t.protected.head) || n.weight > e) break;
        e -= n.weight, n.location === 1 && (t.protected.size -= n.weight), n.moveToTail(t.window.head), t.window.size += n.weight, n.location = 0
    }
    t.protected.maxSize += e, t.window.maxSize -= e, t.adaptiveData.adjustment = e
}

function Cdt(t) {
    if (t.window.maxSize <= 1) return;
    let e = Math.min(-t.adaptiveData.adjustment, Math.max(t.window.maxSize - 1, 0));
    t.window.maxSize -= e, t.protected.maxSize += e;
    for (let r = 0; r < 1e3; r++) {
        const n = t.window.head.next;
        if (n === t.window.head || n.weight > e) break;
        e -= n.weight, n.moveToTail(t.probation.head), n.location = 2, t.window.size -= n.weight
    }
    t.window.maxSize += e, t.protected.maxSize -= e, t.adaptiveData.adjustment = -e
}

const Uh = Symbol("boundlessData"), Zle = 5e3;

class PG extends ON {
    constructor(e) {
        super(), this[Uh] = {values: new Map, removalListener: e.removalListener || null, evictionTimeout: null}
    }

    get maxSize() {
        return -1
    }

    get size() {
        return this[Uh].values.size
    }

    get weightedSize() {
        return this.size
    }

    set(e, r) {
        const n = this[Uh], i = n.values.get(e);
        return n.values.set(e, r), n.evictionTimeout || (n.evictionTimeout = setTimeout(() => this[tu](), Zle)), i !== void 0 ? (this[Nf](e, i, E0.REPLACED), i) : null
    }

    getIfPresent(e) {
        const n = this[Uh].values.get(e);
        return n === void 0 ? null : n
    }

    peek(e) {
        const n = this[Uh].values.get(e);
        return n === void 0 ? null : n
    }

    delete(e) {
        const r = this[Uh], n = r.values.get(e);
        return r.values.delete(e), n !== void 0 ? (this[Nf](e, n, E0.EXPLICIT), r.evictionTimeout || (r.evictionTimeout = setTimeout(() => this[tu](), Zle)), n) : null
    }

    has(e) {
        return this[Uh].values.has(e)
    }

    clear() {
        const e = this[Uh], r = e.values;
        e.values = new Map;
        for (const [n, i] of r.entries()) this[Nf](n, i, E0.EXPLICIT)
    }

    keys() {
        return this[tu](), Array.from(this[Uh].values.keys())
    }

    cleanUp() {
        this[tu]()
    }

    get metrics() {
        throw new Error("Metrics are not supported by this cache")
    }

    [Nf](e, r, n) {
        const i = this[Uh], a = this[W4];
        a && a(e, r, n), i.removalListener && i.removalListener(e, r, n)
    }

    [tu]() {
        const e = this[Cy];
        e && e();
        const r = this[Uh];
        r.evictionTimeout && (clearTimeout(r.evictionTimeout), r.evictionTimeout = null)
    }
}

function Z_(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
}

const NG = [64, 64, 32, 4, 1], Ax = [Z_(1e3), Z_(6e4), Z_(36e5), Z_(864e5), NG[3] * Z_(864e5), NG[3] * Z_(864e5)],
    s7 = Ax.slice(0, Ax.length - 1).map(t => 1 + Math.floor(Math.log(t - 1) * Math.LOG2E));

class Adt {
    constructor(e) {
        this.evict = e, this.base = Date.now(), this.layers = NG.map(r => {
            const n = new Array(r);
            for (let i = 0; i < r; i++) n[i] = new Jle(this, null, null);
            return n
        }), this.time = 0
    }

    get localTime() {
        return Date.now() - this.base
    }

    findBucket(e) {
        const r = e.time - this.time;
        if (r <= 0) return null;
        const n = this.layers;
        for (let i = 0, a = n.length - 1; i < a; i++) {
            if (r >= Ax[i + 1]) continue;
            const s = e.time >>> s7[i] & n[i].length - 1;
            return n[i][s]
        }
        return n[n.length - 1][0]
    }

    advance(e) {
        const r = this.time, n = e || this.localTime;
        this.time = n;
        const i = this.layers;
        let a = null;
        for (let o = 0, s = s7.length; o < s; o++) {
            const l = r >>> s7[o], f = n >>> s7[o];
            if (f <= l) break;
            const d = i[o];
            let p, g;
            n - r >= Ax[o + 1] ? (p = 0, g = d.length - 1) : (p = l & Ax[o] - 1, g = f & Ax[o] - 1);
            for (let b = p; b <= g; b++) {
                const S = d[b & d.length - 1];
                let T = S.next;
                for (S.previous = S, S.next = S; T !== S;) {
                    const I = T.next;
                    if (T.remove(), T.time <= n) a || (a = []), a.push(T.key); else {
                        const N = this.findBucket(T);
                        N && T.appendToTail(N)
                    }
                    T = I
                }
            }
        }
        a && this.evict(a)
    }

    node(e, r) {
        return new Jle(this, e, r)
    }

    schedule(e, r) {
        if (e.remove(), r <= 0) return !1;
        e.time = this.localTime + r;
        const n = this.findBucket(e);
        return n ? (e.appendToTail(n), !0) : !1
    }

    deschedule(e) {
        e.remove()
    }
}

class Jle extends z2e {
    constructor(e, r, n) {
        super(r, n), this.time = Number.MAX_SAFE_INTEGER, this.wheel = e
    }

    isExpired() {
        return this.wheel.localTime > this.time
    }
}

const J_ = Symbol("expirationData");

class Idt extends ON {
    constructor(e) {
        super(), this[Xl] = e.parent, this[J_] = {
            maxWriteAge: e.maxWriteAge,
            maxNoReadAge: e.maxNoReadAge,
            removalListener: e.removalListener || null,
            timerWheel: new Adt(r => {
                for (const n of r) this.delete(n)
            })
        }, this[Xl][W4] = (r, n, i) => {
            const a = n.isExpired() ? E0.EXPIRED : i;
            this[J_].timerWheel.deschedule(n), this[Nf](r, n.value, a)
        }, this[Xl][Cy] = this[tu].bind(this)
    }

    get maxSize() {
        return this[Xl].maxSize
    }

    get size() {
        return this[Xl].size
    }

    get weightedSize() {
        return this[Xl].weightedSize
    }

    set(e, r) {
        const n = this[J_], i = n.timerWheel, a = i.node(e, r);
        let o = null;
        if (n.maxWriteAge ? o = n.maxWriteAge(e, r) || 0 : n.maxNoReadAge && (o = n.maxNoReadAge(e, r) || 0), o !== null && !n.timerWheel.schedule(a, o)) return this.delete(e);
        try {
            const s = this[Xl].set(e, a);
            return s ? s.value : null
        } catch (s) {
            throw i.deschedule(a), s
        }
    }

    getIfPresent(e) {
        const r = this[Xl].getIfPresent(e);
        if (r) {
            if (r.isExpired()) return null;
            const n = this[J_];
            if (n.maxNoReadAge) {
                const i = n.maxNoReadAge(e, r.value);
                n.timerWheel.schedule(r, i) || this.delete(e)
            }
            return r.value
        }
        return null
    }

    peek(e) {
        const r = this[Xl].peek(e);
        return r && !r.isExpired() ? r.value : null
    }

    has(e) {
        const r = this[Xl].peek(e);
        return r && !r.isExpired() || !1
    }

    delete(e) {
        const r = this[Xl].delete(e);
        return r ? r.value : null
    }

    clear() {
        this[Xl].clear()
    }

    keys() {
        return this[Xl].keys()
    }

    cleanUp() {
        this[Xl].cleanUp()
    }

    get metrics() {
        return this[Xl].metrics
    }

    [tu]() {
        this[J_].timerWheel.advance();
        const e = this[Cy];
        e && e()
    }

    [Nf](e, r, n) {
        const i = this[W4];
        i && i(e, r, n);
        const a = this[J_];
        a.removalListener && a.removalListener(e, r, n)
    }
}

class kdt {
    constructor() {
        this.optMetrics = !1
    }

    withRemovalListener(e) {
        return this.optRemovalListener = e, this
    }

    maxSize(e) {
        return this.optMaxSize = e, this
    }

    withWeigher(e) {
        if (typeof e != "function") throw new Error("Weigher should be a function that takes a key and value and returns a number");
        return this.optWeigher = e, this
    }

    loading() {
        return new eue(this, null)
    }

    withLoader(e) {
        if (typeof e != "function") throw new Error("Loader should be a function that takes a key and returns a value or a promise that resolves to a value");
        return new eue(this, e)
    }

    expireAfterWrite(e) {
        let r;
        if (typeof e == "function") r = e; else if (typeof e == "number") r = () => e; else throw new Error("expireAfterWrite needs either a maximum age as a number or a function that returns a number");
        return this.optMaxWriteAge = r, this
    }

    expireAfterRead(e) {
        let r;
        if (typeof e == "function") r = e; else if (typeof e == "number") r = () => e; else throw new Error("expireAfterRead needs either a maximum age as a number or a function that returns a number");
        return this.optMaxNoReadAge = r, this
    }

    metrics() {
        return this.optMetrics = !0, this
    }

    build() {
        let e;
        if (typeof this.optMaxWriteAge < "u" || typeof this.optMaxNoReadAge < "u") {
            let r;
            this.optMaxSize ? r = new OG({
                maxSize: this.optMaxSize,
                weigher: Rdt(this.optWeigher)
            }) : r = new PG({}), e = new Idt({
                maxNoReadAge: this.optMaxNoReadAge,
                maxWriteAge: this.optMaxWriteAge,
                removalListener: this.optRemovalListener,
                parent: r
            })
        } else this.optMaxSize ? e = new OG({
            maxSize: this.optMaxSize,
            weigher: this.optWeigher,
            removalListener: this.optRemovalListener
        }) : e = new PG({removalListener: this.optRemovalListener});
        return this.optMetrics && (e = new hdt({parent: e})), e
    }
}

class eue {
    constructor(e, r) {
        this.parent = e, this.loader = r
    }

    withRemovalListener(e) {
        return this.parent.withRemovalListener(e), this
    }

    maxSize(e) {
        return this.parent.maxSize(e), this
    }

    withWeigher(e) {
        return this.parent.withWeigher(e), this
    }

    loading() {
        throw new Error("Already building a loading cache")
    }

    withLoader(e) {
        throw new Error("Already building a loading cache")
    }

    expireAfterWrite(e) {
        return this.parent.expireAfterWrite(e), this
    }

    expireAfterRead(e) {
        return this.parent.expireAfterRead(e), this
    }

    metrics() {
        return this.parent.metrics(), this
    }

    build() {
        return new pdt({loader: this.loader, parent: this.parent.build()})
    }
}

function Rdt(t) {
    return t ? (e, r) => t(e, r.value) : null
}

function Ddt() {
    return new kdt
}

class aC extends Error {
    constructor(r) {
        super(r.message);
        Ft(this, "type");
        Ft(this, "cause");
        this.name = "SWRCacheError", this.type = r.type, this.cause = r.cause, Object.setPrototypeOf(this, aC.prototype)
    }
}

class nZ {
    constructor(e) {
        Ft(this, "params");
        Ft(this, "cacheSchema");
        Ft(this, "inMemoryCache");
        Ft(this, "cachePrefixKey", "ds:core:swrCache");
        Ft(this, "revalidateFromPersistentCache", tf(async e => {
            const r = await this.getFromPersistentCache(e.cacheKey).catch(i => {
                this.logPersistentCacheReadFailure({cacheKey: e.cacheKey, error: i})
            });
            if (!r) return !1;
            const {isStale: n} = this.isCacheEntryStale(r, this.resolveTimeToStaleInMs(e.timeToStale, r.value));
            return n ? !1 : (this.inMemoryCache.set(e.cacheKey, r), !0)
        }, ([e]) => e.cacheKey));
        Ft(this, "runCallbackAndSetCache", tf(async ({cacheKey: e, callback: r}) => {
            try {
                const n = await r(), i = {value: n, timestamp: Date.now()};
                return this.setToPersistentCache(e, i), this.inMemoryCache.set(e, i), n
            } catch (n) {
                const i = this.getFromInMemoryCache(e);
                throw i && this.isCacheEntryStale(i, this.params.maxStaleInMs).isStale ? new aC({
                    type: "maxStaleError",
                    message: `Cache for ${e} is stale for >${this.params.maxStaleInMs.toLocaleString()}ms`,
                    cause: n
                }) : new aC({type: "refreshError", cause: n})
            }
        }, ([e]) => e.cacheKey));
        Ft(this, "getFromPersistentCache", tf(async e => {
            const r = await this.params.persistentCache.get(e);
            if (r === null) return null;
            try {
                return this.cacheSchema.parse(JSON.parse(r))
            } catch (n) {
                if (this.inMemoryCache.getIfPresent(e) === null) return null;
                throw new aC({type: "parseError", cause: n instanceof _.ZodError ? n.format() : n})
            }
        }));
        this.params = e, this.cacheSchema = _.object({
            value: this.params.schema,
            timestamp: _.number()
        }), this.inMemoryCache = this.params.maxInMemorySize === void 0 ? new PG({}) : new OG({maxSize: this.params.maxInMemorySize})
    }

    async get(e) {
        const r = this.ensureCacheKeyHasPrefix(e.key);
        let n, i = this.getFromInMemoryCache(r);
        if (i) n = "memory"; else try {
            i = await this.getFromPersistentCache(r), i && (n = "persistent", this.inMemoryCache.set(r, i))
        } catch (o) {
            this.logPersistentCacheReadFailure({error: o, cacheKey: r})
        }
        const a = e.timeToStaleInMs ?? this.params.timeToStaleInMs;
        if (i) {
            const {isStale: o, cacheAgeInMs: s} = this.isCacheEntryStale(i, this.resolveTimeToStaleInMs(a, i.value));
            return this.logCacheHit({
                key: e.key,
                cacheSource: n,
                cacheAgeInMs: s,
                isStale: o
            }), o && this.revalidate({
                key: r,
                timeToStale: a,
                callback: () => e.callback(i == null ? void 0 : i.value),
                onRefreshError: e.onRefreshError,
                revalidateFromPersistentCache: e.revalidateFromPersistentCache
            }), i.value
        }
        if (this.logCacheMiss({key: e.key}), e.avoidSyncExecution) {
            this.revalidate({
                key: r,
                timeToStale: a,
                callback: () => e.callback(),
                onRefreshError: e.onRefreshError,
                revalidateFromPersistentCache: e.revalidateFromPersistentCache
            });
            return
        }
        return this.runCallbackAndSetCache({cacheKey: r, callback: e.callback})
    }

    async getIfPresent(e) {
        const r = this.ensureCacheKeyHasPrefix(e.key);
        let n = this.inMemoryCache.getIfPresent(r);
        return n || (n = await this.getFromPersistentCache(r)), n == null ? void 0 : n.value
    }

    async delete(e) {
        const r = this.ensureCacheKeyHasPrefix(e);
        this.inMemoryCache.delete(r), await this.params.persistentCache.delete(r)
    }

    isCacheEntryStale(e, r) {
        const n = Date.now() - e.timestamp;
        return {isStale: n > r, cacheAgeInMs: n}
    }

    async revalidate(e) {
        const r = this.ensureCacheKeyHasPrefix(e.key);
        if (e.revalidateFromPersistentCache && await this.revalidateFromPersistentCache({
            cacheKey: r,
            timeToStale: e.timeToStale
        })) {
            Bj({
                threshold: this.params.logSamplingThreshold, callback: () => {
                    this.params.log.debug({
                        event: {
                            id: "swrCacheCall",
                            data: {namespace: this.params.cacheNamespaceKey, cacheKey: e.key, status: "revalidated"}
                        }
                    })
                }
            });
            return
        }
        try {
            await this.runCallbackAndSetCache({cacheKey: r, callback: e.callback})
        } catch (n) {
            e.onRefreshError(n)
        }
    }

    async revalidateSync(e) {
        const r = this.ensureCacheKeyHasPrefix(e.key);
        return this.runCallbackAndSetCache({cacheKey: r, callback: e.callback})
    }

    getFromInMemoryCache(e) {
        return this.inMemoryCache.getIfPresent(e)
    }

    async setToPersistentCache(e, r) {
        try {
            await this.params.persistentCache.set(e, JSON.stringify(r))
        } catch (n) {
            this.params.log.error({event: {id: "failedSettingToPersistentCache", data: {error: n, cacheKey: e}}})
        }
    }

    ensureCacheKeyHasPrefix(e) {
        const r = `${this.cachePrefixKey}:${this.params.cacheNamespaceKey}:`.toLowerCase();
        return e.toLowerCase().startsWith(r) ? e.toLowerCase() : r + e.toLowerCase()
    }

    resolveTimeToStaleInMs(e, r) {
        return typeof e == "number" ? e : e(r)
    }

    logCacheHit(e) {
        Bj({
            threshold: this.params.logSamplingThreshold, callback: () => {
                this.params.log.debug({
                    event: {
                        id: "swrCacheCall",
                        data: {
                            namespace: this.params.cacheNamespaceKey,
                            cacheKey: e.key,
                            cacheSource: e.cacheSource,
                            status: "hit",
                            isStale: e.isStale,
                            cacheAgeInMs: e.cacheAgeInMs
                        }
                    }
                })
            }
        })
    }

    logCacheMiss(e) {
        Bj({
            threshold: this.params.logSamplingThreshold, callback: () => {
                this.params.log.debug({
                    event: {
                        id: "swrCacheCall",
                        data: {namespace: this.params.cacheNamespaceKey, cacheKey: e.key, status: "miss"}
                    }
                })
            }
        })
    }

    logPersistentCacheReadFailure(e) {
        this.params.log.error({
            event: {
                id: "failedReadingFromPersistentCache",
                data: {error: e.error, namespace: this.params.cacheNamespaceKey, cacheKey: e.cacheKey}
            }
        })
    }
}

const Mdt = pt("@dexscreener/data-access-ds-data/dsDataAdsRepository", Dft, sr, RN, $i(), (t, e, r, n) => {
    const i = t2e(e, "ds-data-ads-repository"), a = new nZ({
        schema: Rft,
        persistentCache: r,
        timeToStaleInMs: n.DS_DATA_TIME_TO_STALE_IN_MS,
        maxStaleInMs: Number.POSITIVE_INFINITY,
        cacheNamespaceKey: "dsDataAdsRepository",
        log: i,
        logSamplingThreshold: n.DS_DATA_LOG_SAMPLING_THRESHOLD
    }), o = {
        getActiveAds: async () => a.get({
            key: "all", callback: async () => t.getActiveAds(), onRefreshError: s => {
                i.error({event: {id: "failedRefreshingAds", data: {error: s}}})
            }
        }), start: async () => {
            await o.getActiveAds()
        }, getNextTrendingBarAdTimeInterval: t.getNextTrendingBarAdTimeInterval
    };
    return o
}), W2e = pt("@dexscreener/data-access-ds-data//DSDataChainsRepository", $ft, $i(), RN, sr, (t, e, r, n) => {
    const i = n.getChildLogger({name: n.settings.name + "/ds-data-chains-repository"}), a = new nZ({
        schema: Cn(I2e),
        persistentCache: r,
        timeToStaleInMs: e.DS_DATA_TIME_TO_STALE_IN_MS,
        maxStaleInMs: Number.POSITIVE_INFINITY,
        cacheNamespaceKey: "dsDataChainsRepository",
        log: i,
        logSamplingThreshold: e.DS_DATA_LOG_SAMPLING_THRESHOLD
    }), o = K1e(l => {
        i.error({event: {id: "failedRefreshingChains", data: {error: l}}})
    }, 1e3), s = {
        start: async () => {
            if ((await s.getAll()).length === 0) throw new Error("Cannot start dsDataChainsRepository due to empty chains list")
        },
        getAll: tf(async () => a.get({key: "all", callback: () => t.getAll(), onRefreshError: o})),
        getSlugs: async () => (await s.getAll()).map(f => f.slug),
        findBySlug: async l => (await s.getAll()).find(d => d.slug === l),
        isChainId: async l => (await s.getSlugs()).includes(l)
    };
    return s
}), q2e = pt("@dexscreener/data-access-ds-data//DSDataDEXesRepository", Jft, $i(), RN, sr, (t, e, r, n) => {
    const i = n.getChildLogger({name: n.settings.name + "/ds-data-dexes-repository"}), a = new nZ({
        schema: Cn(M2e),
        persistentCache: r,
        timeToStaleInMs: e.DS_DATA_TIME_TO_STALE_IN_MS,
        maxStaleInMs: Number.POSITIVE_INFINITY,
        cacheNamespaceKey: "dsDataDEXesRepository",
        log: i,
        logSamplingThreshold: e.DS_DATA_LOG_SAMPLING_THRESHOLD
    }), o = K1e(l => {
        i.error({event: {id: "failedRefreshingDEXes", data: {error: l}}})
    }, 1e3), s = {
        getAll: tf(async () => a.get({key: "all", callback: () => t.getAll(), onRefreshError: o})),
        start: async () => {
            if ((await s.getAll()).length === 0) throw new Error("Cannot start dsDataDEXesRepository due to empty DEXes list")
        },
        findBySlug: async l => (await s.getAll()).find(d => d.slug === l)
    };
    return s
}), Odt = pt(sr, Mdt, Tp, (t, e, r) => {
    const n = tf(e.getActiveAds), i = {
        getActivePairDetailsAds: async () => {
            const {ads: a} = await n(), o = [];
            for (const s of a) s.kind === "pair-details" && o.push(s);
            return o
        }, getThresholdedPairDetailsAds: tf(async () => {
            const [{thresholds: a}, o] = await Promise.all([n(), i.getActivePairDetailsAds()]), s = Math.random(),
                l = s < a.global, f = {};
            for (const [p, g] of Object.entries(a.byChain)) Object.hasOwn(f, p) || (f[p] = s < g);
            const d = [];
            for (const p of o) {
                const g = f[p.chainId];
                (g === !0 || g === void 0 && l) && d.push(p)
            }
            return d
        }), getActiveTrendingBarAds: async () => {
            const {ads: a} = await n(), o = [];
            for (const s of a) s.kind === "trending-bar" && o.push(s);
            return o
        }, getRecentAds: async () => {
            const {recent: a} = await n();
            return a
        }, fetchImpression: async a => {
            try {
                await r.text(a.toString())
            } catch (o) {
                t.error({event: {id: "failedFetchingAdImpression", data: {error: o}}})
            }
        }, hasRecentAd: async a => {
            const o = await i.getRecentAds();
            return G2e({recentAds: o, chainId: a.chainId, tokenAddress: a.tokenAddress})
        }, start: async () => {
            await e.start()
        }, getNextTrendingBarAdTimeInterval: e.getNextTrendingBarAdTimeInterval
    };
    return i
});

function G2e(t) {
    return t.recentAds.some(e => e.chainId === t.chainId && e.tokenAddress.toLowerCase() === t.tokenAddress.toLowerCase())
}

const Pdt = Ci(Gr({date: Ns(), count: Xt()})), Ndt = Ci(Gr({date: Ns(), count: Xt()}));
rZ.optional(), kt().optional(), kt().optional(), Pdt.optional(), V4().optional(), Xt().optional(), Ndt.optional(), Xt().optional();
const Ldt = _.object({
        tokenName: _.string().optional(),
        tokenSymbol: _.string().optional(),
        tokenDecimals: _.number().optional(),
        tokenOwner: _.string().optional(),
        tokenSupply: _.number().optional(),
        tokenCreatedDate: _.number().optional(),
        quickiTokenHash: _.object({exactQHash: _.string().optional(), similarQHash: _.string().optional()}).optional()
    }), c7 = _.object({
        lockDate: _.number().optional(),
        amount: _.number().optional(),
        unlockDate: _.number().optional(),
        lockId: _.string().optional(),
        owner: _.string().optional(),
        percentageLocked: _.string().optional()
    }).optional(), Bdt = _.object({
        pinksale: c7.optional(),
        onlymoons: c7.optional(),
        dxsale: c7.optional(),
        gempad: c7.optional()
    }).optional(), $dt = _.object({
        lastUpdatedTimestamp: _.number().optional(),
        isHoneypot: _.boolean().optional(),
        buyTax: _.string().optional(),
        sellTax: _.string().optional(),
        transferTax: _.string().optional(),
        postCooldownTax: _.string().optional(),
        maxTransaction: _.string().optional(),
        maxTransactionPercent: _.string().optional(),
        maxWallet: _.string().optional(),
        maxWalletPercent: _.string().optional(),
        tokenSupplyBurned: _.number().optional(),
        lpPair: _.string().optional(),
        lpSupply: _.number().optional(),
        lpBurnedPercent: _.string().optional(),
        lpLocks: Bdt,
        priceImpact: _.string().optional(),
        problem: _.boolean().optional(),
        extra: _.string().optional()
    }), Fdt = _.object({
        contractCreator: _.string().optional(),
        contractOwner: _.string().optional(),
        contractName: _.string().optional(),
        contractChain: _.string().optional(),
        contractAddress: _.string().optional(),
        contractRenounced: _.boolean().optional(),
        hiddenOwner: _.boolean().optional(),
        hiddenOwnerModifiers: _.array(_.string()).optional(),
        isProxy: _.boolean().optional(),
        proxyImplementation: _.string().optional(),
        hasExternalContractRisk: _.boolean().optional(),
        externalContracts: _.array(_.string()).optional(),
        hasObfuscatedAddressRisk: _.boolean().optional(),
        obfuscatedAddressList: _.array(_.object({address: _.string(), code: _.string()})).optional(),
        canMint: _.boolean().optional(),
        cantMintRenounced: _.boolean().optional(),
        canBurn: _.boolean().optional(),
        canBlacklist: _.boolean().optional(),
        cantBlacklistRenounced: _.boolean().optional(),
        canMultiBlacklist: _.boolean().optional(),
        canWhitelist: _.boolean().optional(),
        cantWhitelistRenounced: _.boolean().optional(),
        canUpdateFees: _.boolean().optional(),
        cantUpdateFeesRenounced: _.boolean().optional(),
        canUpdateMaxWallet: _.boolean().optional(),
        cantUpdateMaxWalletRenounced: _.boolean().optional(),
        canUpdateMaxTx: _.boolean().optional(),
        cantUpdateMaxTxRenounced: _.boolean().optional(),
        canPauseTrading: _.boolean().optional(),
        cantPauseTradingRenounced: _.boolean().optional(),
        hasTradingCooldown: _.boolean().optional(),
        canUpdateWallets: _.boolean().optional(),
        hasSuspiciousFunctions: _.boolean().optional(),
        hasExternalFunctions: _.boolean().optional(),
        hasFeeWarning: _.boolean().optional(),
        hasModifiedTransferWarning: _.boolean().optional(),
        modifiedTransferFunctions: _.array(_.string()).optional(),
        suspiciousFunctions: _.array(_.string()).optional(),
        externalFunctions: _.array(_.string()).optional(),
        auditFunctions: _.array(_.string()).optional(),
        hasScams: _.boolean().optional(),
        matchedScams: _.string().optional(),
        scamFunctions: _.array(_.string()).optional(),
        contractLinks: _.array(_.string()).optional(),
        functions: _.array(_.string()).optional(),
        onlyOwnerFunctions: _.array(_.string()).optional(),
        multiBlacklistFunctions: _.array(_.string()).optional(),
        hasGeneralVulnerabilities: _.boolean().optional(),
        generalVulnerabilities: _.array(_.string()).optional()
    }), Udt = _.object({
        isScam: _.boolean().optional(),
        contractVerified: _.boolean().optional(),
        tokenDetails: Ldt.optional(),
        tokenDynamicDetails: $dt.optional(),
        quickiAudit: Fdt.optional(),
        chainId: _.string(),
        tokenAddress: _.string(),
        updatedAt: _.number()
    }), jdt = _.object({isMintable: _.boolean(), isFreezable: _.boolean()}), zdt = _.object({solana: jdt.optional()}),
    tue = _.object({
        count: _.number(),
        totalSupply: _.string(),
        holders: _.array(_.object({
            id: _.string(),
            label: _.string().optional(),
            balance: _.string(),
            percentage: _.number(),
            tag: _.string().optional()
        }))
    }), Vdt = _.object({
        totalPercentage: _.number(),
        locks: _.array(_.object({
            tag: _.string(),
            address: _.string(),
            amount: _.string(),
            percentage: _.number(),
            url: _.string().optional()
        }))
    }), Hdt = _.object({status: _.literal("pending")}),
    Wdt = _.object({id: _.string(), description: _.string(), result: _.boolean()}),
    qdt = _.object({address: _.string(), balance: _.number(), isContract: _.boolean()}), Gdt = _.object({
        status: _.literal("ready"),
        chainId: _.string(),
        address: _.string(),
        totalSupply: _.number(),
        deployerAddr: _.string().optional(),
        isFlagged: _.boolean(),
        exploits: _.array(_.string()),
        contract: _.object({
            isSourceVerified: _.boolean(),
            hasMint: _.boolean().optional(),
            hasFeeModifier: _.boolean().optional(),
            hasMaxTransactionAmount: _.boolean().optional(),
            hasBlocklist: _.boolean().optional(),
            hasProxy: _.boolean().optional(),
            hasPausable: _.boolean().optional()
        }),
        score: _.number().optional(),
        riskLevel: _.string().optional(),
        permissions: _.object({ownerAddress: _.string().optional(), isOwnershipRenounced: _.boolean()}).optional(),
        swapSimulation: _.object({
            isSellable: _.boolean().optional(),
            buyFee: _.number().optional(),
            sellFee: _.number().optional()
        }).optional(),
        balances: _.object({
            burnBalance: _.number().optional(),
            lockBalance: _.number().optional(),
            deployerBalance: _.number().optional(),
            ownerBalance: _.number().optional(),
            topHolders: _.array(qdt).optional()
        }).optional(),
        pools: _.array(_.object({
            address: _.string(),
            name: _.string(),
            baseSymbol: _.string(),
            baseAddress: _.string(),
            totalSupply: _.number(),
            decimals: _.number(),
            baseReserve: _.number(),
            ownerBalance: _.number().optional(),
            deployerBalance: _.number().optional(),
            burnBalance: _.number().optional(),
            lockBalance: _.number(),
            locks: _.array(_.object({
                address: _.string(),
                balance: _.number(),
                startTime: _.number().optional(),
                endTime: _.number().optional()
            }))
        })).optional(),
        tests: _.array(Wdt).optional(),
        updatedAt: _.number().optional()
    }), Kdt = _.union([Hdt, Gdt]), Ydt = _.object({circulatingSupply: _.number(), totalSupply: _.number().optional()}),
    Xdt = kN.pick({
        chainId: !0,
        name: !0,
        symbol: !0,
        address: !0,
        pairAddresses: !0,
        description: !0,
        links: !0,
        icon: !0,
        header: !0,
        createdAt: !0,
        updatedAt: !0,
        claims: !0
    }), Qdt = _.object({
        schemaVersion: _.literal("1.0.0"),
        gp: Wct.nullable(),
        cg: zct.nullable(),
        ts: Kdt.nullable(),
        cmc: Hct.nullable(),
        qi: Udt.nullable(),
        ti: Kle.nullable(),
        cms: Xdt.nullable().optional(),
        ds: Kle.nullable().optional(),
        isBoostable: _.boolean().catch(() => !0),
        ll: Vdt.nullable(),
        holders: tue.nullable(),
        lpHolders: tue.nullable(),
        su: Ydt.nullable().optional(),
        ta: zdt.nullable().optional()
    }), K2e = _.object({chainId: _.string().toLowerCase(), pairId: _.string().toLowerCase()}),
    Zdt = _.object({blockNumber: _.number(), blockTimestamp: _.number()}),
    Y2e = Gr({blockNumber: Xt(), blockTimestamp: Xt()}), X2e = t => t.c === "a" && !!t.moonshot,
    PN = t => X2e(t) && t.dexId === "moonshot", MJt = t => X2e(t) && t.dexId !== "moonshot",
    l7 = _.object({buys: _.number(), sells: _.number()}), u7 = Gr({buys: Xt(), sells: Xt()}),
    Jdt = _.object({m5: l7, h1: l7, h6: l7, h24: l7}), eht = Gr({m5: u7, h1: u7, h6: u7, h24: u7}),
    Vz = _.object({m5: _.number(), h1: _.number(), h6: _.number(), h24: _.number()}),
    Hz = Gr({m5: Xt(), h1: Xt(), h6: Xt(), h24: Xt()}),
    rue = _.object({address: _.string(), name: _.string(), symbol: _.string()}),
    nue = Gr({address: kt(), name: kt(), symbol: kt()}), Wz = _.object({
        m5: _.number().optional(),
        h1: _.number().optional(),
        h6: _.number().optional(),
        h24: _.number().optional()
    }), qz = Gr({m5: Xt().optional(), h1: Xt().optional(), h6: Xt().optional(), h24: Xt().optional()}), tht = _.object({
        m5: _.number().optional(),
        h1: _.number().optional(),
        h6: _.number().optional(),
        h24: _.number().optional()
    }), rht = Gr({m5: Xt().optional(), h1: Xt().optional(), h6: Xt().optional(), h24: Xt().optional()}),
    nht = _.object({usd: _.number(), base: _.number(), quote: _.number()}),
    iht = Gr({usd: Xt(), base: Xt(), quote: Xt()}),
    aht = _.object({m5: _.number(), h1: _.number(), h6: _.number(), h24: _.number()}),
    oht = Gr({m5: Xt(), h1: Xt(), h6: Xt(), h24: Xt()}), sht = _.object({
        eti: _.boolean(),
        header: _.boolean().optional(),
        website: _.boolean().optional(),
        twitter: _.boolean().optional(),
        discord: _.boolean().optional(),
        linkCount: _.number().optional(),
        imgKey: _.string().optional()
    }), iZ = Gr({
        eti: Gu(),
        header: Gu().optional(),
        website: Gu().optional(),
        twitter: Gu().optional(),
        discord: Gu().optional(),
        linkCount: Xt().optional(),
        imgKey: kt().optional()
    }), cht = _.object({
        website: _.boolean().optional(),
        twitter: _.boolean().optional(),
        discord: _.boolean().optional(),
        linkCount: _.number().optional(),
        headerId: _.string().optional(),
        iconId: _.string(),
        description: _.string().optional(),
        links: Cn(_.object({
            type: _.enum(["telegram", "twitter", "discord", "facebook", "tiktok"]).optional(),
            url: _.string()
        })).optional()
    }), Q2e = Gr({
        website: Gu().optional(),
        twitter: Gu().optional(),
        discord: Gu().optional(),
        linkCount: Xt().optional(),
        headerId: kt().optional(),
        iconId: kt(),
        description: kt().optional(),
        links: Ci(Gr({type: KE(["telegram", "twitter", "discord", "facebook", "tiktok"]).optional(), url: kt()})).optional()
    }), lht = _.object({
        progress: _.number(),
        quoteMcap: _.number(),
        curvePos: _.string(),
        curveType: _.string(),
        coefB: _.string(),
        mcapThreshold: _.string(),
        creator: _.string()
    }), Z2e = Gr({
        progress: Xt(),
        quoteMcap: Xt(),
        curvePos: kt(),
        curveType: kt(),
        coefB: kt(),
        mcapThreshold: kt(),
        creator: kt()
    }), U8 = _.object({
        chainId: _.string(),
        dexId: _.string(),
        labels: Cn(_.string()).optional(),
        pairAddress: _.string(),
        baseToken: rue,
        quoteToken: rue,
        quoteTokenSymbol: _.string(),
        price: _.string(),
        priceUsd: _.string().optional(),
        txns: Jdt,
        buyers: Vz.optional(),
        sellers: Vz.optional(),
        makers: Vz.optional(),
        volume: Wz,
        volumeBuy: Wz.optional(),
        volumeSell: Wz.optional(),
        priceChange: tht,
        liquidity: nht.optional(),
        marketCap: _.number().optional(),
        fdv: _.number().optional(),
        pairCreatedAt: _.number().optional(),
        eti: _.boolean().optional(),
        profile: sht.optional(),
        cmsProfile: cht.optional(),
        boosts: aht.optional()
    }), j8 = Gr({
        chainId: kt(),
        dexId: kt(),
        labels: Ci(kt()).optional(),
        pairAddress: kt(),
        baseToken: nue,
        quoteToken: nue,
        quoteTokenSymbol: kt(),
        price: kt(),
        priceUsd: kt().optional(),
        txns: eht,
        buyers: Hz.optional(),
        sellers: Hz.optional(),
        makers: Hz.optional(),
        volume: qz,
        volumeBuy: qz.optional(),
        volumeSell: qz.optional(),
        priceChange: rht,
        liquidity: iht.optional(),
        marketCap: Xt().optional(),
        fdv: Xt().optional(),
        pairCreatedAt: Xt().optional(),
        eti: Gu().optional(),
        profile: iZ.optional(),
        cmsProfile: Q2e.optional(),
        boosts: oht.optional()
    }), uht = U8.extend({
        c: _.literal("a"),
        a: _.string(),
        cgi: _.string().optional().nullable(),
        moonshot: lht.optional()
    }), J2e = j8.extend({c: Bs("a"), a: kt(), cgi: kt().optional().nullable(), moonshot: Z2e.optional()}),
    OJt = J2e.extend({moonshot: Z2e}), fht = U8.extend({c: _.undefined().optional()}),
    dht = j8.extend({c: zQ().optional()}), hht = U8.extend({c: _.literal("u")}), pht = j8.extend({c: Bs("u")}),
    mht = U8.extend({c: _.literal("b"), pn: _.string()}), vht = j8.extend({c: Bs("b"), pn: kt()}),
    ght = U8.extend({c: _.literal("o"), cgi: _.string().optional()}),
    yht = j8.extend({c: Bs("o"), cgi: kt().optional()}), e_e = _.union([uht, fht, hht, mht, ght]),
    aZ = US([J2e, dht, pht, vht, yht]),
    t_e = _.enum(["buys", "sells", "volume", "priceChangeH24", "priceChangeH6", "priceChangeH1", "priceChangeM5", "liquidity", "marketCap", "fdv", "pairAge", "moonshotProgress"]),
    r_e = _.enum(["desc", "asc"]), bht = _.object({key: _.union([t_e, _.string()]), order: r_e}),
    As = _.object({min: _.number().optional(), max: _.number().optional()}),
    ex = _.object({min: _.number().int().optional(), max: _.number().int().optional()}),
    wht = _.object({chainId: _.string(), pairId: _.string()}),
    Sht = _.object({chainId: _.string(), tokenAddress: _.string()}), _ht = _.object({
        includePairsInactiveInTimeframe: _.boolean().optional(),
        pairs: _.union([_.array(wht), _.null()]).optional(),
        baseTokens: _.array(Sht).optional(),
        chainIds: _.array(_.string()).optional(),
        dexIds: _.array(_.string()).optional(),
        txns: _.record(ex).optional(),
        buys: _.record(ex).optional(),
        sells: _.record(ex).optional(),
        volume: _.record(As).optional(),
        priceChange: _.record(As).optional(),
        liquidity: As.optional(),
        marketCap: As.optional(),
        fdv: As.optional(),
        pairAge: As.optional(),
        enhancedTokenInfo: _.boolean().optional(),
        circulatingSupply: As.optional(),
        isOpenSource: _.boolean().optional(),
        isHoneypot: _.boolean().optional(),
        isRenounced: _.boolean().optional(),
        isFlagged: _.boolean().optional(),
        holderCount: ex.optional(),
        lpHolderCount: ex.optional(),
        buyTax: As.optional(),
        sellTax: As.optional(),
        tokenSnifferScore: ex.optional(),
        categories: _.array(_.string()).optional(),
        excludedDexIds: _.array(_.string()).optional(),
        pairCreator: _.array(_.string()).optional(),
        moonshotPairCreator: _.array(_.string()).optional(),
        moonshotProgress: As.optional()
    }), xht = _.object({rankBy: bht.optional(), filters: _ht.optional()}),
    f7 = _.object({txns: _.number(), volumeUsd: _.number()}), Eht = _.object({m5: f7, h1: f7, h6: f7, h24: f7}),
    d7 = Gr({txns: Xt(), volumeUsd: Xt()}), n_e = Gr({m5: d7, h1: d7, h6: d7, h24: d7}),
    NN = _.union([_.literal("m5"), _.literal("h1"), _.literal("h6"), _.literal("h24")]),
    PJt = ["m5", "h1", "h6", "h24"], i_e = {
        m5: {label: "Last 5 minutes", shorthand: "5M", intervalInMs: 60 * 5 * 1e3},
        h1: {label: "Last hour", shorthand: "1H", intervalInMs: 60 * 60 * 1e3},
        h6: {label: "Last 6 hours", shorthand: "6H", intervalInMs: 60 * 60 * 6 * 1e3},
        h24: {label: "Last 24 hours", shorthand: "24H", intervalInMs: 60 * 60 * 24 * 1e3}
    }, a_e = mn("@dexscreener/feature-pair//unknownDEXValidatorSupportedDexSlugs")(),
    NJt = pt(a_e, t => ({pair: e}) => PN(e) ? [] : t.length > 0 && !t.includes(e.dexId) ? [{
        type: "unknown-dex",
        status: "warning",
        data: {dexId: e.dexId}
    }] : []),
    o_e = ["0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000001", "0x000000000000000000000000000000000000dead"],
    Tht = {pulsechain: ["0x0000000000000000000000000000000000000369"]}, Cht = t => {
        const e = Tht[t] ?? [];
        return [...o_e, ...e]
    }, iue = ["error", "warning", "success", "neutral"], yA = (t, e = "error") => t ? "success" : e,
    n4 = (t, e) => yA(!t, e),
    oZ = (t, e) => [...t].sort((r, n) => e !== void 0 && r.status === n.status ? e.indexOf(r.key) - e.indexOf(n.key) : iue.indexOf(r.status) - iue.indexOf(n.status)),
    sZ = (t, e) => e ? Cht(e).includes(t.toLowerCase()) : o_e.includes(t.toLowerCase()),
    aue = ["buyTax", "sellTax", "slippageModifiable", "externalCall", "ownershipRenounced", "hiddenOwner", "isOpenSource", "isHoneypot", "isProxy", "isMintable", "transferPausable", "tradingCooldown", "cannotSellAll", "ownerChangeBalance", "isBlacklisted", "isWhitelisted", "isAntiWhale", "holderCount", "lpHolderCount", "creatorAddress", "creatorBalance", "ownerAddress", "ownerBalance"],
    Aht = ["isOpenSource", "holderCount", "lpHolderCount", "creatorAddress", "creatorBalance", "ownerAddress", "ownerBalance"],
    LG = t => t.canTakeBackOwnership === !1 && t.hiddenOwner !== !0 && t.ownerAddress !== void 0 && sZ(t.ownerAddress),
    Iht = t => {
        const e = LG(t);
        return {
            ...t,
            buyTax: t.buyTax === null ? null : t.buyTax !== void 0 ? jM(t.buyTax) : void 0,
            sellTax: t.sellTax === null ? null : t.sellTax !== void 0 ? jM(t.sellTax) : void 0,
            ownershipRenounced: e
        }
    }, kht = pt("@dexscreener/pair-details/token-validators/goplus-security-validator", () => t => {
        const e = t.isOpenSource, r = aue.reduce((i, a) => {
            if (!(e || !e && Aht.includes(a))) return i;
            switch (a) {
                case"isOpenSource":
                case"isTrueToken": {
                    const s = t[a];
                    return s === void 0 ? i : [...i, {key: a, status: yA(s), value: s}]
                }
                case"antiWhaleModifiable":
                case"isHoneypot":
                case"isProxy":
                case"canTakeBackOwnership":
                case"cannotSellAll":
                case"ownerChangeBalance":
                case"transferPausable":
                case"tradingCooldown":
                case"hiddenOwner":
                case"externalCall": {
                    const s = t[a];
                    return s === void 0 ? i : [...i, {key: a, status: n4(s), value: s}]
                }
                case"isBlacklisted":
                case"isWhitelisted": {
                    const s = t[a];
                    return s === void 0 ? i : [...i, {key: a, status: n4(s, "warning"), value: s}]
                }
                case"isAntiWhale": {
                    const s = t[a];
                    return s === void 0 ? i : [...i, {key: a, status: "neutral", value: s}]
                }
                case"trustList": {
                    const s = t[a];
                    return s ? [...i, {key: a, status: yA(s), value: s}] : i
                }
                case"creatorAddress":
                case"ownerAddress": {
                    const s = t[a];
                    return s ? [...i, {key: a, status: "neutral", value: s}] : i
                }
                case"creatorBalance":
                case"ownerBalance": {
                    const s = t[a];
                    if (!s) return i;
                    const l = _.coerce.number().safeParse(s);
                    return l.success ? [...i, {key: a, status: "neutral", value: `${l.data}`}] : i
                }
                case"holderCount":
                case"lpHolderCount": {
                    const s = t[a];
                    if (!s) return i;
                    const l = _.coerce.number().safeParse(s);
                    return l.success ? [...i, {key: a, status: "neutral", value: l.data}] : i
                }
                case"buyTax":
                case"sellTax": {
                    const s = t[a];
                    if (s === null) return [...i, {key: a, status: "neutral", value: void 0}];
                    if (!s) return i;
                    const l = _.coerce.number().safeParse(s);
                    if (!l.success) return i;
                    const f = l.data <= .02 ? "success" : l.data <= .1 ? "warning" : "error";
                    return [...i, {key: a, status: f, value: l.data}]
                }
                case"isMintable":
                case"slippageModifiable": {
                    const s = t[a];
                    if (s === void 0) return i;
                    const f = LG(t) ? !1 : s;
                    return [...i, {key: a, status: n4(f), value: f}]
                }
                case"ownershipRenounced": {
                    const s = LG(t),
                        l = t.canTakeBackOwnership === !0 || t.hiddenOwner === !0 || t.ownerAddress && sZ(t.ownerAddress) === !1,
                        f = s ? "success" : l ? "error" : "neutral";
                    return [...i, {key: a, status: f, value: s}]
                }
                case"creatorPercent":
                case"ownerPercent":
                case"tokenName":
                case"tokenSymbol":
                    return i
            }
        }, []);
        return {result: oZ(r, aue), auditValues: Iht(t)}
    }),
    oue = ["buyTax", "sellTax", "slippageModifiable", "ownershipRenounced", "hiddenOwner", "isOpenSource", "isHoneypot", "isProxy", "isMintable", "transferPausable", "tradingCooldown", "cannotSellAll", "ownerChangeBalance", "isBlacklisted", "isWhitelisted", "isAntiWhale", "holderCount", "lpHolderCount", "creatorAddress", "creatorBalance", "ownerAddress", "ownerBalance"],
    Rht = t => {
        var i, a;
        const {contractRenounced: e, hiddenOwner: r} = t.quickiAudit ?? {},
            n = ((i = t.tokenDetails) == null ? void 0 : i.tokenOwner) !== void 0 ? sZ((a = t.tokenDetails) == null ? void 0 : a.tokenOwner, t.chainId) : void 0;
        return n === void 0 ? e ?? !1 : n ? e ?? r !== !0 : !1
    }, Dht = t => {
        var a, o, s, l, f, d, p, g, b, S, T, I, N, P, F, V, Y;
        const e = Rht(t), r = (a = t.tokenDynamicDetails) == null ? void 0 : a.problem,
            n = ((o = t.tokenDynamicDetails) == null ? void 0 : o.buyTax) !== void 0 ? jM((s = t.tokenDynamicDetails) == null ? void 0 : s.buyTax) / 100 : null,
            i = ((l = t.tokenDynamicDetails) == null ? void 0 : l.sellTax) !== void 0 ? jM((f = t.tokenDynamicDetails) == null ? void 0 : f.sellTax) / 100 : null;
        return {
            ownershipRenounced: e,
            hiddenOwner: (d = t.quickiAudit) == null ? void 0 : d.hiddenOwner,
            isHoneypot: (p = t.tokenDynamicDetails) == null ? void 0 : p.isHoneypot,
            isProxy: (g = t.quickiAudit) == null ? void 0 : g.isProxy,
            isMintable: (b = t.quickiAudit) == null ? void 0 : b.canMint,
            transferPausable: (S = t.quickiAudit) == null ? void 0 : S.canPauseTrading,
            tradingCooldown: (T = t.quickiAudit) == null ? void 0 : T.hasTradingCooldown,
            buyTax: r === !0 ? null : n,
            sellTax: r === !0 ? null : i,
            creatorAddress: (I = t.quickiAudit) == null ? void 0 : I.contractCreator,
            ownerAddress: (N = t.quickiAudit) == null ? void 0 : N.contractOwner,
            isBlacklisted: (P = t.quickiAudit) == null ? void 0 : P.canBlacklist,
            isWhitelisted: (F = t.quickiAudit) == null ? void 0 : F.canWhitelist,
            tokenName: (V = t.tokenDetails) == null ? void 0 : V.tokenName,
            tokenSymbol: (Y = t.tokenDetails) == null ? void 0 : Y.tokenSymbol
        }
    }, Mht = ["isMintable", "transferPausable", "isBlacklisted", "isWhitelisted"],
    X5 = (t, e, r) => Mht.includes(t) && e.ownershipRenounced ? !1 : r, Oht = pt(() => t => {
        const e = Dht(t), r = oue.reduce((n, i) => {
            switch (i) {
                case"isOpenSource":
                case"isTrueToken": {
                    const a = e[i];
                    if (a === void 0) return n;
                    const o = X5(i, e, a);
                    return [...n, {key: i, status: yA(o), value: o}]
                }
                case"antiWhaleModifiable":
                case"isHoneypot":
                case"isProxy":
                case"canTakeBackOwnership":
                case"cannotSellAll":
                case"ownerChangeBalance":
                case"transferPausable":
                case"tradingCooldown":
                case"hiddenOwner":
                case"slippageModifiable":
                case"externalCall":
                case"isMintable": {
                    const a = e[i];
                    if (a === void 0) return n;
                    const o = X5(i, e, a);
                    return [...n, {key: i, status: n4(o), value: o}]
                }
                case"isBlacklisted":
                case"isWhitelisted": {
                    const a = e[i];
                    if (a === void 0) return n;
                    const o = X5(i, e, a);
                    return [...n, {key: i, status: n4(o, "warning"), value: o}]
                }
                case"isAntiWhale": {
                    const a = e[i];
                    if (a === void 0) return n;
                    const o = X5(i, e, a);
                    return [...n, {key: i, status: "neutral", value: o}]
                }
                case"trustList": {
                    const a = e[i];
                    if (!a) return n;
                    const o = X5(i, e, a);
                    return [...n, {key: i, status: yA(o), value: o}]
                }
                case"creatorAddress":
                case"ownerAddress": {
                    const a = e[i];
                    return a ? [...n, {key: i, status: "neutral", value: a}] : n
                }
                case"creatorBalance":
                case"ownerBalance": {
                    const a = e[i];
                    if (!a) return n;
                    const o = _.coerce.number().safeParse(a);
                    return o.success ? [...n, {key: i, status: "neutral", value: `${o.data}`}] : n
                }
                case"holderCount":
                case"lpHolderCount": {
                    const a = e[i];
                    if (!a) return n;
                    const o = _.coerce.number().safeParse(a);
                    return o.success ? [...n, {key: i, status: "neutral", value: o.data}] : n
                }
                case"buyTax":
                case"sellTax": {
                    const a = e[i];
                    if (a === null) return [...n, {key: i, status: "neutral", value: void 0}];
                    if (!a) return n;
                    const o = a <= .02 ? "success" : a <= .1 ? "warning" : "error";
                    return [...n, {key: i, status: o, value: a}]
                }
                case"ownershipRenounced": {
                    if (t.chainId === "solana") return n;
                    const {canTakeBackOwnership: a, hiddenOwner: o, ownershipRenounced: s} = e,
                        f = s ? "success" : a === !0 || o === !0 ? "error" : "neutral";
                    return [...n, {key: i, status: f, value: s}]
                }
                case"creatorPercent":
                case"ownerPercent":
                case"tokenName":
                case"tokenSymbol":
                    return n
            }
            return n
        }, []);
        return {result: oZ(r, oue), auditValues: e}
    }), sue = ["isMintable", "transferPausable"], Pht = t => ({isMintable: t.isMintable, transferPausable: t.isFreezable}),
    Nht = pt(() => t => {
        const e = Pht(t), r = sue.reduce((n, i) => {
            switch (i) {
                case"transferPausable":
                case"isMintable": {
                    const a = e[i];
                    return a === void 0 ? n : [...n, {key: i, status: n4(a), value: a}]
                }
                default:
                    return n
            }
        }, []);
        return {result: oZ(r, sue), auditValues: e}
    }), s_e = mn("@dexscreener/dex-pair-details/host")(),
    LJt = pt("@dexscreener/pair-details/service", s_e, tZ, kht, Oht, Nht, (t, e, r, n, i) => ({
        get: a => {
            const o = new URL(t);
            return o.pathname = `/dex/pair-details/v3/${a.chainId}/${a.pairId}`.toLowerCase(), a.isInverted && o.searchParams.append("inverted", "1"), e.get(o.toString(), Qdt)
        }, validateGoPlus: r, validateQuickIntel: n, validateSolana: i
    })), Lht = K2e.extend({amount: _.number(), amountUsd: _.number()}),
    Bht = Gr({chainId: kt(), pairId: kt(), amount: Xt(), amountUsd: Xt()}),
    $ht = _.object({address: _.string(), updatedAt: _.coerce.date(), pairs: Cn(Lht)}),
    Fht = Gr({address: kt(), updatedAt: Ns(), pairs: Ci(Bht)}),
    c_e = mn("@dexscreener/data-access-balance/balanceServerHost")(), BJt = pt(c_e, Tp, (t, e) => {
        const r = new I4(1);
        return {
            all: r.pipe(op(), Xa), getPortfolio: tf(async ({params: n, query: i}) => {
                const a = new URL(t);
                a.pathname = `/balance/portfolio/${n.address}`, i != null && i.format && a.searchParams.append("format", i.format), i != null && i.page && a.searchParams.append("page", i.page.toString()), i != null && i.limit && a.searchParams.append("limit", i.limit.toString()), i != null && i.ms && a.searchParams.append("ms", i.ms.toString());
                const o = await iC({
                    callback: () => (i == null ? void 0 : i.format) === "json" ? e.get(a.toString(), $ht, {credentials: "include"}) : e.avro(a.toString(), Fht, {credentials: "include"}),
                    timeoutInMs: 15e3,
                    newTimeoutError: f => new r4({timeoutInMs: f, url: a.toString()})
                }), s = o.updatedAt ? new Date(o.updatedAt).getTime() : void 0, l = {...o, updatedAt: s};
                return r.next(l), l
            })
        }
    }), l_e = Gr({
        pairAddress: kt(),
        baseToken: Gr({address: kt(), name: kt(), symbol: kt()}),
        chainId: kt(),
        eti: Gu().optional(),
        priceChange: qq(kt(), Xt().optional()),
        volume: qq(kt(), Xt().optional()),
        liquidity: Gr({usd: Xt(), base: Xt(), quote: Xt()}).optional(),
        pairCreatedAt: Xt().optional()
    });
l_e.extend({schemaVersion: Bs("1.1"), profile: iZ.optional()});
const Uht = l_e.extend({
        schemaVersion: Bs("1.2"),
        profile: iZ.optional(),
        cmsProfile: Q2e.pick({
            website: !0,
            twitter: !0,
            discord: !0,
            linkCount: !0,
            headerId: !0,
            iconId: !0,
            description: !0
        }).optional()
    }), jht = Ci(Uht), u_e = mn("@dexscreener/dex-trending-server/host")(),
    $Jt = pt("@dexscreener/data-access-dex-trending//TrendingPairsService", u_e, Tp, (t, e) => ({
        getPairs: async r => {
            const n = new URL(t);
            return n.pathname = "/dex/trending/v3", r.chainId && n.searchParams.append("chainId", r.chainId), r.dexId && n.searchParams.append("dexId", r.dexId), r.timeframeKey && n.searchParams.append("timeframeKey", r.timeframeKey), e.avro(n.toString(), jht)
        }
    })), zht = _.object({total: _.number()}), Vht = _.record(_.string(), zht),
    cue = _.object({userReaction: _.object({reaction: _.string().optional()}), reactions: Vht}),
    f_e = mn("@dexscreener/data-access-hype/hypeServerHost")(), FJt = pt(f_e, tZ, (t, e) => ({
        createReaction: ({entityType: r, entityId: n, emoji: i}) => {
            const a = new URL(t);
            return a.pathname = `/hype/reactions/${r}/${n}`, e.post(a.toString(), cue, {
                headers: {"content-type": "application/json"},
                body: {emoji: i}
            })
        }, getReactions: ({entityType: r, entityId: n}) => {
            const i = new URL(t);
            return i.pathname = `/hype/reactions/${r}/${n}`, e.get(i.toString(), cue)
        }
    }));
Dct(["LINEAR_V1"]);
const Hht = 55, lue = {
    type: "LINEAR_V1",
    collateralDecimalsNr: 9,
    marketCapDecimalsNr: 9,
    tokenDecimalsNr: 9,
    coefficientBMinimalUnits: 25,
    marketCapThreshold: new Kn(5e11),
    totalSupply: new Kn(1e18)
}, Wht = t => {
    const e = new Kn(10).pow(t.tokenDecimalsNr), r = new Kn(10).pow(t.marketCapDecimalsNr),
        n = new Kn(Hht).dividedBy(100), i = new Kn(t.totalSupply).multipliedBy(n).dividedBy(e);
    return new Kn(t.marketCapThreshold).dividedBy(r).dividedBy(i).minus(t.coefficientB).dividedBy(i)
}, qht = t => new Kn(t.minimalUnits).dividedBy(new Kn(10).pow(t.decimals)), Ght = t => {
    const {
        coefficientA: e,
        coefficientB: r,
        collateralAmount: n,
        curvePosition: i,
        tokenDecimalsNr: a,
        collateralDecimalsNr: o
    } = t;
    try {
        const s = new Kn(10).pow(a), l = new Kn(10).pow(o), f = new Kn(n).dividedBy(l), d = new Kn(i).dividedBy(s),
            p = e;
        let g = p.multipliedBy(d).plus(r).multipliedBy(2), b = f.multipliedBy(-2);
        t.direction === "sell" && (g = g.negated(), b = b.negated());
        const S = g.pow(2).minus(p.multipliedBy(b).multipliedBy(4));
        if (S.isNegative()) throw new Error("Negative discriminant, no real roots for tokensNr from collateral calculation");
        const T = S.sqrt(), I = p.multipliedBy(2), N = g.negated().plus(T).dividedBy(I),
            P = g.negated().minus(T).dividedBy(I), F = t.direction === "sell" ? P : N;
        return new Kn(F.toFixed(0)).multipliedBy(s.toFixed(0))
    } catch {
        return
    }
}, Kht = t => {
    const {
            coefficientA: e,
            coefficientB: r,
            tokenAmount: n,
            curvePosition: i,
            tokenDecimalsNr: a,
            collateralDecimalsNr: o
        } = t, s = new Kn(10).pow(a), l = new Kn(10).pow(o), f = n.dividedBy(s), d = i.dividedBy(s), p = new Kn(2),
        b = new Kn(.5).multipliedBy(e).multipliedBy(f).multipliedBy(p.multipliedBy(d).plus(f)).plus(r.multipliedBy(f)).multipliedBy(l);
    try {
        return new Kn(b.toFixed(0))
    } catch {
        return
    }
};

class Yht {
    constructor(e) {
        Ft(this, "config", lue);
        e != null && e.config && this.setConfig(e.config)
    }

    setConfig(e) {
        this.config = {...this.config, ...e}
    }

    getConfig() {
        return this.config
    }

    getCoefficientA() {
        return Wht({
            tokenDecimalsNr: this.config.tokenDecimalsNr,
            marketCapDecimalsNr: this.config.marketCapDecimalsNr,
            marketCapThreshold: this.config.marketCapThreshold,
            totalSupply: this.config.totalSupply,
            coefficientB: this.getCoefficientB()
        })
    }

    getCoefficientB() {
        return qht({decimals: this.config.collateralDecimalsNr, minimalUnits: this.config.coefficientBMinimalUnits})
    }

    getTokensNumberFromCollateral(e) {
        const {collateralAmount: r, curvePosition: n, direction: i} = e, a = this.getCoefficientA(),
            o = this.getCoefficientB(), s = Ght({
                coefficientA: a,
                coefficientB: o,
                collateralAmount: r,
                curvePosition: n,
                direction: i,
                tokenDecimalsNr: this.config.tokenDecimalsNr,
                collateralDecimalsNr: this.config.collateralDecimalsNr
            });
        if (!s) throw new Error("Expected collateral amount is 0 or undefined!");
        return s
    }

    getCollateralPriceForTokens(e) {
        const {curvePosition: r, tokenAmount: n} = e, i = this.getCoefficientA(), a = this.getCoefficientB(), o = Kht({
            coefficientA: i,
            coefficientB: a,
            tokenAmount: n,
            curvePosition: r,
            tokenDecimalsNr: this.config.tokenDecimalsNr,
            collateralDecimalsNr: this.config.collateralDecimalsNr
        });
        if (!o) throw new Error("Expected collateral amount is 0 or undefined!");
        return o
    }
}

Ft(Yht, "DEFEAULT_CONFIG", lue);
const Xht = _.object({draftTokenId: _.string(), transaction: _.string(), token: _.string()}),
    Qht = nC([Pz("E0001"), Pz("E0002"), Pz("E0003")]), Zht = HQ({code: Qht, message: IN()}), Jht = HQ({message: IN()}),
    uue = nC([Zht, Jht]);

class fue extends Error {
}

class due extends Error {
}

class hue extends Error {
}

class h7 extends Error {
}

const ept = _.object({tokens: Cn(kN)}), tpt = ept,
    rpt = _.object({tokenPairState: _.union([_.literal("MIGRATION_STARTED"), _.literal("READY_FOR_MIGRATION"), _.literal("INITIATED"), _.literal("MIGRATED")])}),
    npt = kN, ipt = _.object({txnId: _.string(), status: _.string(), statusToken: _.string().optional(), token: kN}),
    d_e = _.enum(["buy", "sell"]), apt = _.enum(["initiated", "pending", "success", "failed"]),
    opt = _.object({transaction: _.string(), token: _.string(), direction: d_e}),
    spt = _.object({direction: d_e, transactionSignature: _.string(), status: apt, statusToken: _.string()}), cpt = opt,
    lpt = spt, h_e = mn("@dexscreener/moonshot-server/host")(),
    UJt = pt({moonshotServerHost: h_e, httpClient: Tp}, ({moonshotServerHost: t, httpClient: e}) => {
        const r = i => {
            const a = new FormData;
            return a.append("name", i.name), a.append("symbol", i.symbol), a.append("description", i.description ?? ""), a.append("icon", i.icon), a.append("creatorId", i.creatorId), a.append("chainId", i.chainId), a.append("traceId", i.traceId), a.append("coefB", `${i.coefB}`), a.append("curveType", i.curveType), i.banner && a.append("banner", i.banner), i.links && a.append("links", JSON.stringify(i.links)), i.tokenAmount && a.append("tokenAmount", i.tokenAmount), a
        }, n = i => {
            const a = new FormData;
            return a.append("chainId", i.chainId), a.append("tokenAddress", i.tokenAddress), a.append("description", i.description ?? ""), a.append("signature", i.signature), i.icon && a.append("icon", i.icon), i.banner && a.append("banner", i.banner), i.links && a.append("links", JSON.stringify(i.links)), a
        };
        return {
            mintSubmit: async i => {
                const a = new URL("/tokens/v1/submit", t);
                return e.post(a.toString(), ipt, {body: i, headers: {"content-type": "application/json"}})
            }, tokenPrepare: async i => {
                const a = new URL("/tokens/v1", t);
                try {
                    return await e.post(a.toString(), Xht, {body: r(i)})
                } catch (o) {
                    const s = $f(o);
                    if (s instanceof Kh && s.response) {
                        const l = uue.json.safeDecode(s.response);
                        if (l.ok && "code" in l.value) switch (l.value.code) {
                            case"E0001":
                                throw new fue(l.value.message);
                            case"E0002":
                                throw new due(l.value.message);
                            case"E0003":
                                throw new hue(l.value.message);
                            default:
                                throw new h7(l.value.message)
                        } else if (l.ok) throw new h7(l.value.message)
                    }
                    throw s
                }
            }, tokenPatch: async i => {
                const a = new URL(`/tokens/v1/${i.chainId}/${i.tokenAddress}`, t);
                return e.post(a.toString(), npt, {body: n(i)})
            }, getTokensByCreatorAddress: async i => {
                const a = new URL("/tokens/v1", t);
                return a.searchParams.set("chainId", i.chainId), a.searchParams.set("creatorAddress", i.creatorAddress), i.orderBy && a.searchParams.set("orderBy", i.orderBy), i.direction && a.searchParams.set("direction", i.direction), (await e.get(a.toString(), tpt)).tokens
            }, txPrepare: async i => {
                const a = new URL("/tx/v1/prepare", t);
                try {
                    return await e.post(a.toString(), cpt, {body: i, headers: {"content-type": "application/json"}})
                } catch (o) {
                    const s = $f(o);
                    if (s instanceof Kh && s.response) {
                        const l = uue.json.safeDecode(s.response);
                        if (l.ok && "code" in l.value) switch (l.value.code) {
                            case"E0001":
                                throw new fue(l.value.message);
                            case"E0002":
                                throw new due(l.value.message);
                            case"E0003":
                                throw new hue(l.value.message);
                            default:
                                throw new h7(l.value.message)
                        } else if (l.ok) throw new h7(l.value.message)
                    }
                    throw s
                }
            }, txSubmit: async i => {
                const a = new URL("/tx/v1/submit", t);
                return e.post(a.toString(), lpt, {body: i, headers: {"content-type": "application/json"}})
            }, migrate: async i => {
                const a = new URL(`/tokens/v1/migrate/${i.tokenAddress}`, t);
                return e.post(a.toString(), rpt, {body: i, headers: {"content-type": "application/json"}})
            }
        }
    });

function p_e(t, e) {
    return t.width === e.width && t.height === e.height
}

function jJt(t, e) {
    return t === "responsive" && e === "responsive" ? !0 : t !== "responsive" && e !== "responsive" ? p_e(t, e) : !1
}

const upt = _.object({
    ad: _.object({
        title: _.string(),
        img: _.string().url(),
        thumbnail: _.string().url(),
        description: _.string(),
        description_short: _.string(),
        cta_button: _.string(),
        name: _.string(),
        url: _.string().url(),
        impressionUrl: _.string().url()
    })
});

function fpt(t) {
    return {
        kind: "native",
        provider: "coinzilla",
        title: t.ad.name,
        thumbnail: t.ad.thumbnail,
        description: t.ad.description_short,
        callToAction: t.ad.cta_button,
        url: t.ad.url,
        impressionUrl: t.ad.impressionUrl,
        advertiseLink: "https://docs.dexscreener.com/contact-us/advertise"
    }
}

const m_e = mn("@dexscreener/feature-ads//adsWorkerHost")(),
    zJt = pt("@dexscreener/feature-ads//AdsWorkerAdsDataSource", m_e, tZ, Tp, (t, e, r) => ({
        getAd: n => {
            const i = new URL(t);
            return i.pathname = "/a/cz/native", i.searchParams.append("screen", n.screen), e.get(i.toString(), upt, {credentials: "include"}).pipe(zn(fpt))
        }, notifyViewed: n => Ly(async () => {
            switch (n.provider) {
                case"direct": {
                    await Promise.all(n.impressionURLs.map(i => r.text(i, {credentials: "include"})));
                    break
                }
                case"coinzilla":
                case"fallback": {
                    n.impressionUrl && await r.text(n.impressionUrl, {credentials: "include"});
                    break
                }
            }
        })
    })), dpt = mn("@dexscreener/feature-ads//CoinzillaAdUnitsDataSource")(), hpt = {
        defaultNativeUnit: {adKind: "native", provider: "coinzilla", id: "23561ae610e32dca451"},
        nativeUnits: [{adKind: "native", provider: "coinzilla", screen: "search", id: "73763d0da2cda012691"}],
        defaultDisplayUnit: {
            adKind: "display",
            provider: "coinzilla",
            id: "17561ae610e2fb39895",
            size: {width: 300, height: 250}
        },
        displayUnits: [{
            adKind: "display",
            screen: "pair",
            provider: "coinzilla",
            id: "17561ae610e2fb39895",
            size: {width: 300, height: 250}
        }, {
            adKind: "display",
            screen: "pair",
            provider: "coinzilla",
            id: "33261b1fda835937836",
            size: {width: 320, height: 100}
        }, {
            adKind: "display",
            screen: "pair",
            provider: "coinzilla",
            id: "88063ee279569115919",
            size: "responsive"
        }, {
            adKind: "display",
            screen: "pair",
            provider: "coinzilla",
            id: "99163f475333c9ee950",
            size: "responsive",
            chainId: "bsc"
        }]
    }, ppt = mn("@dexscreener/feature-ads//AAdsAdUnitsDataSource")(), mpt = {
        defaultDisplayUnit: {adKind: "display", provider: "a-ads", size: {width: 300, height: 250}, id: "2182334"},
        displayUnits: [{
            adKind: "display",
            screen: "pair",
            provider: "a-ads",
            size: {width: 300, height: 250},
            id: "2182334"
        }, {
            adKind: "display",
            screen: "pair",
            provider: "a-ads",
            size: {width: 320, height: 100},
            id: "2175148"
        }, {adKind: "display", screen: "pair", provider: "a-ads", size: "responsive", id: "2188452"}]
    }, v_e = mn("@dexscreener/feature-ads/personaAdUnits")(), vpt = [{
        adKind: "display",
        provider: "persona",
        screen: "pair",
        size: {width: 300, height: 250},
        id: "c3a43cc3-d13d-45c7-b85f-2273edfeb6ef"
    }, {
        adKind: "display",
        provider: "persona",
        screen: "pair",
        size: {width: 321, height: 101},
        id: "03eeff04-1b1f-418c-ba28-02e5b7549da6"
    }, {
        adKind: "display",
        provider: "persona",
        screen: "pair",
        size: {width: 300, height: 250},
        id: "ec1dad53-c092-4fe3-900f-59ac2c7812c4",
        chainId: "arbitrum"
    }, {
        adKind: "display",
        provider: "persona",
        screen: "pair",
        size: {width: 321, height: 101},
        id: "79764814-e712-4966-a89d-81e9e8470fe8",
        chainId: "arbitrum"
    }], VJt = pt(v_e, t => ({
        findDisplayAdUnit: e => {
            const r = t.filter(n => n.screen !== e.screen ? !1 : p_e(n.size, e.size));
            return e.chainId !== void 0 ? r.find(n => n.chainId === e.chainId) : r.find(n => n.chainId === void 0)
        }, getDisplayAd: e => Hd({kind: "display", provider: "persona", adUnit: e})
    })), BG = mn("@dexscreener/feature-analytics//analyticsProviders")(),
    g_e = pt("@dexscreener/feature-analytics/analyticsServiceLogger", () => {
    }), XE = pt("@dexscreener/feature-analytics/AnalyticsService", g_e, BG, (t, e) => {
        const r = t ? t2e(t, "analytics-service") : void 0;
        return {
            track: async (n, i) => {
                r == null || r.debug(n);
                const a = [];
                if (i) for (const o of i) {
                    const s = e.find(l => l.id === o);
                    s && a.push(s.track(n))
                } else for (const o of e) a.push(o.track(n));
                await Promise.all(a)
            }
        }
    }), gpt = _.object({
        id: _.string(),
        name: _.string(),
        slug: _.string(),
        orderRank: _.number(),
        createdAt: _.coerce.date(),
        updatedAt: _.coerce.date()
    }), ypt = _.object({
        id: _.string(),
        name: _.string(),
        url: _.string().url(),
        image: _.string().url(),
        scrapeUrls: Cn(_.string().url()),
        feedUrls: Cn(_.string().url()),
        enabled: _.boolean(),
        createdAt: _.coerce.date(),
        updatedAt: _.coerce.date()
    }), y_e = _.enum(["system", "publisher"]), b_e = _.enum(["scrape", "process"]), cZ = _.object({
        id: _.string(),
        publisherId: _.string(),
        url: _.string().url(),
        createdAt: _.coerce.date(),
        updatedAt: _.coerce.date(),
        state: _.literal("crawled"),
        attemptType: b_e.optional(),
        attemptNumber: _.number().optional(),
        lastAttemptError: _.string().optional()
    }), w_e = cZ.extend({
        title: _.string(),
        content: _.string(),
        image: _.string().url(),
        publishedAt: _.coerce.date(),
        state: _.literal("scraped")
    }), S_e = w_e.extend({summary: Cn(_.string()), categoryIds: Cn(_.string()), state: _.literal("ready")}),
    bpt = cZ.extend({rejectionSource: y_e, rejectionReason: _.string(), state: _.literal("rejected")}),
    wpt = _.discriminatedUnion("state", [cZ, w_e, S_e, bpt]);
Array.from(wpt.optionsMap.keys()), b_e.options, y_e.options;
var Gz = {};
const __e = $P(THe);
var Sv = {};
Object.defineProperty(Sv, "__esModule", {value: !0});
Sv.isSignatureError = Sv.WebhookSignatureFormatError = Sv.WebhookSignatureValueError = void 0;

class Spt extends Error {
    constructor() {
        super(...arguments), this.type = "WebhookSignatureValueError", this.statusCode = 401
    }
}

Sv.WebhookSignatureValueError = Spt;

class _pt extends Error {
    constructor() {
        super(...arguments), this.type = "WebhookSignatureFormatError", this.statusCode = 400
    }
}

Sv.WebhookSignatureFormatError = _pt;

function xpt(t) {
    return typeof t == "object" && t !== null && "type" in t && ["WebhookSignatureValueError", "WebhookSignatureFormatError"].includes(t.type)
}

Sv.isSignatureError = xpt;
var lZ = {}, x_e = {exports: {}}, uZ = {}, fZ = {};
Object.defineProperty(fZ, "__esModule", {value: !0});

function Ept(t) {
    var e = 4, r = t.length, n = r % e;
    if (!n) return t;
    var i = r, a = e - n, o = r + a, s = kr.alloc(o);
    for (s.write(t); a--;) s.write("=", i++);
    return s.toString()
}

fZ.default = Ept;
Object.defineProperty(uZ, "__esModule", {value: !0});
var Tpt = fZ;

function E_e(t, e) {
    return e === void 0 && (e = "utf8"), kr.isBuffer(t) ? $G(t.toString("base64")) : $G(kr.from(t, e).toString("base64"))
}

function Cpt(t, e) {
    return e === void 0 && (e = "utf8"), kr.from(dZ(t), "base64").toString(e)
}

function dZ(t) {
    return t = t.toString(), Tpt.default(t).replace(/\-/g, "+").replace(/_/g, "/")
}

function $G(t) {
    return t.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
}

function Apt(t) {
    return kr.from(dZ(t), "base64")
}

var QE = E_e;
QE.encode = E_e;
QE.decode = Cpt;
QE.toBase64 = dZ;
QE.fromBase64 = $G;
QE.toBuffer = Apt;
uZ.default = QE;
(function (t) {
    t.exports = uZ.default, t.exports.default = t.exports
})(x_e);
var Ipt = x_e.exports;
(function (t) {
    Object.defineProperty(t, "__esModule", {value: !0}), t.decodeSignatureHeader = t.encodeSignatureHeader = t.isValidRequest = t.assertValidRequest = t.isValidSignature = t.assertValidSignature = t.SIGNATURE_HEADER_NAME = void 0;
    const e = __e, r = (0, e.__importDefault)(LQ()), n = (0, e.__importDefault)(Ipt), i = Sv, a = 16094592e5,
        o = /^t=(\d+)[, ]+v1=([^, ]+)$/;
    t.SIGNATURE_HEADER_NAME = "sanity-webhook-signature";

    function s(S, T, I) {
        const {timestamp: N} = g(T), P = p(S, N, I);
        if (T !== P) throw new i.WebhookSignatureValueError("Signature is invalid")
    }

    t.assertValidSignature = s;

    function l(S, T, I) {
        try {
            return s(S, T, I), !0
        } catch {
            return !1
        }
    }

    t.isValidSignature = l;

    function f(S, T) {
        const I = S.headers[t.SIGNATURE_HEADER_NAME];
        if (Array.isArray(I)) throw new i.WebhookSignatureFormatError("Multiple signature headers received");
        if (typeof I != "string") throw new i.WebhookSignatureValueError("Request contained no signature header");
        if (typeof S.body > "u") throw new i.WebhookSignatureFormatError("Request contained no parsed request body");
        if (typeof S.body == "string" || kr.isBuffer(S.body)) s(S.body.toString("utf8"), I, T); else throw new Error("[@sanity/webhook] `request.body` was not a string/buffer - this can lead to invalid signatures. See the [migration docs](https://github.com/sanity-io/webhook-toolkit#from-parsed-to-unparsed-body) for details on how to fix this.")
    }

    t.assertValidRequest = f;

    function d(S, T) {
        try {
            return f(S, T), !0
        } catch {
            return !1
        }
    }

    t.isValidRequest = d;

    function p(S, T, I) {
        const N = b(S, T, I);
        return `t=${T},v1=${N}`
    }

    t.encodeSignatureHeader = p;

    function g(S) {
        if (!S) throw new i.WebhookSignatureFormatError("Missing or empty signature header");
        const [, T, I] = S.trim().match(o) || [];
        if (!T || !I) throw new i.WebhookSignatureFormatError("Invalid signature payload format");
        return {timestamp: parseInt(T, 10), hashedPayload: I}
    }

    t.decodeSignatureHeader = g;

    function b(S, T, I) {
        if (!I || typeof I != "string") throw new i.WebhookSignatureFormatError("Invalid secret provided");
        if (!S) throw new i.WebhookSignatureFormatError("Can not create signature for empty payload");
        if (typeof S != "string") throw new i.WebhookSignatureFormatError("Payload must be a JSON-encoded string");
        if (typeof T != "number" || isNaN(T) || T < a) throw new i.WebhookSignatureFormatError("Invalid signature timestamp, must be a unix timestamp with millisecond precision");
        const N = r.default.createHmac("sha256", I), P = `${T}.${S}`, F = N.update(P, "utf8").digest();
        return (0, n.default)(F)
    }
})(lZ);
var Q5 = {}, pue;

function kpt() {
    if (pue) return Q5;
    pue = 1, Object.defineProperty(Q5, "__esModule", {value: !0}), Q5.requireSignedRequest = void 0;
    const t = T_e(), e = lZ;

    function r(n) {
        const i = typeof n.parseBody > "u" ? !0 : n.parseBody,
            a = typeof n.respondOnError > "u" ? !0 : n.respondOnError;
        return function (s, l, f) {
            try {
                (0, e.assertValidRequest)(s, n.secret), i && typeof s.body == "string" && (s.body = JSON.parse(s.body)), f()
            } catch (d) {
                if (!a || !(0, t.isSignatureError)(d)) {
                    f(d);
                    return
                }
                l.status(d.statusCode).json({message: d.message})
            }
        }
    }

    return Q5.requireSignedRequest = r, Q5
}

var mue;

function T_e() {
    return mue || (mue = 1, function (t) {
        Object.defineProperty(t, "__esModule", {value: !0});
        const e = __e;
        (0, e.__exportStar)(Sv, t), (0, e.__exportStar)(lZ, t), (0, e.__exportStar)(kpt(), t)
    }(Gz)), Gz
}

T_e();
const Rpt = gpt.pick({id: !0, name: !0, slug: !0, orderRank: !0}),
    Dpt = Gr({id: kt(), name: kt(), slug: kt(), orderRank: Xt()}), Mpt = Cn(Rpt), Opt = Ci(Dpt),
    Ppt = ypt.pick({id: !0, name: !0, url: !0, image: !0}), Npt = Gr({id: kt(), name: kt(), url: kt(), image: kt()}),
    Lpt = Cn(Ppt), Bpt = Ci(Npt), $pt = S_e.pick({
        id: !0,
        publisherId: !0,
        url: !0,
        title: !0,
        publishedAt: !0,
        summary: !0,
        categoryIds: !0,
        image: !0
    }), Fpt = Gr({
        id: kt(),
        publisherId: kt(),
        url: kt(),
        title: kt(),
        publishedAt: Ns(),
        summary: Ci(kt()),
        categoryIds: Ci(kt()),
        image: kt()
    }), Upt = Cn($pt), jpt = Ci(Fpt), C_e = mn("@dexscreener/feature-news/newsServerHost")(),
    HJt = pt(C_e, Tp, fze, (t, e, r) => ({
        getStories: tf(async ({lastPublishedAt: n, categoryId: i, publisherId: a, format: o}) => {
            const s = new URL(t);
            return s.pathname = "/news/stories", n && s.searchParams.append("lastPublishedAt", new Date(n).toISOString()), i && s.searchParams.append("categoryId", i), a && s.searchParams.append("publisherId", a), o && s.searchParams.append("format", o), (await iC({
                callback: () => o === "avro" ? e.avro(s.toString(), jpt, {credentials: "include"}) : e.get(s.toString(), Upt, {credentials: "include"}),
                timeoutInMs: 15e3,
                newTimeoutError: d => new r4({timeoutInMs: d, url: s.toString()})
            })).map(d => {
                const {publishedAt: p, image: g, ...b} = d, S = r.buildUrl({src: g});
                return {...b, publishedAt: new Date(p).getTime(), image: S}
            })
        }), getPublishers: tf(async ({format: n}) => {
            const i = new URL(t);
            return i.pathname = "/news/publishers", n && i.searchParams.append("format", n), (await iC({
                callback: () => n === "avro" ? e.avro(i.toString(), Bpt, {credentials: "include"}) : e.get(i.toString(), Lpt, {credentials: "include"}),
                timeoutInMs: 15e3,
                newTimeoutError: o => new r4({timeoutInMs: o, url: i.toString()})
            })).map(o => ({...o, image: r.buildUrl({src: o.image})}))
        }), getCategories: tf(async ({format: n}) => {
            const i = new URL(t);
            return i.pathname = "/news/categories", n && i.searchParams.append("format", n), iC({
                callback: () => n === "avro" ? e.avro(i.toString(), Opt, {credentials: "include"}) : e.get(i.toString(), Mpt, {credentials: "include"}),
                timeoutInMs: 15e3,
                newTimeoutError: o => new r4({timeoutInMs: o, url: i.toString()})
            })
        })
    })), A_e = mn("@dexscreener/error-boundary-service")();
var W = Kv();
const ar = za(W), vue = jOe({__proto__: null, default: ar}, [W]), FG = W.createContext(void 0);

function aa(t, e) {
    const r = W.useContext(FG);
    if (r === void 0) throw new Error("useInjectable must be called within DependenciesProvider subtree");
    return W.useMemo(() => t(e === void 0 ? r : Object.assign(Object.assign({}, r), e)), [r, e, t])
}

const zpt = (t, e) => {
    if (e in t) return t[e];
    throw new Error(`Missing dependency: ${JSON.stringify(e)}`)
};

function I_e(t) {
    const e = W.useContext(FG),
        r = W.useMemo(() => Object.assign(Object.assign({[Cge]: zpt}, e), t.value), [e, t.value]);
    return W.createElement(FG.Provider, {value: r}, t.children)
}

function UG(t, e) {
    return UG = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, i) {
        return n.__proto__ = i, n
    }, UG(t, e)
}

function k_e(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, UG(t, e)
}

var Vpt = function (e, r) {
    return e === void 0 && (e = []), r === void 0 && (r = []), e.length !== r.length || e.some(function (n, i) {
        return !Object.is(n, r[i])
    })
}, gue = {error: null}, Hpt = function (t) {
    k_e(e, t);

    function e() {
        for (var n, i = arguments.length, a = new Array(i), o = 0; o < i; o++) a[o] = arguments[o];
        return n = t.call.apply(t, [this].concat(a)) || this, n.state = gue, n.resetErrorBoundary = function () {
            for (var s, l = arguments.length, f = new Array(l), d = 0; d < l; d++) f[d] = arguments[d];
            n.props.onReset == null || (s = n.props).onReset.apply(s, f), n.reset()
        }, n
    }

    e.getDerivedStateFromError = function (i) {
        return {error: i}
    };
    var r = e.prototype;
    return r.reset = function () {
        this.setState(gue)
    }, r.componentDidCatch = function (i, a) {
        var o, s;
        (o = (s = this.props).onError) == null || o.call(s, i, a)
    }, r.componentDidUpdate = function (i, a) {
        var o = this.state.error, s = this.props.resetKeys;
        if (o !== null && a.error !== null && Vpt(i.resetKeys, s)) {
            var l, f;
            (l = (f = this.props).onResetKeysChange) == null || l.call(f, i.resetKeys, s), this.reset()
        }
    }, r.render = function () {
        var i = this.state.error, a = this.props, o = a.fallbackRender, s = a.FallbackComponent, l = a.fallback;
        if (i !== null) {
            var f = {error: i, resetErrorBoundary: this.resetErrorBoundary};
            if (W.isValidElement(l)) return l;
            if (typeof o == "function") return o(f);
            if (s) return W.createElement(s, f);
            throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop")
        }
        return this.props.children
    }, e
}(W.Component);
const R_e = ({children: t, FallbackComponent: e, id: r, onError: n}) => {
    const i = aa(A_e), a = W.useCallback((o, s) => {
        i.log({id: r, error: o, info: s}), n == null || n(o, s)
    }, [i, r, n]);
    return ie.jsx(Hpt, {FallbackComponent: e, onError: a, children: t})
}, Wpt = (t, e) => {
    const r = i => ie.jsx(R_e, {...e, children: ie.jsx(t, {...i})}), n = t.displayName || t.name || "Unknown";
    return r.displayName = `withErrorBoundary(${n})`, r
}, D_e = "chakra-ui-color-mode", hZ = _.enum(["light", "dark"]);
var qpt = Ypt, Gpt = Xpt, Kpt = Object.prototype.toString, p7 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

function Ypt(t, e) {
    if (typeof t != "string") throw new TypeError("argument str must be a string");
    for (var r = {}, n = e || {}, i = n.decode || Qpt, a = 0; a < t.length;) {
        var o = t.indexOf("=", a);
        if (o === -1) break;
        var s = t.indexOf(";", a);
        if (s === -1) s = t.length; else if (s < o) {
            a = t.lastIndexOf(";", o - 1) + 1;
            continue
        }
        var l = t.slice(a, o).trim();
        if (r[l] === void 0) {
            var f = t.slice(o + 1, s).trim();
            f.charCodeAt(0) === 34 && (f = f.slice(1, -1)), r[l] = e0t(f, i)
        }
        a = s + 1
    }
    return r
}

function Xpt(t, e, r) {
    var n = r || {}, i = n.encode || Zpt;
    if (typeof i != "function") throw new TypeError("option encode is invalid");
    if (!p7.test(t)) throw new TypeError("argument name is invalid");
    var a = i(e);
    if (a && !p7.test(a)) throw new TypeError("argument val is invalid");
    var o = t + "=" + a;
    if (n.maxAge != null) {
        var s = n.maxAge - 0;
        if (isNaN(s) || !isFinite(s)) throw new TypeError("option maxAge is invalid");
        o += "; Max-Age=" + Math.floor(s)
    }
    if (n.domain) {
        if (!p7.test(n.domain)) throw new TypeError("option domain is invalid");
        o += "; Domain=" + n.domain
    }
    if (n.path) {
        if (!p7.test(n.path)) throw new TypeError("option path is invalid");
        o += "; Path=" + n.path
    }
    if (n.expires) {
        var l = n.expires;
        if (!Jpt(l) || isNaN(l.valueOf())) throw new TypeError("option expires is invalid");
        o += "; Expires=" + l.toUTCString()
    }
    if (n.httpOnly && (o += "; HttpOnly"), n.secure && (o += "; Secure"), n.partitioned && (o += "; Partitioned"), n.priority) {
        var f = typeof n.priority == "string" ? n.priority.toLowerCase() : n.priority;
        switch (f) {
            case"low":
                o += "; Priority=Low";
                break;
            case"medium":
                o += "; Priority=Medium";
                break;
            case"high":
                o += "; Priority=High";
                break;
            default:
                throw new TypeError("option priority is invalid")
        }
    }
    if (n.sameSite) {
        var d = typeof n.sameSite == "string" ? n.sameSite.toLowerCase() : n.sameSite;
        switch (d) {
            case!0:
                o += "; SameSite=Strict";
                break;
            case"lax":
                o += "; SameSite=Lax";
                break;
            case"strict":
                o += "; SameSite=Strict";
                break;
            case"none":
                o += "; SameSite=None";
                break;
            default:
                throw new TypeError("option sameSite is invalid")
        }
    }
    return o
}

function Qpt(t) {
    return t.indexOf("%") !== -1 ? decodeURIComponent(t) : t
}

function Zpt(t) {
    return encodeURIComponent(t)
}

function Jpt(t) {
    return Kpt.call(t) === "[object Date]" || t instanceof Date
}

function e0t(t, e) {
    try {
        return e(t)
    } catch {
        return t
    }
}

const t0t = (t, e = D_e) => {
        try {
            return t ? hZ.parse(qpt(t)[e]) : void 0
        } catch {
            return
        }
    }, r0t = {
        "1S": "1 second",
        "15S": "15 seconds",
        "30S": "30 seconds",
        1: "1 minute",
        3: "3 minutes",
        5: "5 minutes",
        15: "15 minutes",
        30: "30 minutes",
        60: "1 hour",
        120: "2 hours",
        240: "4 hours",
        480: "8 hours",
        720: "12 hours",
        "1D": "1 day",
        "3D": "3 days",
        "1W": "1 week",
        "1M": "1 month"
    }, M_e = r0t, z8 = Object.fromEntries(Object.entries(M_e).map(([t]) => [t, t])), yue = VP(M_e),
    O_e = _.enum([yue[0] ?? "1S", ...yue.slice(1)]),
    P_e = {bar: 0, candle: 1, line: 2, area: 3, heikinashi: 8, hollowcandle: 9, baseline: 10}, N_e = _.nativeEnum(P_e),
    n0t = t => {
        if (typeof t != "string") return t;
        const e = VP(P_e).find(r => r === t);
        return e ? N_e.enum[e] : Number.parseInt(t)
    }, i0t = _.preprocess(n0t, _.custom(t => N_e.safeParse(t).success)), a0t = t => {
        const e = t ?? Date.now(), r = Math.min(e, Date.now());
        return ZVe(r, {roundingMethod: "floor"}).getTime()
    }, L_e = mn("@dexscreener/feature-screenshots/screenshotHost")(), V8 = pt(L_e, t => ({
        buildChartScreenshotUrl(e) {
            const r = new URL(t);
            return r.pathname = `/screenshot/chart/${e.chainId}/${e.pairId}.png`, r.searchParams.set("width", e.width.toString()), r.searchParams.set("height", e.height.toString()), e.interval && r.searchParams.set("interval", e.interval.toString()), e.theme && r.searchParams.set("theme", e.theme), r.searchParams.set("timestamp", a0t(e.timestamp).toString()), r
        }
    }));

class pZ extends Error {
    constructor(r) {
        super(r.message);
        Ft(this, "baseError");
        this.name = "WalletTransactionRejectedByUserError", this.baseError = r.baseError, Object.setPrototypeOf(this, pZ.prototype)
    }
}

class mZ extends Error {
    constructor(r) {
        super(r.message);
        Ft(this, "baseError");
        this.name = "WalletSignatureRejectedByUserError", this.baseError = r.baseError, Object.setPrototypeOf(this, mZ.prototype)
    }
}

var Kz = {exports: {}}, bue;

function vZ() {
    return bue || (bue = 1, function (t) {
        var e = Object.prototype.hasOwnProperty, r = "~";

        function n() {
        }

        Object.create && (n.prototype = Object.create(null), new n().__proto__ || (r = !1));

        function i(l, f, d) {
            this.fn = l, this.context = f, this.once = d || !1
        }

        function a(l, f, d, p, g) {
            if (typeof d != "function") throw new TypeError("The listener must be a function");
            var b = new i(d, p || l, g), S = r ? r + f : f;
            return l._events[S] ? l._events[S].fn ? l._events[S] = [l._events[S], b] : l._events[S].push(b) : (l._events[S] = b, l._eventsCount++), l
        }

        function o(l, f) {
            --l._eventsCount === 0 ? l._events = new n : delete l._events[f]
        }

        function s() {
            this._events = new n, this._eventsCount = 0
        }

        s.prototype.eventNames = function () {
            var f = [], d, p;
            if (this._eventsCount === 0) return f;
            for (p in d = this._events) e.call(d, p) && f.push(r ? p.slice(1) : p);
            return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(d)) : f
        }, s.prototype.listeners = function (f) {
            var d = r ? r + f : f, p = this._events[d];
            if (!p) return [];
            if (p.fn) return [p.fn];
            for (var g = 0, b = p.length, S = new Array(b); g < b; g++) S[g] = p[g].fn;
            return S
        }, s.prototype.listenerCount = function (f) {
            var d = r ? r + f : f, p = this._events[d];
            return p ? p.fn ? 1 : p.length : 0
        }, s.prototype.emit = function (f, d, p, g, b, S) {
            var T = r ? r + f : f;
            if (!this._events[T]) return !1;
            var I = this._events[T], N = arguments.length, P, F;
            if (I.fn) {
                switch (I.once && this.removeListener(f, I.fn, void 0, !0), N) {
                    case 1:
                        return I.fn.call(I.context), !0;
                    case 2:
                        return I.fn.call(I.context, d), !0;
                    case 3:
                        return I.fn.call(I.context, d, p), !0;
                    case 4:
                        return I.fn.call(I.context, d, p, g), !0;
                    case 5:
                        return I.fn.call(I.context, d, p, g, b), !0;
                    case 6:
                        return I.fn.call(I.context, d, p, g, b, S), !0
                }
                for (F = 1, P = new Array(N - 1); F < N; F++) P[F - 1] = arguments[F];
                I.fn.apply(I.context, P)
            } else {
                var V = I.length, Y;
                for (F = 0; F < V; F++) switch (I[F].once && this.removeListener(f, I[F].fn, void 0, !0), N) {
                    case 1:
                        I[F].fn.call(I[F].context);
                        break;
                    case 2:
                        I[F].fn.call(I[F].context, d);
                        break;
                    case 3:
                        I[F].fn.call(I[F].context, d, p);
                        break;
                    case 4:
                        I[F].fn.call(I[F].context, d, p, g);
                        break;
                    default:
                        if (!P) for (Y = 1, P = new Array(N - 1); Y < N; Y++) P[Y - 1] = arguments[Y];
                        I[F].fn.apply(I[F].context, P)
                }
            }
            return !0
        }, s.prototype.on = function (f, d, p) {
            return a(this, f, d, p, !1)
        }, s.prototype.once = function (f, d, p) {
            return a(this, f, d, p, !0)
        }, s.prototype.removeListener = function (f, d, p, g) {
            var b = r ? r + f : f;
            if (!this._events[b]) return this;
            if (!d) return o(this, b), this;
            var S = this._events[b];
            if (S.fn) S.fn === d && (!g || S.once) && (!p || S.context === p) && o(this, b); else {
                for (var T = 0, I = [], N = S.length; T < N; T++) (S[T].fn !== d || g && !S[T].once || p && S[T].context !== p) && I.push(S[T]);
                I.length ? this._events[b] = I.length === 1 ? I[0] : I : o(this, b)
            }
            return this
        }, s.prototype.removeAllListeners = function (f) {
            var d;
            return f ? (d = r ? r + f : f, this._events[d] && o(this, d)) : (this._events = new n, this._eventsCount = 0), this
        }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = r, s.EventEmitter = s, t.exports = s
    }(Kz)), Kz.exports
}

var o0t = vZ();
const s0t = za(o0t);

class _u extends Error {
    constructor(e, r) {
        super(e), this.error = r
    }
}

class i4 extends _u {
    constructor() {
        super(...arguments), this.name = "WalletNotReadyError"
    }
}

class AT extends _u {
    constructor() {
        super(...arguments), this.name = "WalletConfigError"
    }
}

class IT extends _u {
    constructor() {
        super(...arguments), this.name = "WalletConnectionError"
    }
}

class B_e extends _u {
    constructor() {
        super(...arguments), this.name = "WalletDisconnectedError"
    }
}

class c0t extends _u {
    constructor() {
        super(...arguments), this.name = "WalletDisconnectionError"
    }
}

class Ix extends _u {
    constructor() {
        super(...arguments), this.name = "WalletAccountError"
    }
}

class $_e extends _u {
    constructor() {
        super(...arguments), this.name = "WalletPublicKeyError"
    }
}

class T0 extends _u {
    constructor() {
        super(...arguments), this.name = "WalletNotConnectedError"
    }
}

class Ew extends _u {
    constructor() {
        super(...arguments), this.name = "WalletSendTransactionError"
    }
}

class Ay extends _u {
    constructor() {
        super(...arguments), this.name = "WalletSignTransactionError"
    }
}

class gZ extends _u {
    constructor() {
        super(...arguments), this.name = "WalletSignMessageError"
    }
}

class wue extends _u {
    constructor() {
        super(...arguments), this.name = "WalletSignInError"
    }
}

var la;
(function (t) {
    t.Installed = "Installed", t.NotDetected = "NotDetected", t.Loadable = "Loadable", t.Unsupported = "Unsupported"
})(la || (la = {}));

class F_e extends s0t {
    get connected() {
        return !!this.publicKey
    }

    async autoConnect() {
        await this.connect()
    }

    async prepareTransaction(e, r, n = {}) {
        const i = this.publicKey;
        if (!i) throw new T0;
        return e.feePayer = e.feePayer || i, e.recentBlockhash = e.recentBlockhash || (await r.getLatestBlockhash({
            commitment: n.preflightCommitment,
            minContextSlot: n.minContextSlot
        })).blockhash, e
    }
}

function Tw(t) {
    return "version" in t
}

class l0t extends F_e {
    async sendTransaction(e, r, n = {}) {
        let i = !0;
        try {
            if (Tw(e)) {
                if (!this.supportedTransactionVersions) throw new Ew("Sending versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(e.version)) throw new Ew(`Sending transaction version ${e.version} isn't supported by this wallet`);
                try {
                    e = await this.signTransaction(e);
                    const a = e.serialize();
                    return await r.sendRawTransaction(a, n)
                } catch (a) {
                    throw a instanceof Ay ? (i = !1, a) : new Ew(a == null ? void 0 : a.message, a)
                }
            } else try {
                const {signers: a, ...o} = n;
                e = await this.prepareTransaction(e, r, o), a != null && a.length && e.partialSign(...a), e = await this.signTransaction(e);
                const s = e.serialize();
                return await r.sendRawTransaction(s, o)
            } catch (a) {
                throw a instanceof Ay ? (i = !1, a) : new Ew(a == null ? void 0 : a.message, a)
            }
        } catch (a) {
            throw i && this.emit("error", a), a
        }
    }

    async signAllTransactions(e) {
        for (const n of e) if (Tw(n)) {
            if (!this.supportedTransactionVersions) throw new Ay("Signing versioned transactions isn't supported by this wallet");
            if (!this.supportedTransactionVersions.has(n.version)) throw new Ay(`Signing transaction version ${n.version} isn't supported by this wallet`)
        }
        const r = [];
        for (const n of e) r.push(await this.signTransaction(n));
        return r
    }
}

class u0t extends l0t {
}

class f0t extends u0t {
}

const Sy = "solana:signAndSendTransaction", Yz = "solana:signIn", Z5 = "solana:signMessage",
    Pc = "solana:signTransaction", U_e = "standard:connect", Sue = "standard:disconnect", j_e = "standard:events";

function d0t(t) {
    return U_e in t.features && j_e in t.features && (Sy in t.features || Pc in t.features)
}

var oC;
(function (t) {
    t.Mainnet = "mainnet-beta", t.Testnet = "testnet", t.Devnet = "devnet"
})(oC || (oC = {}));
const h0t = t => {
    switch (t) {
        case"devnet":
            return oC.Devnet;
        case"mainnet-beta":
            return oC.Mainnet;
        case"testnet":
            return oC.Testnet
    }
}, p0t = t => t.connecting ? "connecting" : t.connected ? "connected" : "disconnected", m0t = t => {
    switch (t) {
        case la.Installed:
            return "installed";
        case la.NotDetected:
            return "notdetected";
        case la.Loadable:
            return "loadable";
        case la.Unsupported:
            return "unsupported"
    }
}, z_e = (t, e) => {
    const [r, n] = W.useState(() => e);
    return W.useEffect(() => {
        const i = t.subscribe(a => n(() => a));
        return () => i.unsubscribe()
    }, [t]), r
};

function ss(t) {
    const e = W.useRef(t);
    return e.current = t, e
}

const yZ = (t, e) => {
    W.useEffect(() => {
        var n;
        const r = (n = t()) == null ? void 0 : n.subscribe();
        return () => r == null ? void 0 : r.unsubscribe()
    }, e)
};

function v0t(t, e) {
    const [r, n] = W.useMemo(() => {
        const [i, a] = pqe();
        return [i, t(a)]
    }, e);
    return yZ(() => n, [n]), r
}

const g0t = t => {
    switch (t.kind) {
        case"AsyncSuccess":
        case"AsyncPendingWithData":
        case"AsyncFailureWithData":
            return {kind: "AsyncPendingWithData", value: t.value};
        case"AsyncPending":
        case"AsyncFailure":
            return XT
    }
}, y0t = (t, e) => {
    const r = $f(e);
    switch (t.kind) {
        case"AsyncPending":
        case"AsyncFailure":
            return {kind: "AsyncFailure", error: r};
        case"AsyncSuccess":
        case"AsyncFailureWithData":
        case"AsyncPendingWithData":
            return {kind: "AsyncFailureWithData", error: r, value: t.value}
    }
}, ZE = (t, e, r = XT) => {
    const [n, i] = W.useState(() => r);
    return W.useEffect(() => {
        i(g0t);
        const a = t().subscribe({
            next: o => i({kind: "AsyncSuccess", value: o}), error: o => {
                i(s => y0t(s, o))
            }
        });
        return () => a.unsubscribe()
    }, e), n
}, V_e = t => {
    const [e, r] = W.useState(t), n = W.useCallback(() => r(!0), []), i = W.useCallback(() => r(!1), []),
        a = W.useCallback(() => r(o => !o), []);
    return {value: e, enable: n, disable: i, toggle: a}
};
var jG = {exports: {}}, Xz = {};
var _ue;

function b0t() {
    return _ue || (_ue = 1, function (t) {
        function e(j, $) {
            var C = j.length;
            j.push($);
            e:for (; 0 < C;) {
                var R = C - 1 >>> 1, k = j[R];
                if (0 < i(k, $)) j[R] = $, j[C] = k, C = R; else break e
            }
        }

        function r(j) {
            return j.length === 0 ? null : j[0]
        }

        function n(j) {
            if (j.length === 0) return null;
            var $ = j[0], C = j.pop();
            if (C !== $) {
                j[0] = C;
                e:for (var R = 0, k = j.length, Q = k >>> 1; R < Q;) {
                    var fe = 2 * (R + 1) - 1, ye = j[fe], ue = fe + 1, me = j[ue];
                    if (0 > i(ye, C)) ue < k && 0 > i(me, ye) ? (j[R] = me, j[ue] = C, R = ue) : (j[R] = ye, j[fe] = C, R = fe); else if (ue < k && 0 > i(me, C)) j[R] = me, j[ue] = C, R = ue; else break e
                }
            }
            return $
        }

        function i(j, $) {
            var C = j.sortIndex - $.sortIndex;
            return C !== 0 ? C : j.id - $.id
        }

        if (typeof performance == "object" && typeof performance.now == "function") {
            var a = performance;
            t.unstable_now = function () {
                return a.now()
            }
        } else {
            var o = Date, s = o.now();
            t.unstable_now = function () {
                return o.now() - s
            }
        }
        var l = [], f = [], d = 1, p = null, g = 3, b = !1, S = !1, T = !1,
            I = typeof setTimeout == "function" ? setTimeout : null,
            N = typeof clearTimeout == "function" ? clearTimeout : null,
            P = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

        function F(j) {
            for (var $ = r(f); $ !== null;) {
                if ($.callback === null) n(f); else if ($.startTime <= j) n(f), $.sortIndex = $.expirationTime, e(l, $); else break;
                $ = r(f)
            }
        }

        function V(j) {
            if (T = !1, F(j), !S) if (r(l) !== null) S = !0, B(Y); else {
                var $ = r(f);
                $ !== null && z(V, $.startTime - j)
            }
        }

        function Y(j, $) {
            S = !1, T && (T = !1, N(G), G = -1), b = !0;
            var C = g;
            try {
                for (F($), p = r(l); p !== null && (!(p.expirationTime > $) || j && !re());) {
                    var R = p.callback;
                    if (typeof R == "function") {
                        p.callback = null, g = p.priorityLevel;
                        var k = R(p.expirationTime <= $);
                        $ = t.unstable_now(), typeof k == "function" ? p.callback = k : p === r(l) && n(l), F($)
                    } else n(l);
                    p = r(l)
                }
                if (p !== null) var Q = !0; else {
                    var fe = r(f);
                    fe !== null && z(V, fe.startTime - $), Q = !1
                }
                return Q
            } finally {
                p = null, g = C, b = !1
            }
        }

        var ee = !1, oe = null, G = -1, J = 5, ce = -1;

        function re() {
            return !(t.unstable_now() - ce < J)
        }

        function M() {
            if (oe !== null) {
                var j = t.unstable_now();
                ce = j;
                var $ = !0;
                try {
                    $ = oe(!0, j)
                } finally {
                    $ ? D() : (ee = !1, oe = null)
                }
            } else ee = !1
        }

        var D;
        if (typeof P == "function") D = function () {
            P(M)
        }; else if (typeof MessageChannel < "u") {
            var x = new MessageChannel, A = x.port2;
            x.port1.onmessage = M, D = function () {
                A.postMessage(null)
            }
        } else D = function () {
            I(M, 0)
        };

        function B(j) {
            oe = j, ee || (ee = !0, D())
        }

        function z(j, $) {
            G = I(function () {
                j(t.unstable_now())
            }, $)
        }

        t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (j) {
            j.callback = null
        }, t.unstable_continueExecution = function () {
            S || b || (S = !0, B(Y))
        }, t.unstable_forceFrameRate = function (j) {
            0 > j || 125 < j ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < j ? Math.floor(1e3 / j) : 5
        }, t.unstable_getCurrentPriorityLevel = function () {
            return g
        }, t.unstable_getFirstCallbackNode = function () {
            return r(l)
        }, t.unstable_next = function (j) {
            switch (g) {
                case 1:
                case 2:
                case 3:
                    var $ = 3;
                    break;
                default:
                    $ = g
            }
            var C = g;
            g = $;
            try {
                return j()
            } finally {
                g = C
            }
        }, t.unstable_pauseExecution = function () {
        }, t.unstable_requestPaint = function () {
        }, t.unstable_runWithPriority = function (j, $) {
            switch (j) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    j = 3
            }
            var C = g;
            g = j;
            try {
                return $()
            } finally {
                g = C
            }
        }, t.unstable_scheduleCallback = function (j, $, C) {
            var R = t.unstable_now();
            switch (typeof C == "object" && C !== null ? (C = C.delay, C = typeof C == "number" && 0 < C ? R + C : R) : C = R, j) {
                case 1:
                    var k = -1;
                    break;
                case 2:
                    k = 250;
                    break;
                case 5:
                    k = 1073741823;
                    break;
                case 4:
                    k = 1e4;
                    break;
                default:
                    k = 5e3
            }
            return k = C + k, j = {
                id: d++,
                callback: $,
                priorityLevel: j,
                startTime: C,
                expirationTime: k,
                sortIndex: -1
            }, C > R ? (j.sortIndex = C, e(f, j), r(l) === null && j === r(f) && (T ? (N(G), G = -1) : T = !0, z(V, C - R))) : (j.sortIndex = k, e(l, j), S || b || (S = !0, B(Y))), j
        }, t.unstable_shouldYield = re, t.unstable_wrapCallback = function (j) {
            var $ = g;
            return function () {
                var C = g;
                g = $;
                try {
                    return j.apply(this, arguments)
                } finally {
                    g = C
                }
            }
        }
    }(Xz)), Xz
}

var Qz = {}, xue;

function w0t() {
    return xue || (xue = 1, function (t) {
        Ve.env.NODE_ENV !== "production" && function () {
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
            var e = !1, r = 5;

            function n(X, H) {
                var U = X.length;
                X.push(H), o(X, H, U)
            }

            function i(X) {
                return X.length === 0 ? null : X[0]
            }

            function a(X) {
                if (X.length === 0) return null;
                var H = X[0], U = X.pop();
                return U !== H && (X[0] = U, s(X, U, 0)), H
            }

            function o(X, H, U) {
                for (var q = U; q > 0;) {
                    var le = q - 1 >>> 1, xe = X[le];
                    if (l(xe, H) > 0) X[le] = H, X[q] = xe, q = le; else return
                }
            }

            function s(X, H, U) {
                for (var q = U, le = X.length, xe = le >>> 1; q < xe;) {
                    var Ae = (q + 1) * 2 - 1, De = X[Ae], Ze = Ae + 1, ft = X[Ze];
                    if (l(De, H) < 0) Ze < le && l(ft, De) < 0 ? (X[q] = ft, X[Ze] = H, q = Ze) : (X[q] = De, X[Ae] = H, q = Ae); else if (Ze < le && l(ft, H) < 0) X[q] = ft, X[Ze] = H, q = Ze; else return
                }
            }

            function l(X, H) {
                var U = X.sortIndex - H.sortIndex;
                return U !== 0 ? U : X.id - H.id
            }

            var f = 1, d = 2, p = 3, g = 4, b = 5,
                S = typeof performance == "object" && typeof performance.now == "function";
            if (S) {
                var T = performance;
                t.unstable_now = function () {
                    return T.now()
                }
            } else {
                var I = Date, N = I.now();
                t.unstable_now = function () {
                    return I.now() - N
                }
            }
            var P = 1073741823, F = -1, V = 250, Y = 5e3, ee = 1e4, oe = P, G = [], J = [], ce = 1, re = null, M = p,
                D = !1, x = !1, A = !1, B = typeof setTimeout == "function" ? setTimeout : null,
                z = typeof clearTimeout == "function" ? clearTimeout : null,
                j = typeof setImmediate < "u" ? setImmediate : null;
            typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

            function $(X) {
                for (var H = i(J); H !== null;) {
                    if (H.callback === null) a(J); else if (H.startTime <= X) a(J), H.sortIndex = H.expirationTime, n(G, H); else return;
                    H = i(J)
                }
            }

            function C(X) {
                if (A = !1, $(X), !x) if (i(G) !== null) x = !0, _t(R); else {
                    var H = i(J);
                    H !== null && Dt(C, H.startTime - X)
                }
            }

            function R(X, H) {
                x = !1, A && (A = !1, rr()), D = !0;
                var U = M;
                try {
                    return k(X, H)
                } finally {
                    re = null, M = U, D = !1
                }
            }

            function k(X, H) {
                var U = H;
                for ($(U), re = i(G); re !== null && !e && !(re.expirationTime > U && (!X || Be()));) {
                    var q = re.callback;
                    if (typeof q == "function") {
                        re.callback = null, M = re.priorityLevel;
                        var le = re.expirationTime <= U, xe = q(le);
                        U = t.unstable_now(), typeof xe == "function" ? re.callback = xe : re === i(G) && a(G), $(U)
                    } else a(G);
                    re = i(G)
                }
                if (re !== null) return !0;
                var Ae = i(J);
                return Ae !== null && Dt(C, Ae.startTime - U), !1
            }

            function Q(X, H) {
                switch (X) {
                    case f:
                    case d:
                    case p:
                    case g:
                    case b:
                        break;
                    default:
                        X = p
                }
                var U = M;
                M = X;
                try {
                    return H()
                } finally {
                    M = U
                }
            }

            function fe(X) {
                var H;
                switch (M) {
                    case f:
                    case d:
                    case p:
                        H = p;
                        break;
                    default:
                        H = M;
                        break
                }
                var U = M;
                M = H;
                try {
                    return X()
                } finally {
                    M = U
                }
            }

            function ye(X) {
                var H = M;
                return function () {
                    var U = M;
                    M = H;
                    try {
                        return X.apply(this, arguments)
                    } finally {
                        M = U
                    }
                }
            }

            function ue(X, H, U) {
                var q = t.unstable_now(), le;
                if (typeof U == "object" && U !== null) {
                    var xe = U.delay;
                    typeof xe == "number" && xe > 0 ? le = q + xe : le = q
                } else le = q;
                var Ae;
                switch (X) {
                    case f:
                        Ae = F;
                        break;
                    case d:
                        Ae = V;
                        break;
                    case b:
                        Ae = oe;
                        break;
                    case g:
                        Ae = ee;
                        break;
                    case p:
                    default:
                        Ae = Y;
                        break
                }
                var De = le + Ae,
                    Ze = {id: ce++, callback: H, priorityLevel: X, startTime: le, expirationTime: De, sortIndex: -1};
                return le > q ? (Ze.sortIndex = le, n(J, Ze), i(G) === null && Ze === i(J) && (A ? rr() : A = !0, Dt(C, le - q))) : (Ze.sortIndex = De, n(G, Ze), !x && !D && (x = !0, _t(R))), Ze
            }

            function me() {
            }

            function Se() {
                !x && !D && (x = !0, _t(R))
            }

            function Ce() {
                return i(G)
            }

            function Me(X) {
                X.callback = null
            }

            function ve() {
                return M
            }

            var ne = !1, be = null, Ee = -1, Oe = r, ze = -1;

            function Be() {
                var X = t.unstable_now() - ze;
                return !(X < Oe)
            }

            function it() {
            }

            function Ue(X) {
                if (X < 0 || X > 125) {
                    console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                    return
                }
                X > 0 ? Oe = Math.floor(1e3 / X) : Oe = r
            }

            var bt = function () {
                if (be !== null) {
                    var X = t.unstable_now();
                    ze = X;
                    var H = !0, U = !0;
                    try {
                        U = be(H, X)
                    } finally {
                        U ? gt() : (ne = !1, be = null)
                    }
                } else ne = !1
            }, gt;
            if (typeof j == "function") gt = function () {
                j(bt)
            }; else if (typeof MessageChannel < "u") {
                var Ot = new MessageChannel, zt = Ot.port2;
                Ot.port1.onmessage = bt, gt = function () {
                    zt.postMessage(null)
                }
            } else gt = function () {
                B(bt, 0)
            };

            function _t(X) {
                be = X, ne || (ne = !0, gt())
            }

            function Dt(X, H) {
                Ee = B(function () {
                    X(t.unstable_now())
                }, H)
            }

            function rr() {
                z(Ee), Ee = -1
            }

            var pe = it, te = null;
            t.unstable_IdlePriority = b, t.unstable_ImmediatePriority = f, t.unstable_LowPriority = g, t.unstable_NormalPriority = p, t.unstable_Profiling = te, t.unstable_UserBlockingPriority = d, t.unstable_cancelCallback = Me, t.unstable_continueExecution = Se, t.unstable_forceFrameRate = Ue, t.unstable_getCurrentPriorityLevel = ve, t.unstable_getFirstCallbackNode = Ce, t.unstable_next = fe, t.unstable_pauseExecution = me, t.unstable_requestPaint = pe, t.unstable_runWithPriority = Q, t.unstable_scheduleCallback = ue, t.unstable_shouldYield = Be, t.unstable_wrapCallback = ye, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)
        }()
    }(Qz)), Qz
}

Ve.env.NODE_ENV === "production" ? jG.exports = b0t() : jG.exports = w0t();
var Zz = jG.exports;
const DD = Symbol(), S0t = Symbol(),
    H_e = typeof window > "u" || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent) ? W.useEffect : W.useLayoutEffect,
    _0t = Zz.unstable_runWithPriority ? t => Zz.unstable_runWithPriority(Zz.unstable_NormalPriority, t) : t => t();

function x0t(t) {
    const e = W.createContext({[DD]: {v: {current: t}, n: {current: -1}, l: new Set, u: n => n()}});
    var r;
    return e[S0t] = e.Provider, e.Provider = (r = e.Provider, ({value: n, children: i}) => {
        const a = W.useRef(n), o = W.useRef(0), [s, l] = W.useState(null);
        s && (s(n), l(null));
        const f = W.useRef();
        if (!f.current) {
            const d = new Set, p = (g, b) => {
                Jh.unstable_batchedUpdates(() => {
                    o.current += 1;
                    const S = {n: o.current};
                    b != null && b.suspense && (S.n *= -1, S.p = new Promise(T => {
                        l(() => I => {
                            S.v = I, delete S.p, T(I)
                        })
                    })), d.forEach(T => T(S)), g()
                })
            };
            f.current = {[DD]: {v: a, n: o, l: d, u: p}}
        }
        return H_e(() => {
            a.current = n, o.current += 1, _0t(() => {
                f.current[DD].l.forEach(d => {
                    d({n: o.current, v: n})
                })
            })
        }, [n]), W.createElement(r, {value: f.current}, i)
    }), delete e.Consumer, e
}

function E0t(t, e) {
    const r = W.useContext(t)[DD];
    if (typeof Ve == "object" && Ve.env.NODE_ENV !== "production" && !r) throw new Error("useContextSelector requires special context");
    const {v: {current: n}, n: {current: i}, l: a} = r, o = e(n), [s, l] = W.useReducer((f, d) => {
        if (!d) return [n, o];
        if ("p" in d) throw d.p;
        if (d.n === i) return Object.is(f[1], o) ? f : [n, o];
        try {
            if ("v" in d) {
                if (Object.is(f[0], d.v)) return f;
                const p = e(d.v);
                return Object.is(f[1], p) ? f : [d.v, p]
            }
        } catch {
        }
        return [...f]
    }, [n, o]);
    return Object.is(s[1], o) || l(), H_e(() => (a.add(l), () => {
        a.delete(l)
    }), [a]), s[1]
}

const vO = Symbol("None");

function T0t(t) {
    const e = W.createContext(vO), r = () => {
        const i = W.useContext(e);
        if (i === vO) throw new Error(`use${t} must be called within ${t}Provider subtree`);
        return i
    }, n = i => ie.jsx(e.Provider, {value: i.value, children: i.children});
    return n.displayName = `${t}Provider`, [r, n]
}

function LN(t) {
    const e = x0t(vO);

    function r(i) {
        return E0t(e, a => {
            if (a === vO) throw new Error(`use${t} must be called within ${t}Provider subtree`);
            return i(a)
        })
    }

    const n = i => ie.jsx(e.Provider, {value: i.value, children: i.children});
    return n.displayName = `${t}Provider`, [r, n]
}

function C0t(t) {
    return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array"
}

function A0t(t, ...e) {
    if (!C0t(t)) throw new Error("Expected Uint8Array");
    if (e.length > 0 && !e.includes(t.length)) throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)
}

function Eue(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called")
}

function I0t(t, e) {
    A0t(t);
    const r = e.outputLen;
    if (t.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`)
}

const MD = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0,
    WJt = Object.freeze(Object.defineProperty({__proto__: null, crypto: MD}, Symbol.toStringTag, {value: "Module"}));

function k0t(t) {
    return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array"
}

const Jz = t => new DataView(t.buffer, t.byteOffset, t.byteLength), u0 = (t, e) => t << 32 - e | t >>> e,
    R0t = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!R0t) throw new Error("Non little-endian hardware is not supported");

function D0t(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}

function W_e(t) {
    if (typeof t == "string" && (t = D0t(t)), !k0t(t)) throw new Error(`expected Uint8Array, got ${typeof t}`);
    return t
}

class M0t {
    clone() {
        return this._cloneInto()
    }
}

function q_e(t) {
    const e = n => t().update(W_e(n)).digest(), r = t();
    return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
}

function O0t(t = 32) {
    if (MD && typeof MD.getRandomValues == "function") return MD.getRandomValues(new Uint8Array(t));
    throw new Error("crypto.getRandomValues must be defined")
}

function P0t(t, e, r, n) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, n);
    const i = BigInt(32), a = BigInt(4294967295), o = Number(r >> i & a), s = Number(r & a), l = n ? 4 : 0,
        f = n ? 0 : 4;
    t.setUint32(e + l, o, n), t.setUint32(e + f, s, n)
}

class G_e extends M0t {
    constructor(e, r, n, i) {
        super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Jz(this.buffer)
    }

    update(e) {
        Eue(this);
        const {view: r, buffer: n, blockLen: i} = this;
        e = W_e(e);
        const a = e.length;
        for (let o = 0; o < a;) {
            const s = Math.min(i - this.pos, a - o);
            if (s === i) {
                const l = Jz(e);
                for (; i <= a - o; o += i) this.process(l, o);
                continue
            }
            n.set(e.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === i && (this.process(r, 0), this.pos = 0)
        }
        return this.length += e.length, this.roundClean(), this
    }

    digestInto(e) {
        Eue(this), I0t(e, this), this.finished = !0;
        const {buffer: r, view: n, blockLen: i, isLE: a} = this;
        let {pos: o} = this;
        r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);
        for (let p = o; p < i; p++) r[p] = 0;
        P0t(n, i - 8, BigInt(this.length * 8), a), this.process(n, 0);
        const s = Jz(e), l = this.outputLen;
        if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = l / 4, d = this.get();
        if (f > d.length) throw new Error("_sha2: outputLen bigger than state");
        for (let p = 0; p < f; p++) s.setUint32(4 * p, d[p], a)
    }

    digest() {
        const {buffer: e, outputLen: r} = this;
        this.digestInto(e);
        const n = e.slice(0, r);
        return this.destroy(), n
    }

    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const {blockLen: r, buffer: n, length: i, finished: a, destroyed: o, pos: s} = this;
        return e.length = i, e.pos = s, e.finished = a, e.destroyed = o, i % r && e.buffer.set(n), e
    }
}

const m7 = BigInt(2 ** 32 - 1), zG = BigInt(32);

function K_e(t, e = !1) {
    return e ? {h: Number(t & m7), l: Number(t >> zG & m7)} : {h: Number(t >> zG & m7) | 0, l: Number(t & m7) | 0}
}

function N0t(t, e = !1) {
    let r = new Uint32Array(t.length), n = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
        const {h: a, l: o} = K_e(t[i], e);
        [r[i], n[i]] = [a, o]
    }
    return [r, n]
}

const L0t = (t, e) => BigInt(t >>> 0) << zG | BigInt(e >>> 0), B0t = (t, e, r) => t >>> r,
    $0t = (t, e, r) => t << 32 - r | e >>> r, F0t = (t, e, r) => t >>> r | e << 32 - r,
    U0t = (t, e, r) => t << 32 - r | e >>> r, j0t = (t, e, r) => t << 64 - r | e >>> r - 32,
    z0t = (t, e, r) => t >>> r - 32 | e << 64 - r, V0t = (t, e) => e, H0t = (t, e) => t,
    W0t = (t, e, r) => t << r | e >>> 32 - r, q0t = (t, e, r) => e << r | t >>> 32 - r,
    G0t = (t, e, r) => e << r - 32 | t >>> 64 - r, K0t = (t, e, r) => t << r - 32 | e >>> 64 - r;

function Y0t(t, e, r, n) {
    const i = (e >>> 0) + (n >>> 0);
    return {h: t + r + (i / 2 ** 32 | 0) | 0, l: i | 0}
}

const X0t = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0), Q0t = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0,
    Z0t = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
    J0t = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0,
    emt = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
    tmt = (t, e, r, n, i, a) => e + r + n + i + a + (t / 2 ** 32 | 0) | 0, Un = {
        fromBig: K_e,
        split: N0t,
        toBig: L0t,
        shrSH: B0t,
        shrSL: $0t,
        rotrSH: F0t,
        rotrSL: U0t,
        rotrBH: j0t,
        rotrBL: z0t,
        rotr32H: V0t,
        rotr32L: H0t,
        rotlSH: W0t,
        rotlSL: q0t,
        rotlBH: G0t,
        rotlBL: K0t,
        add: Y0t,
        add3L: X0t,
        add3H: Q0t,
        add4L: Z0t,
        add4H: J0t,
        add5H: tmt,
        add5L: emt
    }, [rmt, nmt] = Un.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
    ry = new Uint32Array(80), ny = new Uint32Array(80);

class imt extends G_e {
    constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
    }

    get() {
        const {
            Ah: e,
            Al: r,
            Bh: n,
            Bl: i,
            Ch: a,
            Cl: o,
            Dh: s,
            Dl: l,
            Eh: f,
            El: d,
            Fh: p,
            Fl: g,
            Gh: b,
            Gl: S,
            Hh: T,
            Hl: I
        } = this;
        return [e, r, n, i, a, o, s, l, f, d, p, g, b, S, T, I]
    }

    set(e, r, n, i, a, o, s, l, f, d, p, g, b, S, T, I) {
        this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = a | 0, this.Cl = o | 0, this.Dh = s | 0, this.Dl = l | 0, this.Eh = f | 0, this.El = d | 0, this.Fh = p | 0, this.Fl = g | 0, this.Gh = b | 0, this.Gl = S | 0, this.Hh = T | 0, this.Hl = I | 0
    }

    process(e, r) {
        for (let F = 0; F < 16; F++, r += 4) ry[F] = e.getUint32(r), ny[F] = e.getUint32(r += 4);
        for (let F = 16; F < 80; F++) {
            const V = ry[F - 15] | 0, Y = ny[F - 15] | 0,
                ee = Un.rotrSH(V, Y, 1) ^ Un.rotrSH(V, Y, 8) ^ Un.shrSH(V, Y, 7),
                oe = Un.rotrSL(V, Y, 1) ^ Un.rotrSL(V, Y, 8) ^ Un.shrSL(V, Y, 7), G = ry[F - 2] | 0, J = ny[F - 2] | 0,
                ce = Un.rotrSH(G, J, 19) ^ Un.rotrBH(G, J, 61) ^ Un.shrSH(G, J, 6),
                re = Un.rotrSL(G, J, 19) ^ Un.rotrBL(G, J, 61) ^ Un.shrSL(G, J, 6),
                M = Un.add4L(oe, re, ny[F - 7], ny[F - 16]), D = Un.add4H(M, ee, ce, ry[F - 7], ry[F - 16]);
            ry[F] = D | 0, ny[F] = M | 0
        }
        let {
            Ah: n,
            Al: i,
            Bh: a,
            Bl: o,
            Ch: s,
            Cl: l,
            Dh: f,
            Dl: d,
            Eh: p,
            El: g,
            Fh: b,
            Fl: S,
            Gh: T,
            Gl: I,
            Hh: N,
            Hl: P
        } = this;
        for (let F = 0; F < 80; F++) {
            const V = Un.rotrSH(p, g, 14) ^ Un.rotrSH(p, g, 18) ^ Un.rotrBH(p, g, 41),
                Y = Un.rotrSL(p, g, 14) ^ Un.rotrSL(p, g, 18) ^ Un.rotrBL(p, g, 41), ee = p & b ^ ~p & T,
                oe = g & S ^ ~g & I, G = Un.add5L(P, Y, oe, nmt[F], ny[F]), J = Un.add5H(G, N, V, ee, rmt[F], ry[F]),
                ce = G | 0, re = Un.rotrSH(n, i, 28) ^ Un.rotrBH(n, i, 34) ^ Un.rotrBH(n, i, 39),
                M = Un.rotrSL(n, i, 28) ^ Un.rotrBL(n, i, 34) ^ Un.rotrBL(n, i, 39), D = n & a ^ n & s ^ a & s,
                x = i & o ^ i & l ^ o & l;
            N = T | 0, P = I | 0, T = b | 0, I = S | 0, b = p | 0, S = g | 0, {
                h: p,
                l: g
            } = Un.add(f | 0, d | 0, J | 0, ce | 0), f = s | 0, d = l | 0, s = a | 0, l = o | 0, a = n | 0, o = i | 0;
            const A = Un.add3L(ce, M, x);
            n = Un.add3H(A, J, re, D), i = A | 0
        }
        ({h: n, l: i} = Un.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), {
            h: a,
            l: o
        } = Un.add(this.Bh | 0, this.Bl | 0, a | 0, o | 0), {
            h: s,
            l
        } = Un.add(this.Ch | 0, this.Cl | 0, s | 0, l | 0), {
            h: f,
            l: d
        } = Un.add(this.Dh | 0, this.Dl | 0, f | 0, d | 0), {
            h: p,
            l: g
        } = Un.add(this.Eh | 0, this.El | 0, p | 0, g | 0), {
            h: b,
            l: S
        } = Un.add(this.Fh | 0, this.Fl | 0, b | 0, S | 0), {
            h: T,
            l: I
        } = Un.add(this.Gh | 0, this.Gl | 0, T | 0, I | 0), {
            h: N,
            l: P
        } = Un.add(this.Hh | 0, this.Hl | 0, N | 0, P | 0), this.set(n, i, a, o, s, l, f, d, p, g, b, S, T, I, N, P)
    }

    roundClean() {
        ry.fill(0), ny.fill(0)
    }

    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}

const amt = q_e(() => new imt);
BigInt(0);
const omt = BigInt(1), smt = BigInt(2);

function H8(t) {
    return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array"
}

const cmt = Array.from({length: 256}, (t, e) => e.toString(16).padStart(2, "0"));

function bZ(t) {
    if (!H8(t)) throw new Error("Uint8Array expected");
    let e = "";
    for (let r = 0; r < t.length; r++) e += cmt[t[r]];
    return e
}

function Y_e(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return BigInt(t === "" ? "0" : `0x${t}`)
}

const Jm = {_0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102};

function Tue(t) {
    if (t >= Jm._0 && t <= Jm._9) return t - Jm._0;
    if (t >= Jm._A && t <= Jm._F) return t - (Jm._A - 10);
    if (t >= Jm._a && t <= Jm._f) return t - (Jm._a - 10)
}

function X_e(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    const e = t.length, r = e / 2;
    if (e % 2) throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(r);
    for (let i = 0, a = 0; i < r; i++, a += 2) {
        const o = Tue(t.charCodeAt(a)), s = Tue(t.charCodeAt(a + 1));
        if (o === void 0 || s === void 0) {
            const l = t[a] + t[a + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + a)
        }
        n[i] = o * 16 + s
    }
    return n
}

function lmt(t) {
    return Y_e(bZ(t))
}

function OD(t) {
    if (!H8(t)) throw new Error("Uint8Array expected");
    return Y_e(bZ(Uint8Array.from(t).reverse()))
}

function Q_e(t, e) {
    return X_e(t.toString(16).padStart(e * 2, "0"))
}

function VG(t, e) {
    return Q_e(t, e).reverse()
}

function iy(t, e, r) {
    let n;
    if (typeof e == "string") try {
        n = X_e(e)
    } catch (a) {
        throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${a}`)
    } else if (H8(e)) n = Uint8Array.from(e); else throw new Error(`${t} must be hex string or Uint8Array`);
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(`${t} expected ${r} bytes, got ${i}`);
    return n
}

function Cue(...t) {
    let e = 0;
    for (let i = 0; i < t.length; i++) {
        const a = t[i];
        if (!H8(a)) throw new Error("Uint8Array expected");
        e += a.length
    }
    let r = new Uint8Array(e), n = 0;
    for (let i = 0; i < t.length; i++) {
        const a = t[i];
        r.set(a, n), n += a.length
    }
    return r
}

const umt = t => (smt << BigInt(t - 1)) - omt, fmt = {
    bigint: t => typeof t == "bigint",
    function: t => typeof t == "function",
    boolean: t => typeof t == "boolean",
    string: t => typeof t == "string",
    stringOrUint8Array: t => typeof t == "string" || H8(t),
    isSafeInteger: t => Number.isSafeInteger(t),
    array: t => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: t => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};

function wZ(t, e, r = {}) {
    const n = (i, a, o) => {
        const s = fmt[a];
        if (typeof s != "function") throw new Error(`Invalid validator "${a}", expected function`);
        const l = t[i];
        if (!(o && l === void 0) && !s(l, t)) throw new Error(`Invalid param ${String(i)}=${l} (${typeof l}), expected ${a}`)
    };
    for (const [i, a] of Object.entries(e)) n(i, a, !1);
    for (const [i, a] of Object.entries(r)) n(i, a, !0);
    return t
}

const Zs = BigInt(0), zo = BigInt(1), dw = BigInt(2), dmt = BigInt(3), HG = BigInt(4), Aue = BigInt(5), Iue = BigInt(8);
BigInt(9);
BigInt(16);

function Is(t, e) {
    const r = t % e;
    return r >= Zs ? r : e + r
}

function hmt(t, e, r) {
    if (r <= Zs || e < Zs) throw new Error("Expected power/modulo > 0");
    if (r === zo) return Zs;
    let n = zo;
    for (; e > Zs;) e & zo && (n = n * t % r), t = t * t % r, e >>= zo;
    return n
}

function f0(t, e, r) {
    let n = t;
    for (; e-- > Zs;) n *= n, n %= r;
    return n
}

function kue(t, e) {
    if (t === Zs || e <= Zs) throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
    let r = Is(t, e), n = e, i = Zs, a = zo;
    for (; r !== Zs;) {
        const s = n / r, l = n % r, f = i - a * s;
        n = r, r = l, i = a, a = f
    }
    if (n !== zo) throw new Error("invert: does not exist");
    return Is(i, e)
}

function pmt(t) {
    const e = (t - zo) / dw;
    let r, n, i;
    for (r = t - zo, n = 0; r % dw === Zs; r /= dw, n++) ;
    for (i = dw; i < t && hmt(i, e, t) !== t - zo; i++) ;
    if (n === 1) {
        const o = (t + zo) / HG;
        return function (l, f) {
            const d = l.pow(f, o);
            if (!l.eql(l.sqr(d), f)) throw new Error("Cannot find square root");
            return d
        }
    }
    const a = (r + zo) / dw;
    return function (s, l) {
        if (s.pow(l, e) === s.neg(s.ONE)) throw new Error("Cannot find square root");
        let f = n, d = s.pow(s.mul(s.ONE, i), r), p = s.pow(l, a), g = s.pow(l, r);
        for (; !s.eql(g, s.ONE);) {
            if (s.eql(g, s.ZERO)) return s.ZERO;
            let b = 1;
            for (let T = s.sqr(g); b < f && !s.eql(T, s.ONE); b++) T = s.sqr(T);
            const S = s.pow(d, zo << BigInt(f - b - 1));
            d = s.sqr(S), p = s.mul(p, S), g = s.mul(g, d), f = b
        }
        return p
    }
}

function mmt(t) {
    if (t % HG === dmt) {
        const e = (t + zo) / HG;
        return function (n, i) {
            const a = n.pow(i, e);
            if (!n.eql(n.sqr(a), i)) throw new Error("Cannot find square root");
            return a
        }
    }
    if (t % Iue === Aue) {
        const e = (t - Aue) / Iue;
        return function (n, i) {
            const a = n.mul(i, dw), o = n.pow(a, e), s = n.mul(i, o), l = n.mul(n.mul(s, dw), o),
                f = n.mul(s, n.sub(l, n.ONE));
            if (!n.eql(n.sqr(f), i)) throw new Error("Cannot find square root");
            return f
        }
    }
    return pmt(t)
}

const vmt = (t, e) => (Is(t, e) & zo) === zo,
    gmt = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function ymt(t) {
    const e = {ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger"},
        r = gmt.reduce((n, i) => (n[i] = "function", n), e);
    return wZ(t, r)
}

function bmt(t, e, r) {
    if (r < Zs) throw new Error("Expected power > 0");
    if (r === Zs) return t.ONE;
    if (r === zo) return e;
    let n = t.ONE, i = e;
    for (; r > Zs;) r & zo && (n = t.mul(n, i)), i = t.sqr(i), r >>= zo;
    return n
}

function wmt(t, e) {
    const r = new Array(e.length), n = e.reduce((a, o, s) => t.is0(o) ? a : (r[s] = a, t.mul(a, o)), t.ONE),
        i = t.inv(n);
    return e.reduceRight((a, o, s) => t.is0(o) ? a : (r[s] = t.mul(a, r[s]), t.mul(a, o)), i), r
}

function Z_e(t, e) {
    const r = e !== void 0 ? e : t.toString(2).length, n = Math.ceil(r / 8);
    return {nBitLength: r, nByteLength: n}
}

function Smt(t, e, r = !1, n = {}) {
    if (t <= Zs) throw new Error(`Expected Field ORDER > 0, got ${t}`);
    const {nBitLength: i, nByteLength: a} = Z_e(t, e);
    if (a > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const o = mmt(t), s = Object.freeze({
        ORDER: t,
        BITS: i,
        BYTES: a,
        MASK: umt(i),
        ZERO: Zs,
        ONE: zo,
        create: l => Is(l, t),
        isValid: l => {
            if (typeof l != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
            return Zs <= l && l < t
        },
        is0: l => l === Zs,
        isOdd: l => (l & zo) === zo,
        neg: l => Is(-l, t),
        eql: (l, f) => l === f,
        sqr: l => Is(l * l, t),
        add: (l, f) => Is(l + f, t),
        sub: (l, f) => Is(l - f, t),
        mul: (l, f) => Is(l * f, t),
        pow: (l, f) => bmt(s, l, f),
        div: (l, f) => Is(l * kue(f, t), t),
        sqrN: l => l * l,
        addN: (l, f) => l + f,
        subN: (l, f) => l - f,
        mulN: (l, f) => l * f,
        inv: l => kue(l, t),
        sqrt: n.sqrt || (l => o(s, l)),
        invertBatch: l => wmt(s, l),
        cmov: (l, f, d) => d ? f : l,
        toBytes: l => r ? VG(l, a) : Q_e(l, a),
        fromBytes: l => {
            if (l.length !== a) throw new Error(`Fp.fromBytes: expected ${a}, got ${l.length}`);
            return r ? OD(l) : lmt(l)
        }
    });
    return Object.freeze(s)
}

function _mt(t, e) {
    if (!t.isOdd) throw new Error("Field doesn't have isOdd");
    const r = t.sqrt(e);
    return t.isOdd(r) ? t.neg(r) : r
}

const xmt = BigInt(0), eV = BigInt(1);

function Emt(t, e) {
    const r = (i, a) => {
        const o = a.negate();
        return i ? o : a
    }, n = i => {
        const a = Math.ceil(e / i) + 1, o = 2 ** (i - 1);
        return {windows: a, windowSize: o}
    };
    return {
        constTimeNegate: r, unsafeLadder(i, a) {
            let o = t.ZERO, s = i;
            for (; a > xmt;) a & eV && (o = o.add(s)), s = s.double(), a >>= eV;
            return o
        }, precomputeWindow(i, a) {
            const {windows: o, windowSize: s} = n(a), l = [];
            let f = i, d = f;
            for (let p = 0; p < o; p++) {
                d = f, l.push(d);
                for (let g = 1; g < s; g++) d = d.add(f), l.push(d);
                f = d.double()
            }
            return l
        }, wNAF(i, a, o) {
            const {windows: s, windowSize: l} = n(i);
            let f = t.ZERO, d = t.BASE;
            const p = BigInt(2 ** i - 1), g = 2 ** i, b = BigInt(i);
            for (let S = 0; S < s; S++) {
                const T = S * l;
                let I = Number(o & p);
                o >>= b, I > l && (I -= g, o += eV);
                const N = T, P = T + Math.abs(I) - 1, F = S % 2 !== 0, V = I < 0;
                I === 0 ? d = d.add(r(F, a[N])) : f = f.add(r(V, a[P]))
            }
            return {p: f, f: d}
        }, wNAFCached(i, a, o, s) {
            const l = i._WINDOW_SIZE || 1;
            let f = a.get(i);
            return f || (f = this.precomputeWindow(i, l), l !== 1 && a.set(i, s(f))), this.wNAF(l, f, o)
        }
    }
}

function Tmt(t) {
    return ymt(t.Fp), wZ(t, {n: "bigint", h: "bigint", Gx: "field", Gy: "field"}, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({...Z_e(t.n, t.nBitLength), ...t, p: t.Fp.ORDER})
}

const jh = BigInt(0), Af = BigInt(1), v7 = BigInt(2), Cmt = BigInt(8), Amt = {zip215: !0};

function Imt(t) {
    const e = Tmt(t);
    return wZ(t, {hash: "function", a: "bigint", d: "bigint", randomBytes: "function"}, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }), Object.freeze({...e})
}

function kmt(t) {
    const e = Imt(t), {Fp: r, n, prehash: i, hash: a, randomBytes: o, nByteLength: s, h: l} = e,
        f = v7 << BigInt(s * 8) - Af, d = r.create, p = e.uvRatio || ((j, $) => {
            try {
                return {isValid: !0, value: r.sqrt(j * r.inv($))}
            } catch {
                return {isValid: !1, value: jh}
            }
        }), g = e.adjustScalarBytes || (j => j), b = e.domain || ((j, $, C) => {
            if ($.length || C) throw new Error("Contexts/pre-hash are not supported");
            return j
        }), S = j => typeof j == "bigint" && jh < j, T = (j, $) => S(j) && S($) && j < $, I = j => j === jh || T(j, f);

    function N(j, $) {
        if (T(j, $)) return j;
        throw new Error(`Expected valid scalar < ${$}, got ${typeof j} ${j}`)
    }

    function P(j) {
        return j === jh ? j : N(j, n)
    }

    const F = new Map;

    function V(j) {
        if (!(j instanceof Y)) throw new Error("ExtendedPoint expected")
    }

    class Y {
        constructor($, C, R, k) {
            if (this.ex = $, this.ey = C, this.ez = R, this.et = k, !I($)) throw new Error("x required");
            if (!I(C)) throw new Error("y required");
            if (!I(R)) throw new Error("z required");
            if (!I(k)) throw new Error("t required")
        }

        get x() {
            return this.toAffine().x
        }

        get y() {
            return this.toAffine().y
        }

        static fromAffine($) {
            if ($ instanceof Y) throw new Error("extended point not allowed");
            const {x: C, y: R} = $ || {};
            if (!I(C) || !I(R)) throw new Error("invalid affine point");
            return new Y(C, R, Af, d(C * R))
        }

        static normalizeZ($) {
            const C = r.invertBatch($.map(R => R.ez));
            return $.map((R, k) => R.toAffine(C[k])).map(Y.fromAffine)
        }

        _setWindowSize($) {
            this._WINDOW_SIZE = $, F.delete(this)
        }

        assertValidity() {
            const {a: $, d: C} = e;
            if (this.is0()) throw new Error("bad point: ZERO");
            const {ex: R, ey: k, ez: Q, et: fe} = this, ye = d(R * R), ue = d(k * k), me = d(Q * Q), Se = d(me * me),
                Ce = d(ye * $), Me = d(me * d(Ce + ue)), ve = d(Se + d(C * d(ye * ue)));
            if (Me !== ve) throw new Error("bad point: equation left != right (1)");
            const ne = d(R * k), be = d(Q * fe);
            if (ne !== be) throw new Error("bad point: equation left != right (2)")
        }

        equals($) {
            V($);
            const {ex: C, ey: R, ez: k} = this, {ex: Q, ey: fe, ez: ye} = $, ue = d(C * ye), me = d(Q * k),
                Se = d(R * ye), Ce = d(fe * k);
            return ue === me && Se === Ce
        }

        is0() {
            return this.equals(Y.ZERO)
        }

        negate() {
            return new Y(d(-this.ex), this.ey, this.ez, d(-this.et))
        }

        double() {
            const {a: $} = e, {ex: C, ey: R, ez: k} = this, Q = d(C * C), fe = d(R * R), ye = d(v7 * d(k * k)),
                ue = d($ * Q), me = C + R, Se = d(d(me * me) - Q - fe), Ce = ue + fe, Me = Ce - ye, ve = ue - fe,
                ne = d(Se * Me), be = d(Ce * ve), Ee = d(Se * ve), Oe = d(Me * Ce);
            return new Y(ne, be, Oe, Ee)
        }

        add($) {
            V($);
            const {a: C, d: R} = e, {ex: k, ey: Q, ez: fe, et: ye} = this, {ex: ue, ey: me, ez: Se, et: Ce} = $;
            if (C === BigInt(-1)) {
                const Ot = d((Q - k) * (me + ue)), zt = d((Q + k) * (me - ue)), _t = d(zt - Ot);
                if (_t === jh) return this.double();
                const Dt = d(fe * v7 * Ce), rr = d(ye * v7 * Se), pe = rr + Dt, te = zt + Ot, X = rr - Dt,
                    H = d(pe * _t), U = d(te * X), q = d(pe * X), le = d(_t * te);
                return new Y(H, U, le, q)
            }
            const Me = d(k * ue), ve = d(Q * me), ne = d(ye * R * Ce), be = d(fe * Se),
                Ee = d((k + Q) * (ue + me) - Me - ve), Oe = be - ne, ze = be + ne, Be = d(ve - C * Me), it = d(Ee * Oe),
                Ue = d(ze * Be), bt = d(Ee * Be), gt = d(Oe * ze);
            return new Y(it, Ue, gt, bt)
        }

        subtract($) {
            return this.add($.negate())
        }

        wNAF($) {
            return G.wNAFCached(this, F, $, Y.normalizeZ)
        }

        multiply($) {
            const {p: C, f: R} = this.wNAF(N($, n));
            return Y.normalizeZ([C, R])[0]
        }

        multiplyUnsafe($) {
            let C = P($);
            return C === jh ? oe : this.equals(oe) || C === Af ? this : this.equals(ee) ? this.wNAF(C).p : G.unsafeLadder(this, C)
        }

        isSmallOrder() {
            return this.multiplyUnsafe(l).is0()
        }

        isTorsionFree() {
            return G.unsafeLadder(this, n).is0()
        }

        toAffine($) {
            const {ex: C, ey: R, ez: k} = this, Q = this.is0();
            $ == null && ($ = Q ? Cmt : r.inv(k));
            const fe = d(C * $), ye = d(R * $), ue = d(k * $);
            if (Q) return {x: jh, y: Af};
            if (ue !== Af) throw new Error("invZ was invalid");
            return {x: fe, y: ye}
        }

        clearCofactor() {
            const {h: $} = e;
            return $ === Af ? this : this.multiplyUnsafe($)
        }

        static fromHex($, C = !1) {
            const {d: R, a: k} = e, Q = r.BYTES;
            $ = iy("pointHex", $, Q);
            const fe = $.slice(), ye = $[Q - 1];
            fe[Q - 1] = ye & -129;
            const ue = OD(fe);
            ue === jh || (C ? N(ue, f) : N(ue, r.ORDER));
            const me = d(ue * ue), Se = d(me - Af), Ce = d(R * me - k);
            let {isValid: Me, value: ve} = p(Se, Ce);
            if (!Me) throw new Error("Point.fromHex: invalid y coordinate");
            const ne = (ve & Af) === Af, be = (ye & 128) !== 0;
            if (!C && ve === jh && be) throw new Error("Point.fromHex: x=0 and x_0=1");
            return be !== ne && (ve = d(-ve)), Y.fromAffine({x: ve, y: ue})
        }

        static fromPrivateKey($) {
            return re($).point
        }

        toRawBytes() {
            const {x: $, y: C} = this.toAffine(), R = VG(C, r.BYTES);
            return R[R.length - 1] |= $ & Af ? 128 : 0, R
        }

        toHex() {
            return bZ(this.toRawBytes())
        }
    }

    Y.BASE = new Y(e.Gx, e.Gy, Af, d(e.Gx * e.Gy)), Y.ZERO = new Y(jh, Af, Af, jh);
    const {BASE: ee, ZERO: oe} = Y, G = Emt(Y, s * 8);

    function J(j) {
        return Is(j, n)
    }

    function ce(j) {
        return J(OD(j))
    }

    function re(j) {
        const $ = s;
        j = iy("private key", j, $);
        const C = iy("hashed private key", a(j), 2 * $), R = g(C.slice(0, $)), k = C.slice($, 2 * $), Q = ce(R),
            fe = ee.multiply(Q), ye = fe.toRawBytes();
        return {head: R, prefix: k, scalar: Q, point: fe, pointBytes: ye}
    }

    function M(j) {
        return re(j).pointBytes
    }

    function D(j = new Uint8Array, ...$) {
        const C = Cue(...$);
        return ce(a(b(C, iy("context", j), !!i)))
    }

    function x(j, $, C = {}) {
        j = iy("message", j), i && (j = i(j));
        const {prefix: R, scalar: k, pointBytes: Q} = re($), fe = D(C.context, R, j), ye = ee.multiply(fe).toRawBytes(),
            ue = D(C.context, ye, Q, j), me = J(fe + ue * k);
        P(me);
        const Se = Cue(ye, VG(me, r.BYTES));
        return iy("result", Se, s * 2)
    }

    const A = Amt;

    function B(j, $, C, R = A) {
        const {context: k, zip215: Q} = R, fe = r.BYTES;
        j = iy("signature", j, 2 * fe), $ = iy("message", $), i && ($ = i($));
        const ye = OD(j.slice(fe, 2 * fe));
        let ue, me, Se;
        try {
            ue = Y.fromHex(C, Q), me = Y.fromHex(j.slice(0, fe), Q), Se = ee.multiplyUnsafe(ye)
        } catch {
            return !1
        }
        if (!Q && ue.isSmallOrder()) return !1;
        const Ce = D(k, me.toRawBytes(), ue.toRawBytes(), $);
        return me.add(ue.multiplyUnsafe(Ce)).subtract(Se).clearCofactor().equals(Y.ZERO)
    }

    return ee._setWindowSize(8), {
        CURVE: e,
        getPublicKey: M,
        sign: x,
        verify: B,
        ExtendedPoint: Y,
        utils: {
            getExtendedPublicKey: re, randomPrivateKey: () => o(r.BYTES), precompute(j = 8, $ = Y.BASE) {
                return $._setWindowSize(j), $.multiply(BigInt(3)), $
            }
        }
    }
}

const SZ = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
    Rue = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const Rmt = BigInt(1), WG = BigInt(2), Dmt = BigInt(5), Due = BigInt(10), Mmt = BigInt(20), Omt = BigInt(40),
    Mue = BigInt(80);

function Pmt(t) {
    const e = SZ, n = t * t % e * t % e, i = f0(n, WG, e) * n % e, a = f0(i, Rmt, e) * t % e, o = f0(a, Dmt, e) * a % e,
        s = f0(o, Due, e) * o % e, l = f0(s, Mmt, e) * s % e, f = f0(l, Omt, e) * l % e, d = f0(f, Mue, e) * f % e,
        p = f0(d, Mue, e) * f % e, g = f0(p, Due, e) * o % e;
    return {pow_p_5_8: f0(g, WG, e) * t % e, b2: n}
}

function Nmt(t) {
    return t[0] &= 248, t[31] &= 127, t[31] |= 64, t
}

function Lmt(t, e) {
    const r = SZ, n = Is(e * e * e, r), i = Is(n * n * e, r), a = Pmt(t * i).pow_p_5_8;
    let o = Is(t * n * a, r);
    const s = Is(e * o * o, r), l = o, f = Is(o * Rue, r), d = s === t, p = s === Is(-t, r), g = s === Is(-t * Rue, r);
    return d && (o = l), (p || g) && (o = f), vmt(o, r) && (o = Is(-o, r)), {isValid: d || p, value: o}
}

const _v = Smt(SZ, void 0, !0), Bmt = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: _v,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: BigInt(8),
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: amt,
    randomBytes: O0t,
    adjustScalarBytes: Nmt,
    uvRatio: Lmt
}, _Z = kmt(Bmt), $mt = (_v.ORDER + BigInt(3)) / BigInt(8);
_v.pow(WG, $mt);
_v.sqrt(_v.neg(_v.ONE));
(_v.ORDER - BigInt(5)) / BigInt(8);
BigInt(486662);
_mt(_v, _v.neg(BigInt(486664)));
BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var g7 = Vn.Buffer;

function Fmt(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
    for (var n = 0; n < t.length; n++) {
        var i = t.charAt(n), a = i.charCodeAt(0);
        if (e[a] !== 255) throw new TypeError(i + " is ambiguous");
        e[a] = n
    }
    var o = t.length, s = t.charAt(0), l = Math.log(o) / Math.log(256), f = Math.log(256) / Math.log(o);

    function d(b) {
        if ((Array.isArray(b) || b instanceof Uint8Array) && (b = g7.from(b)), !g7.isBuffer(b)) throw new TypeError("Expected Buffer");
        if (b.length === 0) return "";
        for (var S = 0, T = 0, I = 0, N = b.length; I !== N && b[I] === 0;) I++, S++;
        for (var P = (N - I) * f + 1 >>> 0, F = new Uint8Array(P); I !== N;) {
            for (var V = b[I], Y = 0, ee = P - 1; (V !== 0 || Y < T) && ee !== -1; ee--, Y++) V += 256 * F[ee] >>> 0, F[ee] = V % o >>> 0, V = V / o >>> 0;
            if (V !== 0) throw new Error("Non-zero carry");
            T = Y, I++
        }
        for (var oe = P - T; oe !== P && F[oe] === 0;) oe++;
        for (var G = s.repeat(S); oe < P; ++oe) G += t.charAt(F[oe]);
        return G
    }

    function p(b) {
        if (typeof b != "string") throw new TypeError("Expected String");
        if (b.length === 0) return g7.alloc(0);
        for (var S = 0, T = 0, I = 0; b[S] === s;) T++, S++;
        for (var N = (b.length - S) * l + 1 >>> 0, P = new Uint8Array(N); b[S];) {
            var F = e[b.charCodeAt(S)];
            if (F === 255) return;
            for (var V = 0, Y = N - 1; (F !== 0 || V < I) && Y !== -1; Y--, V++) F += o * P[Y] >>> 0, P[Y] = F % 256 >>> 0, F = F / 256 >>> 0;
            if (F !== 0) throw new Error("Non-zero carry");
            I = V, S++
        }
        for (var ee = N - I; ee !== N && P[ee] === 0;) ee++;
        var oe = g7.allocUnsafe(T + (N - ee));
        oe.fill(0, 0, T);
        for (var G = T; ee !== N;) oe[G++] = P[ee++];
        return oe
    }

    function g(b) {
        var S = p(b);
        if (S) return S;
        throw new Error("Non-base" + o + " character")
    }

    return {encode: d, decodeUnsafe: p, decode: g}
}

var Umt = Fmt, jmt = Umt, zmt = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", J_e = jmt(zmt);
const jc = za(J_e), Vmt = (t, e, r) => t & e ^ ~t & r, Hmt = (t, e, r) => t & e ^ t & r ^ e & r,
    Wmt = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    ay = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    oy = new Uint32Array(64);

class qmt extends G_e {
    constructor() {
        super(64, 32, 8, !1), this.A = ay[0] | 0, this.B = ay[1] | 0, this.C = ay[2] | 0, this.D = ay[3] | 0, this.E = ay[4] | 0, this.F = ay[5] | 0, this.G = ay[6] | 0, this.H = ay[7] | 0
    }

    get() {
        const {A: e, B: r, C: n, D: i, E: a, F: o, G: s, H: l} = this;
        return [e, r, n, i, a, o, s, l]
    }

    set(e, r, n, i, a, o, s, l) {
        this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = a | 0, this.F = o | 0, this.G = s | 0, this.H = l | 0
    }

    process(e, r) {
        for (let p = 0; p < 16; p++, r += 4) oy[p] = e.getUint32(r, !1);
        for (let p = 16; p < 64; p++) {
            const g = oy[p - 15], b = oy[p - 2], S = u0(g, 7) ^ u0(g, 18) ^ g >>> 3,
                T = u0(b, 17) ^ u0(b, 19) ^ b >>> 10;
            oy[p] = T + oy[p - 7] + S + oy[p - 16] | 0
        }
        let {A: n, B: i, C: a, D: o, E: s, F: l, G: f, H: d} = this;
        for (let p = 0; p < 64; p++) {
            const g = u0(s, 6) ^ u0(s, 11) ^ u0(s, 25), b = d + g + Vmt(s, l, f) + Wmt[p] + oy[p] | 0,
                T = (u0(n, 2) ^ u0(n, 13) ^ u0(n, 22)) + Hmt(n, i, a) | 0;
            d = f, f = l, l = s, s = o + b | 0, o = a, a = i, i = n, n = b + T | 0
        }
        n = n + this.A | 0, i = i + this.B | 0, a = a + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, l = l + this.F | 0, f = f + this.G | 0, d = d + this.H | 0, this.set(n, i, a, o, s, l, f, d)
    }

    roundClean() {
        oy.fill(0)
    }

    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
}

const Oue = q_e(() => new qmt);
var Lc = {};

function nv(t, e, r) {
    return e <= t && t <= r
}

function BN(t) {
    if (t === void 0) return {};
    if (t === Object(t)) return t;
    throw TypeError("Could not convert argument to dictionary")
}

function Gmt(t) {
    for (var e = String(t), r = e.length, n = 0, i = []; n < r;) {
        var a = e.charCodeAt(n);
        if (a < 55296 || a > 57343) i.push(a); else if (56320 <= a && a <= 57343) i.push(65533); else if (55296 <= a && a <= 56319) if (n === r - 1) i.push(65533); else {
            var o = t.charCodeAt(n + 1);
            if (56320 <= o && o <= 57343) {
                var s = a & 1023, l = o & 1023;
                i.push(65536 + (s << 10) + l), n += 1
            } else i.push(65533)
        }
        n += 1
    }
    return i
}

function Kmt(t) {
    for (var e = "", r = 0; r < t.length; ++r) {
        var n = t[r];
        n <= 65535 ? e += String.fromCharCode(n) : (n -= 65536, e += String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320))
    }
    return e
}

var gO = -1;

function xZ(t) {
    this.tokens = [].slice.call(t)
}

xZ.prototype = {
    endOfStream: function () {
        return !this.tokens.length
    }, read: function () {
        return this.tokens.length ? this.tokens.shift() : gO
    }, prepend: function (t) {
        if (Array.isArray(t)) for (var e = t; e.length;) this.tokens.unshift(e.pop()); else this.tokens.unshift(t)
    }, push: function (t) {
        if (Array.isArray(t)) for (var e = t; e.length;) this.tokens.push(e.shift()); else this.tokens.push(t)
    }
};
var q4 = -1;

function tV(t, e) {
    if (t) throw TypeError("Decoder error");
    return e || 65533
}

var yO = "utf-8";

function bO(t, e) {
    if (!(this instanceof bO)) return new bO(t, e);
    if (t = t !== void 0 ? String(t).toLowerCase() : yO, t !== yO) throw new Error("Encoding not supported. Only utf-8 is supported");
    e = BN(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!e.fatal, this._ignoreBOM = !!e.ignoreBOM, Object.defineProperty(this, "encoding", {value: "utf-8"}), Object.defineProperty(this, "fatal", {value: this._fatal}), Object.defineProperty(this, "ignoreBOM", {value: this._ignoreBOM})
}

bO.prototype = {
    decode: function (e, r) {
        var n;
        typeof e == "object" && e instanceof ArrayBuffer ? n = new Uint8Array(e) : typeof e == "object" && "buffer" in e && e.buffer instanceof ArrayBuffer ? n = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : n = new Uint8Array(0), r = BN(r), this._streaming || (this._decoder = new Ymt({fatal: this._fatal}), this._BOMseen = !1), this._streaming = !!r.stream;
        for (var i = new xZ(n), a = [], o; !i.endOfStream() && (o = this._decoder.handler(i, i.read()), o !== q4);) o !== null && (Array.isArray(o) ? a.push.apply(a, o) : a.push(o));
        if (!this._streaming) {
            do {
                if (o = this._decoder.handler(i, i.read()), o === q4) break;
                o !== null && (Array.isArray(o) ? a.push.apply(a, o) : a.push(o))
            } while (!i.endOfStream());
            this._decoder = null
        }
        return a.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (a[0] === 65279 ? (this._BOMseen = !0, a.shift()) : this._BOMseen = !0), Kmt(a)
    }
};

function wO(t, e) {
    if (!(this instanceof wO)) return new wO(t, e);
    if (t = t !== void 0 ? String(t).toLowerCase() : yO, t !== yO) throw new Error("Encoding not supported. Only utf-8 is supported");
    e = BN(e), this._streaming = !1, this._encoder = null, this._options = {fatal: !!e.fatal}, Object.defineProperty(this, "encoding", {value: "utf-8"})
}

wO.prototype = {
    encode: function (e, r) {
        e = e ? String(e) : "", r = BN(r), this._streaming || (this._encoder = new Xmt), this._streaming = !!r.stream;
        for (var n = [], i = new xZ(Gmt(e)), a; !i.endOfStream() && (a = this._encoder.handler(i, i.read()), a !== q4);) Array.isArray(a) ? n.push.apply(n, a) : n.push(a);
        if (!this._streaming) {
            for (; a = this._encoder.handler(i, i.read()), a !== q4;) Array.isArray(a) ? n.push.apply(n, a) : n.push(a);
            this._encoder = null
        }
        return new Uint8Array(n)
    }
};

function Ymt(t) {
    var e = t.fatal, r = 0, n = 0, i = 0, a = 128, o = 191;
    this.handler = function (s, l) {
        if (l === gO && i !== 0) return i = 0, tV(e);
        if (l === gO) return q4;
        if (i === 0) {
            if (nv(l, 0, 127)) return l;
            if (nv(l, 194, 223)) i = 1, r = l - 192; else if (nv(l, 224, 239)) l === 224 && (a = 160), l === 237 && (o = 159), i = 2, r = l - 224; else if (nv(l, 240, 244)) l === 240 && (a = 144), l === 244 && (o = 143), i = 3, r = l - 240; else return tV(e);
            return r = r << 6 * i, null
        }
        if (!nv(l, a, o)) return r = i = n = 0, a = 128, o = 191, s.prepend(l), tV(e);
        if (a = 128, o = 191, n += 1, r += l - 128 << 6 * (i - n), n !== i) return null;
        var f = r;
        return r = i = n = 0, f
    }
}

function Xmt(t) {
    this.handler = function (e, r) {
        if (r === gO) return q4;
        if (nv(r, 0, 127)) return r;
        var n, i;
        nv(r, 128, 2047) ? (n = 1, i = 192) : nv(r, 2048, 65535) ? (n = 2, i = 224) : nv(r, 65536, 1114111) && (n = 3, i = 240);
        for (var a = [(r >> 6 * n) + i]; n > 0;) {
            var o = r >> 6 * (n - 1);
            a.push(128 | o & 63), n -= 1
        }
        return a
    }
}

const Qmt = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: bO,
    TextEncoder: wO
}, Symbol.toStringTag, {value: "Module"})), Zmt = $P(Qmt);
var Jmt = tn && tn.__createBinding || (Object.create ? function (t, e, r, n) {
    n === void 0 && (n = r), Object.defineProperty(t, n, {
        enumerable: !0, get: function () {
            return e[r]
        }
    })
} : function (t, e, r, n) {
    n === void 0 && (n = r), t[n] = e[r]
}), evt = tn && tn.__setModuleDefault || (Object.create ? function (t, e) {
    Object.defineProperty(t, "default", {enumerable: !0, value: e})
} : function (t, e) {
    t.default = e
}), em = tn && tn.__decorate || function (t, e, r, n) {
    var i = arguments.length, a = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") a = Reflect.decorate(t, e, r, n); else for (var s = t.length - 1; s >= 0; s--) (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, r, a) : o(e, r)) || a);
    return i > 3 && a && Object.defineProperty(e, r, a), a
}, tvt = tn && tn.__importStar || function (t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null) for (var r in t) r !== "default" && Object.hasOwnProperty.call(t, r) && Jmt(e, t, r);
    return evt(e, t), e
}, exe = tn && tn.__importDefault || function (t) {
    return t && t.__esModule ? t : {default: t}
};
Object.defineProperty(Lc, "__esModule", {value: !0});
var txe = Lc.deserializeUnchecked = sxe = Lc.deserialize = oxe = Lc.serialize = Lc.BinaryReader = Lc.BinaryWriter = Lc.BorshError = Lc.baseDecode = Lc.baseEncode = void 0;
const Iy = exe(P8), rxe = exe(J_e), rvt = tvt(Zmt),
    nvt = typeof TextDecoder != "function" ? rvt.TextDecoder : TextDecoder, ivt = new nvt("utf-8", {fatal: !0});

function avt(t) {
    return typeof t == "string" && (t = kr.from(t, "utf8")), rxe.default.encode(kr.from(t))
}

Lc.baseEncode = avt;

function ovt(t) {
    return kr.from(rxe.default.decode(t))
}

Lc.baseDecode = ovt;
const rV = 1024;

class ou extends Error {
    constructor(e) {
        super(e), this.fieldPath = [], this.originalMessage = e
    }

    addToFieldPath(e) {
        this.fieldPath.splice(0, 0, e), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
}

Lc.BorshError = ou;

class nxe {
    constructor() {
        this.buf = kr.alloc(rV), this.length = 0
    }

    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = kr.concat([this.buf, kr.alloc(rV)]))
    }

    writeU8(e) {
        this.maybeResize(), this.buf.writeUInt8(e, this.length), this.length += 1
    }

    writeU16(e) {
        this.maybeResize(), this.buf.writeUInt16LE(e, this.length), this.length += 2
    }

    writeU32(e) {
        this.maybeResize(), this.buf.writeUInt32LE(e, this.length), this.length += 4
    }

    writeU64(e) {
        this.maybeResize(), this.writeBuffer(kr.from(new Iy.default(e).toArray("le", 8)))
    }

    writeU128(e) {
        this.maybeResize(), this.writeBuffer(kr.from(new Iy.default(e).toArray("le", 16)))
    }

    writeU256(e) {
        this.maybeResize(), this.writeBuffer(kr.from(new Iy.default(e).toArray("le", 32)))
    }

    writeU512(e) {
        this.maybeResize(), this.writeBuffer(kr.from(new Iy.default(e).toArray("le", 64)))
    }

    writeBuffer(e) {
        this.buf = kr.concat([kr.from(this.buf.subarray(0, this.length)), e, kr.alloc(rV)]), this.length += e.length
    }

    writeString(e) {
        this.maybeResize();
        const r = kr.from(e, "utf8");
        this.writeU32(r.length), this.writeBuffer(r)
    }

    writeFixedArray(e) {
        this.writeBuffer(kr.from(e))
    }

    writeArray(e, r) {
        this.maybeResize(), this.writeU32(e.length);
        for (const n of e) this.maybeResize(), r(n)
    }

    toArray() {
        return this.buf.subarray(0, this.length)
    }
}

Lc.BinaryWriter = nxe;

function tm(t, e, r) {
    const n = r.value;
    r.value = function (...i) {
        try {
            return n.apply(this, i)
        } catch (a) {
            if (a instanceof RangeError) {
                const o = a.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0) throw new ou("Reached the end of buffer when deserializing")
            }
            throw a
        }
    }
}

class td {
    constructor(e) {
        this.buf = e, this.offset = 0
    }

    readU8() {
        const e = this.buf.readUInt8(this.offset);
        return this.offset += 1, e
    }

    readU16() {
        const e = this.buf.readUInt16LE(this.offset);
        return this.offset += 2, e
    }

    readU32() {
        const e = this.buf.readUInt32LE(this.offset);
        return this.offset += 4, e
    }

    readU64() {
        const e = this.readBuffer(8);
        return new Iy.default(e, "le")
    }

    readU128() {
        const e = this.readBuffer(16);
        return new Iy.default(e, "le")
    }

    readU256() {
        const e = this.readBuffer(32);
        return new Iy.default(e, "le")
    }

    readU512() {
        const e = this.readBuffer(64);
        return new Iy.default(e, "le")
    }

    readBuffer(e) {
        if (this.offset + e > this.buf.length) throw new ou(`Expected buffer length ${e} isn't within bounds`);
        const r = this.buf.slice(this.offset, this.offset + e);
        return this.offset += e, r
    }

    readString() {
        const e = this.readU32(), r = this.readBuffer(e);
        try {
            return ivt.decode(r)
        } catch (n) {
            throw new ou(`Error decoding UTF-8 string: ${n}`)
        }
    }

    readFixedArray(e) {
        return new Uint8Array(this.readBuffer(e))
    }

    readArray(e) {
        const r = this.readU32(), n = Array();
        for (let i = 0; i < r; ++i) n.push(e());
        return n
    }
}

em([tm], td.prototype, "readU8", null);
em([tm], td.prototype, "readU16", null);
em([tm], td.prototype, "readU32", null);
em([tm], td.prototype, "readU64", null);
em([tm], td.prototype, "readU128", null);
em([tm], td.prototype, "readU256", null);
em([tm], td.prototype, "readU512", null);
em([tm], td.prototype, "readString", null);
em([tm], td.prototype, "readFixedArray", null);
em([tm], td.prototype, "readArray", null);
Lc.BinaryReader = td;

function ixe(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}

function hw(t, e, r, n, i) {
    try {
        if (typeof n == "string") i[`write${ixe(n)}`](r); else if (n instanceof Array) if (typeof n[0] == "number") {
            if (r.length !== n[0]) throw new ou(`Expecting byte array of length ${n[0]}, but got ${r.length} bytes`);
            i.writeFixedArray(r)
        } else if (n.length === 2 && typeof n[1] == "number") {
            if (r.length !== n[1]) throw new ou(`Expecting byte array of length ${n[1]}, but got ${r.length} bytes`);
            for (let a = 0; a < n[1]; a++) hw(t, null, r[a], n[0], i)
        } else i.writeArray(r, a => {
            hw(t, e, a, n[0], i)
        }); else if (n.kind !== void 0) switch (n.kind) {
            case"option": {
                r == null ? i.writeU8(0) : (i.writeU8(1), hw(t, e, r, n.type, i));
                break
            }
            case"map": {
                i.writeU32(r.size), r.forEach((a, o) => {
                    hw(t, e, o, n.key, i), hw(t, e, a, n.value, i)
                });
                break
            }
            default:
                throw new ou(`FieldType ${n} unrecognized`)
        } else axe(t, r, i)
    } catch (a) {
        throw a instanceof ou && a.addToFieldPath(e), a
    }
}

function axe(t, e, r) {
    if (typeof e.borshSerialize == "function") {
        e.borshSerialize(r);
        return
    }
    const n = t.get(e.constructor);
    if (!n) throw new ou(`Class ${e.constructor.name} is missing in schema`);
    if (n.kind === "struct") n.fields.map(([i, a]) => {
        hw(t, i, e[i], a, r)
    }); else if (n.kind === "enum") {
        const i = e[n.field];
        for (let a = 0; a < n.values.length; ++a) {
            const [o, s] = n.values[a];
            if (o === i) {
                r.writeU8(a), hw(t, o, e[o], s, r);
                break
            }
        }
    } else throw new ou(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
}

function svt(t, e, r = nxe) {
    const n = new r;
    return axe(t, e, n), n.toArray()
}

var oxe = Lc.serialize = svt;

function pw(t, e, r, n) {
    try {
        if (typeof r == "string") return n[`read${ixe(r)}`]();
        if (r instanceof Array) {
            if (typeof r[0] == "number") return n.readFixedArray(r[0]);
            if (typeof r[1] == "number") {
                const i = [];
                for (let a = 0; a < r[1]; a++) i.push(pw(t, null, r[0], n));
                return i
            } else return n.readArray(() => pw(t, e, r[0], n))
        }
        if (r.kind === "option") return n.readU8() ? pw(t, e, r.type, n) : void 0;
        if (r.kind === "map") {
            let i = new Map;
            const a = n.readU32();
            for (let o = 0; o < a; o++) {
                const s = pw(t, e, r.key, n), l = pw(t, e, r.value, n);
                i.set(s, l)
            }
            return i
        }
        return EZ(t, r, n)
    } catch (i) {
        throw i instanceof ou && i.addToFieldPath(e), i
    }
}

function EZ(t, e, r) {
    if (typeof e.borshDeserialize == "function") return e.borshDeserialize(r);
    const n = t.get(e);
    if (!n) throw new ou(`Class ${e.name} is missing in schema`);
    if (n.kind === "struct") {
        const i = {};
        for (const [a, o] of t.get(e).fields) i[a] = pw(t, a, o, r);
        return new e(i)
    }
    if (n.kind === "enum") {
        const i = r.readU8();
        if (i >= n.values.length) throw new ou(`Enum index: ${i} is out of range`);
        const [a, o] = n.values[i], s = pw(t, a, o, r);
        return new e({[a]: s})
    }
    throw new ou(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
}

function cvt(t, e, r, n = td) {
    const i = new n(r), a = EZ(t, e, i);
    if (i.offset < r.length) throw new ou(`Unexpected ${r.length - i.offset} bytes after deserialized data`);
    return a
}

var sxe = Lc.deserialize = cvt;

function lvt(t, e, r, n = td) {
    const i = new n(r);
    return EZ(t, e, i)
}

txe = Lc.deserializeUnchecked = lvt;
var tt = {};
Object.defineProperty(tt, "__esModule", {value: !0});
tt.s16 = tt.s8 = tt.nu64be = tt.u48be = tt.u40be = tt.u32be = tt.u24be = tt.u16be = Mc = tt.nu64 = tt.u48 = tt.u40 = Pr = tt.u32 = tt.u24 = Ud = tt.u16 = si = tt.u8 = jw = tt.offset = tt.greedy = tt.Constant = tt.UTF8 = tt.CString = tt.Blob = tt.Boolean = tt.BitField = tt.BitStructure = tt.VariantLayout = tt.Union = tt.UnionLayoutDiscriminator = tt.UnionDiscriminator = tt.Structure = tt.Sequence = tt.DoubleBE = tt.Double = tt.FloatBE = tt.Float = tt.NearInt64BE = tt.NearInt64 = tt.NearUInt64BE = tt.NearUInt64 = tt.IntBE = tt.Int = tt.UIntBE = tt.UInt = tt.OffsetLayout = tt.GreedyCount = tt.ExternalLayout = tt.bindConstructorLayout = tt.nameWithProperty = tt.Layout = tt.uint8ArrayToBuffer = tt.checkUint8Array = void 0;
tt.constant = tt.utf8 = tt.cstr = va = tt.blob = tt.unionLayoutDiscriminator = tt.union = xl = tt.seq = tt.bits = yr = tt.struct = tt.f64be = tt.f64 = tt.f32be = tt.f32 = tt.ns64be = tt.s48be = tt.s40be = tt.s32be = tt.s24be = tt.s16be = Df = tt.ns64 = tt.s48 = tt.s40 = tt.s32 = tt.s24 = void 0;
const TZ = qr;

function JE(t) {
    if (!(t instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
}

tt.checkUint8Array = JE;

function Bi(t) {
    return JE(t), TZ.Buffer.from(t.buffer, t.byteOffset, t.length)
}

tt.uint8ArrayToBuffer = Bi;

class oa {
    constructor(e, r) {
        if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
        this.span = e, this.property = r
    }

    makeDestinationObject() {
        return {}
    }

    getSpan(e, r) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span
    }

    replicate(e) {
        const r = Object.create(this.constructor.prototype);
        return Object.assign(r, this), r.property = e, r
    }

    fromArray(e) {
    }
}

tt.Layout = oa;

function CZ(t, e) {
    return e.property ? t + "[" + e.property + "]" : t
}

tt.nameWithProperty = CZ;

function uvt(t, e) {
    if (typeof t != "function") throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(t, "layout_")) throw new Error("Class is already bound to a layout");
    if (!(e && e instanceof oa)) throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
    t.layout_ = e, e.boundConstructor_ = t, e.makeDestinationObject = () => new t, Object.defineProperty(t.prototype, "encode", {
        value(r, n) {
            return e.encode(this, r, n)
        }, writable: !0
    }), Object.defineProperty(t, "decode", {
        value(r, n) {
            return e.decode(r, n)
        }, writable: !0
    })
}

tt.bindConstructorLayout = uvt;

class Ku extends oa {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}

tt.ExternalLayout = Ku;

class cxe extends Ku {
    constructor(e = 1, r) {
        if (!Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, r), this.elementSpan = e
    }

    isCount() {
        return !0
    }

    decode(e, r = 0) {
        JE(e);
        const n = e.length - r;
        return Math.floor(n / this.elementSpan)
    }

    encode(e, r, n) {
        return 0
    }
}

tt.GreedyCount = cxe;

class AZ extends Ku {
    constructor(e, r = 0, n) {
        if (!(e instanceof oa)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(r)) throw new TypeError("offset must be integer or undefined");
        super(e.span, n || e.property), this.layout = e, this.offset = r
    }

    isCount() {
        return this.layout instanceof Gd || this.layout instanceof lp
    }

    decode(e, r = 0) {
        return this.layout.decode(e, r + this.offset)
    }

    encode(e, r, n = 0) {
        return this.layout.encode(e, r, n + this.offset)
    }
}

tt.OffsetLayout = AZ;

class Gd extends oa {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }

    decode(e, r = 0) {
        return Bi(e).readUIntLE(r, this.span)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeUIntLE(e, n, this.span), this.span
    }
}

tt.UInt = Gd;

class lp extends oa {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }

    decode(e, r = 0) {
        return Bi(e).readUIntBE(r, this.span)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeUIntBE(e, n, this.span), this.span
    }
}

tt.UIntBE = lp;

class VS extends oa {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }

    decode(e, r = 0) {
        return Bi(e).readIntLE(r, this.span)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeIntLE(e, n, this.span), this.span
    }
}

tt.Int = VS;

class e3 extends oa {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }

    decode(e, r = 0) {
        return Bi(e).readIntBE(r, this.span)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeIntBE(e, n, this.span), this.span
    }
}

tt.IntBE = e3;
const qG = Math.pow(2, 32);

function $N(t) {
    const e = Math.floor(t / qG), r = t - e * qG;
    return {hi32: e, lo32: r}
}

function FN(t, e) {
    return t * qG + e
}

class lxe extends oa {
    constructor(e) {
        super(8, e)
    }

    decode(e, r = 0) {
        const n = Bi(e), i = n.readUInt32LE(r), a = n.readUInt32LE(r + 4);
        return FN(a, i)
    }

    encode(e, r, n = 0) {
        const i = $N(e), a = Bi(r);
        return a.writeUInt32LE(i.lo32, n), a.writeUInt32LE(i.hi32, n + 4), 8
    }
}

tt.NearUInt64 = lxe;

class uxe extends oa {
    constructor(e) {
        super(8, e)
    }

    decode(e, r = 0) {
        const n = Bi(e), i = n.readUInt32BE(r), a = n.readUInt32BE(r + 4);
        return FN(i, a)
    }

    encode(e, r, n = 0) {
        const i = $N(e), a = Bi(r);
        return a.writeUInt32BE(i.hi32, n), a.writeUInt32BE(i.lo32, n + 4), 8
    }
}

tt.NearUInt64BE = uxe;

class fxe extends oa {
    constructor(e) {
        super(8, e)
    }

    decode(e, r = 0) {
        const n = Bi(e), i = n.readUInt32LE(r), a = n.readInt32LE(r + 4);
        return FN(a, i)
    }

    encode(e, r, n = 0) {
        const i = $N(e), a = Bi(r);
        return a.writeUInt32LE(i.lo32, n), a.writeInt32LE(i.hi32, n + 4), 8
    }
}

tt.NearInt64 = fxe;

class dxe extends oa {
    constructor(e) {
        super(8, e)
    }

    decode(e, r = 0) {
        const n = Bi(e), i = n.readInt32BE(r), a = n.readUInt32BE(r + 4);
        return FN(i, a)
    }

    encode(e, r, n = 0) {
        const i = $N(e), a = Bi(r);
        return a.writeInt32BE(i.hi32, n), a.writeUInt32BE(i.lo32, n + 4), 8
    }
}

tt.NearInt64BE = dxe;

class hxe extends oa {
    constructor(e) {
        super(4, e)
    }

    decode(e, r = 0) {
        return Bi(e).readFloatLE(r)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeFloatLE(e, n), 4
    }
}

tt.Float = hxe;

class pxe extends oa {
    constructor(e) {
        super(4, e)
    }

    decode(e, r = 0) {
        return Bi(e).readFloatBE(r)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeFloatBE(e, n), 4
    }
}

tt.FloatBE = pxe;

class mxe extends oa {
    constructor(e) {
        super(8, e)
    }

    decode(e, r = 0) {
        return Bi(e).readDoubleLE(r)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeDoubleLE(e, n), 8
    }
}

tt.Double = mxe;

class vxe extends oa {
    constructor(e) {
        super(8, e)
    }

    decode(e, r = 0) {
        return Bi(e).readDoubleBE(r)
    }

    encode(e, r, n = 0) {
        return Bi(r).writeDoubleBE(e, n), 8
    }
}

tt.DoubleBE = vxe;

class gxe extends oa {
    constructor(e, r, n) {
        if (!(e instanceof oa)) throw new TypeError("elementLayout must be a Layout");
        if (!(r instanceof Ku && r.isCount() || Number.isInteger(r) && 0 <= r)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let i = -1;
        !(r instanceof Ku) && 0 < e.span && (i = r * e.span), super(i, n), this.elementLayout = e, this.count = r
    }

    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        let n = 0, i = this.count;
        if (i instanceof Ku && (i = i.decode(e, r)), 0 < this.elementLayout.span) n = i * this.elementLayout.span; else {
            let a = 0;
            for (; a < i;) n += this.elementLayout.getSpan(e, r + n), ++a
        }
        return n
    }

    decode(e, r = 0) {
        const n = [];
        let i = 0, a = this.count;
        for (a instanceof Ku && (a = a.decode(e, r)); i < a;) n.push(this.elementLayout.decode(e, r)), r += this.elementLayout.getSpan(e, r), i += 1;
        return n
    }

    encode(e, r, n = 0) {
        const i = this.elementLayout, a = e.reduce((o, s) => o + i.encode(s, r, n + o), 0);
        return this.count instanceof Ku && this.count.encode(e.length, r, n), a
    }
}

tt.Sequence = gxe;

class yxe extends oa {
    constructor(e, r, n) {
        if (!(Array.isArray(e) && e.reduce((a, o) => a && o instanceof oa, !0))) throw new TypeError("fields must be array of Layout instances");
        typeof r == "boolean" && n === void 0 && (n = r, r = void 0);
        for (const a of e) if (0 > a.span && a.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
        let i = -1;
        try {
            i = e.reduce((a, o) => a + o.getSpan(), 0)
        } catch {
        }
        super(i, r), this.fields = e, this.decodePrefixes = !!n
    }

    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        try {
            n = this.fields.reduce((i, a) => {
                const o = a.getSpan(e, r);
                return r += o, i + o
            }, 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return n
    }

    decode(e, r = 0) {
        JE(e);
        const n = this.makeDestinationObject();
        for (const i of this.fields) if (i.property !== void 0 && (n[i.property] = i.decode(e, r)), r += i.getSpan(e, r), this.decodePrefixes && e.length === r) break;
        return n
    }

    encode(e, r, n = 0) {
        const i = n;
        let a = 0, o = 0;
        for (const s of this.fields) {
            let l = s.span;
            if (o = 0 < l ? l : 0, s.property !== void 0) {
                const f = e[s.property];
                f !== void 0 && (o = s.encode(f, r, n), 0 > l && (l = s.getSpan(r, n)))
            }
            a = n, n += l
        }
        return a + o - i
    }

    fromArray(e) {
        const r = this.makeDestinationObject();
        for (const n of this.fields) n.property !== void 0 && 0 < e.length && (r[n.property] = e.shift());
        return r
    }

    layoutFor(e) {
        if (typeof e != "string") throw new TypeError("property must be string");
        for (const r of this.fields) if (r.property === e) return r
    }

    offsetOf(e) {
        if (typeof e != "string") throw new TypeError("property must be string");
        let r = 0;
        for (const n of this.fields) {
            if (n.property === e) return r;
            0 > n.span ? r = -1 : 0 <= r && (r += n.span)
        }
    }
}

tt.Structure = yxe;

class IZ {
    constructor(e) {
        this.property = e
    }

    decode(e, r) {
        throw new Error("UnionDiscriminator is abstract")
    }

    encode(e, r, n) {
        throw new Error("UnionDiscriminator is abstract")
    }
}

tt.UnionDiscriminator = IZ;

class SO extends IZ {
    constructor(e, r) {
        if (!(e instanceof Ku && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(r || e.property || "variant"), this.layout = e
    }

    decode(e, r) {
        return this.layout.decode(e, r)
    }

    encode(e, r, n) {
        return this.layout.encode(e, r, n)
    }
}

tt.UnionLayoutDiscriminator = SO;

class kZ extends oa {
    constructor(e, r, n) {
        let i;
        if (e instanceof Gd || e instanceof lp) i = new SO(new AZ(e)); else if (e instanceof Ku && e.isCount()) i = new SO(e); else if (e instanceof IZ) i = e; else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (r === void 0 && (r = null), !(r === null || r instanceof oa)) throw new TypeError("defaultLayout must be null or a Layout");
        if (r !== null) {
            if (0 > r.span) throw new Error("defaultLayout must have constant span");
            r.property === void 0 && (r = r.replicate("content"))
        }
        let a = -1;
        r && (a = r.span, 0 <= a && (e instanceof Gd || e instanceof lp) && (a += i.layout.span)), super(a, n), this.discriminator = i, this.usesPrefixDiscriminator = e instanceof Gd || e instanceof lp, this.defaultLayout = r, this.registry = {};
        let o = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function (s) {
            return o(s)
        }, this.configGetSourceVariant = function (s) {
            o = s.bind(this)
        }
    }

    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        const n = this.getVariant(e, r);
        if (!n) throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(e, r)
    }

    defaultGetSourceVariant(e) {
        if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)) return;
            const r = this.registry[e[this.discriminator.property]];
            if (r && (!r.layout || r.property && Object.prototype.hasOwnProperty.call(e, r.property))) return r
        } else for (const r in this.registry) {
            const n = this.registry[r];
            if (n.property && Object.prototype.hasOwnProperty.call(e, n.property)) return n
        }
        throw new Error("unable to infer src variant")
    }

    decode(e, r = 0) {
        let n;
        const i = this.discriminator, a = i.decode(e, r), o = this.registry[a];
        if (o === void 0) {
            const s = this.defaultLayout;
            let l = 0;
            this.usesPrefixDiscriminator && (l = i.layout.span), n = this.makeDestinationObject(), n[i.property] = a, n[s.property] = s.decode(e, r + l)
        } else n = o.decode(e, r);
        return n
    }

    encode(e, r, n = 0) {
        const i = this.getSourceVariant(e);
        if (i === void 0) {
            const a = this.discriminator, o = this.defaultLayout;
            let s = 0;
            return this.usesPrefixDiscriminator && (s = a.layout.span), a.encode(e[a.property], r, n), s + o.encode(e[o.property], r, n + s)
        }
        return i.encode(e, r, n)
    }

    addVariant(e, r, n) {
        const i = new bxe(this, e, r, n);
        return this.registry[e] = i, i
    }

    getVariant(e, r = 0) {
        let n;
        return e instanceof Uint8Array ? n = this.discriminator.decode(e, r) : n = e, this.registry[n]
    }
}

tt.Union = kZ;

class bxe extends oa {
    constructor(e, r, n, i) {
        if (!(e instanceof kZ)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(r) || 0 > r) throw new TypeError("variant must be a (non-negative) integer");
        if (typeof n == "string" && i === void 0 && (i = n, n = null), n) {
            if (!(n instanceof oa)) throw new TypeError("layout must be a Layout");
            if (e.defaultLayout !== null && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
            if (typeof i != "string") throw new TypeError("variant must have a String property")
        }
        let a = e.span;
        0 > e.span && (a = n ? n.span : 0, 0 <= a && e.usesPrefixDiscriminator && (a += e.discriminator.layout.span)), super(a, i), this.union = e, this.variant = r, this.layout = n || null
    }

    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
        let i = 0;
        return this.layout && (i = this.layout.getSpan(e, r + n)), n + i
    }

    decode(e, r = 0) {
        const n = this.makeDestinationObject();
        if (this !== this.union.getVariant(e, r)) throw new Error("variant mismatch");
        let i = 0;
        return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, r + i) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
    }

    encode(e, r, n = 0) {
        let i = 0;
        if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e, this.property)) throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, r, n);
        let a = i;
        if (this.layout && (this.layout.encode(e[this.property], r, n + i), a += this.layout.getSpan(r, n + i), 0 <= this.union.span && a > this.union.span)) throw new Error("encoded variant overruns containing union");
        return a
    }

    fromArray(e) {
        if (this.layout) return this.layout.fromArray(e)
    }
}

tt.VariantLayout = bxe;

function vx(t) {
    return 0 > t && (t += 4294967296), t
}

class RZ extends oa {
    constructor(e, r, n) {
        if (!(e instanceof Gd || e instanceof lp)) throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof r == "string" && n === void 0 && (n = r, r = !1), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
        super(e.span, n), this.word = e, this.msb = !!r, this.fields = [];
        let i = 0;
        this._packedSetValue = function (a) {
            return i = vx(a), this
        }, this._packedGetValue = function () {
            return i
        }
    }

    decode(e, r = 0) {
        const n = this.makeDestinationObject(), i = this.word.decode(e, r);
        this._packedSetValue(i);
        for (const a of this.fields) a.property !== void 0 && (n[a.property] = a.decode(e));
        return n
    }

    encode(e, r, n = 0) {
        const i = this.word.decode(r, n);
        this._packedSetValue(i);
        for (const a of this.fields) if (a.property !== void 0) {
            const o = e[a.property];
            o !== void 0 && a.encode(o)
        }
        return this.word.encode(this._packedGetValue(), r, n)
    }

    addField(e, r) {
        const n = new DZ(this, e, r);
        return this.fields.push(n), n
    }

    addBoolean(e) {
        const r = new wxe(this, e);
        return this.fields.push(r), r
    }

    fieldFor(e) {
        if (typeof e != "string") throw new TypeError("property must be string");
        for (const r of this.fields) if (r.property === e) return r
    }
}

tt.BitStructure = RZ;

class DZ {
    constructor(e, r, n) {
        if (!(e instanceof RZ)) throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(r) || 0 >= r) throw new TypeError("bits must be positive integer");
        const i = 8 * e.span, a = e.fields.reduce((o, s) => o + s.bits, 0);
        if (r + a > i) throw new Error("bits too long for span remainder (" + (i - a) + " of " + i + " remain)");
        this.container = e, this.bits = r, this.valueMask = (1 << r) - 1, r === 32 && (this.valueMask = 4294967295), this.start = a, this.container.msb && (this.start = i - a - r), this.wordMask = vx(this.valueMask << this.start), this.property = n
    }

    decode(e, r) {
        const n = this.container._packedGetValue();
        return vx(n & this.wordMask) >>> this.start
    }

    encode(e) {
        if (typeof e != "number" || !Number.isInteger(e) || e !== vx(e & this.valueMask)) throw new TypeError(CZ("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const r = this.container._packedGetValue(), n = vx(e << this.start);
        this.container._packedSetValue(vx(r & ~this.wordMask) | n)
    }
}

tt.BitField = DZ;
let wxe = class extends DZ {
    constructor(e, r) {
        super(e, 1, r)
    }

    decode(e, r) {
        return !!super.decode(e, r)
    }

    encode(e) {
        typeof e == "boolean" && (e = +e), super.encode(e)
    }
};
tt.Boolean = wxe;
let Sxe = class extends oa {
    constructor(e, r) {
        if (!(e instanceof Ku && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let n = -1;
        e instanceof Ku || (n = e), super(n, r), this.length = e
    }

    getSpan(e, r) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(e, r)), n
    }

    decode(e, r = 0) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(e, r)), Bi(e).slice(r, r + n)
    }

    encode(e, r, n) {
        let i = this.length;
        if (this.length instanceof Ku && (i = e.length), !(e instanceof Uint8Array && i === e.length)) throw new TypeError(CZ("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
        if (n + i > r.length) throw new RangeError("encoding overruns Uint8Array");
        const a = Bi(e);
        return Bi(r).write(a.toString("hex"), n, i, "hex"), this.length instanceof Ku && this.length.encode(i, r, n), i
    }
};
tt.Blob = Sxe;

class _xe extends oa {
    constructor(e) {
        super(-1, e)
    }

    getSpan(e, r = 0) {
        JE(e);
        let n = r;
        for (; n < e.length && e[n] !== 0;) n += 1;
        return 1 + n - r
    }

    decode(e, r = 0) {
        const n = this.getSpan(e, r);
        return Bi(e).slice(r, r + n - 1).toString("utf-8")
    }

    encode(e, r, n = 0) {
        typeof e != "string" && (e = String(e));
        const i = TZ.Buffer.from(e, "utf8"), a = i.length;
        if (n + a > r.length) throw new RangeError("encoding overruns Buffer");
        const o = Bi(r);
        return i.copy(o, n), o[n + a] = 0, a + 1
    }
}

tt.CString = _xe;

class xxe extends oa {
    constructor(e, r) {
        if (typeof e == "string" && r === void 0 && (r = e, e = void 0), e === void 0) e = -1; else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
        super(-1, r), this.maxSpan = e
    }

    getSpan(e, r = 0) {
        return JE(e), e.length - r
    }

    decode(e, r = 0) {
        const n = this.getSpan(e, r);
        if (0 <= this.maxSpan && this.maxSpan < n) throw new RangeError("text length exceeds maxSpan");
        return Bi(e).slice(r, r + n).toString("utf-8")
    }

    encode(e, r, n = 0) {
        typeof e != "string" && (e = String(e));
        const i = TZ.Buffer.from(e, "utf8"), a = i.length;
        if (0 <= this.maxSpan && this.maxSpan < a) throw new RangeError("text length exceeds maxSpan");
        if (n + a > r.length) throw new RangeError("encoding overruns Buffer");
        return i.copy(Bi(r), n), a
    }
}

tt.UTF8 = xxe;

class Exe extends oa {
    constructor(e, r) {
        super(0, r), this.value = e
    }

    decode(e, r) {
        return this.value
    }

    encode(e, r, n) {
        return 0
    }
}

tt.Constant = Exe;
tt.greedy = (t, e) => new cxe(t, e);
var jw = tt.offset = (t, e, r) => new AZ(t, e, r), si = tt.u8 = t => new Gd(1, t), Ud = tt.u16 = t => new Gd(2, t);
tt.u24 = t => new Gd(3, t);
var Pr = tt.u32 = t => new Gd(4, t);
tt.u40 = t => new Gd(5, t);
tt.u48 = t => new Gd(6, t);
var Mc = tt.nu64 = t => new lxe(t);
tt.u16be = t => new lp(2, t);
tt.u24be = t => new lp(3, t);
tt.u32be = t => new lp(4, t);
tt.u40be = t => new lp(5, t);
tt.u48be = t => new lp(6, t);
tt.nu64be = t => new uxe(t);
tt.s8 = t => new VS(1, t);
tt.s16 = t => new VS(2, t);
tt.s24 = t => new VS(3, t);
tt.s32 = t => new VS(4, t);
tt.s40 = t => new VS(5, t);
tt.s48 = t => new VS(6, t);
var Df = tt.ns64 = t => new fxe(t);
tt.s16be = t => new e3(2, t);
tt.s24be = t => new e3(3, t);
tt.s32be = t => new e3(4, t);
tt.s40be = t => new e3(5, t);
tt.s48be = t => new e3(6, t);
tt.ns64be = t => new dxe(t);
tt.f32 = t => new hxe(t);
tt.f32be = t => new pxe(t);
tt.f64 = t => new mxe(t);
tt.f64be = t => new vxe(t);
var yr = tt.struct = (t, e, r) => new yxe(t, e, r);
tt.bits = (t, e, r) => new RZ(t, e, r);
var xl = tt.seq = (t, e, r) => new gxe(t, e, r);
tt.union = (t, e, r) => new kZ(t, e, r);
tt.unionLayoutDiscriminator = (t, e) => new SO(t, e);
var va = tt.blob = (t, e) => new Sxe(t, e);
tt.cstr = t => new _xe(t);
tt.utf8 = (t, e) => new xxe(t, e);
tt.constant = (t, e) => new Exe(t, e);
var W8 = {};
Object.defineProperty(W8, "__esModule", {value: !0});

function fvt(t) {
    {
        const e = kr.from(t);
        e.reverse();
        const r = e.toString("hex");
        return r.length === 0 ? BigInt(0) : BigInt(`0x${r}`)
    }
}

var Txe = W8.toBigIntLE = fvt;

function dvt(t) {
    {
        const e = t.toString("hex");
        return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`)
    }
}

W8.toBigIntBE = dvt;

function hvt(t, e) {
    {
        const r = t.toString(16), n = kr.from(r.padStart(e * 2, "0").slice(0, e * 2), "hex");
        return n.reverse(), n
    }
}

var Cxe = W8.toBufferLE = hvt;

function pvt(t, e) {
    {
        const r = t.toString(16);
        return kr.from(r.padStart(e * 2, "0").slice(0, e * 2), "hex")
    }
}

W8.toBufferBE = pvt;

class mvt extends TypeError {
    constructor(e, r) {
        let n;
        const {message: i, ...a} = e, {path: o} = e, s = o.length === 0 ? i : "At path: " + o.join(".") + " -- " + i;
        super(s), Object.assign(this, a), this.name = this.constructor.name, this.failures = () => {
            var l;
            return (l = n) != null ? l : n = [e, ...r()]
        }
    }
}

function vvt(t) {
    return $y(t) && typeof t[Symbol.iterator] == "function"
}

function $y(t) {
    return typeof t == "object" && t != null
}

function mp(t) {
    return typeof t == "string" ? JSON.stringify(t) : "" + t
}

function gvt(t) {
    const {done: e, value: r} = t.next();
    return e ? void 0 : r
}

function yvt(t, e, r, n) {
    if (t === !0) return;
    t === !1 ? t = {} : typeof t == "string" && (t = {message: t});
    const {path: i, branch: a} = e, {type: o} = r, {
        refinement: s,
        message: l = "Expected a value of type `" + o + "`" + (s ? " with refinement `" + s + "`" : "") + ", but received: `" + mp(n) + "`"
    } = t;
    return {value: n, type: o, refinement: s, key: i[i.length - 1], path: i, branch: a, ...t, message: l}
}

function* Pue(t, e, r, n) {
    vvt(t) || (t = [t]);
    for (const i of t) {
        const a = yvt(i, e, r, n);
        a && (yield a)
    }
}

function* MZ(t, e, r = {}) {
    const {path: n = [], branch: i = [t], coerce: a = !1, mask: o = !1} = r, s = {path: n, branch: i};
    if (a && (t = e.coercer(t, s), o && e.type !== "type" && $y(e.schema) && $y(t) && !Array.isArray(t))) for (const f in t) e.schema[f] === void 0 && delete t[f];
    let l = !0;
    for (const f of e.validator(t, s)) l = !1, yield[f, void 0];
    for (let [f, d, p] of e.entries(t, s)) {
        const g = MZ(d, p, {
            path: f === void 0 ? n : [...n, f],
            branch: f === void 0 ? i : [...i, d],
            coerce: a,
            mask: o
        });
        for (const b of g) b[0] ? (l = !1, yield[b[0], void 0]) : a && (d = b[1], f === void 0 ? t = d : t instanceof Map ? t.set(f, d) : t instanceof Set ? t.add(d) : $y(t) && (t[f] = d))
    }
    if (l) for (const f of e.refiner(t, s)) l = !1, yield[f, void 0];
    l && (yield[void 0, t])
}

let rm = class {
    constructor(e) {
        const {
            type: r, schema: n, validator: i, refiner: a, coercer: o = l => l, entries: s = function* () {
            }
        } = e;
        this.type = r, this.schema = n, this.entries = s, this.coercer = o, i ? this.validator = (l, f) => {
            const d = i(l, f);
            return Pue(d, f, this, l)
        } : this.validator = () => [], a ? this.refiner = (l, f) => {
            const d = a(l, f);
            return Pue(d, f, this, l)
        } : this.refiner = () => []
    }

    assert(e) {
        return bvt(e, this)
    }

    create(e) {
        return Ut(e, this)
    }

    is(e) {
        return Axe(e, this)
    }

    mask(e) {
        return wvt(e, this)
    }

    validate(e, r = {}) {
        return q8(e, this, r)
    }
};

function bvt(t, e) {
    const r = q8(t, e);
    if (r[0]) throw r[0]
}

function Ut(t, e) {
    const r = q8(t, e, {coerce: !0});
    if (r[0]) throw r[0];
    return r[1]
}

function wvt(t, e) {
    const r = q8(t, e, {coerce: !0, mask: !0});
    if (r[0]) throw r[0];
    return r[1]
}

function Axe(t, e) {
    return !q8(t, e)[0]
}

function q8(t, e, r = {}) {
    const n = MZ(t, e, r), i = gvt(n);
    return i[0] ? [new mvt(i[0], function* () {
        for (const o of n) o[0] && (yield o[0])
    }), void 0] : [void 0, i[1]]
}

function HS(t, e) {
    return new rm({type: t, schema: null, validator: e})
}

function Svt() {
    return HS("any", () => !0)
}

function er(t) {
    return new rm({
        type: "array", schema: t, * entries(e) {
            if (t && Array.isArray(e)) for (const [r, n] of e.entries()) yield[r, n, t]
        }, coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        }, validator(e) {
            return Array.isArray(e) || "Expected an array value, but received: " + mp(e)
        }
    })
}

function q0() {
    return HS("boolean", t => typeof t == "boolean")
}

function OZ(t) {
    return HS("instance", e => e instanceof t || "Expected a `" + t.name + "` instance, but received: " + mp(e))
}

function co(t) {
    const e = mp(t), r = typeof t;
    return new rm({
        type: "literal",
        schema: r === "string" || r === "number" || r === "boolean" ? t : null,
        validator(n) {
            return n === t || "Expected the literal `" + e + "`, but received: " + mp(n)
        }
    })
}

function _vt() {
    return HS("never", () => !1)
}

function Qt(t) {
    return new rm({
        ...t,
        validator: (e, r) => e === null || t.validator(e, r),
        refiner: (e, r) => e === null || t.refiner(e, r)
    })
}

function Ge() {
    return HS("number", t => typeof t == "number" && !isNaN(t) || "Expected a number, but received: " + mp(t))
}

function an(t) {
    return new rm({
        ...t,
        validator: (e, r) => e === void 0 || t.validator(e, r),
        refiner: (e, r) => e === void 0 || t.refiner(e, r)
    })
}

function Ixe(t, e) {
    return new rm({
        type: "record", schema: null, * entries(r) {
            if ($y(r)) for (const n in r) {
                const i = r[n];
                yield[n, n, t], yield[n, i, e]
            }
        }, validator(r) {
            return $y(r) || "Expected an object, but received: " + mp(r)
        }
    })
}

function Bt() {
    return HS("string", t => typeof t == "string" || "Expected a string, but received: " + mp(t))
}

function PZ(t) {
    const e = _vt();
    return new rm({
        type: "tuple", schema: null, * entries(r) {
            if (Array.isArray(r)) {
                const n = Math.max(t.length, r.length);
                for (let i = 0; i < n; i++) yield[i, r[i], t[i] || e]
            }
        }, validator(r) {
            return Array.isArray(r) || "Expected an array, but received: " + mp(r)
        }
    })
}

function Tt(t) {
    const e = Object.keys(t);
    return new rm({
        type: "type", schema: t, * entries(r) {
            if ($y(r)) for (const n of e) yield[n, r[n], t[n]]
        }, validator(r) {
            return $y(r) || "Expected an object, but received: " + mp(r)
        }
    })
}

function cf(t) {
    const e = t.map(r => r.type).join(" | ");
    return new rm({
        type: "union", schema: null, validator(r, n) {
            const i = [];
            for (const a of t) {
                const [...o] = MZ(r, a, n), [s] = o;
                if (s[0]) for (const [l] of o) l && i.push(l); else return []
            }
            return ["Expected the value to satisfy a union of `" + e + "`, but received: " + mp(r), ...i]
        }
    })
}

function G8() {
    return HS("unknown", () => !0)
}

function K8(t, e, r) {
    return new rm({...t, coercer: (n, i) => Axe(n, e) ? t.coercer(r(n, i), i) : t.coercer(n, i)})
}

var y7, xvt = new Uint8Array(16);

function kxe() {
    if (!y7 && (y7 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !y7)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return y7(xvt)
}

const Evt = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function UN(t) {
    return typeof t == "string" && Evt.test(t)
}

var Rc = [];
for (var nV = 0; nV < 256; ++nV) Rc.push((nV + 256).toString(16).substr(1));

function jN(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        r = (Rc[t[e + 0]] + Rc[t[e + 1]] + Rc[t[e + 2]] + Rc[t[e + 3]] + "-" + Rc[t[e + 4]] + Rc[t[e + 5]] + "-" + Rc[t[e + 6]] + Rc[t[e + 7]] + "-" + Rc[t[e + 8]] + Rc[t[e + 9]] + "-" + Rc[t[e + 10]] + Rc[t[e + 11]] + Rc[t[e + 12]] + Rc[t[e + 13]] + Rc[t[e + 14]] + Rc[t[e + 15]]).toLowerCase();
    if (!UN(r)) throw TypeError("Stringified UUID is invalid");
    return r
}

var Nue, iV, aV = 0, oV = 0;

function Tvt(t, e, r) {
    var n = e && r || 0, i = e || new Array(16);
    t = t || {};
    var a = t.node || Nue, o = t.clockseq !== void 0 ? t.clockseq : iV;
    if (a == null || o == null) {
        var s = t.random || (t.rng || kxe)();
        a == null && (a = Nue = [s[0] | 1, s[1], s[2], s[3], s[4], s[5]]), o == null && (o = iV = (s[6] << 8 | s[7]) & 16383)
    }
    var l = t.msecs !== void 0 ? t.msecs : Date.now(), f = t.nsecs !== void 0 ? t.nsecs : oV + 1,
        d = l - aV + (f - oV) / 1e4;
    if (d < 0 && t.clockseq === void 0 && (o = o + 1 & 16383), (d < 0 || l > aV) && t.nsecs === void 0 && (f = 0), f >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    aV = l, oV = f, iV = o, l += 122192928e5;
    var p = ((l & 268435455) * 1e4 + f) % 4294967296;
    i[n++] = p >>> 24 & 255, i[n++] = p >>> 16 & 255, i[n++] = p >>> 8 & 255, i[n++] = p & 255;
    var g = l / 4294967296 * 1e4 & 268435455;
    i[n++] = g >>> 8 & 255, i[n++] = g & 255, i[n++] = g >>> 24 & 15 | 16, i[n++] = g >>> 16 & 255, i[n++] = o >>> 8 | 128, i[n++] = o & 255;
    for (var b = 0; b < 6; ++b) i[n + b] = a[b];
    return e || jN(i)
}

function Rxe(t) {
    if (!UN(t)) throw TypeError("Invalid UUID");
    var e, r = new Uint8Array(16);
    return r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, r[1] = e >>> 16 & 255, r[2] = e >>> 8 & 255, r[3] = e & 255, r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, r[5] = e & 255, r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, r[7] = e & 255, r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, r[9] = e & 255, r[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = e / 4294967296 & 255, r[12] = e >>> 24 & 255, r[13] = e >>> 16 & 255, r[14] = e >>> 8 & 255, r[15] = e & 255, r
}

function Cvt(t) {
    t = unescape(encodeURIComponent(t));
    for (var e = [], r = 0; r < t.length; ++r) e.push(t.charCodeAt(r));
    return e
}

var Avt = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Ivt = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";

function Dxe(t, e, r) {
    function n(i, a, o, s) {
        if (typeof i == "string" && (i = Cvt(i)), typeof a == "string" && (a = Rxe(a)), a.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var l = new Uint8Array(16 + i.length);
        if (l.set(a), l.set(i, a.length), l = r(l), l[6] = l[6] & 15 | e, l[8] = l[8] & 63 | 128, o) {
            s = s || 0;
            for (var f = 0; f < 16; ++f) o[s + f] = l[f];
            return o
        }
        return jN(l)
    }

    try {
        n.name = t
    } catch {
    }
    return n.DNS = Avt, n.URL = Ivt, n
}

function kvt(t) {
    if (typeof t == "string") {
        var e = unescape(encodeURIComponent(t));
        t = new Uint8Array(e.length);
        for (var r = 0; r < e.length; ++r) t[r] = e.charCodeAt(r)
    }
    return Rvt(Dvt(Mvt(t), t.length * 8))
}

function Rvt(t) {
    for (var e = [], r = t.length * 32, n = "0123456789abcdef", i = 0; i < r; i += 8) {
        var a = t[i >> 5] >>> i % 32 & 255, o = parseInt(n.charAt(a >>> 4 & 15) + n.charAt(a & 15), 16);
        e.push(o)
    }
    return e
}

function Mxe(t) {
    return (t + 64 >>> 9 << 4) + 14 + 1
}

function Dvt(t, e) {
    t[e >> 5] |= 128 << e % 32, t[Mxe(e) - 1] = e;
    for (var r = 1732584193, n = -271733879, i = -1732584194, a = 271733878, o = 0; o < t.length; o += 16) {
        var s = r, l = n, f = i, d = a;
        r = vl(r, n, i, a, t[o], 7, -680876936), a = vl(a, r, n, i, t[o + 1], 12, -389564586), i = vl(i, a, r, n, t[o + 2], 17, 606105819), n = vl(n, i, a, r, t[o + 3], 22, -1044525330), r = vl(r, n, i, a, t[o + 4], 7, -176418897), a = vl(a, r, n, i, t[o + 5], 12, 1200080426), i = vl(i, a, r, n, t[o + 6], 17, -1473231341), n = vl(n, i, a, r, t[o + 7], 22, -45705983), r = vl(r, n, i, a, t[o + 8], 7, 1770035416), a = vl(a, r, n, i, t[o + 9], 12, -1958414417), i = vl(i, a, r, n, t[o + 10], 17, -42063), n = vl(n, i, a, r, t[o + 11], 22, -1990404162), r = vl(r, n, i, a, t[o + 12], 7, 1804603682), a = vl(a, r, n, i, t[o + 13], 12, -40341101), i = vl(i, a, r, n, t[o + 14], 17, -1502002290), n = vl(n, i, a, r, t[o + 15], 22, 1236535329), r = gl(r, n, i, a, t[o + 1], 5, -165796510), a = gl(a, r, n, i, t[o + 6], 9, -1069501632), i = gl(i, a, r, n, t[o + 11], 14, 643717713), n = gl(n, i, a, r, t[o], 20, -373897302), r = gl(r, n, i, a, t[o + 5], 5, -701558691), a = gl(a, r, n, i, t[o + 10], 9, 38016083), i = gl(i, a, r, n, t[o + 15], 14, -660478335), n = gl(n, i, a, r, t[o + 4], 20, -405537848), r = gl(r, n, i, a, t[o + 9], 5, 568446438), a = gl(a, r, n, i, t[o + 14], 9, -1019803690), i = gl(i, a, r, n, t[o + 3], 14, -187363961), n = gl(n, i, a, r, t[o + 8], 20, 1163531501), r = gl(r, n, i, a, t[o + 13], 5, -1444681467), a = gl(a, r, n, i, t[o + 2], 9, -51403784), i = gl(i, a, r, n, t[o + 7], 14, 1735328473), n = gl(n, i, a, r, t[o + 12], 20, -1926607734), r = yl(r, n, i, a, t[o + 5], 4, -378558), a = yl(a, r, n, i, t[o + 8], 11, -2022574463), i = yl(i, a, r, n, t[o + 11], 16, 1839030562), n = yl(n, i, a, r, t[o + 14], 23, -35309556), r = yl(r, n, i, a, t[o + 1], 4, -1530992060), a = yl(a, r, n, i, t[o + 4], 11, 1272893353), i = yl(i, a, r, n, t[o + 7], 16, -155497632), n = yl(n, i, a, r, t[o + 10], 23, -1094730640), r = yl(r, n, i, a, t[o + 13], 4, 681279174), a = yl(a, r, n, i, t[o], 11, -358537222), i = yl(i, a, r, n, t[o + 3], 16, -722521979), n = yl(n, i, a, r, t[o + 6], 23, 76029189), r = yl(r, n, i, a, t[o + 9], 4, -640364487), a = yl(a, r, n, i, t[o + 12], 11, -421815835), i = yl(i, a, r, n, t[o + 15], 16, 530742520), n = yl(n, i, a, r, t[o + 2], 23, -995338651), r = bl(r, n, i, a, t[o], 6, -198630844), a = bl(a, r, n, i, t[o + 7], 10, 1126891415), i = bl(i, a, r, n, t[o + 14], 15, -1416354905), n = bl(n, i, a, r, t[o + 5], 21, -57434055), r = bl(r, n, i, a, t[o + 12], 6, 1700485571), a = bl(a, r, n, i, t[o + 3], 10, -1894986606), i = bl(i, a, r, n, t[o + 10], 15, -1051523), n = bl(n, i, a, r, t[o + 1], 21, -2054922799), r = bl(r, n, i, a, t[o + 8], 6, 1873313359), a = bl(a, r, n, i, t[o + 15], 10, -30611744), i = bl(i, a, r, n, t[o + 6], 15, -1560198380), n = bl(n, i, a, r, t[o + 13], 21, 1309151649), r = bl(r, n, i, a, t[o + 4], 6, -145523070), a = bl(a, r, n, i, t[o + 11], 10, -1120210379), i = bl(i, a, r, n, t[o + 2], 15, 718787259), n = bl(n, i, a, r, t[o + 9], 21, -343485551), r = ky(r, s), n = ky(n, l), i = ky(i, f), a = ky(a, d)
    }
    return [r, n, i, a]
}

function Mvt(t) {
    if (t.length === 0) return [];
    for (var e = t.length * 8, r = new Uint32Array(Mxe(e)), n = 0; n < e; n += 8) r[n >> 5] |= (t[n / 8] & 255) << n % 32;
    return r
}

function ky(t, e) {
    var r = (t & 65535) + (e & 65535), n = (t >> 16) + (e >> 16) + (r >> 16);
    return n << 16 | r & 65535
}

function Ovt(t, e) {
    return t << e | t >>> 32 - e
}

function zN(t, e, r, n, i, a) {
    return ky(Ovt(ky(ky(e, t), ky(n, a)), i), r)
}

function vl(t, e, r, n, i, a, o) {
    return zN(e & r | ~e & n, t, e, i, a, o)
}

function gl(t, e, r, n, i, a, o) {
    return zN(e & n | r & ~n, t, e, i, a, o)
}

function yl(t, e, r, n, i, a, o) {
    return zN(e ^ r ^ n, t, e, i, a, o)
}

function bl(t, e, r, n, i, a, o) {
    return zN(r ^ (e | ~n), t, e, i, a, o)
}

var Pvt = Dxe("v3", 48, kvt);
const Nvt = Pvt;

function Lvt(t, e, r) {
    t = t || {};
    var n = t.random || (t.rng || kxe)();
    if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
        r = r || 0;
        for (var i = 0; i < 16; ++i) e[r + i] = n[i];
        return e
    }
    return jN(n)
}

function Bvt(t, e, r, n) {
    switch (t) {
        case 0:
            return e & r ^ ~e & n;
        case 1:
            return e ^ r ^ n;
        case 2:
            return e & r ^ e & n ^ r & n;
        case 3:
            return e ^ r ^ n
    }
}

function sV(t, e) {
    return t << e | t >>> 32 - e
}

function $vt(t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782],
        r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof t == "string") {
        var n = unescape(encodeURIComponent(t));
        t = [];
        for (var i = 0; i < n.length; ++i) t.push(n.charCodeAt(i))
    } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (var a = t.length / 4 + 2, o = Math.ceil(a / 16), s = new Array(o), l = 0; l < o; ++l) {
        for (var f = new Uint32Array(16), d = 0; d < 16; ++d) f[d] = t[l * 64 + d * 4] << 24 | t[l * 64 + d * 4 + 1] << 16 | t[l * 64 + d * 4 + 2] << 8 | t[l * 64 + d * 4 + 3];
        s[l] = f
    }
    s[o - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), s[o - 1][14] = Math.floor(s[o - 1][14]), s[o - 1][15] = (t.length - 1) * 8 & 4294967295;
    for (var p = 0; p < o; ++p) {
        for (var g = new Uint32Array(80), b = 0; b < 16; ++b) g[b] = s[p][b];
        for (var S = 16; S < 80; ++S) g[S] = sV(g[S - 3] ^ g[S - 8] ^ g[S - 14] ^ g[S - 16], 1);
        for (var T = r[0], I = r[1], N = r[2], P = r[3], F = r[4], V = 0; V < 80; ++V) {
            var Y = Math.floor(V / 20), ee = sV(T, 5) + Bvt(Y, I, N, P) + F + e[Y] + g[V] >>> 0;
            F = P, P = N, N = sV(I, 30) >>> 0, I = T, T = ee
        }
        r[0] = r[0] + T >>> 0, r[1] = r[1] + I >>> 0, r[2] = r[2] + N >>> 0, r[3] = r[3] + P >>> 0, r[4] = r[4] + F >>> 0
    }
    return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, r[0] & 255, r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, r[1] & 255, r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, r[2] & 255, r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, r[3] & 255, r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, r[4] & 255]
}

var Fvt = Dxe("v5", 80, $vt);
const Uvt = Fvt, jvt = "00000000-0000-0000-0000-000000000000";

function zvt(t) {
    if (!UN(t)) throw TypeError("Invalid UUID");
    return parseInt(t.substr(14, 1), 16)
}

const Vvt = Object.freeze(Object.defineProperty({
    __proto__: null,
    NIL: jvt,
    parse: Rxe,
    stringify: jN,
    v1: Tvt,
    v3: Nvt,
    v4: Lvt,
    v5: Uvt,
    validate: UN,
    version: zvt
}, Symbol.toStringTag, {value: "Module"})), Oxe = $P(Vvt), Hvt = Oxe.v4, Wvt = function (t, e, r, n) {
    if (typeof t != "string") throw new TypeError(t + " must be a string");
    n = n || {};
    const i = typeof n.version == "number" ? n.version : 2;
    if (i !== 1 && i !== 2) throw new TypeError(i + " must be 1 or 2");
    const a = {method: t};
    if (i === 2 && (a.jsonrpc = "2.0"), e) {
        if (typeof e != "object" && !Array.isArray(e)) throw new TypeError(e + " must be an object, array or omitted");
        a.params = e
    }
    if (typeof r > "u") {
        const o = typeof n.generator == "function" ? n.generator : function () {
            return Hvt()
        };
        a.id = o(a, n)
    } else i === 2 && r === null ? n.notificationIdNull && (a.id = null) : a.id = r;
    return a
};
var qvt = Wvt;
const Gvt = Oxe.v4, Kvt = qvt, bA = function (t, e) {
    if (!(this instanceof bA)) return new bA(t, e);
    e || (e = {}), this.options = {
        reviver: typeof e.reviver < "u" ? e.reviver : null,
        replacer: typeof e.replacer < "u" ? e.replacer : null,
        generator: typeof e.generator < "u" ? e.generator : function () {
            return Gvt()
        },
        version: typeof e.version < "u" ? e.version : 2,
        notificationIdNull: typeof e.notificationIdNull == "boolean" ? e.notificationIdNull : !1
    }, this.callServer = t
};
var Yvt = bA;
bA.prototype.request = function (t, e, r, n) {
    const i = this;
    let a = null;
    const o = Array.isArray(t) && typeof e == "function";
    if (this.options.version === 1 && o) throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (o || !o && t && typeof t == "object" && typeof e == "function") n = e, a = t; else {
        typeof r == "function" && (n = r, r = void 0);
        const f = typeof n == "function";
        try {
            a = Kvt(t, e, r, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (d) {
            if (f) return n(d);
            throw d
        }
        if (!f) return a
    }
    let l;
    try {
        l = JSON.stringify(a, this.options.replacer)
    } catch (f) {
        return n(f)
    }
    return this.callServer(l, function (f, d) {
        i._parseResponse(f, d, n)
    }), a
};
bA.prototype._parseResponse = function (t, e, r) {
    if (t) {
        r(t);
        return
    }
    if (!e) return r();
    let n;
    try {
        n = JSON.parse(e, this.options.reviver)
    } catch (i) {
        return r(i)
    }
    if (r.length === 3) if (Array.isArray(n)) {
        const i = function (o) {
            return typeof o.error < "u"
        }, a = function (o) {
            return !i(o)
        };
        return r(null, n.filter(i), n.filter(a))
    } else return r(null, n.error, n.result);
    r(null, n)
};
const Xvt = za(Yvt);
var Pxe = {}, Nxe = {exports: {}};
(function (t) {
    function e(r) {
        return r && r.__esModule ? r : {default: r}
    }

    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(Nxe);
var NZ = Nxe.exports, cV = {exports: {}}, lV = {exports: {}}, Lue;

function Y8() {
    return Lue || (Lue = 1, function (t) {
        function e(r) {
            "@babel/helpers - typeof";
            return t.exports = e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (n) {
                return typeof n
            } : function (n) {
                return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
            }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r)
        }

        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
    }(lV)), lV.exports
}

var Bue;

function Qvt() {
    return Bue || (Bue = 1, function (t) {
        var e = Y8().default;

        function r() {
            t.exports = r = function () {
                return i
            }, t.exports.__esModule = !0, t.exports.default = t.exports;
            var n, i = {}, a = Object.prototype, o = a.hasOwnProperty, s = Object.defineProperty || function ($, C, R) {
                    $[C] = R.value
                }, l = typeof Symbol == "function" ? Symbol : {}, f = l.iterator || "@@iterator",
                d = l.asyncIterator || "@@asyncIterator", p = l.toStringTag || "@@toStringTag";

            function g($, C, R) {
                return Object.defineProperty($, C, {value: R, enumerable: !0, configurable: !0, writable: !0}), $[C]
            }

            try {
                g({}, "")
            } catch {
                g = function (R, k, Q) {
                    return R[k] = Q
                }
            }

            function b($, C, R, k) {
                var Q = C && C.prototype instanceof V ? C : V, fe = Object.create(Q.prototype), ye = new z(k || []);
                return s(fe, "_invoke", {value: D($, R, ye)}), fe
            }

            function S($, C, R) {
                try {
                    return {type: "normal", arg: $.call(C, R)}
                } catch (k) {
                    return {type: "throw", arg: k}
                }
            }

            i.wrap = b;
            var T = "suspendedStart", I = "suspendedYield", N = "executing", P = "completed", F = {};

            function V() {
            }

            function Y() {
            }

            function ee() {
            }

            var oe = {};
            g(oe, f, function () {
                return this
            });
            var G = Object.getPrototypeOf, J = G && G(G(j([])));
            J && J !== a && o.call(J, f) && (oe = J);
            var ce = ee.prototype = V.prototype = Object.create(oe);

            function re($) {
                ["next", "throw", "return"].forEach(function (C) {
                    g($, C, function (R) {
                        return this._invoke(C, R)
                    })
                })
            }

            function M($, C) {
                function R(Q, fe, ye, ue) {
                    var me = S($[Q], $, fe);
                    if (me.type !== "throw") {
                        var Se = me.arg, Ce = Se.value;
                        return Ce && e(Ce) == "object" && o.call(Ce, "__await") ? C.resolve(Ce.__await).then(function (Me) {
                            R("next", Me, ye, ue)
                        }, function (Me) {
                            R("throw", Me, ye, ue)
                        }) : C.resolve(Ce).then(function (Me) {
                            Se.value = Me, ye(Se)
                        }, function (Me) {
                            return R("throw", Me, ye, ue)
                        })
                    }
                    ue(me.arg)
                }

                var k;
                s(this, "_invoke", {
                    value: function (fe, ye) {
                        function ue() {
                            return new C(function (me, Se) {
                                R(fe, ye, me, Se)
                            })
                        }

                        return k = k ? k.then(ue, ue) : ue()
                    }
                })
            }

            function D($, C, R) {
                var k = T;
                return function (Q, fe) {
                    if (k === N) throw Error("Generator is already running");
                    if (k === P) {
                        if (Q === "throw") throw fe;
                        return {value: n, done: !0}
                    }
                    for (R.method = Q, R.arg = fe; ;) {
                        var ye = R.delegate;
                        if (ye) {
                            var ue = x(ye, R);
                            if (ue) {
                                if (ue === F) continue;
                                return ue
                            }
                        }
                        if (R.method === "next") R.sent = R._sent = R.arg; else if (R.method === "throw") {
                            if (k === T) throw k = P, R.arg;
                            R.dispatchException(R.arg)
                        } else R.method === "return" && R.abrupt("return", R.arg);
                        k = N;
                        var me = S($, C, R);
                        if (me.type === "normal") {
                            if (k = R.done ? P : I, me.arg === F) continue;
                            return {value: me.arg, done: R.done}
                        }
                        me.type === "throw" && (k = P, R.method = "throw", R.arg = me.arg)
                    }
                }
            }

            function x($, C) {
                var R = C.method, k = $.iterator[R];
                if (k === n) return C.delegate = null, R === "throw" && $.iterator.return && (C.method = "return", C.arg = n, x($, C), C.method === "throw") || R !== "return" && (C.method = "throw", C.arg = new TypeError("The iterator does not provide a '" + R + "' method")), F;
                var Q = S(k, $.iterator, C.arg);
                if (Q.type === "throw") return C.method = "throw", C.arg = Q.arg, C.delegate = null, F;
                var fe = Q.arg;
                return fe ? fe.done ? (C[$.resultName] = fe.value, C.next = $.nextLoc, C.method !== "return" && (C.method = "next", C.arg = n), C.delegate = null, F) : fe : (C.method = "throw", C.arg = new TypeError("iterator result is not an object"), C.delegate = null, F)
            }

            function A($) {
                var C = {tryLoc: $[0]};
                1 in $ && (C.catchLoc = $[1]), 2 in $ && (C.finallyLoc = $[2], C.afterLoc = $[3]), this.tryEntries.push(C)
            }

            function B($) {
                var C = $.completion || {};
                C.type = "normal", delete C.arg, $.completion = C
            }

            function z($) {
                this.tryEntries = [{tryLoc: "root"}], $.forEach(A, this), this.reset(!0)
            }

            function j($) {
                if ($ || $ === "") {
                    var C = $[f];
                    if (C) return C.call($);
                    if (typeof $.next == "function") return $;
                    if (!isNaN($.length)) {
                        var R = -1, k = function Q() {
                            for (; ++R < $.length;) if (o.call($, R)) return Q.value = $[R], Q.done = !1, Q;
                            return Q.value = n, Q.done = !0, Q
                        };
                        return k.next = k
                    }
                }
                throw new TypeError(e($) + " is not iterable")
            }

            return Y.prototype = ee, s(ce, "constructor", {
                value: ee,
                configurable: !0
            }), s(ee, "constructor", {
                value: Y,
                configurable: !0
            }), Y.displayName = g(ee, p, "GeneratorFunction"), i.isGeneratorFunction = function ($) {
                var C = typeof $ == "function" && $.constructor;
                return !!C && (C === Y || (C.displayName || C.name) === "GeneratorFunction")
            }, i.mark = function ($) {
                return Object.setPrototypeOf ? Object.setPrototypeOf($, ee) : ($.__proto__ = ee, g($, p, "GeneratorFunction")), $.prototype = Object.create(ce), $
            }, i.awrap = function ($) {
                return {__await: $}
            }, re(M.prototype), g(M.prototype, d, function () {
                return this
            }), i.AsyncIterator = M, i.async = function ($, C, R, k, Q) {
                Q === void 0 && (Q = Promise);
                var fe = new M(b($, C, R, k), Q);
                return i.isGeneratorFunction(C) ? fe : fe.next().then(function (ye) {
                    return ye.done ? ye.value : fe.next()
                })
            }, re(ce), g(ce, p, "Generator"), g(ce, f, function () {
                return this
            }), g(ce, "toString", function () {
                return "[object Generator]"
            }), i.keys = function ($) {
                var C = Object($), R = [];
                for (var k in C) R.push(k);
                return R.reverse(), function Q() {
                    for (; R.length;) {
                        var fe = R.pop();
                        if (fe in C) return Q.value = fe, Q.done = !1, Q
                    }
                    return Q.done = !0, Q
                }
            }, i.values = j, z.prototype = {
                constructor: z, reset: function (C) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = n, this.done = !1, this.delegate = null, this.method = "next", this.arg = n, this.tryEntries.forEach(B), !C) for (var R in this) R.charAt(0) === "t" && o.call(this, R) && !isNaN(+R.slice(1)) && (this[R] = n)
                }, stop: function () {
                    this.done = !0;
                    var C = this.tryEntries[0].completion;
                    if (C.type === "throw") throw C.arg;
                    return this.rval
                }, dispatchException: function (C) {
                    if (this.done) throw C;
                    var R = this;

                    function k(Se, Ce) {
                        return ye.type = "throw", ye.arg = C, R.next = Se, Ce && (R.method = "next", R.arg = n), !!Ce
                    }

                    for (var Q = this.tryEntries.length - 1; Q >= 0; --Q) {
                        var fe = this.tryEntries[Q], ye = fe.completion;
                        if (fe.tryLoc === "root") return k("end");
                        if (fe.tryLoc <= this.prev) {
                            var ue = o.call(fe, "catchLoc"), me = o.call(fe, "finallyLoc");
                            if (ue && me) {
                                if (this.prev < fe.catchLoc) return k(fe.catchLoc, !0);
                                if (this.prev < fe.finallyLoc) return k(fe.finallyLoc)
                            } else if (ue) {
                                if (this.prev < fe.catchLoc) return k(fe.catchLoc, !0)
                            } else {
                                if (!me) throw Error("try statement without catch or finally");
                                if (this.prev < fe.finallyLoc) return k(fe.finallyLoc)
                            }
                        }
                    }
                }, abrupt: function (C, R) {
                    for (var k = this.tryEntries.length - 1; k >= 0; --k) {
                        var Q = this.tryEntries[k];
                        if (Q.tryLoc <= this.prev && o.call(Q, "finallyLoc") && this.prev < Q.finallyLoc) {
                            var fe = Q;
                            break
                        }
                    }
                    fe && (C === "break" || C === "continue") && fe.tryLoc <= R && R <= fe.finallyLoc && (fe = null);
                    var ye = fe ? fe.completion : {};
                    return ye.type = C, ye.arg = R, fe ? (this.method = "next", this.next = fe.finallyLoc, F) : this.complete(ye)
                }, complete: function (C, R) {
                    if (C.type === "throw") throw C.arg;
                    return C.type === "break" || C.type === "continue" ? this.next = C.arg : C.type === "return" ? (this.rval = this.arg = C.arg, this.method = "return", this.next = "end") : C.type === "normal" && R && (this.next = R), F
                }, finish: function (C) {
                    for (var R = this.tryEntries.length - 1; R >= 0; --R) {
                        var k = this.tryEntries[R];
                        if (k.finallyLoc === C) return this.complete(k.completion, k.afterLoc), B(k), F
                    }
                }, catch: function (C) {
                    for (var R = this.tryEntries.length - 1; R >= 0; --R) {
                        var k = this.tryEntries[R];
                        if (k.tryLoc === C) {
                            var Q = k.completion;
                            if (Q.type === "throw") {
                                var fe = Q.arg;
                                B(k)
                            }
                            return fe
                        }
                    }
                    throw Error("illegal catch attempt")
                }, delegateYield: function (C, R, k) {
                    return this.delegate = {
                        iterator: j(C),
                        resultName: R,
                        nextLoc: k
                    }, this.method === "next" && (this.arg = n), F
                }
            }, i
        }

        t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
    }(cV)), cV.exports
}

var uV, $ue;

function Zvt() {
    if ($ue) return uV;
    $ue = 1;
    var t = Qvt()();
    uV = t;
    try {
        regeneratorRuntime = t
    } catch {
        typeof globalThis == "object" ? globalThis.regeneratorRuntime = t : Function("r", "regeneratorRuntime = r")(t)
    }
    return uV
}

var fV = {exports: {}}, Fue;

function Jvt() {
    return Fue || (Fue = 1, function (t) {
        function e(n, i, a, o, s, l, f) {
            try {
                var d = n[l](f), p = d.value
            } catch (g) {
                a(g);
                return
            }
            d.done ? i(p) : Promise.resolve(p).then(o, s)
        }

        function r(n) {
            return function () {
                var i = this, a = arguments;
                return new Promise(function (o, s) {
                    var l = n.apply(i, a);

                    function f(p) {
                        e(l, o, s, f, d, "next", p)
                    }

                    function d(p) {
                        e(l, o, s, f, d, "throw", p)
                    }

                    f(void 0)
                })
            }
        }

        t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
    }(fV)), fV.exports
}

var dV = {exports: {}}, Uue;

function LZ() {
    return Uue || (Uue = 1, function (t) {
        function e(r, n) {
            if (!(r instanceof n)) throw new TypeError("Cannot call a class as a function")
        }

        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
    }(dV)), dV.exports
}

var hV = {exports: {}}, pV = {exports: {}}, mV = {exports: {}}, jue;

function egt() {
    return jue || (jue = 1, function (t) {
        var e = Y8().default;

        function r(n, i) {
            if (e(n) != "object" || !n) return n;
            var a = n[Symbol.toPrimitive];
            if (a !== void 0) {
                var o = a.call(n, i || "default");
                if (e(o) != "object") return o;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return (i === "string" ? String : Number)(n)
        }

        t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
    }(mV)), mV.exports
}

var zue;

function tgt() {
    return zue || (zue = 1, function (t) {
        var e = Y8().default, r = egt();

        function n(i) {
            var a = r(i, "string");
            return e(a) == "symbol" ? a : a + ""
        }

        t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports
    }(pV)), pV.exports
}

var Vue;

function BZ() {
    return Vue || (Vue = 1, function (t) {
        var e = tgt();

        function r(i, a) {
            for (var o = 0; o < a.length; o++) {
                var s = a[o];
                s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(i, e(s.key), s)
            }
        }

        function n(i, a, o) {
            return a && r(i.prototype, a), o && r(i, o), Object.defineProperty(i, "prototype", {writable: !1}), i
        }

        t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports
    }(hV)), hV.exports
}

var vV = {exports: {}}, gV = {exports: {}}, Hue;

function rgt() {
    return Hue || (Hue = 1, function (t) {
        function e(r, n) {
            return t.exports = e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (a, o) {
                return a.__proto__ = o, a
            }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r, n)
        }

        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
    }(gV)), gV.exports
}

var Wue;

function Lxe() {
    return Wue || (Wue = 1, function (t) {
        var e = rgt();

        function r(n, i) {
            if (typeof i != "function" && i !== null) throw new TypeError("Super expression must either be null or a function");
            n.prototype = Object.create(i && i.prototype, {
                constructor: {
                    value: n,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(n, "prototype", {writable: !1}), i && e(n, i)
        }

        t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
    }(vV)), vV.exports
}

var yV = {exports: {}}, bV = {exports: {}}, que;

function ngt() {
    return que || (que = 1, function (t) {
        function e(r) {
            if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r
        }

        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
    }(bV)), bV.exports
}

var Gue;

function Bxe() {
    return Gue || (Gue = 1, function (t) {
        var e = Y8().default, r = ngt();

        function n(i, a) {
            if (a && (e(a) === "object" || typeof a == "function")) return a;
            if (a !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return r(i)
        }

        t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports
    }(yV)), yV.exports
}

var wV = {exports: {}}, Kue;

function $xe() {
    return Kue || (Kue = 1, function (t) {
        function e(r) {
            return t.exports = e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (i) {
                return i.__proto__ || Object.getPrototypeOf(i)
            }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r)
        }

        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
    }(wV)), wV.exports
}

var tx = {}, Yue;

function igt() {
    if (Yue) return tx;
    Yue = 1;
    var t = NZ;
    Object.defineProperty(tx, "__esModule", {value: !0}), tx.DefaultDataPack = void 0, tx.createError = a;
    var e = t(LZ()), r = t(BZ()),
        n = new Map([[-32e3, "Event not provided"], [-32600, "Invalid Request"], [-32601, "Method not found"], [-32602, "Invalid params"], [-32603, "Internal error"], [-32604, "Params not found"], [-32605, "Method forbidden"], [-32606, "Event forbidden"], [-32700, "Parse error"]]),
        i = function () {
            function o() {
                (0, e.default)(this, o)
            }

            return (0, r.default)(o, [{
                key: "encode", value: function (l) {
                    return JSON.stringify(l)
                }
            }, {
                key: "decode", value: function (l) {
                    return JSON.parse(l)
                }
            }]), o
        }();
    tx.DefaultDataPack = i;

    function a(o, s) {
        var l = {code: o, message: n.get(o) || "Internal Server Error"};
        return s && (l.data = s), l
    }

    return tx
}

(function (t) {
    var e = NZ;
    Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0;
    var r = e(Zvt()), n = e(Jvt()), i = e(Y8()), a = e(LZ()), o = e(BZ()), s = e(Lxe()), l = e(Bxe()), f = e($xe()),
        d = vZ(), p = igt();

    function g(I) {
        var N = b();
        return function () {
            var F = (0, f.default)(I), V;
            if (N) {
                var Y = (0, f.default)(this).constructor;
                V = Reflect.construct(F, arguments, Y)
            } else V = F.apply(this, arguments);
            return (0, l.default)(this, V)
        }
    }

    function b() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
            })), !0
        } catch {
            return !1
        }
    }

    var S = function (I, N) {
        var P = {};
        for (var F in I) Object.prototype.hasOwnProperty.call(I, F) && N.indexOf(F) < 0 && (P[F] = I[F]);
        if (I != null && typeof Object.getOwnPropertySymbols == "function") for (var V = 0, F = Object.getOwnPropertySymbols(I); V < F.length; V++) N.indexOf(F[V]) < 0 && Object.prototype.propertyIsEnumerable.call(I, F[V]) && (P[F[V]] = I[F[V]]);
        return P
    }, T = function (I) {
        (0, s.default)(P, I);
        var N = g(P);

        function P(F) {
            var V, Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080",
                ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                oe = arguments.length > 3 ? arguments[3] : void 0, G = arguments.length > 4 ? arguments[4] : void 0;
            (0, a.default)(this, P);
            var J = ee.autoconnect, ce = J === void 0 ? !0 : J, re = ee.reconnect, M = re === void 0 ? !0 : re,
                D = ee.reconnect_interval, x = D === void 0 ? 1e3 : D, A = ee.max_reconnects, B = A === void 0 ? 5 : A,
                z = S(ee, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
            return V = N.call(this), V.webSocketFactory = F, V.queue = {}, V.rpc_id = 0, V.address = Y, V.autoconnect = ce, V.ready = !1, V.reconnect = M, V.reconnect_timer_id = void 0, V.reconnect_interval = x, V.max_reconnects = B, V.rest_options = z, V.current_reconnects = 0, V.generate_request_id = oe || function () {
                return ++V.rpc_id
            }, G ? V.dataPack = G : V.dataPack = new p.DefaultDataPack, V.autoconnect && V._connect(V.address, Object.assign({
                autoconnect: V.autoconnect,
                reconnect: V.reconnect,
                reconnect_interval: V.reconnect_interval,
                max_reconnects: V.max_reconnects
            }, V.rest_options)), V
        }

        return (0, o.default)(P, [{
            key: "connect", value: function () {
                this.socket || this._connect(this.address, Object.assign({
                    autoconnect: this.autoconnect,
                    reconnect: this.reconnect,
                    reconnect_interval: this.reconnect_interval,
                    max_reconnects: this.max_reconnects
                }, this.rest_options))
            }
        }, {
            key: "call", value: function (V, Y, ee, oe) {
                var G = this;
                return !oe && (0, i.default)(ee) === "object" && (oe = ee, ee = null), new Promise(function (J, ce) {
                    if (!G.ready) return ce(new Error("socket not ready"));
                    var re = G.generate_request_id(V, Y), M = {jsonrpc: "2.0", method: V, params: Y || void 0, id: re};
                    G.socket.send(G.dataPack.encode(M), oe, function (D) {
                        if (D) return ce(D);
                        G.queue[re] = {promise: [J, ce]}, ee && (G.queue[re].timeout = setTimeout(function () {
                            delete G.queue[re], ce(new Error("reply timeout"))
                        }, ee))
                    })
                })
            }
        }, {
            key: "login", value: function () {
                var F = (0, n.default)(r.default.mark(function Y(ee) {
                    var oe;
                    return r.default.wrap(function (J) {
                        for (; ;) switch (J.prev = J.next) {
                            case 0:
                                return J.next = 2, this.call("rpc.login", ee);
                            case 2:
                                if (oe = J.sent, oe) {
                                    J.next = 5;
                                    break
                                }
                                throw new Error("authentication failed");
                            case 5:
                                return J.abrupt("return", oe);
                            case 6:
                            case"end":
                                return J.stop()
                        }
                    }, Y, this)
                }));

                function V(Y) {
                    return F.apply(this, arguments)
                }

                return V
            }()
        }, {
            key: "listMethods", value: function () {
                var F = (0, n.default)(r.default.mark(function Y() {
                    return r.default.wrap(function (oe) {
                        for (; ;) switch (oe.prev = oe.next) {
                            case 0:
                                return oe.next = 2, this.call("__listMethods");
                            case 2:
                                return oe.abrupt("return", oe.sent);
                            case 3:
                            case"end":
                                return oe.stop()
                        }
                    }, Y, this)
                }));

                function V() {
                    return F.apply(this, arguments)
                }

                return V
            }()
        }, {
            key: "notify", value: function (V, Y) {
                var ee = this;
                return new Promise(function (oe, G) {
                    if (!ee.ready) return G(new Error("socket not ready"));
                    var J = {jsonrpc: "2.0", method: V, params: Y};
                    ee.socket.send(ee.dataPack.encode(J), function (ce) {
                        if (ce) return G(ce);
                        oe()
                    })
                })
            }
        }, {
            key: "subscribe", value: function () {
                var F = (0, n.default)(r.default.mark(function Y(ee) {
                    var oe;
                    return r.default.wrap(function (J) {
                        for (; ;) switch (J.prev = J.next) {
                            case 0:
                                return typeof ee == "string" && (ee = [ee]), J.next = 3, this.call("rpc.on", ee);
                            case 3:
                                if (oe = J.sent, !(typeof ee == "string" && oe[ee] !== "ok")) {
                                    J.next = 6;
                                    break
                                }
                                throw new Error("Failed subscribing to an event '" + ee + "' with: " + oe[ee]);
                            case 6:
                                return J.abrupt("return", oe);
                            case 7:
                            case"end":
                                return J.stop()
                        }
                    }, Y, this)
                }));

                function V(Y) {
                    return F.apply(this, arguments)
                }

                return V
            }()
        }, {
            key: "unsubscribe", value: function () {
                var F = (0, n.default)(r.default.mark(function Y(ee) {
                    var oe;
                    return r.default.wrap(function (J) {
                        for (; ;) switch (J.prev = J.next) {
                            case 0:
                                return typeof ee == "string" && (ee = [ee]), J.next = 3, this.call("rpc.off", ee);
                            case 3:
                                if (oe = J.sent, !(typeof ee == "string" && oe[ee] !== "ok")) {
                                    J.next = 6;
                                    break
                                }
                                throw new Error("Failed unsubscribing from an event with: " + oe);
                            case 6:
                                return J.abrupt("return", oe);
                            case 7:
                            case"end":
                                return J.stop()
                        }
                    }, Y, this)
                }));

                function V(Y) {
                    return F.apply(this, arguments)
                }

                return V
            }()
        }, {
            key: "close", value: function (V, Y) {
                this.socket.close(V || 1e3, Y)
            }
        }, {
            key: "_connect", value: function (V, Y) {
                var ee = this;
                clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(V, Y), this.socket.addEventListener("open", function () {
                    ee.ready = !0, ee.emit("open"), ee.current_reconnects = 0
                }), this.socket.addEventListener("message", function (oe) {
                    var G = oe.data;
                    G instanceof ArrayBuffer && (G = kr.from(G).toString());
                    try {
                        G = ee.dataPack.decode(G)
                    } catch {
                        return
                    }
                    if (G.notification && ee.listeners(G.notification).length) {
                        if (!Object.keys(G.params).length) return ee.emit(G.notification);
                        var J = [G.notification];
                        if (G.params.constructor === Object) J.push(G.params); else for (var ce = 0; ce < G.params.length; ce++) J.push(G.params[ce]);
                        return Promise.resolve().then(function () {
                            ee.emit.apply(ee, J)
                        })
                    }
                    if (!ee.queue[G.id]) return G.method ? Promise.resolve().then(function () {
                        ee.emit(G.method, G == null ? void 0 : G.params)
                    }) : void 0;
                    "error" in G == "result" in G && ee.queue[G.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), ee.queue[G.id].timeout && clearTimeout(ee.queue[G.id].timeout), G.error ? ee.queue[G.id].promise[1](G.error) : ee.queue[G.id].promise[0](G.result), delete ee.queue[G.id]
                }), this.socket.addEventListener("error", function (oe) {
                    return ee.emit("error", oe)
                }), this.socket.addEventListener("close", function (oe) {
                    var G = oe.code, J = oe.reason;
                    ee.ready && setTimeout(function () {
                        return ee.emit("close", G, J)
                    }, 0), ee.ready = !1, ee.socket = void 0, G !== 1e3 && (ee.current_reconnects++, ee.reconnect && (ee.max_reconnects > ee.current_reconnects || ee.max_reconnects === 0) && (ee.reconnect_timer_id = setTimeout(function () {
                        return ee._connect(V, Y)
                    }, ee.reconnect_interval)))
                })
            }
        }]), P
    }(d.EventEmitter);
    t.default = T
})(Pxe);
const agt = za(Pxe);
var Fxe = {};
(function (t) {
    var e = NZ;
    Object.defineProperty(t, "__esModule", {value: !0}), t.default = p;
    var r = e(LZ()), n = e(BZ()), i = e(Lxe()), a = e(Bxe()), o = e($xe()), s = vZ();

    function l(g) {
        var b = f();
        return function () {
            var T = (0, o.default)(g), I;
            if (b) {
                var N = (0, o.default)(this).constructor;
                I = Reflect.construct(T, arguments, N)
            } else I = T.apply(this, arguments);
            return (0, a.default)(this, I)
        }
    }

    function f() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
            })), !0
        } catch {
            return !1
        }
    }

    var d = function (g) {
        (0, i.default)(S, g);
        var b = l(S);

        function S(T, I, N) {
            var P;
            return (0, r.default)(this, S), P = b.call(this), P.socket = new window.WebSocket(T, N), P.socket.onopen = function () {
                return P.emit("open")
            }, P.socket.onmessage = function (F) {
                return P.emit("message", F.data)
            }, P.socket.onerror = function (F) {
                return P.emit("error", F)
            }, P.socket.onclose = function (F) {
                P.emit("close", F.code, F.reason)
            }, P
        }

        return (0, n.default)(S, [{
            key: "send", value: function (I, N, P) {
                var F = P || N;
                try {
                    this.socket.send(I), F()
                } catch (V) {
                    F(V)
                }
            }
        }, {
            key: "close", value: function (I, N) {
                this.socket.close(I, N)
            }
        }, {
            key: "addEventListener", value: function (I, N, P) {
                this.socket.addEventListener(I, N, P)
            }
        }]), S
    }(s.EventEmitter);

    function p(g, b) {
        return new d(g, b)
    }
})(Fxe);
const ogt = za(Fxe);

function Xue(t) {
    try {
        return _Z.ExtendedPoint.fromHex(t), !0
    } catch {
        return !1
    }
}

const Uxe = (t, e) => _Z.sign(t, e.slice(0, 32)), sgt = _Z.verify,
    G4 = t => qr.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? qr.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : qr.Buffer.from(t);

class cgt {
    constructor(e) {
        Object.assign(this, e)
    }

    encode() {
        return qr.Buffer.from(oxe(PD, this))
    }

    static decode(e) {
        return sxe(PD, this, e)
    }

    static decodeUnchecked(e) {
        return txe(PD, this, e)
    }
}

const PD = new Map;
var jxe;
let zxe;
const lgt = 32, Fy = 32;

function ugt(t) {
    return t._bn !== void 0
}

let Que = 1;
zxe = Symbol.toStringTag;

class Sr extends cgt {
    constructor(e) {
        if (super({}), this._bn = void 0, ugt(e)) this._bn = e._bn; else {
            if (typeof e == "string") {
                const r = jc.decode(e);
                if (r.length != Fy) throw new Error("Invalid public key input");
                this._bn = new Qce(r)
            } else this._bn = new Qce(e);
            if (this._bn.byteLength() > Fy) throw new Error("Invalid public key input")
        }
    }

    static unique() {
        const e = new Sr(Que);
        return Que += 1, new Sr(e.toBuffer())
    }

    equals(e) {
        return this._bn.eq(e._bn)
    }

    toBase58() {
        return jc.encode(this.toBytes())
    }

    toJSON() {
        return this.toBase58()
    }

    toBytes() {
        const e = this.toBuffer();
        return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
    }

    toBuffer() {
        const e = this._bn.toArrayLike(qr.Buffer);
        if (e.length === Fy) return e;
        const r = qr.Buffer.alloc(32);
        return e.copy(r, 32 - e.length), r
    }

    get [zxe]() {
        return `PublicKey(${this.toString()})`
    }

    toString() {
        return this.toBase58()
    }

    static async createWithSeed(e, r, n) {
        const i = qr.Buffer.concat([e.toBuffer(), qr.Buffer.from(r), n.toBuffer()]), a = Oue(i);
        return new Sr(a)
    }

    static createProgramAddressSync(e, r) {
        let n = qr.Buffer.alloc(0);
        e.forEach(function (a) {
            if (a.length > lgt) throw new TypeError("Max seed length exceeded");
            n = qr.Buffer.concat([n, G4(a)])
        }), n = qr.Buffer.concat([n, r.toBuffer(), qr.Buffer.from("ProgramDerivedAddress")]);
        const i = Oue(n);
        if (Xue(i)) throw new Error("Invalid seeds, address must fall off the curve");
        return new Sr(i)
    }

    static async createProgramAddress(e, r) {
        return this.createProgramAddressSync(e, r)
    }

    static findProgramAddressSync(e, r) {
        let n = 255, i;
        for (; n != 0;) {
            try {
                const a = e.concat(qr.Buffer.from([n]));
                i = this.createProgramAddressSync(a, r)
            } catch (a) {
                if (a instanceof TypeError) throw a;
                n--;
                continue
            }
            return [i, n]
        }
        throw new Error("Unable to find a viable program address nonce")
    }

    static async findProgramAddress(e, r) {
        return this.findProgramAddressSync(e, r)
    }

    static isOnCurve(e) {
        const r = new Sr(e);
        return Xue(r.toBytes())
    }
}

jxe = Sr;
Sr.default = new jxe("11111111111111111111111111111111");
PD.set(Sr, {kind: "struct", fields: [["_bn", "u256"]]});
new Sr("BPFLoader1111111111111111111111111111111111");
const a4 = 1232, $Z = 127, wA = 64;

class Vxe extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: block height exceeded.`), this.signature = void 0, this.signature = e
    }
}

Object.defineProperty(Vxe.prototype, "name", {value: "TransactionExpiredBlockheightExceededError"});

class Hxe extends Error {
    constructor(e, r) {
        super(`Transaction was not confirmed in ${r.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = e
    }
}

Object.defineProperty(Hxe.prototype, "name", {value: "TransactionExpiredTimeoutError"});

class kT extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = e
    }
}

Object.defineProperty(kT.prototype, "name", {value: "TransactionExpiredNonceInvalidError"});

class _O {
    constructor(e, r) {
        this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = r
    }

    keySegments() {
        const e = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e
    }

    get(e) {
        for (const r of this.keySegments()) {
            if (e < r.length) return r[e];
            e -= r.length
        }
    }

    get length() {
        return this.keySegments().flat().length
    }

    compileInstructions(e) {
        if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
        const n = new Map;
        this.keySegments().flat().forEach((a, o) => {
            n.set(a.toBase58(), o)
        });
        const i = a => {
            const o = n.get(a.toBase58());
            if (o === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
            return o
        };
        return e.map(a => ({
            programIdIndex: i(a.programId),
            accountKeyIndexes: a.keys.map(o => i(o.pubkey)),
            data: a.data
        }))
    }
}

const ni = (t = "publicKey") => va(32, t), fgt = (t = "signature") => va(64, t), kx = (t = "string") => {
        const e = yr([Pr("length"), Pr("lengthPadding"), va(jw(Pr(), -8), "chars")], t), r = e.decode.bind(e),
            n = e.encode.bind(e), i = e;
        return i.decode = (a, o) => r(a, o).chars.toString(), i.encode = (a, o, s) => {
            const l = {chars: qr.Buffer.from(a, "utf8")};
            return n(l, o, s)
        }, i.alloc = a => Pr().span + Pr().span + qr.Buffer.from(a, "utf8").length, i
    }, dgt = (t = "authorized") => yr([ni("staker"), ni("withdrawer")], t),
    hgt = (t = "lockup") => yr([Df("unixTimestamp"), Df("epoch"), ni("custodian")], t),
    pgt = (t = "voteInit") => yr([ni("nodePubkey"), ni("authorizedVoter"), ni("authorizedWithdrawer"), si("commission")], t),
    mgt = (t = "voteAuthorizeWithSeedArgs") => yr([Pr("voteAuthorizationType"), ni("currentAuthorityDerivedKeyOwnerPubkey"), kx("currentAuthorityDerivedKeySeed"), ni("newAuthorized")], t);

function Mf(t) {
    let e = 0, r = 0;
    for (; ;) {
        let n = t.shift();
        if (e |= (n & 127) << r * 7, r += 1, !(n & 128)) break
    }
    return e
}

function Of(t, e) {
    let r = e;
    for (; ;) {
        let n = r & 127;
        if (r >>= 7, r == 0) {
            t.push(n);
            break
        } else n |= 128, t.push(n)
    }
}

function Ga(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}

class VN {
    constructor(e, r) {
        this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = r
    }

    static compile(e, r) {
        const n = new Map, i = o => {
            const s = o.toBase58();
            let l = n.get(s);
            return l === void 0 && (l = {isSigner: !1, isWritable: !1, isInvoked: !1}, n.set(s, l)), l
        }, a = i(r);
        a.isSigner = !0, a.isWritable = !0;
        for (const o of e) {
            i(o.programId).isInvoked = !0;
            for (const s of o.keys) {
                const l = i(s.pubkey);
                l.isSigner || (l.isSigner = s.isSigner), l.isWritable || (l.isWritable = s.isWritable)
            }
        }
        return new VN(r, n)
    }

    getMessageComponents() {
        const e = [...this.keyMetaMap.entries()];
        Ga(e.length <= 256, "Max static account keys length exceeded");
        const r = e.filter(([, l]) => l.isSigner && l.isWritable), n = e.filter(([, l]) => l.isSigner && !l.isWritable),
            i = e.filter(([, l]) => !l.isSigner && l.isWritable), a = e.filter(([, l]) => !l.isSigner && !l.isWritable),
            o = {
                numRequiredSignatures: r.length + n.length,
                numReadonlySignedAccounts: n.length,
                numReadonlyUnsignedAccounts: a.length
            };
        {
            Ga(r.length > 0, "Expected at least one writable signer key");
            const [l] = r[0];
            Ga(l === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const s = [...r.map(([l]) => new Sr(l)), ...n.map(([l]) => new Sr(l)), ...i.map(([l]) => new Sr(l)), ...a.map(([l]) => new Sr(l))];
        return [o, s]
    }

    extractTableLookup(e) {
        const [r, n] = this.drainKeysFoundInLookupTable(e.state.addresses, o => !o.isSigner && !o.isInvoked && o.isWritable), [i, a] = this.drainKeysFoundInLookupTable(e.state.addresses, o => !o.isSigner && !o.isInvoked && !o.isWritable);
        if (!(r.length === 0 && i.length === 0)) return [{
            accountKey: e.key,
            writableIndexes: r,
            readonlyIndexes: i
        }, {writable: n, readonly: a}]
    }

    drainKeysFoundInLookupTable(e, r) {
        const n = new Array, i = new Array;
        for (const [a, o] of this.keyMetaMap.entries()) if (r(o)) {
            const s = new Sr(a), l = e.findIndex(f => f.equals(s));
            l >= 0 && (Ga(l < 256, "Max lookup table index exceeded"), n.push(l), i.push(s), this.keyMetaMap.delete(a))
        }
        return [n, i]
    }
}

const Wxe = "Reached end of buffer unexpectedly";

function iv(t) {
    if (t.length === 0) throw new Error(Wxe);
    return t.shift()
}

function Pf(t, ...e) {
    const [r] = e;
    if (e.length === 2 ? r + (e[1] ?? 0) > t.length : r >= t.length) throw new Error(Wxe);
    return t.splice(...e)
}

class Bv {
    constructor(e) {
        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = e.header, this.accountKeys = e.accountKeys.map(r => new Sr(r)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach(r => this.indexToProgramIds.set(r.programIdIndex, this.accountKeys[r.programIdIndex]))
    }

    get version() {
        return "legacy"
    }

    get staticAccountKeys() {
        return this.accountKeys
    }

    get compiledInstructions() {
        return this.instructions.map(e => ({
            programIdIndex: e.programIdIndex,
            accountKeyIndexes: e.accounts,
            data: jc.decode(e.data)
        }))
    }

    get addressTableLookups() {
        return []
    }

    getAccountKeys() {
        return new _O(this.staticAccountKeys)
    }

    static compile(e) {
        const r = VN.compile(e.instructions, e.payerKey), [n, i] = r.getMessageComponents(),
            o = new _O(i).compileInstructions(e.instructions).map(s => ({
                programIdIndex: s.programIdIndex,
                accounts: s.accountKeyIndexes,
                data: jc.encode(s.data)
            }));
        return new Bv({header: n, accountKeys: i, recentBlockhash: e.recentBlockhash, instructions: o})
    }

    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }

    isAccountWritable(e) {
        const r = this.header.numRequiredSignatures;
        if (e >= this.header.numRequiredSignatures) {
            const n = e - r, a = this.accountKeys.length - r - this.header.numReadonlyUnsignedAccounts;
            return n < a
        } else {
            const n = r - this.header.numReadonlySignedAccounts;
            return e < n
        }
    }

    isProgramId(e) {
        return this.indexToProgramIds.has(e)
    }

    programIds() {
        return [...this.indexToProgramIds.values()]
    }

    nonProgramIds() {
        return this.accountKeys.filter((e, r) => !this.isProgramId(r))
    }

    serialize() {
        const e = this.accountKeys.length;
        let r = [];
        Of(r, e);
        const n = this.instructions.map(p => {
            const {accounts: g, programIdIndex: b} = p, S = Array.from(jc.decode(p.data));
            let T = [];
            Of(T, g.length);
            let I = [];
            return Of(I, S.length), {
                programIdIndex: b,
                keyIndicesCount: qr.Buffer.from(T),
                keyIndices: g,
                dataLength: qr.Buffer.from(I),
                data: S
            }
        });
        let i = [];
        Of(i, n.length);
        let a = qr.Buffer.alloc(a4);
        qr.Buffer.from(i).copy(a);
        let o = i.length;
        n.forEach(p => {
            const b = yr([si("programIdIndex"), va(p.keyIndicesCount.length, "keyIndicesCount"), xl(si("keyIndex"), p.keyIndices.length, "keyIndices"), va(p.dataLength.length, "dataLength"), xl(si("userdatum"), p.data.length, "data")]).encode(p, a, o);
            o += b
        }), a = a.slice(0, o);
        const s = yr([va(1, "numRequiredSignatures"), va(1, "numReadonlySignedAccounts"), va(1, "numReadonlyUnsignedAccounts"), va(r.length, "keyCount"), xl(ni("key"), e, "keys"), ni("recentBlockhash")]),
            l = {
                numRequiredSignatures: qr.Buffer.from([this.header.numRequiredSignatures]),
                numReadonlySignedAccounts: qr.Buffer.from([this.header.numReadonlySignedAccounts]),
                numReadonlyUnsignedAccounts: qr.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                keyCount: qr.Buffer.from(r),
                keys: this.accountKeys.map(p => G4(p.toBytes())),
                recentBlockhash: jc.decode(this.recentBlockhash)
            };
        let f = qr.Buffer.alloc(2048);
        const d = s.encode(l, f);
        return a.copy(f, d), f.slice(0, d + a.length)
    }

    static from(e) {
        let r = [...e];
        const n = iv(r);
        if (n !== (n & $Z)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const i = iv(r), a = iv(r), o = Mf(r);
        let s = [];
        for (let g = 0; g < o; g++) {
            const b = Pf(r, 0, Fy);
            s.push(new Sr(qr.Buffer.from(b)))
        }
        const l = Pf(r, 0, Fy), f = Mf(r);
        let d = [];
        for (let g = 0; g < f; g++) {
            const b = iv(r), S = Mf(r), T = Pf(r, 0, S), I = Mf(r), N = Pf(r, 0, I), P = jc.encode(qr.Buffer.from(N));
            d.push({programIdIndex: b, accounts: T, data: P})
        }
        const p = {
            header: {numRequiredSignatures: n, numReadonlySignedAccounts: i, numReadonlyUnsignedAccounts: a},
            recentBlockhash: jc.encode(qr.Buffer.from(l)),
            accountKeys: s,
            instructions: d
        };
        return new Bv(p)
    }
}

class SA {
    constructor(e) {
        this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups
    }

    get version() {
        return 0
    }

    get numAccountKeysFromLookups() {
        let e = 0;
        for (const r of this.addressTableLookups) e += r.readonlyIndexes.length + r.writableIndexes.length;
        return e
    }

    getAccountKeys(e) {
        let r;
        if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            r = e.accountKeysFromLookups
        } else if (e && "addressLookupTableAccounts" in e && e.addressLookupTableAccounts) r = this.resolveAddressTableLookups(e.addressLookupTableAccounts); else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new _O(this.staticAccountKeys, r)
    }

    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }

    isAccountWritable(e) {
        const r = this.header.numRequiredSignatures, n = this.staticAccountKeys.length;
        if (e >= n) {
            const i = e - n, a = this.addressTableLookups.reduce((o, s) => o + s.writableIndexes.length, 0);
            return i < a
        } else if (e >= this.header.numRequiredSignatures) {
            const i = e - r, o = n - r - this.header.numReadonlyUnsignedAccounts;
            return i < o
        } else {
            const i = r - this.header.numReadonlySignedAccounts;
            return e < i
        }
    }

    resolveAddressTableLookups(e) {
        const r = {writable: [], readonly: []};
        for (const n of this.addressTableLookups) {
            const i = e.find(a => a.key.equals(n.accountKey));
            if (!i) throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);
            for (const a of n.writableIndexes) if (a < i.state.addresses.length) r.writable.push(i.state.addresses[a]); else throw new Error(`Failed to find address for index ${a} in address lookup table ${n.accountKey.toBase58()}`);
            for (const a of n.readonlyIndexes) if (a < i.state.addresses.length) r.readonly.push(i.state.addresses[a]); else throw new Error(`Failed to find address for index ${a} in address lookup table ${n.accountKey.toBase58()}`)
        }
        return r
    }

    static compile(e) {
        const r = VN.compile(e.instructions, e.payerKey), n = new Array, i = {writable: new Array, readonly: new Array},
            a = e.addressLookupTableAccounts || [];
        for (const d of a) {
            const p = r.extractTableLookup(d);
            if (p !== void 0) {
                const [g, {writable: b, readonly: S}] = p;
                n.push(g), i.writable.push(...b), i.readonly.push(...S)
            }
        }
        const [o, s] = r.getMessageComponents(), f = new _O(s, i).compileInstructions(e.instructions);
        return new SA({
            header: o,
            staticAccountKeys: s,
            recentBlockhash: e.recentBlockhash,
            compiledInstructions: f,
            addressTableLookups: n
        })
    }

    serialize() {
        const e = Array();
        Of(e, this.staticAccountKeys.length);
        const r = this.serializeInstructions(), n = Array();
        Of(n, this.compiledInstructions.length);
        const i = this.serializeAddressTableLookups(), a = Array();
        Of(a, this.addressTableLookups.length);
        const o = yr([si("prefix"), yr([si("numRequiredSignatures"), si("numReadonlySignedAccounts"), si("numReadonlyUnsignedAccounts")], "header"), va(e.length, "staticAccountKeysLength"), xl(ni(), this.staticAccountKeys.length, "staticAccountKeys"), ni("recentBlockhash"), va(n.length, "instructionsLength"), va(r.length, "serializedInstructions"), va(a.length, "addressTableLookupsLength"), va(i.length, "serializedAddressTableLookups")]),
            s = new Uint8Array(a4), f = o.encode({
                prefix: 128,
                header: this.header,
                staticAccountKeysLength: new Uint8Array(e),
                staticAccountKeys: this.staticAccountKeys.map(d => d.toBytes()),
                recentBlockhash: jc.decode(this.recentBlockhash),
                instructionsLength: new Uint8Array(n),
                serializedInstructions: r,
                addressTableLookupsLength: new Uint8Array(a),
                serializedAddressTableLookups: i
            }, s);
        return s.slice(0, f)
    }

    serializeInstructions() {
        let e = 0;
        const r = new Uint8Array(a4);
        for (const n of this.compiledInstructions) {
            const i = Array();
            Of(i, n.accountKeyIndexes.length);
            const a = Array();
            Of(a, n.data.length);
            const o = yr([si("programIdIndex"), va(i.length, "encodedAccountKeyIndexesLength"), xl(si(), n.accountKeyIndexes.length, "accountKeyIndexes"), va(a.length, "encodedDataLength"), va(n.data.length, "data")]);
            e += o.encode({
                programIdIndex: n.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(i),
                accountKeyIndexes: n.accountKeyIndexes,
                encodedDataLength: new Uint8Array(a),
                data: n.data
            }, r, e)
        }
        return r.slice(0, e)
    }

    serializeAddressTableLookups() {
        let e = 0;
        const r = new Uint8Array(a4);
        for (const n of this.addressTableLookups) {
            const i = Array();
            Of(i, n.writableIndexes.length);
            const a = Array();
            Of(a, n.readonlyIndexes.length);
            const o = yr([ni("accountKey"), va(i.length, "encodedWritableIndexesLength"), xl(si(), n.writableIndexes.length, "writableIndexes"), va(a.length, "encodedReadonlyIndexesLength"), xl(si(), n.readonlyIndexes.length, "readonlyIndexes")]);
            e += o.encode({
                accountKey: n.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(i),
                writableIndexes: n.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(a),
                readonlyIndexes: n.readonlyIndexes
            }, r, e)
        }
        return r.slice(0, e)
    }

    static deserialize(e) {
        let r = [...e];
        const n = iv(r), i = n & $Z;
        Ga(n !== i, "Expected versioned message but received legacy message");
        const a = i;
        Ga(a === 0, `Expected versioned message with version 0 but found version ${a}`);
        const o = {numRequiredSignatures: iv(r), numReadonlySignedAccounts: iv(r), numReadonlyUnsignedAccounts: iv(r)},
            s = [], l = Mf(r);
        for (let S = 0; S < l; S++) s.push(new Sr(Pf(r, 0, Fy)));
        const f = jc.encode(Pf(r, 0, Fy)), d = Mf(r), p = [];
        for (let S = 0; S < d; S++) {
            const T = iv(r), I = Mf(r), N = Pf(r, 0, I), P = Mf(r), F = new Uint8Array(Pf(r, 0, P));
            p.push({programIdIndex: T, accountKeyIndexes: N, data: F})
        }
        const g = Mf(r), b = [];
        for (let S = 0; S < g; S++) {
            const T = new Sr(Pf(r, 0, Fy)), I = Mf(r), N = Pf(r, 0, I), P = Mf(r), F = Pf(r, 0, P);
            b.push({accountKey: T, writableIndexes: N, readonlyIndexes: F})
        }
        return new SA({
            header: o,
            staticAccountKeys: s,
            recentBlockhash: f,
            compiledInstructions: p,
            addressTableLookups: b
        })
    }
}

const FZ = {
    deserializeMessageVersion(t) {
        const e = t[0], r = e & $Z;
        return r === e ? "legacy" : r
    }, deserialize: t => {
        const e = FZ.deserializeMessageVersion(t);
        if (e === "legacy") return Bv.from(t);
        if (e === 0) return SA.deserialize(t);
        throw new Error(`Transaction message version ${e} deserialization is not supported`)
    }
};
let sy = function (t) {
    return t[t.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", t[t.PROCESSED = 1] = "PROCESSED", t[t.TIMED_OUT = 2] = "TIMED_OUT", t[t.NONCE_INVALID = 3] = "NONCE_INVALID", t
}({});
const vgt = qr.Buffer.alloc(wA).fill(0);

class Zue {
    constructor(e) {
        this.keys = void 0, this.programId = void 0, this.data = qr.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data)
    }

    toJSON() {
        return {
            keys: this.keys.map(({pubkey: e, isSigner: r, isWritable: n}) => ({
                pubkey: e.toJSON(),
                isSigner: r,
                isWritable: n
            })), programId: this.programId.toJSON(), data: [...this.data]
        }
    }
}

class Yh {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }

    constructor(e) {
        if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!e) if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, "nonceInfo")) {
            const {minContextSlot: r, nonceInfo: n} = e;
            this.minNonceContextSlot = r, this.nonceInfo = n
        } else if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
            const {blockhash: r, lastValidBlockHeight: n} = e;
            this.recentBlockhash = r, this.lastValidBlockHeight = n
        } else {
            const {recentBlockhash: r, nonceInfo: n} = e;
            n && (this.nonceInfo = n), this.recentBlockhash = r
        }
    }

    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(e => e.toJSON()),
            signers: this.signatures.map(({publicKey: e}) => e.toJSON())
        }
    }

    add(...e) {
        if (e.length === 0) throw new Error("No instructions");
        return e.forEach(r => {
            "instructions" in r ? this.instructions = this.instructions.concat(r.instructions) : "data" in r && "programId" in r && "keys" in r ? this.instructions.push(r) : this.instructions.push(new Zue(r))
        }), this
    }

    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
        let e, r;
        if (this.nonceInfo ? (e = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? r = [this.nonceInfo.nonceInstruction, ...this.instructions] : r = this.instructions) : (e = this.recentBlockhash, r = this.instructions), !e) throw new Error("Transaction recentBlockhash required");
        r.length < 1 && console.warn("No instructions provided");
        let n;
        if (this.feePayer) n = this.feePayer; else if (this.signatures.length > 0 && this.signatures[0].publicKey) n = this.signatures[0].publicKey; else throw new Error("Transaction fee payer required");
        for (let T = 0; T < r.length; T++) if (r[T].programId === void 0) throw new Error(`Transaction instruction index ${T} has undefined program id`);
        const i = [], a = [];
        r.forEach(T => {
            T.keys.forEach(N => {
                a.push({...N})
            });
            const I = T.programId.toString();
            i.includes(I) || i.push(I)
        }), i.forEach(T => {
            a.push({pubkey: new Sr(T), isSigner: !1, isWritable: !1})
        });
        const o = [];
        a.forEach(T => {
            const I = T.pubkey.toString(), N = o.findIndex(P => P.pubkey.toString() === I);
            N > -1 ? (o[N].isWritable = o[N].isWritable || T.isWritable, o[N].isSigner = o[N].isSigner || T.isSigner) : o.push(T)
        }), o.sort(function (T, I) {
            if (T.isSigner !== I.isSigner) return T.isSigner ? -1 : 1;
            if (T.isWritable !== I.isWritable) return T.isWritable ? -1 : 1;
            const N = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return T.pubkey.toBase58().localeCompare(I.pubkey.toBase58(), "en", N)
        });
        const s = o.findIndex(T => T.pubkey.equals(n));
        if (s > -1) {
            const [T] = o.splice(s, 1);
            T.isSigner = !0, T.isWritable = !0, o.unshift(T)
        } else o.unshift({pubkey: n, isSigner: !0, isWritable: !0});
        for (const T of this.signatures) {
            const I = o.findIndex(N => N.pubkey.equals(T.publicKey));
            if (I > -1) o[I].isSigner || (o[I].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.")); else throw new Error(`unknown signer: ${T.publicKey.toString()}`)
        }
        let l = 0, f = 0, d = 0;
        const p = [], g = [];
        o.forEach(({pubkey: T, isSigner: I, isWritable: N}) => {
            I ? (p.push(T.toString()), l += 1, N || (f += 1)) : (g.push(T.toString()), N || (d += 1))
        });
        const b = p.concat(g), S = r.map(T => {
            const {data: I, programId: N} = T;
            return {
                programIdIndex: b.indexOf(N.toString()),
                accounts: T.keys.map(P => b.indexOf(P.pubkey.toString())),
                data: jc.encode(I)
            }
        });
        return S.forEach(T => {
            Ga(T.programIdIndex >= 0), T.accounts.forEach(I => Ga(I >= 0))
        }), new Bv({
            header: {numRequiredSignatures: l, numReadonlySignedAccounts: f, numReadonlyUnsignedAccounts: d},
            accountKeys: b,
            recentBlockhash: e,
            instructions: S
        })
    }

    _compile() {
        const e = this.compileMessage(), r = e.accountKeys.slice(0, e.header.numRequiredSignatures);
        return this.signatures.length === r.length && this.signatures.every((i, a) => r[a].equals(i.publicKey)) || (this.signatures = r.map(n => ({
            signature: null,
            publicKey: n
        }))), e
    }

    serializeMessage() {
        return this._compile().serialize()
    }

    async getEstimatedFee(e) {
        return (await e.getFeeForMessage(this.compileMessage())).value
    }

    setSigners(...e) {
        if (e.length === 0) throw new Error("No signers");
        const r = new Set;
        this.signatures = e.filter(n => {
            const i = n.toString();
            return r.has(i) ? !1 : (r.add(i), !0)
        }).map(n => ({signature: null, publicKey: n}))
    }

    sign(...e) {
        if (e.length === 0) throw new Error("No signers");
        const r = new Set, n = [];
        for (const a of e) {
            const o = a.publicKey.toString();
            r.has(o) || (r.add(o), n.push(a))
        }
        this.signatures = n.map(a => ({signature: null, publicKey: a.publicKey}));
        const i = this._compile();
        this._partialSign(i, ...n)
    }

    partialSign(...e) {
        if (e.length === 0) throw new Error("No signers");
        const r = new Set, n = [];
        for (const a of e) {
            const o = a.publicKey.toString();
            r.has(o) || (r.add(o), n.push(a))
        }
        const i = this._compile();
        this._partialSign(i, ...n)
    }

    _partialSign(e, ...r) {
        const n = e.serialize();
        r.forEach(i => {
            const a = Uxe(n, i.secretKey);
            this._addSignature(i.publicKey, G4(a))
        })
    }

    addSignature(e, r) {
        this._compile(), this._addSignature(e, r)
    }

    _addSignature(e, r) {
        Ga(r.length === 64);
        const n = this.signatures.findIndex(i => e.equals(i.publicKey));
        if (n < 0) throw new Error(`unknown signer: ${e.toString()}`);
        this.signatures[n].signature = qr.Buffer.from(r)
    }

    verifySignatures(e = !0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), e)
    }

    _getMessageSignednessErrors(e, r) {
        const n = {};
        for (const {
            signature: i,
            publicKey: a
        } of this.signatures) i === null ? r && (n.missing || (n.missing = [])).push(a) : sgt(i, e, a.toBytes()) || (n.invalid || (n.invalid = [])).push(a);
        return n.invalid || n.missing ? n : void 0
    }

    serialize(e) {
        const {requireAllSignatures: r, verifySignatures: n} = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, e), i = this.serializeMessage();
        if (n) {
            const a = this._getMessageSignednessErrors(i, r);
            if (a) {
                let o = "Signature verification failed.";
                throw a.invalid && (o += `
Invalid signature for public key${a.invalid.length === 1 ? "" : "(s)"} [\`${a.invalid.map(s => s.toBase58()).join("`, `")}\`].`), a.missing && (o += `
Missing signature for public key${a.missing.length === 1 ? "" : "(s)"} [\`${a.missing.map(s => s.toBase58()).join("`, `")}\`].`), new Error(o)
            }
        }
        return this._serialize(i)
    }

    _serialize(e) {
        const {signatures: r} = this, n = [];
        Of(n, r.length);
        const i = n.length + r.length * 64 + e.length, a = qr.Buffer.alloc(i);
        return Ga(r.length < 256), qr.Buffer.from(n).copy(a, 0), r.forEach(({signature: o}, s) => {
            o !== null && (Ga(o.length === 64, "signature has invalid length"), qr.Buffer.from(o).copy(a, n.length + s * 64))
        }), e.copy(a, n.length + r.length * 64), Ga(a.length <= a4, `Transaction too large: ${a.length} > ${a4}`), a
    }

    get keys() {
        return Ga(this.instructions.length === 1), this.instructions[0].keys.map(e => e.pubkey)
    }

    get programId() {
        return Ga(this.instructions.length === 1), this.instructions[0].programId
    }

    get data() {
        return Ga(this.instructions.length === 1), this.instructions[0].data
    }

    static from(e) {
        let r = [...e];
        const n = Mf(r);
        let i = [];
        for (let a = 0; a < n; a++) {
            const o = Pf(r, 0, wA);
            i.push(jc.encode(qr.Buffer.from(o)))
        }
        return Yh.populate(Bv.from(r), i)
    }

    static populate(e, r = []) {
        const n = new Yh;
        return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), r.forEach((i, a) => {
            const o = {signature: i == jc.encode(vgt) ? null : jc.decode(i), publicKey: e.accountKeys[a]};
            n.signatures.push(o)
        }), e.instructions.forEach(i => {
            const a = i.accounts.map(o => {
                const s = e.accountKeys[o];
                return {
                    pubkey: s,
                    isSigner: n.signatures.some(l => l.publicKey.toString() === s.toString()) || e.isAccountSigner(o),
                    isWritable: e.isAccountWritable(o)
                }
            });
            n.instructions.push(new Zue({keys: a, programId: e.accountKeys[i.programIdIndex], data: jc.decode(i.data)}))
        }), n._message = e, n._json = n.toJSON(), n
    }
}

class K4 {
    get version() {
        return this.message.version
    }

    constructor(e, r) {
        if (this.signatures = void 0, this.message = void 0, r !== void 0) Ga(r.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = r; else {
            const n = [];
            for (let i = 0; i < e.header.numRequiredSignatures; i++) n.push(new Uint8Array(wA));
            this.signatures = n
        }
        this.message = e
    }

    serialize() {
        const e = this.message.serialize(), r = Array();
        Of(r, this.signatures.length);
        const n = yr([va(r.length, "encodedSignaturesLength"), xl(fgt(), this.signatures.length, "signatures"), va(e.length, "serializedMessage")]),
            i = new Uint8Array(2048), a = n.encode({
                encodedSignaturesLength: new Uint8Array(r),
                signatures: this.signatures,
                serializedMessage: e
            }, i);
        return i.slice(0, a)
    }

    static deserialize(e) {
        let r = [...e];
        const n = [], i = Mf(r);
        for (let o = 0; o < i; o++) n.push(new Uint8Array(Pf(r, 0, wA)));
        const a = FZ.deserialize(new Uint8Array(r));
        return new K4(a, n)
    }

    sign(e) {
        const r = this.message.serialize(),
            n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const i of e) {
            const a = n.findIndex(o => o.equals(i.publicKey));
            Ga(a >= 0, `Cannot sign with non signer key ${i.publicKey.toBase58()}`), this.signatures[a] = Uxe(r, i.secretKey)
        }
    }

    addSignature(e, r) {
        Ga(r.byteLength === 64, "Signature must be 64 bytes long");
        const i = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(a => a.equals(e));
        Ga(i >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`), this.signatures[i] = r
    }
}

const ggt = 160, ygt = 64, bgt = ggt / ygt, wgt = 1e3 / bgt;
new Sr("SysvarC1ock11111111111111111111111111111111");
new Sr("SysvarEpochSchedu1e111111111111111111111111");
new Sr("Sysvar1nstructions1111111111111111111111111");
new Sr("SysvarRecentB1ockHashes11111111111111111111");
new Sr("SysvarRent111111111111111111111111111111111");
new Sr("SysvarRewards111111111111111111111111111111");
new Sr("SysvarS1otHashes111111111111111111111111111");
new Sr("SysvarS1otHistory11111111111111111111111111");
new Sr("SysvarStakeHistory1111111111111111111111111");

function gx(t) {
    return new Promise(e => setTimeout(e, t))
}

const Sgt = Mc("lamportsPerSignature"),
    _gt = yr([Pr("version"), Pr("state"), ni("authorizedPubkey"), ni("nonce"), yr([Sgt], "feeCalculator")]);

class UZ {
    constructor(e) {
        this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = e.authorizedPubkey, this.nonce = e.nonce, this.feeCalculator = e.feeCalculator
    }

    static fromAccountData(e) {
        const r = _gt.decode(G4(e), 0);
        return new UZ({
            authorizedPubkey: new Sr(r.authorizedPubkey),
            nonce: new Sr(r.nonce).toString(),
            feeCalculator: r.feeCalculator
        })
    }
}

const xgt = t => {
    const e = t.decode.bind(t), r = t.encode.bind(t);
    return {decode: e, encode: r}
}, Egt = t => e => {
    const r = va(t, e), {encode: n, decode: i} = xgt(r), a = r;
    return a.decode = (o, s) => {
        const l = i(o, s);
        return Txe(qr.Buffer.from(l))
    }, a.encode = (o, s, l) => {
        const f = Cxe(o, t);
        return n(f, s, l)
    }, a
}, Y4 = Egt(8);
Object.freeze({
    Create: {index: 0, layout: yr([Pr("instruction"), Df("lamports"), Df("space"), ni("programId")])},
    Assign: {index: 1, layout: yr([Pr("instruction"), ni("programId")])},
    Transfer: {index: 2, layout: yr([Pr("instruction"), Y4("lamports")])},
    CreateWithSeed: {
        index: 3,
        layout: yr([Pr("instruction"), ni("base"), kx("seed"), Df("lamports"), Df("space"), ni("programId")])
    },
    AdvanceNonceAccount: {index: 4, layout: yr([Pr("instruction")])},
    WithdrawNonceAccount: {index: 5, layout: yr([Pr("instruction"), Df("lamports")])},
    InitializeNonceAccount: {index: 6, layout: yr([Pr("instruction"), ni("authorized")])},
    AuthorizeNonceAccount: {index: 7, layout: yr([Pr("instruction"), ni("authorized")])},
    Allocate: {index: 8, layout: yr([Pr("instruction"), Df("space")])},
    AllocateWithSeed: {index: 9, layout: yr([Pr("instruction"), ni("base"), kx("seed"), Df("space"), ni("programId")])},
    AssignWithSeed: {index: 10, layout: yr([Pr("instruction"), ni("base"), kx("seed"), ni("programId")])},
    TransferWithSeed: {index: 11, layout: yr([Pr("instruction"), Y4("lamports"), kx("seed"), ni("programId")])},
    UpgradeNonceAccount: {index: 12, layout: yr([Pr("instruction")])}
});
new Sr("11111111111111111111111111111111");
new Sr("BPFLoader2111111111111111111111111111111111");

function Tgt(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

var Cgt = Object.prototype.toString, Agt = Object.keys || function (t) {
    var e = [];
    for (var r in t) e.push(r);
    return e
};

function RT(t, e) {
    var r, n, i, a, o, s, l;
    if (t === !0) return "true";
    if (t === !1) return "false";
    switch (typeof t) {
        case"object":
            if (t === null) return null;
            if (t.toJSON && typeof t.toJSON == "function") return RT(t.toJSON(), e);
            if (l = Cgt.call(t), l === "[object Array]") {
                for (i = "[", n = t.length - 1, r = 0; r < n; r++) i += RT(t[r], !0) + ",";
                return n > -1 && (i += RT(t[r], !0)), i + "]"
            } else if (l === "[object Object]") {
                for (a = Agt(t).sort(), n = a.length, i = "", r = 0; r < n;) o = a[r], s = RT(t[o], !1), s !== void 0 && (i && (i += ","), i += JSON.stringify(o) + ":" + s), r++;
                return "{" + i + "}"
            } else return JSON.stringify(t);
        case"function":
        case"undefined":
            return e ? null : void 0;
        case"string":
            return JSON.stringify(t);
        default:
            return isFinite(t) ? t : null
    }
}

var Igt = function (t) {
    var e = RT(t, !1);
    if (e !== void 0) return "" + e
}, Jue = Tgt(Igt);
const J5 = 32;

function SV(t) {
    let e = 0;
    for (; t > 1;) t /= 2, e++;
    return e
}

function kgt(t) {
    return t === 0 ? 1 : (t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, t |= t >> 32, t + 1)
}

class Rgt {
    constructor(e, r, n, i, a) {
        this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = e, this.leaderScheduleSlotOffset = r, this.warmup = n, this.firstNormalEpoch = i, this.firstNormalSlot = a
    }

    getEpoch(e) {
        return this.getEpochAndSlotIndex(e)[0]
    }

    getEpochAndSlotIndex(e) {
        if (e < this.firstNormalSlot) {
            const r = SV(kgt(e + J5 + 1)) - SV(J5) - 1, n = this.getSlotsInEpoch(r), i = e - (n - J5);
            return [r, i]
        } else {
            const r = e - this.firstNormalSlot, n = Math.floor(r / this.slotsPerEpoch), i = this.firstNormalEpoch + n,
                a = r % this.slotsPerEpoch;
            return [i, a]
        }
    }

    getFirstSlotInEpoch(e) {
        return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * J5 : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }

    getLastSlotInEpoch(e) {
        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
    }

    getSlotsInEpoch(e) {
        return e < this.firstNormalEpoch ? Math.pow(2, e + SV(J5)) : this.slotsPerEpoch
    }
}

class efe extends Error {
    constructor(e, r) {
        super(e), this.logs = void 0, this.logs = r
    }
}

class Or extends Error {
    constructor({code: e, message: r, data: n}, i) {
        super(i != null ? `${i}: ${r}` : r), this.code = void 0, this.data = void 0, this.code = e, this.data = n, this.name = "SolanaJSONRPCError"
    }
}

var Dgt = globalThis.fetch;

class Mgt extends agt {
    constructor(e, r, n) {
        const i = a => {
            const o = ogt(a, {autoconnect: !0, max_reconnects: 5, reconnect: !0, reconnect_interval: 1e3, ...r});
            return "socket" in o ? this.underlyingSocket = o.socket : this.underlyingSocket = o, o
        };
        super(i, e, r, n), this.underlyingSocket = void 0
    }

    call(...e) {
        var n;
        const r = (n = this.underlyingSocket) == null ? void 0 : n.readyState;
        return r === 1 ? super.call(...e) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + r + ")"))
    }

    notify(...e) {
        var n;
        const r = (n = this.underlyingSocket) == null ? void 0 : n.readyState;
        return r === 1 ? super.notify(...e) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + e[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + r + ")"))
    }
}

function Ogt(t, e) {
    let r;
    try {
        r = t.layout.decode(e)
    } catch (n) {
        throw new Error("invalid instruction; " + n)
    }
    if (r.typeIndex !== t.index) throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${t.index}`);
    return r
}

const tfe = 56;

class rfe {
    constructor(e) {
        this.key = void 0, this.state = void 0, this.key = e.key, this.state = e.state
    }

    isActive() {
        const e = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === e
    }

    static deserialize(e) {
        const r = Ogt(Pgt, e), n = e.length - tfe;
        Ga(n >= 0, "lookup table is invalid"), Ga(n % 32 === 0, "lookup table is invalid");
        const i = n / 32, {addresses: a} = yr([xl(ni(), i, "addresses")]).decode(e.slice(tfe));
        return {
            deactivationSlot: r.deactivationSlot,
            lastExtendedSlot: r.lastExtendedSlot,
            lastExtendedSlotStartIndex: r.lastExtendedStartIndex,
            authority: r.authority.length !== 0 ? new Sr(r.authority[0]) : void 0,
            addresses: a.map(o => new Sr(o))
        }
    }
}

const Pgt = {
    index: 1,
    layout: yr([Pr("typeIndex"), Y4("deactivationSlot"), Mc("lastExtendedSlot"), si("lastExtendedStartIndex"), si(), xl(ni(), jw(si(), -1), "authority")])
}, Ngt = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;

function Lgt(t) {
    const e = t.match(Ngt);
    if (e == null) throw TypeError(`Failed to validate endpoint URL \`${t}\``);
    const [r, n, i, a] = e, o = t.startsWith("https:") ? "wss:" : "ws:",
        s = i == null ? null : parseInt(i.slice(1), 10), l = s == null ? "" : `:${s + 1}`;
    return `${o}//${n}${l}${a}`
}

const cs = K8(OZ(Sr), Bt(), t => new Sr(t)), qxe = PZ([Bt(), co("base64")]),
    jZ = K8(OZ(qr.Buffer), qxe, t => qr.Buffer.from(t[0], "base64")), Bgt = 30 * 1e3;

function $gt(t) {
    if (/^https?:/.test(t) === !1) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return t
}

function Wa(t) {
    let e, r;
    if (typeof t == "string") e = t; else if (t) {
        const {commitment: n, ...i} = t;
        e = n, r = i
    }
    return {commitment: e, config: r}
}

function Gxe(t) {
    return cf([Tt({jsonrpc: co("2.0"), id: Bt(), result: t}), Tt({
        jsonrpc: co("2.0"),
        id: Bt(),
        error: Tt({code: G8(), message: Bt(), data: an(Svt())})
    })])
}

const Fgt = Gxe(G8());

function jn(t) {
    return K8(Gxe(t), Fgt, e => "error" in e ? e : {...e, result: Ut(e.result, t)})
}

function To(t) {
    return jn(Tt({context: Tt({slot: Ge()}), value: t}))
}

function HN(t) {
    return Tt({context: Tt({slot: Ge()}), value: t})
}

function _V(t, e) {
    return t === 0 ? new SA({
        header: e.header,
        staticAccountKeys: e.accountKeys.map(r => new Sr(r)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map(r => ({
            programIdIndex: r.programIdIndex,
            accountKeyIndexes: r.accounts,
            data: jc.decode(r.data)
        })),
        addressTableLookups: e.addressTableLookups
    }) : new Bv(e)
}

const Ugt = Tt({foundation: Ge(), foundationTerm: Ge(), initial: Ge(), taper: Ge(), terminal: Ge()}),
    jgt = jn(er(Qt(Tt({epoch: Ge(), effectiveSlot: Ge(), amount: Ge(), postBalance: Ge(), commission: an(Qt(Ge()))})))),
    zgt = er(Tt({slot: Ge(), prioritizationFee: Ge()})),
    Vgt = Tt({total: Ge(), validator: Ge(), foundation: Ge(), epoch: Ge()}), Hgt = Tt({
        epoch: Ge(),
        slotIndex: Ge(),
        slotsInEpoch: Ge(),
        absoluteSlot: Ge(),
        blockHeight: an(Ge()),
        transactionCount: an(Ge())
    }), Wgt = Tt({
        slotsPerEpoch: Ge(),
        leaderScheduleSlotOffset: Ge(),
        warmup: q0(),
        firstNormalEpoch: Ge(),
        firstNormalSlot: Ge()
    }), qgt = Ixe(Bt(), er(Ge())), WS = Qt(cf([Tt({}), Bt()])), Ggt = Tt({err: WS}), Kgt = co("receivedSignature"),
    Ygt = Tt({"solana-core": Bt(), "feature-set": an(Ge())}), nfe = To(Tt({
        err: Qt(cf([Tt({}), Bt()])),
        logs: Qt(er(Bt())),
        accounts: an(Qt(er(Qt(Tt({executable: q0(), owner: Bt(), lamports: Ge(), data: er(Bt()), rentEpoch: an(Ge())}))))),
        unitsConsumed: an(Ge()),
        returnData: an(Qt(Tt({programId: Bt(), data: PZ([Bt(), co("base64")])})))
    })), Xgt = To(Tt({byIdentity: Ixe(Bt(), er(Ge())), range: Tt({firstSlot: Ge(), lastSlot: Ge()})}));

function Qgt(t, e, r, n, i, a) {
    const o = r || Dgt;
    let s;
    a != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    let l;
    return n && (l = async (d, p) => {
        const g = await new Promise((b, S) => {
            try {
                n(d, p, (T, I) => b([T, I]))
            } catch (T) {
                S(T)
            }
        });
        return await o(...g)
    }), new Xvt(async (d, p) => {
        const g = {
            method: "POST",
            body: d,
            agent: s,
            headers: Object.assign({"Content-Type": "application/json"}, e || {}, Zyt)
        };
        try {
            let b = 5, S, T = 500;
            for (; l ? S = await l(t, g) : S = await o(t, g), !(S.status !== 429 || i === !0 || (b -= 1, b === 0));) console.error(`Server responded with ${S.status} ${S.statusText}.  Retrying after ${T}ms delay...`), await gx(T), T *= 2;
            const I = await S.text();
            S.ok ? p(null, I) : p(new Error(`${S.status} ${S.statusText}: ${I}`))
        } catch (b) {
            b instanceof Error && p(b)
        }
    }, {})
}

function Zgt(t) {
    return (e, r) => new Promise((n, i) => {
        t.request(e, r, (a, o) => {
            if (a) {
                i(a);
                return
            }
            n(o)
        })
    })
}

function Jgt(t) {
    return e => new Promise((r, n) => {
        e.length === 0 && r([]);
        const i = e.map(a => t.request(a.methodName, a.args));
        t.request(i, (a, o) => {
            if (a) {
                n(a);
                return
            }
            r(o)
        })
    })
}

const eyt = jn(Ugt), tyt = jn(Vgt), ryt = jn(zgt), nyt = jn(Hgt), iyt = jn(Wgt), ayt = jn(qgt), oyt = jn(Ge()),
    syt = To(Tt({total: Ge(), circulating: Ge(), nonCirculating: Ge(), nonCirculatingAccounts: er(cs)})),
    GG = Tt({amount: Bt(), uiAmount: Qt(Ge()), decimals: Ge(), uiAmountString: an(Bt())}),
    cyt = To(er(Tt({address: cs, amount: Bt(), uiAmount: Qt(Ge()), decimals: Ge(), uiAmountString: an(Bt())}))),
    lyt = To(er(Tt({
        pubkey: cs,
        account: Tt({executable: q0(), owner: cs, lamports: Ge(), data: jZ, rentEpoch: Ge()})
    }))), KG = Tt({program: Bt(), parsed: G8(), space: Ge()}), uyt = To(er(Tt({
        pubkey: cs,
        account: Tt({executable: q0(), owner: cs, lamports: Ge(), data: KG, rentEpoch: Ge()})
    }))), fyt = To(er(Tt({lamports: Ge(), address: cs}))),
    _A = Tt({executable: q0(), owner: cs, lamports: Ge(), data: jZ, rentEpoch: Ge()}),
    dyt = Tt({pubkey: cs, account: _A}),
    hyt = K8(cf([OZ(qr.Buffer), KG]), cf([qxe, KG]), t => Array.isArray(t) ? Ut(t, jZ) : t),
    YG = Tt({executable: q0(), owner: cs, lamports: Ge(), data: hyt, rentEpoch: Ge()}),
    pyt = Tt({pubkey: cs, account: YG}), myt = Tt({
        state: cf([co("active"), co("inactive"), co("activating"), co("deactivating")]),
        active: Ge(),
        inactive: Ge()
    }), vyt = jn(er(Tt({signature: Bt(), slot: Ge(), err: WS, memo: Qt(Bt()), blockTime: an(Qt(Ge()))}))),
    gyt = jn(er(Tt({signature: Bt(), slot: Ge(), err: WS, memo: Qt(Bt()), blockTime: an(Qt(Ge()))}))),
    yyt = Tt({subscription: Ge(), result: HN(_A)}), byt = Tt({pubkey: cs, account: _A}),
    wyt = Tt({subscription: Ge(), result: HN(byt)}), Syt = Tt({parent: Ge(), slot: Ge(), root: Ge()}),
    _yt = Tt({subscription: Ge(), result: Syt}), xyt = cf([Tt({
        type: cf([co("firstShredReceived"), co("completed"), co("optimisticConfirmation"), co("root")]),
        slot: Ge(),
        timestamp: Ge()
    }), Tt({type: co("createdBank"), parent: Ge(), slot: Ge(), timestamp: Ge()}), Tt({
        type: co("frozen"),
        slot: Ge(),
        timestamp: Ge(),
        stats: Tt({
            numTransactionEntries: Ge(),
            numSuccessfulTransactions: Ge(),
            numFailedTransactions: Ge(),
            maxTransactionsPerEntry: Ge()
        })
    }), Tt({type: co("dead"), slot: Ge(), timestamp: Ge(), err: Bt()})]), Eyt = Tt({subscription: Ge(), result: xyt}),
    Tyt = Tt({subscription: Ge(), result: HN(cf([Ggt, Kgt]))}), Cyt = Tt({subscription: Ge(), result: Ge()}),
    Ayt = Tt({pubkey: Bt(), gossip: Qt(Bt()), tpu: Qt(Bt()), rpc: Qt(Bt()), version: Qt(Bt())}), ife = Tt({
        votePubkey: Bt(),
        nodePubkey: Bt(),
        activatedStake: Ge(),
        epochVoteAccount: q0(),
        epochCredits: er(PZ([Ge(), Ge(), Ge()])),
        commission: Ge(),
        lastVote: Ge(),
        rootSlot: Qt(Ge())
    }), Iyt = jn(Tt({current: er(ife), delinquent: er(ife)})),
    kyt = cf([co("processed"), co("confirmed"), co("finalized")]),
    Ryt = Tt({slot: Ge(), confirmations: Qt(Ge()), err: WS, confirmationStatus: an(kyt)}), Dyt = To(er(Qt(Ryt))),
    Myt = jn(Ge()), Kxe = Tt({accountKey: cs, writableIndexes: er(Ge()), readonlyIndexes: er(Ge())}), zZ = Tt({
        signatures: er(Bt()),
        message: Tt({
            accountKeys: er(Bt()),
            header: Tt({numRequiredSignatures: Ge(), numReadonlySignedAccounts: Ge(), numReadonlyUnsignedAccounts: Ge()}),
            instructions: er(Tt({accounts: er(Ge()), data: Bt(), programIdIndex: Ge()})),
            recentBlockhash: Bt(),
            addressTableLookups: an(er(Kxe))
        })
    }), Yxe = Tt({pubkey: cs, signer: q0(), writable: q0(), source: an(cf([co("transaction"), co("lookupTable")]))}),
    Xxe = Tt({accountKeys: er(Yxe), signatures: er(Bt())}), Qxe = Tt({parsed: G8(), program: Bt(), programId: cs}),
    Zxe = Tt({accounts: er(cs), data: Bt(), programId: cs}), Oyt = cf([Zxe, Qxe]),
    Pyt = cf([Tt({parsed: G8(), program: Bt(), programId: Bt()}), Tt({
        accounts: er(Bt()),
        data: Bt(),
        programId: Bt()
    })]), Jxe = K8(Oyt, Pyt, t => "accounts" in t ? Ut(t, Zxe) : Ut(t, Qxe)), e4e = Tt({
        signatures: er(Bt()),
        message: Tt({
            accountKeys: er(Yxe),
            instructions: er(Jxe),
            recentBlockhash: Bt(),
            addressTableLookups: an(Qt(er(Kxe)))
        })
    }), xO = Tt({accountIndex: Ge(), mint: Bt(), owner: an(Bt()), uiTokenAmount: GG}),
    t4e = Tt({writable: er(cs), readonly: er(cs)}), WN = Tt({
        err: WS,
        fee: Ge(),
        innerInstructions: an(Qt(er(Tt({
            index: Ge(),
            instructions: er(Tt({accounts: er(Ge()), data: Bt(), programIdIndex: Ge()}))
        })))),
        preBalances: er(Ge()),
        postBalances: er(Ge()),
        logMessages: an(Qt(er(Bt()))),
        preTokenBalances: an(Qt(er(xO))),
        postTokenBalances: an(Qt(er(xO))),
        loadedAddresses: an(t4e),
        computeUnitsConsumed: an(Ge())
    }), VZ = Tt({
        err: WS,
        fee: Ge(),
        innerInstructions: an(Qt(er(Tt({index: Ge(), instructions: er(Jxe)})))),
        preBalances: er(Ge()),
        postBalances: er(Ge()),
        logMessages: an(Qt(er(Bt()))),
        preTokenBalances: an(Qt(er(xO))),
        postTokenBalances: an(Qt(er(xO))),
        loadedAddresses: an(t4e),
        computeUnitsConsumed: an(Ge())
    }), t3 = cf([co(0), co("legacy")]),
    qS = Tt({pubkey: Bt(), lamports: Ge(), postBalance: Qt(Ge()), rewardType: Qt(Bt()), commission: an(Qt(Ge()))}),
    Nyt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        transactions: er(Tt({transaction: zZ, meta: Qt(WN), version: an(t3)})),
        rewards: an(er(qS)),
        blockTime: Qt(Ge()),
        blockHeight: Qt(Ge())
    }))), Lyt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        rewards: an(er(qS)),
        blockTime: Qt(Ge()),
        blockHeight: Qt(Ge())
    }))), Byt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        transactions: er(Tt({transaction: Xxe, meta: Qt(WN), version: an(t3)})),
        rewards: an(er(qS)),
        blockTime: Qt(Ge()),
        blockHeight: Qt(Ge())
    }))), $yt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        transactions: er(Tt({transaction: e4e, meta: Qt(VZ), version: an(t3)})),
        rewards: an(er(qS)),
        blockTime: Qt(Ge()),
        blockHeight: Qt(Ge())
    }))), Fyt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        transactions: er(Tt({transaction: Xxe, meta: Qt(VZ), version: an(t3)})),
        rewards: an(er(qS)),
        blockTime: Qt(Ge()),
        blockHeight: Qt(Ge())
    }))), Uyt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        rewards: an(er(qS)),
        blockTime: Qt(Ge()),
        blockHeight: Qt(Ge())
    }))), jyt = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        transactions: er(Tt({transaction: zZ, meta: Qt(WN)})),
        rewards: an(er(qS)),
        blockTime: Qt(Ge())
    }))), afe = jn(Qt(Tt({
        blockhash: Bt(),
        previousBlockhash: Bt(),
        parentSlot: Ge(),
        signatures: er(Bt()),
        blockTime: Qt(Ge())
    }))), xV = jn(Qt(Tt({slot: Ge(), meta: Qt(WN), blockTime: an(Qt(Ge())), transaction: zZ, version: an(t3)}))),
    b7 = jn(Qt(Tt({slot: Ge(), transaction: e4e, meta: Qt(VZ), blockTime: an(Qt(Ge())), version: an(t3)}))),
    zyt = To(Tt({blockhash: Bt(), feeCalculator: Tt({lamportsPerSignature: Ge()})})),
    Vyt = To(Tt({blockhash: Bt(), lastValidBlockHeight: Ge()})), Hyt = To(q0()),
    Wyt = Tt({slot: Ge(), numTransactions: Ge(), numSlots: Ge(), samplePeriodSecs: Ge()}), qyt = jn(er(Wyt)),
    Gyt = To(Qt(Tt({feeCalculator: Tt({lamportsPerSignature: Ge()})}))), Kyt = jn(Bt()), Yyt = jn(Bt()),
    Xyt = Tt({err: WS, logs: er(Bt()), signature: Bt()}), Qyt = Tt({result: HN(Xyt), subscription: Ge()}),
    Zyt = {"solana-client": "js/0.0.0-development"};

class Jyt {
    constructor(e, r) {
        this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, this.getBlockHeight = (() => {
            const f = {};
            return async d => {
                const {commitment: p, config: g} = Wa(d), b = this._buildArgs([], p, void 0, g), S = Jue(b);
                return f[S] = f[S] ?? (async () => {
                    try {
                        const T = await this._rpcRequest("getBlockHeight", b), I = Ut(T, jn(Ge()));
                        if ("error" in I) throw new Or(I.error, "failed to get block height information");
                        return I.result
                    } finally {
                        delete f[S]
                    }
                })(), await f[S]
            }
        })();
        let n, i, a, o, s, l;
        r && typeof r == "string" ? this._commitment = r : r && (this._commitment = r.commitment, this._confirmTransactionInitialTimeout = r.confirmTransactionInitialTimeout, n = r.wsEndpoint, i = r.httpHeaders, a = r.fetch, o = r.fetchMiddleware, s = r.disableRetryOnRateLimit, l = r.httpAgent), this._rpcEndpoint = $gt(e), this._rpcWsEndpoint = n || Lgt(e), this._rpcClient = Qgt(e, i, a, o, s, l), this._rpcRequest = Zgt(this._rpcClient), this._rpcBatchRequest = Jgt(this._rpcClient), this._rpcWebSocket = new Mgt(this._rpcWsEndpoint, {
            autoconnect: !1,
            max_reconnects: 1 / 0
        }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }

    get commitment() {
        return this._commitment
    }

    get rpcEndpoint() {
        return this._rpcEndpoint
    }

    async getBalanceAndContext(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgs([e.toBase58()], n, void 0, i),
            o = await this._rpcRequest("getBalance", a), s = Ut(o, To(Ge()));
        if ("error" in s) throw new Or(s.error, `failed to get balance for ${e.toBase58()}`);
        return s.result
    }

    async getBalance(e, r) {
        return await this.getBalanceAndContext(e, r).then(n => n.value).catch(n => {
            throw new Error("failed to get balance of account " + e.toBase58() + ": " + n)
        })
    }

    async getBlockTime(e) {
        const r = await this._rpcRequest("getBlockTime", [e]), n = Ut(r, jn(Qt(Ge())));
        if ("error" in n) throw new Or(n.error, `failed to get block time for slot ${e}`);
        return n.result
    }

    async getMinimumLedgerSlot() {
        const e = await this._rpcRequest("minimumLedgerSlot", []), r = Ut(e, jn(Ge()));
        if ("error" in r) throw new Or(r.error, "failed to get minimum ledger slot");
        return r.result
    }

    async getFirstAvailableBlock() {
        const e = await this._rpcRequest("getFirstAvailableBlock", []), r = Ut(e, oyt);
        if ("error" in r) throw new Or(r.error, "failed to get first available block");
        return r.result
    }

    async getSupply(e) {
        let r = {};
        typeof e == "string" ? r = {commitment: e} : e ? r = {
            ...e,
            commitment: e && e.commitment || this.commitment
        } : r = {commitment: this.commitment};
        const n = await this._rpcRequest("getSupply", [r]), i = Ut(n, syt);
        if ("error" in i) throw new Or(i.error, "failed to get supply");
        return i.result
    }

    async getTokenSupply(e, r) {
        const n = this._buildArgs([e.toBase58()], r), i = await this._rpcRequest("getTokenSupply", n),
            a = Ut(i, To(GG));
        if ("error" in a) throw new Or(a.error, "failed to get token supply");
        return a.result
    }

    async getTokenAccountBalance(e, r) {
        const n = this._buildArgs([e.toBase58()], r), i = await this._rpcRequest("getTokenAccountBalance", n),
            a = Ut(i, To(GG));
        if ("error" in a) throw new Or(a.error, "failed to get token account balance");
        return a.result
    }

    async getTokenAccountsByOwner(e, r, n) {
        const {commitment: i, config: a} = Wa(n);
        let o = [e.toBase58()];
        "mint" in r ? o.push({mint: r.mint.toBase58()}) : o.push({programId: r.programId.toBase58()});
        const s = this._buildArgs(o, i, "base64", a), l = await this._rpcRequest("getTokenAccountsByOwner", s),
            f = Ut(l, lyt);
        if ("error" in f) throw new Or(f.error, `failed to get token accounts owned by account ${e.toBase58()}`);
        return f.result
    }

    async getParsedTokenAccountsByOwner(e, r, n) {
        let i = [e.toBase58()];
        "mint" in r ? i.push({mint: r.mint.toBase58()}) : i.push({programId: r.programId.toBase58()});
        const a = this._buildArgs(i, n, "jsonParsed"), o = await this._rpcRequest("getTokenAccountsByOwner", a),
            s = Ut(o, uyt);
        if ("error" in s) throw new Or(s.error, `failed to get token accounts owned by account ${e.toBase58()}`);
        return s.result
    }

    async getLargestAccounts(e) {
        const r = {...e, commitment: e && e.commitment || this.commitment}, n = r.filter || r.commitment ? [r] : [],
            i = await this._rpcRequest("getLargestAccounts", n), a = Ut(i, fyt);
        if ("error" in a) throw new Or(a.error, "failed to get largest accounts");
        return a.result
    }

    async getTokenLargestAccounts(e, r) {
        const n = this._buildArgs([e.toBase58()], r), i = await this._rpcRequest("getTokenLargestAccounts", n),
            a = Ut(i, cyt);
        if ("error" in a) throw new Or(a.error, "failed to get token largest accounts");
        return a.result
    }

    async getAccountInfoAndContext(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgs([e.toBase58()], n, "base64", i),
            o = await this._rpcRequest("getAccountInfo", a), s = Ut(o, To(Qt(_A)));
        if ("error" in s) throw new Or(s.error, `failed to get info about account ${e.toBase58()}`);
        return s.result
    }

    async getParsedAccountInfo(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgs([e.toBase58()], n, "jsonParsed", i),
            o = await this._rpcRequest("getAccountInfo", a), s = Ut(o, To(Qt(YG)));
        if ("error" in s) throw new Or(s.error, `failed to get info about account ${e.toBase58()}`);
        return s.result
    }

    async getAccountInfo(e, r) {
        try {
            return (await this.getAccountInfoAndContext(e, r)).value
        } catch (n) {
            throw new Error("failed to get info about account " + e.toBase58() + ": " + n)
        }
    }

    async getMultipleParsedAccounts(e, r) {
        const {commitment: n, config: i} = Wa(r), a = e.map(f => f.toBase58()),
            o = this._buildArgs([a], n, "jsonParsed", i), s = await this._rpcRequest("getMultipleAccounts", o),
            l = Ut(s, To(er(Qt(YG))));
        if ("error" in l) throw new Or(l.error, `failed to get info for accounts ${a}`);
        return l.result
    }

    async getMultipleAccountsInfoAndContext(e, r) {
        const {commitment: n, config: i} = Wa(r), a = e.map(f => f.toBase58()),
            o = this._buildArgs([a], n, "base64", i), s = await this._rpcRequest("getMultipleAccounts", o),
            l = Ut(s, To(er(Qt(_A))));
        if ("error" in l) throw new Or(l.error, `failed to get info for accounts ${a}`);
        return l.result
    }

    async getMultipleAccountsInfo(e, r) {
        return (await this.getMultipleAccountsInfoAndContext(e, r)).value
    }

    async getStakeActivation(e, r, n) {
        const {commitment: i, config: a} = Wa(r),
            o = this._buildArgs([e.toBase58()], i, void 0, {...a, epoch: n ?? (a == null ? void 0 : a.epoch)}),
            s = await this._rpcRequest("getStakeActivation", o), l = Ut(s, jn(myt));
        if ("error" in l) throw new Or(l.error, `failed to get Stake Activation ${e.toBase58()}`);
        return l.result
    }

    async getProgramAccounts(e, r) {
        const {commitment: n, config: i} = Wa(r), {encoding: a, ...o} = i || {},
            s = this._buildArgs([e.toBase58()], n, a || "base64", o),
            l = await this._rpcRequest("getProgramAccounts", s), f = er(dyt),
            d = o.withContext === !0 ? Ut(l, To(f)) : Ut(l, jn(f));
        if ("error" in d) throw new Or(d.error, `failed to get accounts owned by program ${e.toBase58()}`);
        return d.result
    }

    async getParsedProgramAccounts(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgs([e.toBase58()], n, "jsonParsed", i),
            o = await this._rpcRequest("getProgramAccounts", a), s = Ut(o, jn(er(pyt)));
        if ("error" in s) throw new Or(s.error, `failed to get accounts owned by program ${e.toBase58()}`);
        return s.result
    }

    async confirmTransaction(e, r) {
        var a;
        let n;
        if (typeof e == "string") n = e; else {
            const o = e;
            if ((a = o.abortSignal) != null && a.aborted) return Promise.reject(o.abortSignal.reason);
            n = o.signature
        }
        let i;
        try {
            i = jc.decode(n)
        } catch {
            throw new Error("signature must be base58 encoded: " + n)
        }
        return Ga(i.length === 64, "signature has invalid length"), typeof e == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: r || this.commitment,
            signature: n
        }) : "lastValidBlockHeight" in e ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: r || this.commitment,
            strategy: e
        }) : await this.confirmTransactionUsingDurableNonceStrategy({commitment: r || this.commitment, strategy: e})
    }

    getCancellationPromise(e) {
        return new Promise((r, n) => {
            e != null && (e.aborted ? n(e.reason) : e.addEventListener("abort", () => {
                n(e.reason)
            }))
        })
    }

    getTransactionConfirmationPromise({commitment: e, signature: r}) {
        let n, i, a = !1;
        const o = new Promise((l, f) => {
            try {
                n = this.onSignature(r, (p, g) => {
                    n = void 0;
                    const b = {context: g, value: p};
                    l({__type: sy.PROCESSED, response: b})
                }, e);
                const d = new Promise(p => {
                    n == null ? p() : i = this._onSubscriptionStateChange(n, g => {
                        g === "subscribed" && p()
                    })
                });
                (async () => {
                    if (await d, a) return;
                    const p = await this.getSignatureStatus(r);
                    if (a || p == null) return;
                    const {context: g, value: b} = p;
                    if (b != null) if (b != null && b.err) f(b.err); else {
                        switch (e) {
                            case"confirmed":
                            case"single":
                            case"singleGossip": {
                                if (b.confirmationStatus === "processed") return;
                                break
                            }
                            case"finalized":
                            case"max":
                            case"root": {
                                if (b.confirmationStatus === "processed" || b.confirmationStatus === "confirmed") return;
                                break
                            }
                        }
                        a = !0, l({__type: sy.PROCESSED, response: {context: g, value: b}})
                    }
                })()
            } catch (d) {
                f(d)
            }
        });
        return {
            abortConfirmation: () => {
                i && (i(), i = void 0), n != null && (this.removeSignatureListener(n), n = void 0)
            }, confirmationPromise: o
        }
    }

    async confirmTransactionUsingBlockHeightExceedanceStrategy({
                                                                   commitment: e,
                                                                   strategy: {
                                                                       abortSignal: r,
                                                                       lastValidBlockHeight: n,
                                                                       signature: i
                                                                   }
                                                               }) {
        let a = !1;
        const o = new Promise(p => {
            const g = async () => {
                try {
                    return await this.getBlockHeight(e)
                } catch {
                    return -1
                }
            };
            (async () => {
                let b = await g();
                if (!a) {
                    for (; b <= n;) if (await gx(1e3), a || (b = await g(), a)) return;
                    p({__type: sy.BLOCKHEIGHT_EXCEEDED})
                }
            })()
        }), {abortConfirmation: s, confirmationPromise: l} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: i
        }), f = this.getCancellationPromise(r);
        let d;
        try {
            const p = await Promise.race([f, l, o]);
            if (p.__type === sy.PROCESSED) d = p.response; else throw new Vxe(i)
        } finally {
            a = !0, s()
        }
        return d
    }

    async confirmTransactionUsingDurableNonceStrategy({
                                                          commitment: e,
                                                          strategy: {
                                                              abortSignal: r,
                                                              minContextSlot: n,
                                                              nonceAccountPubkey: i,
                                                              nonceValue: a,
                                                              signature: o
                                                          }
                                                      }) {
        let s = !1;
        const l = new Promise(b => {
            let S = a, T = null;
            const I = async () => {
                try {
                    const {context: N, value: P} = await this.getNonceAndContext(i, {commitment: e, minContextSlot: n});
                    return T = N.slot, P == null ? void 0 : P.nonce
                } catch {
                    return S
                }
            };
            (async () => {
                if (S = await I(), !s) for (; ;) {
                    if (a !== S) {
                        b({__type: sy.NONCE_INVALID, slotInWhichNonceDidAdvance: T});
                        return
                    }
                    if (await gx(2e3), s || (S = await I(), s)) return
                }
            })()
        }), {abortConfirmation: f, confirmationPromise: d} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: o
        }), p = this.getCancellationPromise(r);
        let g;
        try {
            const b = await Promise.race([p, d, l]);
            if (b.__type === sy.PROCESSED) g = b.response; else {
                let S;
                for (; ;) {
                    const T = await this.getSignatureStatus(o);
                    if (T == null) break;
                    if (T.context.slot < (b.slotInWhichNonceDidAdvance ?? n)) {
                        await gx(400);
                        continue
                    }
                    S = T;
                    break
                }
                if (S != null && S.value) {
                    const T = e || "finalized", {confirmationStatus: I} = S.value;
                    switch (T) {
                        case"processed":
                        case"recent":
                            if (I !== "processed" && I !== "confirmed" && I !== "finalized") throw new kT(o);
                            break;
                        case"confirmed":
                        case"single":
                        case"singleGossip":
                            if (I !== "confirmed" && I !== "finalized") throw new kT(o);
                            break;
                        case"finalized":
                        case"max":
                        case"root":
                            if (I !== "finalized") throw new kT(o);
                            break
                    }
                    g = {context: S.context, value: {err: S.value.err}}
                } else throw new kT(o)
            }
        } finally {
            s = !0, f()
        }
        return g
    }

    async confirmTransactionUsingLegacyTimeoutStrategy({commitment: e, signature: r}) {
        let n;
        const i = new Promise(l => {
            let f = this._confirmTransactionInitialTimeout || 6e4;
            switch (e) {
                case"processed":
                case"recent":
                case"single":
                case"confirmed":
                case"singleGossip": {
                    f = this._confirmTransactionInitialTimeout || 3e4;
                    break
                }
            }
            n = setTimeout(() => l({__type: sy.TIMED_OUT, timeoutMs: f}), f)
        }), {abortConfirmation: a, confirmationPromise: o} = this.getTransactionConfirmationPromise({
            commitment: e,
            signature: r
        });
        let s;
        try {
            const l = await Promise.race([o, i]);
            if (l.__type === sy.PROCESSED) s = l.response; else throw new Hxe(r, l.timeoutMs / 1e3)
        } finally {
            clearTimeout(n), a()
        }
        return s
    }

    async getClusterNodes() {
        const e = await this._rpcRequest("getClusterNodes", []), r = Ut(e, jn(er(Ayt)));
        if ("error" in r) throw new Or(r.error, "failed to get cluster nodes");
        return r.result
    }

    async getVoteAccounts(e) {
        const r = this._buildArgs([], e), n = await this._rpcRequest("getVoteAccounts", r), i = Ut(n, Iyt);
        if ("error" in i) throw new Or(i.error, "failed to get vote accounts");
        return i.result
    }

    async getSlot(e) {
        const {commitment: r, config: n} = Wa(e), i = this._buildArgs([], r, void 0, n),
            a = await this._rpcRequest("getSlot", i), o = Ut(a, jn(Ge()));
        if ("error" in o) throw new Or(o.error, "failed to get slot");
        return o.result
    }

    async getSlotLeader(e) {
        const {commitment: r, config: n} = Wa(e), i = this._buildArgs([], r, void 0, n),
            a = await this._rpcRequest("getSlotLeader", i), o = Ut(a, jn(Bt()));
        if ("error" in o) throw new Or(o.error, "failed to get slot leader");
        return o.result
    }

    async getSlotLeaders(e, r) {
        const n = [e, r], i = await this._rpcRequest("getSlotLeaders", n), a = Ut(i, jn(er(cs)));
        if ("error" in a) throw new Or(a.error, "failed to get slot leaders");
        return a.result
    }

    async getSignatureStatus(e, r) {
        const {context: n, value: i} = await this.getSignatureStatuses([e], r);
        Ga(i.length === 1);
        const a = i[0];
        return {context: n, value: a}
    }

    async getSignatureStatuses(e, r) {
        const n = [e];
        r && n.push(r);
        const i = await this._rpcRequest("getSignatureStatuses", n), a = Ut(i, Dyt);
        if ("error" in a) throw new Or(a.error, "failed to get signature status");
        return a.result
    }

    async getTransactionCount(e) {
        const {commitment: r, config: n} = Wa(e), i = this._buildArgs([], r, void 0, n),
            a = await this._rpcRequest("getTransactionCount", i), o = Ut(a, jn(Ge()));
        if ("error" in o) throw new Or(o.error, "failed to get transaction count");
        return o.result
    }

    async getTotalSupply(e) {
        return (await this.getSupply({commitment: e, excludeNonCirculatingAccountsList: !0})).value.total
    }

    async getInflationGovernor(e) {
        const r = this._buildArgs([], e), n = await this._rpcRequest("getInflationGovernor", r), i = Ut(n, eyt);
        if ("error" in i) throw new Or(i.error, "failed to get inflation");
        return i.result
    }

    async getInflationReward(e, r, n) {
        const {commitment: i, config: a} = Wa(n), o = this._buildArgs([e.map(f => f.toBase58())], i, void 0, {
            ...a,
            epoch: r ?? (a == null ? void 0 : a.epoch)
        }), s = await this._rpcRequest("getInflationReward", o), l = Ut(s, jgt);
        if ("error" in l) throw new Or(l.error, "failed to get inflation reward");
        return l.result
    }

    async getInflationRate() {
        const e = await this._rpcRequest("getInflationRate", []), r = Ut(e, tyt);
        if ("error" in r) throw new Or(r.error, "failed to get inflation rate");
        return r.result
    }

    async getEpochInfo(e) {
        const {commitment: r, config: n} = Wa(e), i = this._buildArgs([], r, void 0, n),
            a = await this._rpcRequest("getEpochInfo", i), o = Ut(a, nyt);
        if ("error" in o) throw new Or(o.error, "failed to get epoch info");
        return o.result
    }

    async getEpochSchedule() {
        const e = await this._rpcRequest("getEpochSchedule", []), r = Ut(e, iyt);
        if ("error" in r) throw new Or(r.error, "failed to get epoch schedule");
        const n = r.result;
        return new Rgt(n.slotsPerEpoch, n.leaderScheduleSlotOffset, n.warmup, n.firstNormalEpoch, n.firstNormalSlot)
    }

    async getLeaderSchedule() {
        const e = await this._rpcRequest("getLeaderSchedule", []), r = Ut(e, ayt);
        if ("error" in r) throw new Or(r.error, "failed to get leader schedule");
        return r.result
    }

    async getMinimumBalanceForRentExemption(e, r) {
        const n = this._buildArgs([e], r), i = await this._rpcRequest("getMinimumBalanceForRentExemption", n),
            a = Ut(i, Myt);
        return "error" in a ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : a.result
    }

    async getRecentBlockhashAndContext(e) {
        const r = this._buildArgs([], e), n = await this._rpcRequest("getRecentBlockhash", r), i = Ut(n, zyt);
        if ("error" in i) throw new Or(i.error, "failed to get recent blockhash");
        return i.result
    }

    async getRecentPerformanceSamples(e) {
        const r = await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : []), n = Ut(r, qyt);
        if ("error" in n) throw new Or(n.error, "failed to get recent performance samples");
        return n.result
    }

    async getFeeCalculatorForBlockhash(e, r) {
        const n = this._buildArgs([e], r), i = await this._rpcRequest("getFeeCalculatorForBlockhash", n),
            a = Ut(i, Gyt);
        if ("error" in a) throw new Or(a.error, "failed to get fee calculator");
        const {context: o, value: s} = a.result;
        return {context: o, value: s !== null ? s.feeCalculator : null}
    }

    async getFeeForMessage(e, r) {
        const n = G4(e.serialize()).toString("base64"), i = this._buildArgs([n], r),
            a = await this._rpcRequest("getFeeForMessage", i), o = Ut(a, To(Qt(Ge())));
        if ("error" in o) throw new Or(o.error, "failed to get fee for message");
        if (o.result === null) throw new Error("invalid blockhash");
        return o.result
    }

    async getRecentPrioritizationFees(e) {
        var o;
        const r = (o = e == null ? void 0 : e.lockedWritableAccounts) == null ? void 0 : o.map(s => s.toBase58()),
            n = r != null && r.length ? [r] : [], i = await this._rpcRequest("getRecentPrioritizationFees", n),
            a = Ut(i, ryt);
        if ("error" in a) throw new Or(a.error, "failed to get recent prioritization fees");
        return a.result
    }

    async getRecentBlockhash(e) {
        try {
            return (await this.getRecentBlockhashAndContext(e)).value
        } catch (r) {
            throw new Error("failed to get recent blockhash: " + r)
        }
    }

    async getLatestBlockhash(e) {
        try {
            return (await this.getLatestBlockhashAndContext(e)).value
        } catch (r) {
            throw new Error("failed to get recent blockhash: " + r)
        }
    }

    async getLatestBlockhashAndContext(e) {
        const {commitment: r, config: n} = Wa(e), i = this._buildArgs([], r, void 0, n),
            a = await this._rpcRequest("getLatestBlockhash", i), o = Ut(a, Vyt);
        if ("error" in o) throw new Or(o.error, "failed to get latest blockhash");
        return o.result
    }

    async isBlockhashValid(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgs([e], n, void 0, i),
            o = await this._rpcRequest("isBlockhashValid", a), s = Ut(o, Hyt);
        if ("error" in s) throw new Or(s.error, "failed to determine if the blockhash `" + e + "`is valid");
        return s.result
    }

    async getVersion() {
        const e = await this._rpcRequest("getVersion", []), r = Ut(e, jn(Ygt));
        if ("error" in r) throw new Or(r.error, "failed to get version");
        return r.result
    }

    async getGenesisHash() {
        const e = await this._rpcRequest("getGenesisHash", []), r = Ut(e, jn(Bt()));
        if ("error" in r) throw new Or(r.error, "failed to get genesis hash");
        return r.result
    }

    async getBlock(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgsAtLeastConfirmed([e], n, void 0, i),
            o = await this._rpcRequest("getBlock", a);
        try {
            switch (i == null ? void 0 : i.transactionDetails) {
                case"accounts": {
                    const s = Ut(o, Byt);
                    if ("error" in s) throw s.error;
                    return s.result
                }
                case"none": {
                    const s = Ut(o, Lyt);
                    if ("error" in s) throw s.error;
                    return s.result
                }
                default: {
                    const s = Ut(o, Nyt);
                    if ("error" in s) throw s.error;
                    const {result: l} = s;
                    return l ? {
                        ...l,
                        transactions: l.transactions.map(({transaction: f, meta: d, version: p}) => ({
                            meta: d,
                            transaction: {...f, message: _V(p, f.message)},
                            version: p
                        }))
                    } : null
                }
            }
        } catch (s) {
            throw new Or(s, "failed to get confirmed block")
        }
    }

    async getParsedBlock(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", i),
            o = await this._rpcRequest("getBlock", a);
        try {
            switch (i == null ? void 0 : i.transactionDetails) {
                case"accounts": {
                    const s = Ut(o, Fyt);
                    if ("error" in s) throw s.error;
                    return s.result
                }
                case"none": {
                    const s = Ut(o, Uyt);
                    if ("error" in s) throw s.error;
                    return s.result
                }
                default: {
                    const s = Ut(o, $yt);
                    if ("error" in s) throw s.error;
                    return s.result
                }
            }
        } catch (s) {
            throw new Or(s, "failed to get block")
        }
    }

    async getBlockProduction(e) {
        let r, n;
        if (typeof e == "string") n = e; else if (e) {
            const {commitment: s, ...l} = e;
            n = s, r = l
        }
        const i = this._buildArgs([], n, "base64", r), a = await this._rpcRequest("getBlockProduction", i),
            o = Ut(a, Xgt);
        if ("error" in o) throw new Or(o.error, "failed to get block production information");
        return o.result
    }

    async getTransaction(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgsAtLeastConfirmed([e], n, void 0, i),
            o = await this._rpcRequest("getTransaction", a), s = Ut(o, xV);
        if ("error" in s) throw new Or(s.error, "failed to get transaction");
        const l = s.result;
        return l && {...l, transaction: {...l.transaction, message: _V(l.version, l.transaction.message)}}
    }

    async getParsedTransaction(e, r) {
        const {commitment: n, config: i} = Wa(r), a = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", i),
            o = await this._rpcRequest("getTransaction", a), s = Ut(o, b7);
        if ("error" in s) throw new Or(s.error, "failed to get transaction");
        return s.result
    }

    async getParsedTransactions(e, r) {
        const {commitment: n, config: i} = Wa(r), a = e.map(l => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([l], n, "jsonParsed", i)
        }));
        return (await this._rpcBatchRequest(a)).map(l => {
            const f = Ut(l, b7);
            if ("error" in f) throw new Or(f.error, "failed to get transactions");
            return f.result
        })
    }

    async getTransactions(e, r) {
        const {commitment: n, config: i} = Wa(r),
            a = e.map(l => ({methodName: "getTransaction", args: this._buildArgsAtLeastConfirmed([l], n, void 0, i)}));
        return (await this._rpcBatchRequest(a)).map(l => {
            const f = Ut(l, xV);
            if ("error" in f) throw new Or(f.error, "failed to get transactions");
            const d = f.result;
            return d && {...d, transaction: {...d.transaction, message: _V(d.version, d.transaction.message)}}
        })
    }

    async getConfirmedBlock(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r), i = await this._rpcRequest("getConfirmedBlock", n),
            a = Ut(i, jyt);
        if ("error" in a) throw new Or(a.error, "failed to get confirmed block");
        const o = a.result;
        if (!o) throw new Error("Confirmed block " + e + " not found");
        const s = {
            ...o, transactions: o.transactions.map(({transaction: l, meta: f}) => {
                const d = new Bv(l.message);
                return {meta: f, transaction: {...l, message: d}}
            })
        };
        return {
            ...s,
            transactions: s.transactions.map(({transaction: l, meta: f}) => ({
                meta: f,
                transaction: Yh.populate(l.message, l.signatures)
            }))
        }
    }

    async getBlocks(e, r, n) {
        const i = this._buildArgsAtLeastConfirmed(r !== void 0 ? [e, r] : [e], n),
            a = await this._rpcRequest("getBlocks", i), o = Ut(a, jn(er(Ge())));
        if ("error" in o) throw new Or(o.error, "failed to get blocks");
        return o.result
    }

    async getBlockSignatures(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, void 0, {transactionDetails: "signatures", rewards: !1}),
            i = await this._rpcRequest("getBlock", n), a = Ut(i, afe);
        if ("error" in a) throw new Or(a.error, "failed to get block");
        const o = a.result;
        if (!o) throw new Error("Block " + e + " not found");
        return o
    }

    async getConfirmedBlockSignatures(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, void 0, {transactionDetails: "signatures", rewards: !1}),
            i = await this._rpcRequest("getConfirmedBlock", n), a = Ut(i, afe);
        if ("error" in a) throw new Or(a.error, "failed to get confirmed block");
        const o = a.result;
        if (!o) throw new Error("Confirmed block " + e + " not found");
        return o
    }

    async getConfirmedTransaction(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r), i = await this._rpcRequest("getConfirmedTransaction", n),
            a = Ut(i, xV);
        if ("error" in a) throw new Or(a.error, "failed to get transaction");
        const o = a.result;
        if (!o) return o;
        const s = new Bv(o.transaction.message), l = o.transaction.signatures;
        return {...o, transaction: Yh.populate(s, l)}
    }

    async getParsedConfirmedTransaction(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed"),
            i = await this._rpcRequest("getConfirmedTransaction", n), a = Ut(i, b7);
        if ("error" in a) throw new Or(a.error, "failed to get confirmed transaction");
        return a.result
    }

    async getParsedConfirmedTransactions(e, r) {
        const n = e.map(o => ({
            methodName: "getConfirmedTransaction",
            args: this._buildArgsAtLeastConfirmed([o], r, "jsonParsed")
        }));
        return (await this._rpcBatchRequest(n)).map(o => {
            const s = Ut(o, b7);
            if ("error" in s) throw new Or(s.error, "failed to get confirmed transactions");
            return s.result
        })
    }

    async getConfirmedSignaturesForAddress(e, r, n) {
        let i = {}, a = await this.getFirstAvailableBlock();
        for (; !("until" in i) && (r--, !(r <= 0 || r < a));) try {
            const l = await this.getConfirmedBlockSignatures(r, "finalized");
            l.signatures.length > 0 && (i.until = l.signatures[l.signatures.length - 1].toString())
        } catch (l) {
            if (l instanceof Error && l.message.includes("skipped")) continue;
            throw l
        }
        let o = await this.getSlot("finalized");
        for (; !("before" in i) && (n++, !(n > o));) try {
            const l = await this.getConfirmedBlockSignatures(n);
            l.signatures.length > 0 && (i.before = l.signatures[l.signatures.length - 1].toString())
        } catch (l) {
            if (l instanceof Error && l.message.includes("skipped")) continue;
            throw l
        }
        return (await this.getConfirmedSignaturesForAddress2(e, i)).map(l => l.signature)
    }

    async getConfirmedSignaturesForAddress2(e, r, n) {
        const i = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, r),
            a = await this._rpcRequest("getConfirmedSignaturesForAddress2", i), o = Ut(a, vyt);
        if ("error" in o) throw new Or(o.error, "failed to get confirmed signatures for address");
        return o.result
    }

    async getSignaturesForAddress(e, r, n) {
        const i = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, r),
            a = await this._rpcRequest("getSignaturesForAddress", i), o = Ut(a, gyt);
        if ("error" in o) throw new Or(o.error, "failed to get signatures for address");
        return o.result
    }

    async getAddressLookupTable(e, r) {
        const {context: n, value: i} = await this.getAccountInfoAndContext(e, r);
        let a = null;
        return i !== null && (a = new rfe({key: e, state: rfe.deserialize(i.data)})), {context: n, value: a}
    }

    async getNonceAndContext(e, r) {
        const {context: n, value: i} = await this.getAccountInfoAndContext(e, r);
        let a = null;
        return i !== null && (a = UZ.fromAccountData(i.data)), {context: n, value: a}
    }

    async getNonce(e, r) {
        return await this.getNonceAndContext(e, r).then(n => n.value).catch(n => {
            throw new Error("failed to get nonce for account " + e.toBase58() + ": " + n)
        })
    }

    async requestAirdrop(e, r) {
        const n = await this._rpcRequest("requestAirdrop", [e.toBase58(), r]), i = Ut(n, Kyt);
        if ("error" in i) throw new Or(i.error, `airdrop to ${e.toBase58()} failed`);
        return i.result
    }

    async _blockhashWithExpiryBlockHeight(e) {
        if (!e) {
            for (; this._pollingBlockhash;) await gx(100);
            const n = Date.now() - this._blockhashInfo.lastFetch >= Bgt;
            if (this._blockhashInfo.latestBlockhash !== null && !n) return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }

    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const e = Date.now(), r = this._blockhashInfo.latestBlockhash, n = r ? r.blockhash : null;
            for (let i = 0; i < 50; i++) {
                const a = await this.getLatestBlockhash("finalized");
                if (n !== a.blockhash) return this._blockhashInfo = {
                    latestBlockhash: a,
                    lastFetch: Date.now(),
                    transactionSignatures: [],
                    simulatedSignatures: []
                }, a;
                await gx(wgt / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - e}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }

    async getStakeMinimumDelegation(e) {
        const {commitment: r, config: n} = Wa(e), i = this._buildArgs([], r, "base64", n),
            a = await this._rpcRequest("getStakeMinimumDelegation", i), o = Ut(a, To(Ge()));
        if ("error" in o) throw new Or(o.error, "failed to get stake minimum delegation");
        return o.result
    }

    async simulateTransaction(e, r, n) {
        if ("message" in e) {
            const T = e.serialize(), I = qr.Buffer.from(T).toString("base64");
            if (Array.isArray(r) || n !== void 0) throw new Error("Invalid arguments");
            const N = r || {};
            N.encoding = "base64", "commitment" in N || (N.commitment = this.commitment);
            const P = [I, N], F = await this._rpcRequest("simulateTransaction", P), V = Ut(F, nfe);
            if ("error" in V) throw new Error("failed to simulate transaction: " + V.error.message);
            return V.result
        }
        let i;
        if (e instanceof Yh) {
            let S = e;
            i = new Yh, i.feePayer = S.feePayer, i.instructions = e.instructions, i.nonceInfo = S.nonceInfo, i.signatures = S.signatures
        } else i = Yh.populate(e), i._message = i._json = void 0;
        if (r !== void 0 && !Array.isArray(r)) throw new Error("Invalid arguments");
        const a = r;
        if (i.nonceInfo && a) i.sign(...a); else {
            let S = this._disableBlockhashCaching;
            for (; ;) {
                const T = await this._blockhashWithExpiryBlockHeight(S);
                if (i.lastValidBlockHeight = T.lastValidBlockHeight, i.recentBlockhash = T.blockhash, !a) break;
                if (i.sign(...a), !i.signature) throw new Error("!signature");
                const I = i.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(I) && !this._blockhashInfo.transactionSignatures.includes(I)) {
                    this._blockhashInfo.simulatedSignatures.push(I);
                    break
                } else S = !0
            }
        }
        const o = i._compile(), s = o.serialize(), f = i._serialize(s).toString("base64"),
            d = {encoding: "base64", commitment: this.commitment};
        if (n) {
            const S = (Array.isArray(n) ? n : o.nonProgramIds()).map(T => T.toBase58());
            d.accounts = {encoding: "base64", addresses: S}
        }
        a && (d.sigVerify = !0);
        const p = [f, d], g = await this._rpcRequest("simulateTransaction", p), b = Ut(g, nfe);
        if ("error" in b) {
            let S;
            if ("data" in b.error && (S = b.error.data.logs, S && Array.isArray(S))) {
                const T = `
    `, I = T + S.join(T);
                console.error(b.error.message, I)
            }
            throw new efe("failed to simulate transaction: " + b.error.message, S)
        }
        return b.result
    }

    async sendTransaction(e, r, n) {
        if ("version" in e) {
            if (r && Array.isArray(r)) throw new Error("Invalid arguments");
            const o = e.serialize();
            return await this.sendRawTransaction(o, r)
        }
        if (r === void 0 || !Array.isArray(r)) throw new Error("Invalid arguments");
        const i = r;
        if (e.nonceInfo) e.sign(...i); else {
            let o = this._disableBlockhashCaching;
            for (; ;) {
                const s = await this._blockhashWithExpiryBlockHeight(o);
                if (e.lastValidBlockHeight = s.lastValidBlockHeight, e.recentBlockhash = s.blockhash, e.sign(...i), !e.signature) throw new Error("!signature");
                const l = e.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(l)) o = !0; else {
                    this._blockhashInfo.transactionSignatures.push(l);
                    break
                }
            }
        }
        const a = e.serialize();
        return await this.sendRawTransaction(a, n)
    }

    async sendRawTransaction(e, r) {
        const n = G4(e).toString("base64");
        return await this.sendEncodedTransaction(n, r)
    }

    async sendEncodedTransaction(e, r) {
        const n = {encoding: "base64"}, i = r && r.skipPreflight, a = r && r.preflightCommitment || this.commitment;
        r && r.maxRetries != null && (n.maxRetries = r.maxRetries), r && r.minContextSlot != null && (n.minContextSlot = r.minContextSlot), i && (n.skipPreflight = i), a && (n.preflightCommitment = a);
        const o = [e, n], s = await this._rpcRequest("sendTransaction", o), l = Ut(s, Yyt);
        if ("error" in l) {
            let f;
            throw "data" in l.error && (f = l.error.data.logs), new efe("failed to send transaction: " + l.error.message, f)
        }
        return l.result
    }

    _wsOnOpen() {
        this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
            (async () => {
                try {
                    await this._rpcWebSocket.notify("ping")
                } catch {
                }
            })()
        }, 5e3), this._updateSubscriptions()
    }

    _wsOnError(e) {
        this._rpcWebSocketConnected = !1, console.error("ws error:", e.message)
    }

    _wsOnClose(e) {
        if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), e === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([r, n]) => {
            this._setSubscription(r, {...n, state: "pending"})
        })
    }

    _setSubscription(e, r) {
        var i;
        const n = (i = this._subscriptionsByHash[e]) == null ? void 0 : i.state;
        if (this._subscriptionsByHash[e] = r, n !== r.state) {
            const a = this._subscriptionStateChangeCallbacksByHash[e];
            a && a.forEach(o => {
                try {
                    o(r.state)
                } catch {
                }
            })
        }
    }

    _onSubscriptionStateChange(e, r) {
        var a;
        const n = this._subscriptionHashByClientSubscriptionId[e];
        if (n == null) return () => {
        };
        const i = (a = this._subscriptionStateChangeCallbacksByHash)[n] || (a[n] = new Set);
        return i.add(r), () => {
            i.delete(r), i.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[n]
        }
    }

    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch (n) {
                    n instanceof Error && console.log(`Error when closing socket connection: ${n.message}`)
                }
            }, 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const e = this._rpcWebSocketGeneration, r = () => e === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async n => {
            const i = this._subscriptionsByHash[n];
            if (i !== void 0) switch (i.state) {
                case"pending":
                case"unsubscribed":
                    if (i.callbacks.size === 0) {
                        delete this._subscriptionsByHash[n], i.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[i.serverSubscriptionId], await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {args: a, method: o} = i;
                        try {
                            this._setSubscription(n, {...i, state: "subscribing"});
                            const s = await this._rpcWebSocket.call(o, a);
                            this._setSubscription(n, {
                                ...i,
                                serverSubscriptionId: s,
                                state: "subscribed"
                            }), this._subscriptionCallbacksByServerSubscriptionId[s] = i.callbacks, await this._updateSubscriptions()
                        } catch (s) {
                            if (s instanceof Error && console.error(`${o} error for argument`, a, s.message), !r()) return;
                            this._setSubscription(n, {...i, state: "pending"}), await this._updateSubscriptions()
                        }
                    })();
                    break;
                case"subscribed":
                    i.callbacks.size === 0 && await (async () => {
                        const {serverSubscriptionId: a, unsubscribeMethod: o} = i;
                        if (this._subscriptionsAutoDisposedByRpc.has(a)) this._subscriptionsAutoDisposedByRpc.delete(a); else {
                            this._setSubscription(n, {...i, state: "unsubscribing"}), this._setSubscription(n, {
                                ...i,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(o, [a])
                            } catch (s) {
                                if (s instanceof Error && console.error(`${o} error:`, s.message), !r()) return;
                                this._setSubscription(n, {
                                    ...i,
                                    state: "subscribed"
                                }), await this._updateSubscriptions();
                                return
                            }
                        }
                        this._setSubscription(n, {...i, state: "unsubscribed"}), await this._updateSubscriptions()
                    })();
                    break
            }
        }))
    }

    _handleServerNotification(e, r) {
        const n = this._subscriptionCallbacksByServerSubscriptionId[e];
        n !== void 0 && n.forEach(i => {
            try {
                i(...r)
            } catch (a) {
                console.error(a)
            }
        })
    }

    _wsOnAccountNotification(e) {
        const {result: r, subscription: n} = Ut(e, yyt);
        this._handleServerNotification(n, [r.value, r.context])
    }

    _makeSubscription(e, r) {
        const n = this._nextClientSubscriptionId++, i = Jue([e.method, r], !0), a = this._subscriptionsByHash[i];
        return a === void 0 ? this._subscriptionsByHash[i] = {
            ...e,
            args: r,
            callbacks: new Set([e.callback]),
            state: "pending"
        } : a.callbacks.add(e.callback), this._subscriptionHashByClientSubscriptionId[n] = i, this._subscriptionDisposeFunctionsByClientSubscriptionId[n] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n], delete this._subscriptionHashByClientSubscriptionId[n];
            const o = this._subscriptionsByHash[i];
            Ga(o !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${n}`), o.callbacks.delete(e.callback), await this._updateSubscriptions()
        }, this._updateSubscriptions(), n
    }

    onAccountChange(e, r, n) {
        const i = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64");
        return this._makeSubscription({
            callback: r,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, i)
    }

    async removeAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "account change")
    }

    _wsOnProgramAccountNotification(e) {
        const {result: r, subscription: n} = Ut(e, wyt);
        this._handleServerNotification(n, [{accountId: r.value.pubkey, accountInfo: r.value.account}, r.context])
    }

    onProgramAccountChange(e, r, n, i) {
        const a = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64", i ? {filters: i} : void 0);
        return this._makeSubscription({
            callback: r,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, a)
    }

    async removeProgramAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "program account change")
    }

    onLogs(e, r, n) {
        const i = this._buildArgs([typeof e == "object" ? {mentions: [e.toString()]} : e], n || this._commitment || "finalized");
        return this._makeSubscription({callback: r, method: "logsSubscribe", unsubscribeMethod: "logsUnsubscribe"}, i)
    }

    async removeOnLogsListener(e) {
        await this._unsubscribeClientSubscription(e, "logs")
    }

    _wsOnLogsNotification(e) {
        const {result: r, subscription: n} = Ut(e, Qyt);
        this._handleServerNotification(n, [r.value, r.context])
    }

    _wsOnSlotNotification(e) {
        const {result: r, subscription: n} = Ut(e, _yt);
        this._handleServerNotification(n, [r])
    }

    onSlotChange(e) {
        return this._makeSubscription({callback: e, method: "slotSubscribe", unsubscribeMethod: "slotUnsubscribe"}, [])
    }

    async removeSlotChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "slot change")
    }

    _wsOnSlotUpdatesNotification(e) {
        const {result: r, subscription: n} = Ut(e, Eyt);
        this._handleServerNotification(n, [r])
    }

    onSlotUpdate(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }

    async removeSlotUpdateListener(e) {
        await this._unsubscribeClientSubscription(e, "slot update")
    }

    async _unsubscribeClientSubscription(e, r) {
        const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
        n ? await n() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${r}' events could not be found.`)
    }

    _buildArgs(e, r, n, i) {
        const a = r || this._commitment;
        if (a || n || i) {
            let o = {};
            n && (o.encoding = n), a && (o.commitment = a), i && (o = Object.assign(o, i)), e.push(o)
        }
        return e
    }

    _buildArgsAtLeastConfirmed(e, r, n, i) {
        const a = r || this._commitment;
        if (a && !["confirmed", "finalized"].includes(a)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(e, r, n, i)
    }

    _wsOnSignatureNotification(e) {
        const {result: r, subscription: n} = Ut(e, Tyt);
        r.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(n), this._handleServerNotification(n, r.value === "receivedSignature" ? [{type: "received"}, r.context] : [{
            type: "status",
            result: r.value
        }, r.context])
    }

    onSignature(e, r, n) {
        const i = this._buildArgs([e], n || this._commitment || "finalized"), a = this._makeSubscription({
            callback: (o, s) => {
                if (o.type === "status") {
                    r(o.result, s);
                    try {
                        this.removeSignatureListener(a)
                    } catch {
                    }
                }
            }, method: "signatureSubscribe", unsubscribeMethod: "signatureUnsubscribe"
        }, i);
        return a
    }

    onSignatureWithOptions(e, r, n) {
        const {commitment: i, ...a} = {...n, commitment: n && n.commitment || this._commitment || "finalized"},
            o = this._buildArgs([e], i, void 0, a), s = this._makeSubscription({
                callback: (l, f) => {
                    r(l, f);
                    try {
                        this.removeSignatureListener(s)
                    } catch {
                    }
                }, method: "signatureSubscribe", unsubscribeMethod: "signatureUnsubscribe"
            }, o);
        return s
    }

    async removeSignatureListener(e) {
        await this._unsubscribeClientSubscription(e, "signature result")
    }

    _wsOnRootNotification(e) {
        const {result: r, subscription: n} = Ut(e, Cyt);
        this._handleServerNotification(n, [r])
    }

    onRootChange(e) {
        return this._makeSubscription({callback: e, method: "rootSubscribe", unsubscribeMethod: "rootUnsubscribe"}, [])
    }

    async removeRootChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "root change")
    }
}

Object.freeze({
    CreateLookupTable: {index: 0, layout: yr([Pr("instruction"), Y4("recentSlot"), si("bumpSeed")])},
    FreezeLookupTable: {index: 1, layout: yr([Pr("instruction")])},
    ExtendLookupTable: {index: 2, layout: yr([Pr("instruction"), Y4(), xl(ni(), jw(Pr(), -8), "addresses")])},
    DeactivateLookupTable: {index: 3, layout: yr([Pr("instruction")])},
    CloseLookupTable: {index: 4, layout: yr([Pr("instruction")])}
});
new Sr("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
    RequestUnits: {index: 0, layout: yr([si("instruction"), Pr("units"), Pr("additionalFee")])},
    RequestHeapFrame: {index: 1, layout: yr([si("instruction"), Pr("bytes")])},
    SetComputeUnitLimit: {index: 2, layout: yr([si("instruction"), Pr("units")])},
    SetComputeUnitPrice: {index: 3, layout: yr([si("instruction"), Y4("microLamports")])}
});
new Sr("ComputeBudget111111111111111111111111111111");
yr([si("numSignatures"), si("padding"), Ud("signatureOffset"), Ud("signatureInstructionIndex"), Ud("publicKeyOffset"), Ud("publicKeyInstructionIndex"), Ud("messageDataOffset"), Ud("messageDataSize"), Ud("messageInstructionIndex")]);
new Sr("Ed25519SigVerify111111111111111111111111111");
yr([si("numSignatures"), Ud("signatureOffset"), si("signatureInstructionIndex"), Ud("ethAddressOffset"), si("ethAddressInstructionIndex"), Ud("messageDataOffset"), Ud("messageDataSize"), si("messageInstructionIndex"), va(20, "ethAddress"), va(64, "signature"), si("recoveryId")]);
new Sr("KeccakSecp256k11111111111111111111111111111");
var r4e;
new Sr("StakeConfig11111111111111111111111111111111");

class n4e {
    constructor(e, r, n) {
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = r, this.custodian = n
    }
}

r4e = n4e;
n4e.default = new r4e(0, 0, Sr.default);
Object.freeze({
    Initialize: {index: 0, layout: yr([Pr("instruction"), dgt(), hgt()])},
    Authorize: {index: 1, layout: yr([Pr("instruction"), ni("newAuthorized"), Pr("stakeAuthorizationType")])},
    Delegate: {index: 2, layout: yr([Pr("instruction")])},
    Split: {index: 3, layout: yr([Pr("instruction"), Df("lamports")])},
    Withdraw: {index: 4, layout: yr([Pr("instruction"), Df("lamports")])},
    Deactivate: {index: 5, layout: yr([Pr("instruction")])},
    Merge: {index: 7, layout: yr([Pr("instruction")])},
    AuthorizeWithSeed: {
        index: 8,
        layout: yr([Pr("instruction"), ni("newAuthorized"), Pr("stakeAuthorizationType"), kx("authoritySeed"), ni("authorityOwner")])
    }
});
new Sr("Stake11111111111111111111111111111111111111");
Object.freeze({
    InitializeAccount: {index: 0, layout: yr([Pr("instruction"), pgt()])},
    Authorize: {index: 1, layout: yr([Pr("instruction"), ni("newAuthorized"), Pr("voteAuthorizationType")])},
    Withdraw: {index: 3, layout: yr([Pr("instruction"), Df("lamports")])},
    UpdateValidatorIdentity: {index: 4, layout: yr([Pr("instruction")])},
    AuthorizeWithSeed: {index: 10, layout: yr([Pr("instruction"), mgt()])}
});
new Sr("Vote111111111111111111111111111111111111111");
new Sr("Va1idator1nfo111111111111111111111111111111");
Tt({name: Bt(), website: an(Bt()), details: an(Bt()), keybaseUsername: an(Bt())});
new Sr("Vote111111111111111111111111111111111111111");
yr([ni("nodePubkey"), ni("authorizedWithdrawer"), si("commission"), Mc(), xl(yr([Mc("slot"), Pr("confirmationCount")]), jw(Pr(), -8), "votes"), si("rootSlotValid"), Mc("rootSlot"), Mc(), xl(yr([Mc("epoch"), ni("authorizedVoter")]), jw(Pr(), -8), "authorizedVoters"), yr([xl(yr([ni("authorizedPubkey"), Mc("epochOfLastAuthorizedSwitch"), Mc("targetEpoch")]), 32, "buf"), Mc("idx"), si("isEmpty")], "priorVoters"), Mc(), xl(yr([Mc("epoch"), Mc("credits"), Mc("prevCredits")]), jw(Pr(), -8), "epochCredits"), yr([Mc("slot"), Mc("timestamp")], "lastTimestamp")]);
const ofe = {
    http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
};

function e1t(t, e) {
    const r = e === !1 ? "http" : "https";
    if (!t) return ofe[r].devnet;
    const n = ofe[r][t];
    if (!n) throw new Error(`Unknown ${r} cluster: ${t}`);
    return n
}

const HZ = new Sr("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
new Sr("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
const t1t = new Sr("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
new Sr("So11111111111111111111111111111111111111112");
new Sr("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
const WZ = t => {
    const e = t.decode.bind(t), r = t.encode.bind(t);
    return {decode: e, encode: r}
}, r1t = t => e => {
    const r = va(t, e), {encode: n, decode: i} = WZ(r), a = r;
    return a.decode = (o, s) => {
        const l = i(o, s);
        return Txe(kr.from(l))
    }, a.encode = (o, s, l) => {
        const f = Cxe(o, t);
        return n(f, s, l)
    }, a
}, ND = r1t(8), i4e = t => {
    const e = si(t), {encode: r, decode: n} = WZ(e), i = e;
    return i.decode = (a, o) => !!n(a, o), i.encode = (a, o, s) => {
        const l = Number(a);
        return r(l, o, s)
    }, i
}, Oc = t => {
    const e = va(32, t), {encode: r, decode: n} = WZ(e), i = e;
    return i.decode = (a, o) => {
        const s = n(a, o);
        return new Sr(s)
    }, i.encode = (a, o, s) => {
        const l = a.toBuffer();
        return r(l, o, s)
    }, i
};

class X8 extends Error {
    constructor(e) {
        super(e)
    }
}

class a4e extends X8 {
    constructor() {
        super(...arguments), this.name = "TokenAccountNotFoundError"
    }
}

class n1t extends X8 {
    constructor() {
        super(...arguments), this.name = "TokenInvalidAccountError"
    }
}

class i1t extends X8 {
    constructor() {
        super(...arguments), this.name = "TokenInvalidAccountOwnerError"
    }
}

class sfe extends X8 {
    constructor() {
        super(...arguments), this.name = "TokenInvalidAccountSizeError"
    }
}

class a1t extends X8 {
    constructor() {
        super(...arguments), this.name = "TokenOwnerOffCurveError"
    }
}

var XG;
(function (t) {
    t[t.Uninitialized = 0] = "Uninitialized", t[t.Mint = 1] = "Mint", t[t.Account = 2] = "Account"
})(XG || (XG = {}));
const o1t = 1,
    s1t = yr([si("m"), si("n"), i4e("isInitialized"), Oc("signer1"), Oc("signer2"), Oc("signer3"), Oc("signer4"), Oc("signer5"), Oc("signer6"), Oc("signer7"), Oc("signer8"), Oc("signer9"), Oc("signer10"), Oc("signer11")]),
    c1t = s1t.span;
var EO;
(function (t) {
    t[t.Uninitialized = 0] = "Uninitialized", t[t.Initialized = 1] = "Initialized", t[t.Frozen = 2] = "Frozen"
})(EO || (EO = {}));
const o4e = yr([Oc("mint"), Oc("owner"), ND("amount"), Pr("delegateOption"), Oc("delegate"), si("state"), Pr("isNativeOption"), ND("isNative"), ND("delegatedAmount"), Pr("closeAuthorityOption"), Oc("closeAuthority")]),
    eT = o4e.span;

async function l1t(t, e, r, n = HZ) {
    const i = await t.getAccountInfo(e, r);
    return u1t(e, i, n)
}

function u1t(t, e, r = HZ) {
    if (!e) throw new a4e;
    if (!e.owner.equals(r)) throw new i1t;
    if (e.data.length < eT) throw new sfe;
    const n = o4e.decode(e.data.slice(0, eT));
    let i = kr.alloc(0);
    if (e.data.length > eT) {
        if (e.data.length === c1t) throw new sfe;
        if (e.data[eT] != XG.Account) throw new n1t;
        i = e.data.slice(eT + o1t)
    }
    return {
        address: t,
        mint: n.mint,
        owner: n.owner,
        amount: n.amount,
        delegate: n.delegateOption ? n.delegate : null,
        delegatedAmount: n.delegatedAmount,
        isInitialized: n.state !== EO.Uninitialized,
        isFrozen: n.state === EO.Frozen,
        isNative: !!n.isNativeOption,
        rentExemptReserve: n.isNativeOption ? n.isNative : null,
        closeAuthority: n.closeAuthorityOption ? n.closeAuthority : null,
        tlvData: i
    }
}

yr([Pr("mintAuthorityOption"), Oc("mintAuthority"), ND("supply"), si("decimals"), i4e("isInitialized"), Pr("freezeAuthorityOption"), Oc("freezeAuthority")]);

function f1t(t, e, r = !1, n = HZ, i = t1t) {
    if (!r && !Sr.isOnCurve(e.toBuffer())) throw new a1t;
    const [a] = Sr.findProgramAddressSync([e.toBuffer(), n.toBuffer(), t.toBuffer()], i);
    return a
}

const s4e = W.createContext({});

function c4e() {
    return W.useContext(s4e)
}

const d1t = ({children: t, endpoint: e, config: r = {commitment: "confirmed"}}) => {
    const n = W.useMemo(() => new Jyt(e, r), [e, r]);
    return ar.createElement(s4e.Provider, {value: {connection: n}}, t)
};

class cfe extends _u {
    constructor() {
        super(...arguments), this.name = "WalletNotSelectedError"
    }
}

const h1t = [], qN = {
    autoConnect: !1, connecting: !1, connected: !1, disconnecting: !1, select() {
        Vh("call", "select")
    }, connect() {
        return Promise.reject(Vh("call", "connect"))
    }, disconnect() {
        return Promise.reject(Vh("call", "disconnect"))
    }, sendTransaction() {
        return Promise.reject(Vh("call", "sendTransaction"))
    }, signTransaction() {
        return Promise.reject(Vh("call", "signTransaction"))
    }, signAllTransactions() {
        return Promise.reject(Vh("call", "signAllTransactions"))
    }, signMessage() {
        return Promise.reject(Vh("call", "signMessage"))
    }, signIn() {
        return Promise.reject(Vh("call", "signIn"))
    }
};
Object.defineProperty(qN, "wallets", {
    get() {
        return Vh("read", "wallets"), h1t
    }
});
Object.defineProperty(qN, "wallet", {
    get() {
        return Vh("read", "wallet"), null
    }
});
Object.defineProperty(qN, "publicKey", {
    get() {
        return Vh("read", "publicKey"), null
    }
});

function Vh(t, e) {
    const r = new Error(`You have tried to ${t} "${e}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`);
    return console.error(r), r
}

const l4e = W.createContext(qN);

function p1t() {
    return W.useContext(l4e)
}

function m1t(t, e) {
    const r = W.useState(() => {
        try {
            const a = localStorage.getItem(t);
            if (a) return JSON.parse(a)
        } catch (a) {
            typeof window < "u" && console.error(a)
        }
        return e
    }), n = r[0], i = W.useRef(!0);
    return W.useEffect(() => {
        if (i.current) {
            i.current = !1;
            return
        }
        try {
            n === null ? localStorage.removeItem(t) : localStorage.setItem(t, JSON.stringify(n))
        } catch (a) {
            typeof window < "u" && console.error(a)
        }
    }, [n, t]), r
}

function EV(t) {
    switch (t) {
        case"processed":
        case"confirmed":
        case"finalized":
        case void 0:
            return t;
        case"recent":
            return "processed";
        case"single":
        case"singleGossip":
            return "confirmed";
        case"max":
        case"root":
            return "finalized";
        default:
            return
    }
}

const lfe = "solana:mainnet", v1t = "solana:devnet", g1t = "solana:testnet", y1t = "solana:localnet",
    b1t = "https://api.mainnet-beta.solana.com";

function w1t(t) {
    return t.includes(b1t) ? lfe : /\bdevnet\b/i.test(t) ? v1t : /\btestnet\b/i.test(t) ? g1t : /\blocalhost\b/i.test(t) || /\b127\.0\.0\.1\b/.test(t) ? y1t : lfe
}

function S1t(t) {
    let e = `${t.domain} wants you to sign in with your Solana account:
`;
    e += `${t.address}`, t.statement && (e += `

${t.statement}`);
    const r = [];
    if (t.uri && r.push(`URI: ${t.uri}`), t.version && r.push(`Version: ${t.version}`), t.chainId && r.push(`Chain ID: ${t.chainId}`), t.nonce && r.push(`Nonce: ${t.nonce}`), t.issuedAt && r.push(`Issued At: ${t.issuedAt}`), t.expirationTime && r.push(`Expiration Time: ${t.expirationTime}`), t.notBefore && r.push(`Not Before: ${t.notBefore}`), t.requestId && r.push(`Request ID: ${t.requestId}`), t.resources) {
        r.push("Resources:");
        for (const n of t.resources) r.push(`- ${n}`)
    }
    return r.length && (e += `

${r.join(`
`)}`), e
}

const $v = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
    ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION"
};

class Fv extends Error {
    constructor(...e) {
        const [r, n, i] = e;
        super(n), this.code = r, this.data = i, this.name = "SolanaMobileWalletAdapterError"
    }
}

class u4e extends Error {
    constructor(...e) {
        const [r, n, i, a] = e;
        super(i), this.code = n, this.data = a, this.jsonRpcMessageId = r, this.name = "SolanaMobileWalletAdapterProtocolError"
    }
}

function Ds(t, e, r, n) {
    function i(a) {
        return a instanceof r ? a : new r(function (o) {
            o(a)
        })
    }

    return new (r || (r = Promise))(function (a, o) {
        function s(d) {
            try {
                f(n.next(d))
            } catch (p) {
                o(p)
            }
        }

        function l(d) {
            try {
                f(n.throw(d))
            } catch (p) {
                o(p)
            }
        }

        function f(d) {
            d.done ? a(d.value) : i(d.value).then(s, l)
        }

        f((n = n.apply(t, e || [])).next())
    })
}

function _1t(t, e) {
    return Ds(this, void 0, void 0, function* () {
        const r = yield crypto.subtle.exportKey("raw", t),
            n = yield crypto.subtle.sign({hash: "SHA-256", name: "ECDSA"}, e, r),
            i = new Uint8Array(r.byteLength + n.byteLength);
        return i.set(new Uint8Array(r), 0), i.set(new Uint8Array(n), r.byteLength), i
    })
}

function x1t(t) {
    return window.btoa(t)
}

function E1t(t) {
    return S1t(t)
}

function T1t(t) {
    return x1t(E1t(t))
}

const C1t = "solana:signTransactions", ufe = "solana:cloneAuthorization";

function A1t(t, e) {
    return new Proxy({}, {
        get(r, n) {
            return r[n] == null && (r[n] = function (i) {
                return Ds(this, void 0, void 0, function* () {
                    const {method: a, params: o} = I1t(n, i, t), s = yield e(a, o);
                    return a === "authorize" && o.sign_in_payload && !s.sign_in_result && (s.sign_in_result = yield R1t(o.sign_in_payload, s, e)), k1t(n, s, t)
                })
            }), r[n]
        }, defineProperty() {
            return !1
        }, deleteProperty() {
            return !1
        }
    })
}

function I1t(t, e, r) {
    let n = e, i = t.toString().replace(/[A-Z]/g, a => `_${a.toLowerCase()}`).toLowerCase();
    switch (t) {
        case"authorize": {
            let {chain: a} = n;
            if (r === "legacy") {
                switch (a) {
                    case"solana:testnet": {
                        a = "testnet";
                        break
                    }
                    case"solana:devnet": {
                        a = "devnet";
                        break
                    }
                    case"solana:mainnet": {
                        a = "mainnet-beta";
                        break
                    }
                    default:
                        a = n.cluster
                }
                n.cluster = a
            } else {
                switch (a) {
                    case"testnet":
                    case"devnet": {
                        a = `solana:${a}`;
                        break
                    }
                    case"mainnet-beta": {
                        a = "solana:mainnet";
                        break
                    }
                }
                n.chain = a
            }
        }
        case"reauthorize": {
            const {auth_token: a, identity: o} = n;
            if (a) switch (r) {
                case"legacy": {
                    i = "reauthorize", n = {auth_token: a, identity: o};
                    break
                }
                default: {
                    i = "authorize";
                    break
                }
            }
            break
        }
    }
    return {method: i, params: n}
}

function k1t(t, e, r) {
    switch (t) {
        case"getCapabilities": {
            const n = e;
            switch (r) {
                case"legacy": {
                    const i = [C1t];
                    return n.supports_clone_authorization === !0 && i.push(ufe), Object.assign(Object.assign({}, n), {features: i})
                }
                case"v1":
                    return Object.assign(Object.assign({}, n), {
                        supports_sign_and_send_transactions: !0,
                        supports_clone_authorization: n.features.includes(ufe)
                    })
            }
        }
    }
    return e
}

function R1t(t, e, r) {
    var n;
    return Ds(this, void 0, void 0, function* () {
        const i = (n = t.domain) !== null && n !== void 0 ? n : window.location.host, a = e.accounts[0].address,
            o = T1t(Object.assign(Object.assign({}, t), {domain: i, address: a})),
            s = yield r("sign_messages", {addresses: [a], payloads: [o]});
        return {address: a, signed_message: o, signature: s.signed_payloads[0].slice(o.length)}
    })
}

const Cw = 4;

function D1t(t) {
    if (t >= 4294967296) throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
    const e = new ArrayBuffer(Cw);
    return new DataView(e).setUint32(0, t, !1), new Uint8Array(e)
}

const QG = 12, f4e = 65;

function M1t(t, e, r) {
    return Ds(this, void 0, void 0, function* () {
        const n = D1t(e), i = new Uint8Array(QG);
        crypto.getRandomValues(i);
        const a = yield crypto.subtle.encrypt(h4e(n, i), r, new TextEncoder().encode(t)),
            o = new Uint8Array(n.byteLength + i.byteLength + a.byteLength);
        return o.set(new Uint8Array(n), 0), o.set(new Uint8Array(i), n.byteLength), o.set(new Uint8Array(a), n.byteLength + i.byteLength), o
    })
}

function d4e(t, e) {
    return Ds(this, void 0, void 0, function* () {
        const r = t.slice(0, Cw), n = t.slice(Cw, Cw + QG), i = t.slice(Cw + QG),
            a = yield crypto.subtle.decrypt(h4e(r, n), e, i);
        return O1t().decode(a)
    })
}

function h4e(t, e) {
    return {additionalData: t, iv: e, name: "AES-GCM", tagLength: 128}
}

let TV;

function O1t() {
    return TV === void 0 && (TV = new TextDecoder("utf-8")), TV
}

function P1t() {
    return Ds(this, void 0, void 0, function* () {
        return yield crypto.subtle.generateKey({name: "ECDSA", namedCurve: "P-256"}, !1, ["sign"])
    })
}

function N1t() {
    return Ds(this, void 0, void 0, function* () {
        return yield crypto.subtle.generateKey({name: "ECDH", namedCurve: "P-256"}, !1, ["deriveKey", "deriveBits"])
    })
}

function L1t(t, e) {
    return Ds(this, void 0, void 0, function* () {
        const r = JSON.stringify(t), n = t.id;
        return M1t(r, n, e)
    })
}

function B1t(t, e) {
    return Ds(this, void 0, void 0, function* () {
        const r = yield d4e(t, e), n = JSON.parse(r);
        if (Object.hasOwnProperty.call(n, "error")) throw new u4e(n.id, n.error.code, n.error.message);
        return n
    })
}

function $1t(t, e, r) {
    return Ds(this, void 0, void 0, function* () {
        const [n, i] = yield Promise.all([crypto.subtle.exportKey("raw", e), crypto.subtle.importKey("raw", t.slice(0, f4e), {
                name: "ECDH",
                namedCurve: "P-256"
            }, !1, [])]), a = yield crypto.subtle.deriveBits({name: "ECDH", public: i}, r, 256),
            o = yield crypto.subtle.importKey("raw", a, "HKDF", !1, ["deriveKey"]);
        return yield crypto.subtle.deriveKey({
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array(n),
            info: new Uint8Array
        }, o, {name: "AES-GCM", length: 128}, !1, ["encrypt", "decrypt"])
    })
}

function F1t(t, e) {
    return Ds(this, void 0, void 0, function* () {
        const r = yield d4e(t, e), n = JSON.parse(r);
        let i = "legacy";
        if (Object.hasOwnProperty.call(n, "v")) switch (n.v) {
            case 1:
            case"1":
            case"v1":
                i = "v1";
                break;
            case"legacy":
                i = "legacy";
                break;
            default:
                throw new Fv($v.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${n.v}`)
        }
        return {protocol_version: i}
    })
}

function U1t() {
    return p4e(49152 + Math.floor(Math.random() * 16384))
}

function p4e(t) {
    if (t < 49152 || t > 65535) throw new Fv($v.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${t} given.`, {port: t});
    return t
}

function j1t(t) {
    let e = "";
    const r = new Uint8Array(t), n = r.byteLength;
    for (let i = 0; i < n; i++) e += String.fromCharCode(r[i]);
    return window.btoa(e)
}

function z1t(t) {
    return t.replace(/[/+=]/g, e => ({"/": "_", "+": "-", "=": "."})[e])
}

const V1t = "solana-wallet";

function ffe(t) {
    return t.replace(/(^\/+|\/+$)/g, "").split("/")
}

function H1t(t, e) {
    let r = null;
    if (e) {
        try {
            r = new URL(e)
        } catch {
        }
        if ((r == null ? void 0 : r.protocol) !== "https:") throw new Fv($v.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs")
    }
    r || (r = new URL(`${V1t}:/`));
    const n = t.startsWith("/") ? t : [...ffe(r.pathname), ...ffe(t)].join("/");
    return new URL(n, r)
}

function W1t(t, e, r, n = ["v1"]) {
    return Ds(this, void 0, void 0, function* () {
        const i = p4e(e), a = yield crypto.subtle.exportKey("raw", t), o = j1t(a), s = H1t("v1/associate/local", r);
        return s.searchParams.set("association", z1t(o)), s.searchParams.set("port", `${i}`), n.forEach(l => {
            s.searchParams.set("v", l)
        }), s
    })
}

const TO = {Firefox: 0, Other: 1};

function q1t() {
    return navigator.userAgent.indexOf("Firefox/") !== -1 ? TO.Firefox : TO.Other
}

function G1t() {
    return new Promise((t, e) => {
        function r() {
            clearTimeout(i), window.removeEventListener("blur", n)
        }

        function n() {
            r(), t()
        }

        window.addEventListener("blur", n);
        const i = setTimeout(() => {
            r(), e()
        }, 2e3)
    })
}

let tT = null;

function K1t(t) {
    tT == null && (tT = document.createElement("iframe"), tT.style.display = "none", document.body.appendChild(tT)), tT.contentWindow.location.href = t.toString()
}

function Y1t(t, e) {
    return Ds(this, void 0, void 0, function* () {
        const r = U1t(), n = yield W1t(t, r, e);
        if (n.protocol === "https:") window.location.assign(n); else try {
            switch (q1t()) {
                case TO.Firefox:
                    K1t(n);
                    break;
                case TO.Other: {
                    const a = G1t();
                    window.location.assign(n), yield a;
                    break
                }
            }
        } catch {
            throw new Fv($v.ERROR_WALLET_NOT_FOUND, "Found no installed wallet that supports the mobile wallet protocol.")
        }
        return r
    })
}

const dfe = {retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3], timeoutMs: 3e4},
    X1t = "com.solana.mobilewalletadapter.v1";

function Q1t() {
    if (typeof window > "u" || window.isSecureContext !== !0) throw new Fv($v.ERROR_SECURE_CONTEXT_REQUIRED, "The mobile wallet adapter protocol must be used in a secure context (`https`).")
}

function Z1t(t) {
    let e;
    try {
        e = new URL(t)
    } catch {
        throw new Fv($v.ERROR_FORBIDDEN_WALLET_BASE_URL, "Invalid base URL supplied by wallet")
    }
    if (e.protocol !== "https:") throw new Fv($v.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs")
}

function hfe(t) {
    return new DataView(t).getUint32(0, !1)
}

function J1t(t, e) {
    return Ds(this, void 0, void 0, function* () {
        Q1t();
        const r = yield P1t(), n = yield Y1t(r.publicKey, e == null ? void 0 : e.baseUri),
            i = `ws://localhost:${n}/solana-wallet`;
        let a;
        const o = (() => {
            const d = [...dfe.retryDelayScheduleMs];
            return () => d.length > 1 ? d.shift() : d[0]
        })();
        let s = 1, l = 0, f = {__type: "disconnected"};
        return new Promise((d, p) => {
            let g;
            const b = {}, S = () => Ds(this, void 0, void 0, function* () {
                if (f.__type !== "connecting") {
                    console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${f.__type}\`.`);
                    return
                }
                const {associationKeypair: Y} = f;
                g.removeEventListener("open", S);
                const ee = yield N1t();
                g.send(yield _1t(ee.publicKey, Y.privateKey)), f = {
                    __type: "hello_req_sent",
                    associationPublicKey: Y.publicKey,
                    ecdhPrivateKey: ee.privateKey
                }
            }), T = Y => {
                Y.wasClean ? f = {__type: "disconnected"} : p(new Fv($v.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${Y.code}: ${Y.reason}).`, {closeEvent: Y})), P()
            }, I = Y => Ds(this, void 0, void 0, function* () {
                P(), Date.now() - a >= dfe.timeoutMs ? p(new Fv($v.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket on port ${n}.`)) : (yield new Promise(ee => {
                    const oe = o();
                    F = window.setTimeout(ee, oe)
                }), V())
            }), N = Y => Ds(this, void 0, void 0, function* () {
                const ee = yield Y.data.arrayBuffer();
                switch (f.__type) {
                    case"connected":
                        try {
                            const oe = ee.slice(0, Cw), G = hfe(oe);
                            if (G !== l + 1) throw new Error("Encrypted message has invalid sequence number");
                            l = G;
                            const J = yield B1t(ee, f.sharedSecret), ce = b[J.id];
                            delete b[J.id], ce.resolve(J.result)
                        } catch (oe) {
                            if (oe instanceof u4e) {
                                const G = b[oe.jsonRpcMessageId];
                                delete b[oe.jsonRpcMessageId], G.reject(oe)
                            } else throw oe
                        }
                        break;
                    case"hello_req_sent": {
                        const oe = yield $1t(ee, f.associationPublicKey, f.ecdhPrivateKey), G = ee.slice(f4e),
                            J = G.byteLength !== 0 ? yield Ds(this, void 0, void 0, function* () {
                                const re = G.slice(0, Cw), M = hfe(re);
                                if (M !== l + 1) throw new Error("Encrypted message has invalid sequence number");
                                return l = M, F1t(G, oe)
                            }) : {protocol_version: "legacy"};
                        f = {__type: "connected", sharedSecret: oe, sessionProperties: J};
                        const ce = A1t(J.protocol_version, (re, M) => Ds(this, void 0, void 0, function* () {
                            const D = s++;
                            return g.send(yield L1t({
                                id: D,
                                jsonrpc: "2.0",
                                method: re,
                                params: M ?? {}
                            }, oe)), new Promise((x, A) => {
                                b[D] = {
                                    resolve(B) {
                                        switch (re) {
                                            case"authorize":
                                            case"reauthorize": {
                                                const {wallet_uri_base: z} = B;
                                                if (z != null) try {
                                                    Z1t(z)
                                                } catch (j) {
                                                    A(j);
                                                    return
                                                }
                                                break
                                            }
                                        }
                                        x(B)
                                    }, reject: A
                                }
                            })
                        }));
                        try {
                            d(yield t(ce))
                        } catch (re) {
                            p(re)
                        } finally {
                            P(), g.close()
                        }
                        break
                    }
                }
            });
            let P, F;
            const V = () => {
                P && P(), f = {
                    __type: "connecting",
                    associationKeypair: r
                }, a === void 0 && (a = Date.now()), g = new WebSocket(i, [X1t]), g.addEventListener("open", S), g.addEventListener("close", T), g.addEventListener("error", I), g.addEventListener("message", N), P = () => {
                    window.clearTimeout(F), g.removeEventListener("open", S), g.removeEventListener("close", T), g.removeEventListener("error", I), g.removeEventListener("message", N)
                }
            };
            V()
        })
    })
}

function ebt(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
    for (var n = 0; n < t.length; n++) {
        var i = t.charAt(n), a = i.charCodeAt(0);
        if (e[a] !== 255) throw new TypeError(i + " is ambiguous");
        e[a] = n
    }
    var o = t.length, s = t.charAt(0), l = Math.log(o) / Math.log(256), f = Math.log(256) / Math.log(o);

    function d(b) {
        if (b instanceof Uint8Array || (ArrayBuffer.isView(b) ? b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength) : Array.isArray(b) && (b = Uint8Array.from(b))), !(b instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (b.length === 0) return "";
        for (var S = 0, T = 0, I = 0, N = b.length; I !== N && b[I] === 0;) I++, S++;
        for (var P = (N - I) * f + 1 >>> 0, F = new Uint8Array(P); I !== N;) {
            for (var V = b[I], Y = 0, ee = P - 1; (V !== 0 || Y < T) && ee !== -1; ee--, Y++) V += 256 * F[ee] >>> 0, F[ee] = V % o >>> 0, V = V / o >>> 0;
            if (V !== 0) throw new Error("Non-zero carry");
            T = Y, I++
        }
        for (var oe = P - T; oe !== P && F[oe] === 0;) oe++;
        for (var G = s.repeat(S); oe < P; ++oe) G += t.charAt(F[oe]);
        return G
    }

    function p(b) {
        if (typeof b != "string") throw new TypeError("Expected String");
        if (b.length === 0) return new Uint8Array;
        for (var S = 0, T = 0, I = 0; b[S] === s;) T++, S++;
        for (var N = (b.length - S) * l + 1 >>> 0, P = new Uint8Array(N); b[S];) {
            var F = e[b.charCodeAt(S)];
            if (F === 255) return;
            for (var V = 0, Y = N - 1; (F !== 0 || V < I) && Y !== -1; Y--, V++) F += o * P[Y] >>> 0, P[Y] = F % 256 >>> 0, F = F / 256 >>> 0;
            if (F !== 0) throw new Error("Non-zero carry");
            I = V, S++
        }
        for (var ee = N - I; ee !== N && P[ee] === 0;) ee++;
        for (var oe = new Uint8Array(T + (N - ee)), G = T; ee !== N;) oe[G++] = P[ee++];
        return oe
    }

    function g(b) {
        var S = p(b);
        if (S) return S;
        throw new Error("Non-base" + o + " character")
    }

    return {encode: d, decodeUnsafe: p, decode: g}
}

var tbt = ebt;
const rbt = tbt, nbt = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var ibt = rbt(nbt);
const qZ = za(ibt);

function CV(t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
}

function w7(t, e, r, n) {
    function i(a) {
        return a instanceof r ? a : new r(function (o) {
            o(a)
        })
    }

    return new (r || (r = Promise))(function (a, o) {
        function s(d) {
            try {
                f(n.next(d))
            } catch (p) {
                o(p)
            }
        }

        function l(d) {
            try {
                f(n.throw(d))
            } catch (p) {
                o(p)
            }
        }

        function f(d) {
            d.done ? a(d.value) : i(d.value).then(s, l)
        }

        f((n = n.apply(t, e || [])).next())
    })
}

function m4e(t) {
    return window.btoa(String.fromCharCode.call(null, ...t))
}

function AV(t) {
    return new Uint8Array(window.atob(t).split("").map(e => e.charCodeAt(0)))
}

function pfe(t) {
    const e = "version" in t ? t.serialize() : t.serialize({requireAllSignatures: !1, verifySignatures: !1});
    return m4e(e)
}

function abt(t) {
    const r = t[0] * wA + 1;
    return FZ.deserializeMessageVersion(t.slice(r, t.length)) === "legacy" ? Yh.from(t) : K4.deserialize(t)
}

function obt(t, e) {
    return w7(this, void 0, void 0, function* () {
        return yield J1t(n => {
            const i = new Proxy({}, {
                get(a, o) {
                    if (a[o] == null) switch (o) {
                        case"signAndSendTransactions":
                            a[o] = function (s) {
                                var {
                                        minContextSlot: l,
                                        commitment: f,
                                        skipPreflight: d,
                                        maxRetries: p,
                                        waitForCommitmentToSendNextTransaction: g,
                                        transactions: b
                                    } = s,
                                    S = CV(s, ["minContextSlot", "commitment", "skipPreflight", "maxRetries", "waitForCommitmentToSendNextTransaction", "transactions"]);
                                return w7(this, void 0, void 0, function* () {
                                    const T = b.map(pfe), I = {
                                        min_context_slot: l,
                                        commitment: f,
                                        skip_preflight: d,
                                        max_retries: p,
                                        wait_for_commitment_to_send_next_transaction: g
                                    }, {signatures: N} = yield n.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, S), Object.values(I).some(F => F != null) ? {options: I} : null), {payloads: T}));
                                    return N.map(AV).map(qZ.encode)
                                })
                            };
                            break;
                        case"signMessages":
                            a[o] = function (s) {
                                var {payloads: l} = s, f = CV(s, ["payloads"]);
                                return w7(this, void 0, void 0, function* () {
                                    const d = l.map(m4e), {signed_payloads: p} = yield n.signMessages(Object.assign(Object.assign({}, f), {payloads: d}));
                                    return p.map(AV)
                                })
                            };
                            break;
                        case"signTransactions":
                            a[o] = function (s) {
                                var {transactions: l} = s, f = CV(s, ["transactions"]);
                                return w7(this, void 0, void 0, function* () {
                                    const d = l.map(pfe), {signed_payloads: p} = yield n.signTransactions(Object.assign(Object.assign({}, f), {payloads: d}));
                                    return p.map(AV).map(abt)
                                })
                            };
                            break;
                        default: {
                            a[o] = n[o];
                            break
                        }
                    }
                    return a[o]
                }, defineProperty() {
                    return !1
                }, deleteProperty() {
                    return !1
                }
            });
            return t(i)
        }, e)
    })
}

function Mi(t, e, r, n) {
    function i(a) {
        return a instanceof r ? a : new r(function (o) {
            o(a)
        })
    }

    return new (r || (r = Promise))(function (a, o) {
        function s(d) {
            try {
                f(n.next(d))
            } catch (p) {
                o(p)
            }
        }

        function l(d) {
            try {
                f(n.throw(d))
            } catch (p) {
                o(p)
            }
        }

        function f(d) {
            d.done ? a(d.value) : i(d.value).then(s, l)
        }

        f((n = n.apply(t, e || [])).next())
    })
}

function LD(t) {
    return new Uint8Array(window.atob(t).split("").map(e => e.charCodeAt(0)))
}

function sbt() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}

const yy = "Mobile Wallet Adapter", cbt = 64;

function lbt(t) {
    const e = LD(t);
    return new Sr(e)
}

function mfe(t) {
    return "version" in t
}

class ubt extends f0t {
    constructor(e) {
        var r;
        super(), this.supportedTransactionVersions = new Set(["legacy", 0]), this.name = yy, this.url = "https://solanamobile.com/wallets", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==", this._connecting = !1, this._connectionGeneration = 0, this._readyState = sbt() ? la.Loadable : la.Unsupported, this._authorizationResultCache = e.authorizationResultCache, this._addressSelector = e.addressSelector, this._appIdentity = e.appIdentity, this._chain = (r = e.chain) !== null && r !== void 0 ? r : e.cluster, this._onWalletNotFound = e.onWalletNotFound, this._readyState !== la.Unsupported && this._authorizationResultCache.get().then(n => {
            n && this.declareWalletAsInstalled()
        })
    }

    get publicKey() {
        if (this._publicKey == null && this._selectedAddress != null) try {
            this._publicKey = lbt(this._selectedAddress)
        } catch (e) {
            throw new $_e(e instanceof Error && (e == null ? void 0 : e.message) || "Unknown error", e)
        }
        return this._publicKey ? this._publicKey : null
    }

    get connected() {
        return !!this._authorizationResult
    }

    get connecting() {
        return this._connecting
    }

    get readyState() {
        return this._readyState
    }

    declareWalletAsInstalled() {
        this._readyState !== la.Installed && this.emit("readyStateChange", this._readyState = la.Installed)
    }

    runWithGuard(e) {
        return Mi(this, void 0, void 0, function* () {
            try {
                return yield e()
            } catch (r) {
                throw this.emit("error", r), r
            }
        })
    }

    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return Mi(this, void 0, void 0, function* () {
            return yield this.autoConnect()
        })
    }

    autoConnect() {
        return Mi(this, void 0, void 0, function* () {
            if (!(this.connecting || this.connected)) return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                if (this._readyState !== la.Installed && this._readyState !== la.Loadable) throw new i4;
                this._connecting = !0;
                try {
                    const e = yield this._authorizationResultCache.get();
                    e && this.handleAuthorizationResult(e)
                } catch (e) {
                    throw new IT(e instanceof Error && e.message || "Unknown error", e)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }

    connect() {
        return Mi(this, void 0, void 0, function* () {
            if (!(this.connecting || this.connected)) return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                if (this._readyState !== la.Installed && this._readyState !== la.Loadable) throw new i4;
                this._connecting = !0;
                try {
                    yield this.performAuthorization()
                } catch (e) {
                    throw new IT(e instanceof Error && e.message || "Unknown error", e)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }

    performAuthorization(e) {
        return Mi(this, void 0, void 0, function* () {
            try {
                const r = yield this._authorizationResultCache.get();
                return r ? (this.handleAuthorizationResult(r), r) : yield this.transact(n => Mi(this, void 0, void 0, function* () {
                    const i = yield n.authorize({chain: this._chain, identity: this._appIdentity, sign_in_payload: e});
                    return Promise.all([this._authorizationResultCache.set(i), this.handleAuthorizationResult(i)]), i
                }))
            } catch (r) {
                throw new IT(r instanceof Error && r.message || "Unknown error", r)
            }
        })
    }

    handleAuthorizationResult(e) {
        var r;
        return Mi(this, void 0, void 0, function* () {
            const n = this._authorizationResult == null || ((r = this._authorizationResult) === null || r === void 0 ? void 0 : r.accounts.length) !== e.accounts.length || this._authorizationResult.accounts.some((i, a) => i.address !== e.accounts[a].address);
            if (this._authorizationResult = e, this.declareWalletAsInstalled(), n) {
                const i = yield this._addressSelector.select(e.accounts.map(({address: a}) => a));
                i !== this._selectedAddress && (this._selectedAddress = i, delete this._publicKey, this.emit("connect", this.publicKey))
            }
        })
    }

    performReauthorization(e, r) {
        return Mi(this, void 0, void 0, function* () {
            try {
                const n = yield e.authorize({auth_token: r, identity: this._appIdentity});
                Promise.all([this._authorizationResultCache.set(n), this.handleAuthorizationResult(n)])
            } catch (n) {
                throw this.disconnect(), new B_e(n instanceof Error && (n == null ? void 0 : n.message) || "Unknown error", n)
            }
        })
    }

    disconnect() {
        return Mi(this, void 0, void 0, function* () {
            this._authorizationResultCache.clear(), this._connecting = !1, this._connectionGeneration++, delete this._authorizationResult, delete this._publicKey, delete this._selectedAddress, this.emit("disconnect")
        })
    }

    transact(e) {
        var r;
        return Mi(this, void 0, void 0, function* () {
            const n = (r = this._authorizationResult) === null || r === void 0 ? void 0 : r.wallet_uri_base,
                i = n ? {baseUri: n} : void 0, a = this._connectionGeneration;
            try {
                return yield obt(e, i)
            } catch (o) {
                throw this._connectionGeneration !== a && (yield new Promise(() => {
                })), o instanceof Error && o.name === "SolanaMobileWalletAdapterError" && o.code === "ERROR_WALLET_NOT_FOUND" && (yield this._onWalletNotFound(this)), o
            }
        })
    }

    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress) throw new T0;
        return {authToken: this._authorizationResult.auth_token, selectedAddress: this._selectedAddress}
    }

    performSignTransactions(e) {
        return Mi(this, void 0, void 0, function* () {
            const {authToken: r} = this.assertIsAuthorized();
            try {
                return yield this.transact(n => Mi(this, void 0, void 0, function* () {
                    return yield this.performReauthorization(n, r), yield n.signTransactions({transactions: e})
                }))
            } catch (n) {
                throw new Ay(n == null ? void 0 : n.message, n)
            }
        })
    }

    sendTransaction(e, r, n) {
        return Mi(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                const {authToken: i} = this.assertIsAuthorized(), a = n == null ? void 0 : n.minContextSlot;
                try {
                    return yield this.transact(o => Mi(this, void 0, void 0, function* () {
                        function s() {
                            let p;
                            switch (r.commitment) {
                                case"confirmed":
                                case"finalized":
                                case"processed":
                                    p = r.commitment;
                                    break;
                                default:
                                    p = "finalized"
                            }
                            let g;
                            switch (n == null ? void 0 : n.preflightCommitment) {
                                case"confirmed":
                                case"finalized":
                                case"processed":
                                    g = n.preflightCommitment;
                                    break;
                                case void 0:
                                    g = p;
                                    break;
                                default:
                                    g = "finalized"
                            }
                            return (g === "finalized" ? 2 : g === "confirmed" ? 1 : 0) < (p === "finalized" ? 2 : p === "confirmed" ? 1 : 0) ? g : p
                        }

                        const [l, f, d] = yield Promise.all([o.getCapabilities(), this.performReauthorization(o, i), mfe(e) ? null : Mi(this, void 0, void 0, function* () {
                            var p;
                            if (e.feePayer || (e.feePayer = (p = this.publicKey) !== null && p !== void 0 ? p : void 0), e.recentBlockhash == null) {
                                const {blockhash: g} = yield r.getLatestBlockhash({commitment: s()});
                                e.recentBlockhash = g
                            }
                        })]);
                        if (l.supports_sign_and_send_transactions) return (yield o.signAndSendTransactions({
                            minContextSlot: a,
                            transactions: [e]
                        }))[0];
                        {
                            const [p] = yield o.signTransactions({transactions: [e]});
                            if (mfe(p)) return yield r.sendTransaction(p);
                            {
                                const g = p.serialize();
                                return yield r.sendRawTransaction(g, Object.assign(Object.assign({}, n), {preflightCommitment: s()}))
                            }
                        }
                    }))
                } catch (o) {
                    throw new Ew(o == null ? void 0 : o.message, o)
                }
            }))
        })
    }

    signTransaction(e) {
        return Mi(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                const [r] = yield this.performSignTransactions([e]);
                return r
            }))
        })
    }

    signAllTransactions(e) {
        return Mi(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                return yield this.performSignTransactions(e)
            }))
        })
    }

    signMessage(e) {
        return Mi(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                const {authToken: r, selectedAddress: n} = this.assertIsAuthorized();
                try {
                    return yield this.transact(i => Mi(this, void 0, void 0, function* () {
                        yield this.performReauthorization(i, r);
                        const [a] = yield i.signMessages({addresses: [n], payloads: [e]});
                        return a.slice(-cbt)
                    }))
                } catch (i) {
                    throw new gZ(i == null ? void 0 : i.message, i)
                }
            }))
        })
    }

    signIn(e) {
        return Mi(this, void 0, void 0, function* () {
            return yield this.runWithGuard(() => Mi(this, void 0, void 0, function* () {
                var r, n;
                if (this._readyState !== la.Installed && this._readyState !== la.Loadable) throw new i4;
                this._connecting = !0;
                try {
                    const i = yield this.performAuthorization(Object.assign(Object.assign({}, e), {domain: (r = e == null ? void 0 : e.domain) !== null && r !== void 0 ? r : window.location.host}));
                    if (!i.sign_in_result) throw new Error("Sign in failed, no sign in result returned by wallet");
                    const a = i.sign_in_result.address;
                    return {
                        account: Object.assign(Object.assign({}, (n = i.accounts.find(s => s.address == a)) !== null && n !== void 0 ? n : {address: a}), {publicKey: LD(a)}),
                        signedMessage: LD(i.sign_in_result.signed_message),
                        signature: LD(i.sign_in_result.signature)
                    }
                } catch (i) {
                    throw new IT(i instanceof Error && i.message || "Unknown error", i)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
}

function fbt() {
    return {
        select(t) {
            return Mi(this, void 0, void 0, function* () {
                return t[0]
            })
        }
    }
}

const IV = "SolanaMobileWalletAdapterDefaultAuthorizationCache";

function dbt() {
    let t;
    try {
        t = window.localStorage
    } catch {
    }
    return {
        clear() {
            return Mi(this, void 0, void 0, function* () {
                if (t) try {
                    t.removeItem(IV)
                } catch {
                }
            })
        }, get() {
            return Mi(this, void 0, void 0, function* () {
                if (t) try {
                    return JSON.parse(t.getItem(IV)) || void 0
                } catch {
                }
            })
        }, set(e) {
            return Mi(this, void 0, void 0, function* () {
                if (t) try {
                    t.setItem(IV, JSON.stringify(e))
                } catch {
                }
            })
        }
    }
}

function hbt(t) {
    return Mi(this, void 0, void 0, function* () {
        typeof window < "u" && window.location.assign(t.url)
    })
}

function pbt() {
    return hbt
}

function mbt(t, e) {
    if (t === e) return !0;
    const r = t.length;
    if (r !== e.length) return !1;
    for (let n = 0; n < r; n++) if (t[n] !== e[n]) return !1;
    return !0
}

var is = function (t, e, r, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
}, Ir = function (t, e, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t)
}, Nc, Wu, Aw, Iw, nw, DT, CO, Oi, AO, ZG, BD, JG, sC, eK, vfe, gfe, yfe, bfe;

class vbt extends F_e {
    constructor({wallet: e}) {
        super(), Nc.add(this), Wu.set(this, void 0), Aw.set(this, void 0), Iw.set(this, void 0), nw.set(this, void 0), DT.set(this, void 0), CO.set(this, void 0), Oi.set(this, void 0), AO.set(this, typeof window > "u" || typeof document > "u" ? la.Unsupported : la.Installed), eK.set(this, r => {
            if ("accounts" in r) {
                const n = Ir(this, Oi, "f").accounts[0];
                Ir(this, Wu, "f") && !Ir(this, nw, "f") && n !== Ir(this, Wu, "f") && (n ? Ir(this, Nc, "m", BD).call(this, n) : (this.emit("error", new B_e), Ir(this, Nc, "m", JG).call(this)))
            }
            "features" in r && Ir(this, Nc, "m", sC).call(this)
        }), is(this, Oi, e, "f"), is(this, Wu, null, "f"), is(this, Aw, null, "f"), is(this, Iw, !1, "f"), is(this, nw, !1, "f"), is(this, DT, Ir(this, Oi, "f").features[j_e].on("change", Ir(this, eK, "f")), "f"), Ir(this, Nc, "m", sC).call(this)
    }

    get name() {
        return Ir(this, Oi, "f").name
    }

    get url() {
        return "https://github.com/solana-labs/wallet-standard"
    }

    get icon() {
        return Ir(this, Oi, "f").icon
    }

    get readyState() {
        return Ir(this, AO, "f")
    }

    get publicKey() {
        return Ir(this, Aw, "f")
    }

    get connecting() {
        return Ir(this, Iw, "f")
    }

    get supportedTransactionVersions() {
        return Ir(this, CO, "f")
    }

    get wallet() {
        return Ir(this, Oi, "f")
    }

    get standard() {
        return !0
    }

    destroy() {
        is(this, Wu, null, "f"), is(this, Aw, null, "f"), is(this, Iw, !1, "f"), is(this, nw, !1, "f");
        const e = Ir(this, DT, "f");
        e && (is(this, DT, null, "f"), e())
    }

    async autoConnect() {
        return Ir(this, Nc, "m", ZG).call(this, {silent: !0})
    }

    async connect() {
        return Ir(this, Nc, "m", ZG).call(this)
    }

    async disconnect() {
        if (Sue in Ir(this, Oi, "f").features) try {
            is(this, nw, !0, "f"), await Ir(this, Oi, "f").features[Sue].disconnect()
        } catch (e) {
            this.emit("error", new c0t(e == null ? void 0 : e.message, e))
        } finally {
            is(this, nw, !1, "f")
        }
        Ir(this, Nc, "m", JG).call(this)
    }

    async sendTransaction(e, r, n = {}) {
        try {
            const i = Ir(this, Wu, "f");
            if (!i) throw new T0;
            let a;
            if (Sy in Ir(this, Oi, "f").features) if (i.features.includes(Sy)) a = Sy; else if (Pc in Ir(this, Oi, "f").features && i.features.includes(Pc)) a = Pc; else throw new Ix; else if (Pc in Ir(this, Oi, "f").features) {
                if (!i.features.includes(Pc)) throw new Ix;
                a = Pc
            } else throw new AT;
            const o = w1t(r.rpcEndpoint);
            if (!i.chains.includes(o)) throw new Ew;
            try {
                const {signers: s, ...l} = n;
                let f;
                if (Tw(e) ? (s != null && s.length && e.sign(s), f = e.serialize()) : (e = await this.prepareTransaction(e, r, l), s != null && s.length && e.partialSign(...s), f = new Uint8Array(e.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))), a === Sy) {
                    const [d] = await Ir(this, Oi, "f").features[Sy].signAndSendTransaction({
                        account: i,
                        chain: o,
                        transaction: f,
                        options: {
                            preflightCommitment: EV(l.preflightCommitment || r.commitment),
                            skipPreflight: l.skipPreflight,
                            maxRetries: l.maxRetries,
                            minContextSlot: l.minContextSlot
                        }
                    });
                    return qZ.encode(d.signature)
                } else {
                    const [d] = await Ir(this, Oi, "f").features[Pc].signTransaction({
                        account: i,
                        chain: o,
                        transaction: f,
                        options: {
                            preflightCommitment: EV(l.preflightCommitment || r.commitment),
                            minContextSlot: l.minContextSlot
                        }
                    });
                    return await r.sendRawTransaction(d.signedTransaction, {
                        ...l,
                        preflightCommitment: EV(l.preflightCommitment || r.commitment)
                    })
                }
            } catch (s) {
                throw s instanceof _u ? s : new Ew(s == null ? void 0 : s.message, s)
            }
        } catch (i) {
            throw this.emit("error", i), i
        }
    }
}

Wu = new WeakMap, Aw = new WeakMap, Iw = new WeakMap, nw = new WeakMap, DT = new WeakMap, CO = new WeakMap, Oi = new WeakMap, AO = new WeakMap, eK = new WeakMap, Nc = new WeakSet, ZG = async function (e) {
    try {
        if (this.connected || this.connecting) return;
        if (Ir(this, AO, "f") !== la.Installed) throw new i4;
        if (is(this, Iw, !0, "f"), !Ir(this, Oi, "f").accounts.length) try {
            await Ir(this, Oi, "f").features[U_e].connect(e)
        } catch (n) {
            throw new IT(n == null ? void 0 : n.message, n)
        }
        const r = Ir(this, Oi, "f").accounts[0];
        if (!r) throw new Ix;
        Ir(this, Nc, "m", BD).call(this, r)
    } catch (r) {
        throw this.emit("error", r), r
    } finally {
        is(this, Iw, !1, "f")
    }
}, BD = function (e) {
    let r;
    try {
        r = new Sr(e.address)
    } catch (n) {
        throw new $_e(n == null ? void 0 : n.message, n)
    }
    is(this, Wu, e, "f"), is(this, Aw, r, "f"), Ir(this, Nc, "m", sC).call(this), this.emit("connect", r)
}, JG = function () {
    is(this, Wu, null, "f"), is(this, Aw, null, "f"), Ir(this, Nc, "m", sC).call(this), this.emit("disconnect")
}, sC = function () {
    var r, n;
    const e = Sy in Ir(this, Oi, "f").features ? Ir(this, Oi, "f").features[Sy].supportedTransactionVersions : Ir(this, Oi, "f").features[Pc].supportedTransactionVersions;
    is(this, CO, mbt(e, ["legacy"]) ? null : new Set(e), "f"), Pc in Ir(this, Oi, "f").features && ((r = Ir(this, Wu, "f")) != null && r.features.includes(Pc)) ? (this.signTransaction = Ir(this, Nc, "m", vfe), this.signAllTransactions = Ir(this, Nc, "m", gfe)) : (delete this.signTransaction, delete this.signAllTransactions), Z5 in Ir(this, Oi, "f").features && ((n = Ir(this, Wu, "f")) != null && n.features.includes(Z5)) ? this.signMessage = Ir(this, Nc, "m", yfe) : delete this.signMessage, Yz in Ir(this, Oi, "f").features ? this.signIn = Ir(this, Nc, "m", bfe) : delete this.signIn
}, vfe = async function (e) {
    try {
        const r = Ir(this, Wu, "f");
        if (!r) throw new T0;
        if (!(Pc in Ir(this, Oi, "f").features)) throw new AT;
        if (!r.features.includes(Pc)) throw new Ix;
        try {
            const i = (await Ir(this, Oi, "f").features[Pc].signTransaction({
                account: r,
                transaction: Tw(e) ? e.serialize() : new Uint8Array(e.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))[0].signedTransaction;
            return Tw(e) ? K4.deserialize(i) : Yh.from(i)
        } catch (n) {
            throw n instanceof _u ? n : new Ay(n == null ? void 0 : n.message, n)
        }
    } catch (r) {
        throw this.emit("error", r), r
    }
}, gfe = async function (e) {
    try {
        const r = Ir(this, Wu, "f");
        if (!r) throw new T0;
        if (!(Pc in Ir(this, Oi, "f").features)) throw new AT;
        if (!r.features.includes(Pc)) throw new Ix;
        try {
            const n = await Ir(this, Oi, "f").features[Pc].signTransaction(...e.map(i => ({
                account: r,
                transaction: Tw(i) ? i.serialize() : new Uint8Array(i.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            })));
            return e.map((i, a) => {
                const o = n[a].signedTransaction;
                return Tw(i) ? K4.deserialize(o) : Yh.from(o)
            })
        } catch (n) {
            throw new Ay(n == null ? void 0 : n.message, n)
        }
    } catch (r) {
        throw this.emit("error", r), r
    }
}, yfe = async function (e) {
    try {
        const r = Ir(this, Wu, "f");
        if (!r) throw new T0;
        if (!(Z5 in Ir(this, Oi, "f").features)) throw new AT;
        if (!r.features.includes(Z5)) throw new Ix;
        try {
            return (await Ir(this, Oi, "f").features[Z5].signMessage({account: r, message: e}))[0].signature
        } catch (n) {
            throw new gZ(n == null ? void 0 : n.message, n)
        }
    } catch (r) {
        throw this.emit("error", r), r
    }
}, bfe = async function (e = {}) {
    try {
        if (!(Yz in Ir(this, Oi, "f").features)) throw new AT;
        let r;
        try {
            [r] = await Ir(this, Oi, "f").features[Yz].signIn(e)
        } catch (n) {
            throw new wue(n == null ? void 0 : n.message, n)
        }
        if (!r) throw new wue;
        return Ir(this, Nc, "m", BD).call(this, r.account), r
    } catch (r) {
        throw this.emit("error", r), r
    }
};
const gbt = d0t;
var ybt = function (t, e, r, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
}, bbt = function (t, e, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t)
}, $D;
let Rf;
const FD = new Set, Rx = {};

function wbt() {
    if (Rf || (Rf = Object.freeze({register: wfe, get: Sbt, on: _bt}), typeof window > "u")) return Rf;
    const t = Object.freeze({register: wfe});
    try {
        window.addEventListener("wallet-standard:register-wallet", ({detail: e}) => e(t))
    } catch (e) {
        console.error(`wallet-standard:register-wallet event listener could not be added
`, e)
    }
    try {
        window.dispatchEvent(new xbt(t))
    } catch (e) {
        console.error(`wallet-standard:app-ready event could not be dispatched
`, e)
    }
    return Rf
}

function wfe(...t) {
    var e;
    return t = t.filter(r => !FD.has(r)), t.length ? (t.forEach(r => FD.add(r)), (e = Rx.register) == null || e.forEach(r => tK(() => r(...t))), function () {
        var n;
        t.forEach(i => FD.delete(i)), (n = Rx.unregister) == null || n.forEach(i => tK(() => i(...t)))
    }) : () => {
    }
}

function Sbt() {
    return [...FD]
}

function _bt(t, e) {
    var r;
    return (r = Rx[t]) != null && r.push(e) || (Rx[t] = [e]), function () {
        var i;
        Rx[t] = (i = Rx[t]) == null ? void 0 : i.filter(a => e !== a)
    }
}

function tK(t) {
    try {
        t()
    } catch (e) {
        console.error(e)
    }
}

class xbt extends Event {
    constructor(e) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }), $D.set(this, void 0), ybt(this, $D, e, "f")
    }

    get detail() {
        return bbt(this, $D, "f")
    }

    get type() {
        return "wallet-standard:app-ready"
    }

    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }

    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }

    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}

$D = new WeakMap;

function Ebt() {
    if (Rf || (Rf = wbt(), typeof window > "u")) return Rf;
    const t = window.navigator.wallets || [];
    if (!Array.isArray(t)) return console.error("window.navigator.wallets is not an array"), Rf;
    const {register: e} = Rf, r = (...n) => n.forEach(i => tK(() => i({register: e})));
    try {
        Object.defineProperty(window.navigator, "wallets", {value: Object.freeze({push: r})})
    } catch {
        return console.error("window.navigator.wallets could not be set"), Rf
    }
    return r(...t), Rf
}

function Tbt(t) {
    const e = Sfe(() => new Set), {get: r, on: n} = Sfe(() => Ebt()), [i, a] = W.useState(() => _fe(r()));
    W.useEffect(() => {
        const s = [n("register", (...l) => a(f => [...f, ..._fe(l)])), n("unregister", (...l) => a(f => f.filter(d => l.some(p => p === d.wallet))))];
        return () => s.forEach(l => l())
    }, [n]);
    const o = Cbt(i);
    return W.useEffect(() => {
        if (!o) return;
        const s = new Set(i);
        new Set(o.filter(f => !s.has(f))).forEach(f => f.destroy())
    }, [o, i]), W.useEffect(() => () => i.forEach(s => s.destroy()), []), W.useMemo(() => [...i, ...t.filter(({name: s}) => i.some(l => l.name === s) ? (e.has(s) || (e.add(s), console.warn(`${s} was registered as a Standard Wallet. The Wallet Adapter for ${s} can be removed from your app.`)), !1) : !0)], [i, t, e])
}

function Sfe(t) {
    const e = W.useRef();
    return e.current || (e.current = {value: t()}), e.current.value
}

function Cbt(t) {
    const e = W.useRef();
    return W.useEffect(() => {
        e.current = t
    }), e.current
}

function _fe(t) {
    return t.filter(gbt).map(e => new vbt({wallet: e}))
}

var o4;
(function (t) {
    t[t.DESKTOP_WEB = 0] = "DESKTOP_WEB", t[t.MOBILE_WEB = 1] = "MOBILE_WEB"
})(o4 || (o4 = {}));

function Abt(t) {
    return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(t)
}

function Ibt({adapters: t, userAgentString: e}) {
    return t.some(r => r.name !== yy && r.readyState === la.Installed) ? o4.DESKTOP_WEB : e && /android/i.test(e) && !Abt(e) ? o4.MOBILE_WEB : o4.DESKTOP_WEB
}

function kbt(t) {
    return t ? /devnet/i.test(t) ? "devnet" : /testnet/i.test(t) ? "testnet" : "mainnet-beta" : "mainnet-beta"
}

function Rbt({
                 children: t,
                 wallets: e,
                 adapter: r,
                 isUnloadingRef: n,
                 onAutoConnectRequest: i,
                 onConnectError: a,
                 onError: o,
                 onSelectWallet: s
             }) {
    const l = W.useRef(!1), [f, d] = W.useState(!1),
        p = W.useRef(!1), [g, b] = W.useState(!1), [S, T] = W.useState(() => (r == null ? void 0 : r.publicKey) ?? null), [I, N] = W.useState(() => (r == null ? void 0 : r.connected) ?? !1),
        P = W.useRef(o);
    W.useEffect(() => (P.current = o, () => {
        P.current = void 0
    }), [o]);
    const F = W.useRef((A, B) => (n.current || (P.current ? P.current(A, B) : (console.error(A, B), A instanceof i4 && typeof window < "u" && B && window.open(B.url, "_blank"))), A)), [V, Y] = W.useState(() => e.map(A => ({
        adapter: A,
        readyState: A.readyState
    })).filter(({readyState: A}) => A !== la.Unsupported));
    W.useEffect(() => {
        Y(B => e.map((z, j) => {
            const $ = B[j];
            return $ && $.adapter === z && $.readyState === z.readyState ? $ : {adapter: z, readyState: z.readyState}
        }).filter(({readyState: z}) => z !== la.Unsupported));

        function A(B) {
            Y(z => {
                const j = z.findIndex(({adapter: C}) => C === this);
                if (j === -1) return z;
                const {adapter: $} = z[j];
                return [...z.slice(0, j), {
                    adapter: $,
                    readyState: B
                }, ...z.slice(j + 1)].filter(({readyState: C}) => C !== la.Unsupported)
            })
        }

        return e.forEach(B => B.on("readyStateChange", A, B)), () => {
            e.forEach(B => B.off("readyStateChange", A, B))
        }
    }, [r, e]);
    const ee = W.useMemo(() => V.find(A => A.adapter === r) ?? null, [r, V]);
    W.useEffect(() => {
        if (!r) return;
        const A = j => {
            T(j), l.current = !1, d(!1), N(!0), p.current = !1, b(!1)
        }, B = () => {
            n.current || (T(null), l.current = !1, d(!1), N(!1), p.current = !1, b(!1))
        }, z = j => {
            F.current(j, r)
        };
        return r.on("connect", A), r.on("disconnect", B), r.on("error", z), () => {
            r.off("connect", A), r.off("disconnect", B), r.off("error", z), B()
        }
    }, [r, n]);
    const oe = W.useRef(!1);
    W.useEffect(() => () => {
        oe.current = !1
    }, [r]), W.useEffect(() => {
        oe.current || l.current || I || !i || !((ee == null ? void 0 : ee.readyState) === la.Installed || (ee == null ? void 0 : ee.readyState) === la.Loadable) || (l.current = !0, d(!0), oe.current = !0, async function () {
            try {
                await i()
            } catch {
                a()
            } finally {
                d(!1), l.current = !1
            }
        }())
    }, [I, i, a, ee]);
    const G = W.useCallback(async (A, B, z) => {
            if (!r) throw F.current(new cfe);
            if (!I) throw F.current(new T0, r);
            return await r.sendTransaction(A, B, z)
        }, [r, I]), J = W.useMemo(() => r && "signTransaction" in r ? async A => {
            if (!I) throw F.current(new T0, r);
            return await r.signTransaction(A)
        } : void 0, [r, I]), ce = W.useMemo(() => r && "signAllTransactions" in r ? async A => {
            if (!I) throw F.current(new T0, r);
            return await r.signAllTransactions(A)
        } : void 0, [r, I]), re = W.useMemo(() => r && "signMessage" in r ? async A => {
            if (!I) throw F.current(new T0, r);
            return await r.signMessage(A)
        } : void 0, [r, I]), M = W.useMemo(() => r && "signIn" in r ? async A => await r.signIn(A) : void 0, [r]),
        D = W.useCallback(async () => {
            if (l.current || p.current || ee != null && ee.adapter.connected) return;
            if (!ee) throw F.current(new cfe);
            const {adapter: A, readyState: B} = ee;
            if (!(B === la.Installed || B === la.Loadable)) throw F.current(new i4, A);
            l.current = !0, d(!0);
            try {
                await A.connect()
            } catch (z) {
                throw a(), z
            } finally {
                d(!1), l.current = !1
            }
        }, [a, ee]), x = W.useCallback(async () => {
            if (!p.current && r) {
                p.current = !0, b(!0);
                try {
                    await r.disconnect()
                } finally {
                    b(!1), p.current = !1
                }
            }
        }, [r]);
    return ar.createElement(l4e.Provider, {
        value: {
            autoConnect: !!i,
            wallets: V,
            wallet: ee,
            publicKey: S,
            connected: I,
            connecting: f,
            disconnecting: g,
            select: s,
            connect: D,
            disconnect: x,
            sendTransaction: G,
            signTransaction: J,
            signAllTransactions: ce,
            signMessage: re,
            signIn: M
        }
    }, t)
}

let kV;

function Dbt() {
    var t;
    return kV === void 0 && (kV = ((t = globalThis.navigator) == null ? void 0 : t.userAgent) ?? null), kV
}

function S7(t) {
    const e = Dbt();
    return Ibt({adapters: t, userAgentString: e}) === o4.MOBILE_WEB
}

function Mbt() {
    const t = globalThis.location;
    if (t) return `${t.protocol}//${t.host}`
}

function Obt({children: t, wallets: e, autoConnect: r, localStorageKey: n = "walletName", onError: i}) {
    const {connection: a} = c4e(), o = Tbt(e), s = W.useMemo(() => {
            if (!S7(o)) return null;
            const P = o.find(F => F.name === yy);
            return P || new ubt({
                addressSelector: fbt(),
                appIdentity: {uri: Mbt()},
                authorizationResultCache: dbt(),
                cluster: kbt(a == null ? void 0 : a.rpcEndpoint),
                onWalletNotFound: pbt()
            })
        }, [o, a == null ? void 0 : a.rpcEndpoint]),
        l = W.useMemo(() => s == null || o.indexOf(s) !== -1 ? o : [s, ...o], [o, s]), [f, d] = m1t(n, S7(o) ? yy : null),
        p = W.useMemo(() => l.find(P => P.name === f) ?? null, [l, f]), g = W.useCallback(P => {
            f !== P && (p && p.name !== yy && p.disconnect(), d(P))
        }, [p, d, f]);
    W.useEffect(() => {
        if (!p) return;

        function P() {
            T.current || f === yy && S7(o) || d(null)
        }

        return p.on("disconnect", P), () => {
            p.off("disconnect", P)
        }
    }, [p, o, d, f]);
    const b = W.useRef(!1), S = W.useMemo(() => {
        if (!(!r || !p)) return async () => {
            (r === !0 || await r(p)) && (b.current ? await p.connect() : await p.autoConnect())
        }
    }, [r, p]), T = W.useRef(!1);
    W.useEffect(() => {
        if (f === yy && S7(o)) {
            T.current = !1;
            return
        }

        function P() {
            T.current = !0
        }

        return window.addEventListener("beforeunload", P), () => {
            window.removeEventListener("beforeunload", P)
        }
    }, [o, f]);
    const I = W.useCallback(() => {
        p && p.name !== yy && g(null)
    }, [p, g]), N = W.useCallback(P => {
        b.current = !0, g(P)
    }, [g]);
    return ar.createElement(Rbt, {
        wallets: l,
        adapter: p,
        isUnloadingRef: T,
        onAutoConnectRequest: S,
        onConnectError: I,
        onError: i,
        onSelectWallet: N
    }, t)
}

function Pbt(t) {
    if (t.sheet) return t.sheet;
    for (var e = 0; e < document.styleSheets.length; e++) if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e]
}

function Nbt(t) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e
}

var Lbt = function () {
        function t(r) {
            var n = this;
            this._insertTag = function (i) {
                var a;
                n.tags.length === 0 ? n.insertionPoint ? a = n.insertionPoint.nextSibling : n.prepend ? a = n.container.firstChild : a = n.before : a = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(i, a), n.tags.push(i)
            }, this.isSpeedy = r.speedy === void 0 ? Ve.env.NODE_ENV === "production" : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null
        }

        var e = t.prototype;
        return e.hydrate = function (n) {
            n.forEach(this._insertTag)
        }, e.insert = function (n) {
            this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Nbt(this));
            var i = this.tags[this.tags.length - 1];
            if (Ve.env.NODE_ENV !== "production") {
                var a = n.charCodeAt(0) === 64 && n.charCodeAt(1) === 105;
                a && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + n + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !a
            }
            if (this.isSpeedy) {
                var o = Pbt(i);
                try {
                    o.insertRule(n, o.cssRules.length)
                } catch (s) {
                    Ve.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(n) && console.error('There was a problem inserting the following rule: "' + n + '"', s)
                }
            } else i.appendChild(document.createTextNode(n));
            this.ctr++
        }, e.flush = function () {
            this.tags.forEach(function (n) {
                return n.parentNode && n.parentNode.removeChild(n)
            }), this.tags = [], this.ctr = 0, Ve.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1)
        }, t
    }(), wl = "-ms-", IO = "-moz-", zi = "-webkit-", GZ = "comm", KZ = "rule", YZ = "decl", Bbt = "@import",
    v4e = "@keyframes", $bt = "@layer", Fbt = Math.abs, GN = String.fromCharCode, Ubt = Object.assign;

function jbt(t, e) {
    return Uc(t, 0) ^ 45 ? (((e << 2 ^ Uc(t, 0)) << 2 ^ Uc(t, 1)) << 2 ^ Uc(t, 2)) << 2 ^ Uc(t, 3) : 0
}

function g4e(t) {
    return t.trim()
}

function zbt(t, e) {
    return (t = e.exec(t)) ? t[0] : t
}

function Vi(t, e, r) {
    return t.replace(e, r)
}

function rK(t, e) {
    return t.indexOf(e)
}

function Uc(t, e) {
    return t.charCodeAt(e) | 0
}

function xA(t, e, r) {
    return t.slice(e, r)
}

function y0(t) {
    return t.length
}

function XZ(t) {
    return t.length
}

function _7(t, e) {
    return e.push(t), t
}

function Vbt(t, e) {
    return t.map(e).join("")
}

var KN = 1, X4 = 1, y4e = 0, lf = 0, os = 0, r3 = "";

function YN(t, e, r, n, i, a, o) {
    return {value: t, root: e, parent: r, type: n, props: i, children: a, line: KN, column: X4, length: o, return: ""}
}

function rT(t, e) {
    return Ubt(YN("", null, null, "", null, null, 0), t, {length: -t.length}, e)
}

function Hbt() {
    return os
}

function Wbt() {
    return os = lf > 0 ? Uc(r3, --lf) : 0, X4--, os === 10 && (X4 = 1, KN--), os
}

function Uf() {
    return os = lf < y4e ? Uc(r3, lf++) : 0, X4++, os === 10 && (X4 = 1, KN++), os
}

function P0() {
    return Uc(r3, lf)
}

function UD() {
    return lf
}

function Q8(t, e) {
    return xA(r3, t, e)
}

function EA(t) {
    switch (t) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1
    }
    return 0
}

function b4e(t) {
    return KN = X4 = 1, y4e = y0(r3 = t), lf = 0, []
}

function w4e(t) {
    return r3 = "", t
}

function jD(t) {
    return g4e(Q8(lf - 1, nK(t === 91 ? t + 2 : t === 40 ? t + 1 : t)))
}

function qbt(t) {
    for (; (os = P0()) && os < 33;) Uf();
    return EA(t) > 2 || EA(os) > 3 ? "" : " "
}

function Gbt(t, e) {
    for (; --e && Uf() && !(os < 48 || os > 102 || os > 57 && os < 65 || os > 70 && os < 97);) ;
    return Q8(t, UD() + (e < 6 && P0() == 32 && Uf() == 32))
}

function nK(t) {
    for (; Uf();) switch (os) {
        case t:
            return lf;
        case 34:
        case 39:
            t !== 34 && t !== 39 && nK(os);
            break;
        case 40:
            t === 41 && nK(t);
            break;
        case 92:
            Uf();
            break
    }
    return lf
}

function Kbt(t, e) {
    for (; Uf() && t + os !== 57;) if (t + os === 84 && P0() === 47) break;
    return "/*" + Q8(e, lf - 1) + "*" + GN(t === 47 ? t : Uf())
}

function Ybt(t) {
    for (; !EA(P0());) Uf();
    return Q8(t, lf)
}

function Xbt(t) {
    return w4e(zD("", null, null, null, [""], t = b4e(t), 0, [0], t))
}

function zD(t, e, r, n, i, a, o, s, l) {
    for (var f = 0, d = 0, p = o, g = 0, b = 0, S = 0, T = 1, I = 1, N = 1, P = 0, F = "", V = i, Y = a, ee = n, oe = F; I;) switch (S = P, P = Uf()) {
        case 40:
            if (S != 108 && Uc(oe, p - 1) == 58) {
                rK(oe += Vi(jD(P), "&", "&\f"), "&\f") != -1 && (N = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            oe += jD(P);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            oe += qbt(S);
            break;
        case 92:
            oe += Gbt(UD() - 1, 7);
            continue;
        case 47:
            switch (P0()) {
                case 42:
                case 47:
                    _7(Qbt(Kbt(Uf(), UD()), e, r), l);
                    break;
                default:
                    oe += "/"
            }
            break;
        case 123 * T:
            s[f++] = y0(oe) * N;
        case 125 * T:
        case 59:
        case 0:
            switch (P) {
                case 0:
                case 125:
                    I = 0;
                case 59 + d:
                    N == -1 && (oe = Vi(oe, /\f/g, "")), b > 0 && y0(oe) - p && _7(b > 32 ? Efe(oe + ";", n, r, p - 1) : Efe(Vi(oe, " ", "") + ";", n, r, p - 2), l);
                    break;
                case 59:
                    oe += ";";
                default:
                    if (_7(ee = xfe(oe, e, r, f, d, i, s, F, V = [], Y = [], p), a), P === 123) if (d === 0) zD(oe, e, ee, ee, V, a, p, s, Y); else switch (g === 99 && Uc(oe, 3) === 110 ? 100 : g) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            zD(t, ee, ee, n && _7(xfe(t, ee, ee, 0, 0, i, s, F, i, V = [], p), Y), i, Y, p, s, n ? V : Y);
                            break;
                        default:
                            zD(oe, ee, ee, ee, [""], Y, 0, s, Y)
                    }
            }
            f = d = b = 0, T = N = 1, F = oe = "", p = o;
            break;
        case 58:
            p = 1 + y0(oe), b = S;
        default:
            if (T < 1) {
                if (P == 123) --T; else if (P == 125 && T++ == 0 && Wbt() == 125) continue
            }
            switch (oe += GN(P), P * T) {
                case 38:
                    N = d > 0 ? 1 : (oe += "\f", -1);
                    break;
                case 44:
                    s[f++] = (y0(oe) - 1) * N, N = 1;
                    break;
                case 64:
                    P0() === 45 && (oe += jD(Uf())), g = P0(), d = p = y0(F = oe += Ybt(UD())), P++;
                    break;
                case 45:
                    S === 45 && y0(oe) == 2 && (T = 0)
            }
    }
    return a
}

function xfe(t, e, r, n, i, a, o, s, l, f, d) {
    for (var p = i - 1, g = i === 0 ? a : [""], b = XZ(g), S = 0, T = 0, I = 0; S < n; ++S) for (var N = 0, P = xA(t, p + 1, p = Fbt(T = o[S])), F = t; N < b; ++N) (F = g4e(T > 0 ? g[N] + " " + P : Vi(P, /&\f/g, g[N]))) && (l[I++] = F);
    return YN(t, e, r, i === 0 ? KZ : s, l, f, d)
}

function Qbt(t, e, r) {
    return YN(t, e, r, GZ, GN(Hbt()), xA(t, 2, -2), 0)
}

function Efe(t, e, r, n) {
    return YN(t, e, r, YZ, xA(t, 0, n), xA(t, n + 1, -1), n)
}

function s4(t, e) {
    for (var r = "", n = XZ(t), i = 0; i < n; i++) r += e(t[i], i, t, e) || "";
    return r
}

function Zbt(t, e, r, n) {
    switch (t.type) {
        case $bt:
            if (t.children.length) break;
        case Bbt:
        case YZ:
            return t.return = t.return || t.value;
        case GZ:
            return "";
        case v4e:
            return t.return = t.value + "{" + s4(t.children, n) + "}";
        case KZ:
            t.value = t.props.join(",")
    }
    return y0(r = s4(t.children, n)) ? t.return = t.value + "{" + r + "}" : ""
}

function Jbt(t) {
    var e = XZ(t);
    return function (r, n, i, a) {
        for (var o = "", s = 0; s < e; s++) o += t[s](r, n, i, a) || "";
        return o
    }
}

function ewt(t) {
    return function (e) {
        e.root || (e = e.return) && t(e)
    }
}

var Tfe = function (e) {
    var r = new WeakMap;
    return function (n) {
        if (r.has(n)) return r.get(n);
        var i = e(n);
        return r.set(n, i), i
    }
};

function S4e(t) {
    var e = Object.create(null);
    return function (r) {
        return e[r] === void 0 && (e[r] = t(r)), e[r]
    }
}

var twt = function (e, r, n) {
        for (var i = 0, a = 0; i = a, a = P0(), i === 38 && a === 12 && (r[n] = 1), !EA(a);) Uf();
        return Q8(e, lf)
    }, rwt = function (e, r) {
        var n = -1, i = 44;
        do switch (EA(i)) {
            case 0:
                i === 38 && P0() === 12 && (r[n] = 1), e[n] += twt(lf - 1, r, n);
                break;
            case 2:
                e[n] += jD(i);
                break;
            case 4:
                if (i === 44) {
                    e[++n] = P0() === 58 ? "&\f" : "", r[n] = e[n].length;
                    break
                }
            default:
                e[n] += GN(i)
        } while (i = Uf());
        return e
    }, nwt = function (e, r) {
        return w4e(rwt(b4e(e), r))
    }, Cfe = new WeakMap, iwt = function (e) {
        if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
            for (var r = e.value, n = e.parent, i = e.column === n.column && e.line === n.line; n.type !== "rule";) if (n = n.parent, !n) return;
            if (!(e.props.length === 1 && r.charCodeAt(0) !== 58 && !Cfe.get(n)) && !i) {
                Cfe.set(e, !0);
                for (var a = [], o = nwt(r, a), s = n.props, l = 0, f = 0; l < o.length; l++) for (var d = 0; d < s.length; d++, f++) e.props[f] = a[l] ? o[l].replace(/&\f/g, s[d]) : s[d] + " " + o[l]
            }
        }
    }, awt = function (e) {
        if (e.type === "decl") {
            var r = e.value;
            r.charCodeAt(0) === 108 && r.charCodeAt(2) === 98 && (e.return = "", e.value = "")
        }
    },
    owt = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason",
    swt = function (e) {
        return e.type === "comm" && e.children.indexOf(owt) > -1
    }, cwt = function (e) {
        return function (r, n, i) {
            if (!(r.type !== "rule" || e.compat)) {
                var a = r.value.match(/(:first|:nth|:nth-last)-child/g);
                if (a) {
                    for (var o = !!r.parent, s = o ? r.parent.children : i, l = s.length - 1; l >= 0; l--) {
                        var f = s[l];
                        if (f.line < r.line) break;
                        if (f.column < r.column) {
                            if (swt(f)) return;
                            break
                        }
                    }
                    a.forEach(function (d) {
                        console.error('The pseudo class "' + d + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + d.split("-child")[0] + '-of-type".')
                    })
                }
            }
        }
    }, _4e = function (e) {
        return e.type.charCodeAt(1) === 105 && e.type.charCodeAt(0) === 64
    }, lwt = function (e, r) {
        for (var n = e - 1; n >= 0; n--) if (!_4e(r[n])) return !0;
        return !1
    }, Afe = function (e) {
        e.type = "", e.value = "", e.return = "", e.children = "", e.props = ""
    }, uwt = function (e, r, n) {
        _4e(e) && (e.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), Afe(e)) : lwt(r, n) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), Afe(e)))
    };

function x4e(t, e) {
    switch (jbt(t, e)) {
        case 5103:
            return zi + "print-" + t + t;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return zi + t + t;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return zi + t + IO + t + wl + t + t;
        case 6828:
        case 4268:
            return zi + t + wl + t + t;
        case 6165:
            return zi + t + wl + "flex-" + t + t;
        case 5187:
            return zi + t + Vi(t, /(\w+).+(:[^]+)/, zi + "box-$1$2" + wl + "flex-$1$2") + t;
        case 5443:
            return zi + t + wl + "flex-item-" + Vi(t, /flex-|-self/, "") + t;
        case 4675:
            return zi + t + wl + "flex-line-pack" + Vi(t, /align-content|flex-|-self/, "") + t;
        case 5548:
            return zi + t + wl + Vi(t, "shrink", "negative") + t;
        case 5292:
            return zi + t + wl + Vi(t, "basis", "preferred-size") + t;
        case 6060:
            return zi + "box-" + Vi(t, "-grow", "") + zi + t + wl + Vi(t, "grow", "positive") + t;
        case 4554:
            return zi + Vi(t, /([^-])(transform)/g, "$1" + zi + "$2") + t;
        case 6187:
            return Vi(Vi(Vi(t, /(zoom-|grab)/, zi + "$1"), /(image-set)/, zi + "$1"), t, "") + t;
        case 5495:
        case 3959:
            return Vi(t, /(image-set\([^]*)/, zi + "$1$`$1");
        case 4968:
            return Vi(Vi(t, /(.+:)(flex-)?(.*)/, zi + "box-pack:$3" + wl + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + zi + t + t;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return Vi(t, /(.+)-inline(.+)/, zi + "$1$2") + t;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (y0(t) - 1 - e > 6) switch (Uc(t, e + 1)) {
                case 109:
                    if (Uc(t, e + 4) !== 45) break;
                case 102:
                    return Vi(t, /(.+:)(.+)-([^]+)/, "$1" + zi + "$2-$3$1" + IO + (Uc(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
                case 115:
                    return ~rK(t, "stretch") ? x4e(Vi(t, "stretch", "fill-available"), e) + t : t
            }
            break;
        case 4949:
            if (Uc(t, e + 1) !== 115) break;
        case 6444:
            switch (Uc(t, y0(t) - 3 - (~rK(t, "!important") && 10))) {
                case 107:
                    return Vi(t, ":", ":" + zi) + t;
                case 101:
                    return Vi(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + zi + (Uc(t, 14) === 45 ? "inline-" : "") + "box$3$1" + zi + "$2$3$1" + wl + "$2box$3") + t
            }
            break;
        case 5936:
            switch (Uc(t, e + 11)) {
                case 114:
                    return zi + t + wl + Vi(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
                case 108:
                    return zi + t + wl + Vi(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
                case 45:
                    return zi + t + wl + Vi(t, /[svh]\w+-[tblr]{2}/, "lr") + t
            }
            return zi + t + wl + t + t
    }
    return t
}

var fwt = function (e, r, n, i) {
    if (e.length > -1 && !e.return) switch (e.type) {
        case YZ:
            e.return = x4e(e.value, e.length);
            break;
        case v4e:
            return s4([rT(e, {value: Vi(e.value, "@", "@" + zi)})], i);
        case KZ:
            if (e.length) return Vbt(e.props, function (a) {
                switch (zbt(a, /(::plac\w+|:read-\w+)/)) {
                    case":read-only":
                    case":read-write":
                        return s4([rT(e, {props: [Vi(a, /:(read-\w+)/, ":" + IO + "$1")]})], i);
                    case"::placeholder":
                        return s4([rT(e, {props: [Vi(a, /:(plac\w+)/, ":" + zi + "input-$1")]}), rT(e, {props: [Vi(a, /:(plac\w+)/, ":" + IO + "$1")]}), rT(e, {props: [Vi(a, /:(plac\w+)/, wl + "input-$1")]})], i)
                }
                return ""
            })
    }
}, dwt = [fwt], E4e = function (e) {
    var r = e.key;
    if (Ve.env.NODE_ENV !== "production" && !r) throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
    if (r === "css") {
        var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(n, function (T) {
            var I = T.getAttribute("data-emotion");
            I.indexOf(" ") !== -1 && (document.head.appendChild(T), T.setAttribute("data-s", ""))
        })
    }
    var i = e.stylisPlugins || dwt;
    if (Ve.env.NODE_ENV !== "production" && /[^a-z-]/.test(r)) throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + r + '" was passed');
    var a = {}, o, s = [];
    o = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + r + ' "]'), function (T) {
        for (var I = T.getAttribute("data-emotion").split(" "), N = 1; N < I.length; N++) a[I[N]] = !0;
        s.push(T)
    });
    var l, f = [iwt, awt];
    Ve.env.NODE_ENV !== "production" && f.push(cwt({
        get compat() {
            return S.compat
        }
    }), uwt);
    {
        var d, p = [Zbt, Ve.env.NODE_ENV !== "production" ? function (T) {
            T.root || (T.return ? d.insert(T.return) : T.value && T.type !== GZ && d.insert(T.value + "{}"))
        } : ewt(function (T) {
            d.insert(T)
        })], g = Jbt(f.concat(i, p)), b = function (I) {
            return s4(Xbt(I), g)
        };
        l = function (I, N, P, F) {
            d = P, Ve.env.NODE_ENV !== "production" && N.map !== void 0 && (d = {
                insert: function (Y) {
                    P.insert(Y + N.map)
                }
            }), b(I ? I + "{" + N.styles + "}" : N.styles), F && (S.inserted[N.name] = !0)
        }
    }
    var S = {
        key: r,
        sheet: new Lbt({
            key: r,
            container: o,
            nonce: e.nonce,
            speedy: e.speedy,
            prepend: e.prepend,
            insertionPoint: e.insertionPoint
        }),
        nonce: e.nonce,
        inserted: a,
        registered: {},
        insert: l
    };
    return S.sheet.hydrate(s), S
};

function dS() {
    return dS = Object.assign ? Object.assign.bind() : function (t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }, dS.apply(this, arguments)
}

var iK = {exports: {}}, Xi = {};
var Ife;

function hwt() {
    if (Ife) return Xi;
    Ife = 1;
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103,
        r = t ? Symbol.for("react.portal") : 60106, n = t ? Symbol.for("react.fragment") : 60107,
        i = t ? Symbol.for("react.strict_mode") : 60108, a = t ? Symbol.for("react.profiler") : 60114,
        o = t ? Symbol.for("react.provider") : 60109, s = t ? Symbol.for("react.context") : 60110,
        l = t ? Symbol.for("react.async_mode") : 60111, f = t ? Symbol.for("react.concurrent_mode") : 60111,
        d = t ? Symbol.for("react.forward_ref") : 60112, p = t ? Symbol.for("react.suspense") : 60113,
        g = t ? Symbol.for("react.suspense_list") : 60120, b = t ? Symbol.for("react.memo") : 60115,
        S = t ? Symbol.for("react.lazy") : 60116, T = t ? Symbol.for("react.block") : 60121,
        I = t ? Symbol.for("react.fundamental") : 60117, N = t ? Symbol.for("react.responder") : 60118,
        P = t ? Symbol.for("react.scope") : 60119;

    function F(Y) {
        if (typeof Y == "object" && Y !== null) {
            var ee = Y.$$typeof;
            switch (ee) {
                case e:
                    switch (Y = Y.type, Y) {
                        case l:
                        case f:
                        case n:
                        case a:
                        case i:
                        case p:
                            return Y;
                        default:
                            switch (Y = Y && Y.$$typeof, Y) {
                                case s:
                                case d:
                                case S:
                                case b:
                                case o:
                                    return Y;
                                default:
                                    return ee
                            }
                    }
                case r:
                    return ee
            }
        }
    }

    function V(Y) {
        return F(Y) === f
    }

    return Xi.AsyncMode = l, Xi.ConcurrentMode = f, Xi.ContextConsumer = s, Xi.ContextProvider = o, Xi.Element = e, Xi.ForwardRef = d, Xi.Fragment = n, Xi.Lazy = S, Xi.Memo = b, Xi.Portal = r, Xi.Profiler = a, Xi.StrictMode = i, Xi.Suspense = p, Xi.isAsyncMode = function (Y) {
        return V(Y) || F(Y) === l
    }, Xi.isConcurrentMode = V, Xi.isContextConsumer = function (Y) {
        return F(Y) === s
    }, Xi.isContextProvider = function (Y) {
        return F(Y) === o
    }, Xi.isElement = function (Y) {
        return typeof Y == "object" && Y !== null && Y.$$typeof === e
    }, Xi.isForwardRef = function (Y) {
        return F(Y) === d
    }, Xi.isFragment = function (Y) {
        return F(Y) === n
    }, Xi.isLazy = function (Y) {
        return F(Y) === S
    }, Xi.isMemo = function (Y) {
        return F(Y) === b
    }, Xi.isPortal = function (Y) {
        return F(Y) === r
    }, Xi.isProfiler = function (Y) {
        return F(Y) === a
    }, Xi.isStrictMode = function (Y) {
        return F(Y) === i
    }, Xi.isSuspense = function (Y) {
        return F(Y) === p
    }, Xi.isValidElementType = function (Y) {
        return typeof Y == "string" || typeof Y == "function" || Y === n || Y === f || Y === a || Y === i || Y === p || Y === g || typeof Y == "object" && Y !== null && (Y.$$typeof === S || Y.$$typeof === b || Y.$$typeof === o || Y.$$typeof === s || Y.$$typeof === d || Y.$$typeof === I || Y.$$typeof === N || Y.$$typeof === P || Y.$$typeof === T)
    }, Xi.typeOf = F, Xi
}

var Qi = {}, kfe;

function pwt() {
    return kfe || (kfe = 1, Ve.env.NODE_ENV !== "production" && function () {
        var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103,
            r = t ? Symbol.for("react.portal") : 60106, n = t ? Symbol.for("react.fragment") : 60107,
            i = t ? Symbol.for("react.strict_mode") : 60108, a = t ? Symbol.for("react.profiler") : 60114,
            o = t ? Symbol.for("react.provider") : 60109, s = t ? Symbol.for("react.context") : 60110,
            l = t ? Symbol.for("react.async_mode") : 60111, f = t ? Symbol.for("react.concurrent_mode") : 60111,
            d = t ? Symbol.for("react.forward_ref") : 60112, p = t ? Symbol.for("react.suspense") : 60113,
            g = t ? Symbol.for("react.suspense_list") : 60120, b = t ? Symbol.for("react.memo") : 60115,
            S = t ? Symbol.for("react.lazy") : 60116, T = t ? Symbol.for("react.block") : 60121,
            I = t ? Symbol.for("react.fundamental") : 60117, N = t ? Symbol.for("react.responder") : 60118,
            P = t ? Symbol.for("react.scope") : 60119;

        function F(ne) {
            return typeof ne == "string" || typeof ne == "function" || ne === n || ne === f || ne === a || ne === i || ne === p || ne === g || typeof ne == "object" && ne !== null && (ne.$$typeof === S || ne.$$typeof === b || ne.$$typeof === o || ne.$$typeof === s || ne.$$typeof === d || ne.$$typeof === I || ne.$$typeof === N || ne.$$typeof === P || ne.$$typeof === T)
        }

        function V(ne) {
            if (typeof ne == "object" && ne !== null) {
                var be = ne.$$typeof;
                switch (be) {
                    case e:
                        var Ee = ne.type;
                        switch (Ee) {
                            case l:
                            case f:
                            case n:
                            case a:
                            case i:
                            case p:
                                return Ee;
                            default:
                                var Oe = Ee && Ee.$$typeof;
                                switch (Oe) {
                                    case s:
                                    case d:
                                    case S:
                                    case b:
                                    case o:
                                        return Oe;
                                    default:
                                        return be
                                }
                        }
                    case r:
                        return be
                }
            }
        }

        var Y = l, ee = f, oe = s, G = o, J = e, ce = d, re = n, M = S, D = b, x = r, A = a, B = i, z = p, j = !1;

        function $(ne) {
            return j || (j = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), C(ne) || V(ne) === l
        }

        function C(ne) {
            return V(ne) === f
        }

        function R(ne) {
            return V(ne) === s
        }

        function k(ne) {
            return V(ne) === o
        }

        function Q(ne) {
            return typeof ne == "object" && ne !== null && ne.$$typeof === e
        }

        function fe(ne) {
            return V(ne) === d
        }

        function ye(ne) {
            return V(ne) === n
        }

        function ue(ne) {
            return V(ne) === S
        }

        function me(ne) {
            return V(ne) === b
        }

        function Se(ne) {
            return V(ne) === r
        }

        function Ce(ne) {
            return V(ne) === a
        }

        function Me(ne) {
            return V(ne) === i
        }

        function ve(ne) {
            return V(ne) === p
        }

        Qi.AsyncMode = Y, Qi.ConcurrentMode = ee, Qi.ContextConsumer = oe, Qi.ContextProvider = G, Qi.Element = J, Qi.ForwardRef = ce, Qi.Fragment = re, Qi.Lazy = M, Qi.Memo = D, Qi.Portal = x, Qi.Profiler = A, Qi.StrictMode = B, Qi.Suspense = z, Qi.isAsyncMode = $, Qi.isConcurrentMode = C, Qi.isContextConsumer = R, Qi.isContextProvider = k, Qi.isElement = Q, Qi.isForwardRef = fe, Qi.isFragment = ye, Qi.isLazy = ue, Qi.isMemo = me, Qi.isPortal = Se, Qi.isProfiler = Ce, Qi.isStrictMode = Me, Qi.isSuspense = ve, Qi.isValidElementType = F, Qi.typeOf = V
    }()), Qi
}

Ve.env.NODE_ENV === "production" ? iK.exports = hwt() : iK.exports = pwt();
var T4e = iK.exports, mwt = !0;

function QZ(t, e, r) {
    var n = "";
    return r.split(" ").forEach(function (i) {
        t[i] !== void 0 ? e.push(t[i] + ";") : n += i + " "
    }), n
}

var XN = function (e, r, n) {
    var i = e.key + "-" + r.name;
    (n === !1 || mwt === !1) && e.registered[i] === void 0 && (e.registered[i] = r.styles)
}, QN = function (e, r, n) {
    XN(e, r, n);
    var i = e.key + "-" + r.name;
    if (e.inserted[r.name] === void 0) {
        var a = r;
        do e.insert(r === a ? "." + i : "", a, e.sheet, !0), a = a.next; while (a !== void 0)
    }
};

function vwt(t) {
    for (var e = 0, r, n = 0, i = t.length; i >= 4; ++n, i -= 4) r = t.charCodeAt(n) & 255 | (t.charCodeAt(++n) & 255) << 8 | (t.charCodeAt(++n) & 255) << 16 | (t.charCodeAt(++n) & 255) << 24, r = (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= r >>> 24, e = (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
        case 3:
            e ^= (t.charCodeAt(n + 2) & 255) << 16;
        case 2:
            e ^= (t.charCodeAt(n + 1) & 255) << 8;
        case 1:
            e ^= t.charCodeAt(n) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16)
    }
    return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36)
}

var gwt = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    }, Rfe = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`,
    ywt = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).",
    bwt = /[A-Z]|^ms/g, C4e = /_EMO_([^_]+?)_([^]*?)_EMO_/g, ZZ = function (e) {
        return e.charCodeAt(1) === 45
    }, Dfe = function (e) {
        return e != null && typeof e != "boolean"
    }, RV = S4e(function (t) {
        return ZZ(t) ? t : t.replace(bwt, "-$&").toLowerCase()
    }), kO = function (e, r) {
        switch (e) {
            case"animation":
            case"animationName":
                if (typeof r == "string") return r.replace(C4e, function (n, i, a) {
                    return qh = {name: i, styles: a, next: qh}, i
                })
        }
        return gwt[e] !== 1 && !ZZ(e) && typeof r == "number" && r !== 0 ? r + "px" : r
    };
if (Ve.env.NODE_ENV !== "production") {
    var wwt = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/,
        Swt = ["normal", "none", "initial", "inherit", "unset"], _wt = kO, xwt = /^-ms-/, Ewt = /-(.)/g, Mfe = {};
    kO = function (e, r) {
        if (e === "content" && (typeof r != "string" || Swt.indexOf(r) === -1 && !wwt.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'"))) throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + r + "\"'`");
        var n = _wt(e, r);
        return n !== "" && !ZZ(e) && e.indexOf("-") !== -1 && Mfe[e] === void 0 && (Mfe[e] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + e.replace(xwt, "ms-").replace(Ewt, function (i, a) {
            return a.toUpperCase()
        }) + "?")), n
    }
}
var A4e = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";

function TA(t, e, r) {
    if (r == null) return "";
    if (r.__emotion_styles !== void 0) {
        if (Ve.env.NODE_ENV !== "production" && r.toString() === "NO_COMPONENT_SELECTOR") throw new Error(A4e);
        return r
    }
    switch (typeof r) {
        case"boolean":
            return "";
        case"object": {
            if (r.anim === 1) return qh = {name: r.name, styles: r.styles, next: qh}, r.name;
            if (r.styles !== void 0) {
                var n = r.next;
                if (n !== void 0) for (; n !== void 0;) qh = {name: n.name, styles: n.styles, next: qh}, n = n.next;
                var i = r.styles + ";";
                return Ve.env.NODE_ENV !== "production" && r.map !== void 0 && (i += r.map), i
            }
            return Twt(t, e, r)
        }
        case"function": {
            if (t !== void 0) {
                var a = qh, o = r(t);
                return qh = a, TA(t, e, o)
            } else Ve.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
            break
        }
        case"string":
            if (Ve.env.NODE_ENV !== "production") {
                var s = [], l = r.replace(C4e, function (d, p, g) {
                    var b = "animation" + s.length;
                    return s.push("const " + b + " = keyframes`" + g.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + b + "}"
                });
                s.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(s, ["`" + l + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + l + "`"))
            }
            break
    }
    if (e == null) return r;
    var f = e[r];
    return f !== void 0 ? f : r
}

function Twt(t, e, r) {
    var n = "";
    if (Array.isArray(r)) for (var i = 0; i < r.length; i++) n += TA(t, e, r[i]) + ";"; else for (var a in r) {
        var o = r[a];
        if (typeof o != "object") e != null && e[o] !== void 0 ? n += a + "{" + e[o] + "}" : Dfe(o) && (n += RV(a) + ":" + kO(a, o) + ";"); else {
            if (a === "NO_COMPONENT_SELECTOR" && Ve.env.NODE_ENV !== "production") throw new Error(A4e);
            if (Array.isArray(o) && typeof o[0] == "string" && (e == null || e[o[0]] === void 0)) for (var s = 0; s < o.length; s++) Dfe(o[s]) && (n += RV(a) + ":" + kO(a, o[s]) + ";"); else {
                var l = TA(t, e, o);
                switch (a) {
                    case"animation":
                    case"animationName": {
                        n += RV(a) + ":" + l + ";";
                        break
                    }
                    default:
                        Ve.env.NODE_ENV !== "production" && a === "undefined" && console.error(ywt), n += a + "{" + l + "}"
                }
            }
        }
    }
    return n
}

var Ofe = /label:\s*([^\s;\n{]+)\s*(;|$)/g, I4e;
Ve.env.NODE_ENV !== "production" && (I4e = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var qh, Q4 = function (e, r, n) {
        if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0) return e[0];
        var i = !0, a = "";
        qh = void 0;
        var o = e[0];
        o == null || o.raw === void 0 ? (i = !1, a += TA(n, r, o)) : (Ve.env.NODE_ENV !== "production" && o[0] === void 0 && console.error(Rfe), a += o[0]);
        for (var s = 1; s < e.length; s++) a += TA(n, r, e[s]), i && (Ve.env.NODE_ENV !== "production" && o[s] === void 0 && console.error(Rfe), a += o[s]);
        var l;
        Ve.env.NODE_ENV !== "production" && (a = a.replace(I4e, function (g) {
            return l = g, ""
        })), Ofe.lastIndex = 0;
        for (var f = "", d; (d = Ofe.exec(a)) !== null;) f += "-" + d[1];
        var p = vwt(a) + f;
        return Ve.env.NODE_ENV !== "production" ? {
            name: p, styles: a, map: l, next: qh, toString: function () {
                return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."
            }
        } : {name: p, styles: a, next: qh}
    }, Cwt = function (e) {
        return e()
    }, k4e = vue.useInsertionEffect ? vue.useInsertionEffect : !1, JZ = k4e || Cwt, Pfe = k4e || W.useLayoutEffect,
    Awt = {}.hasOwnProperty, eJ = W.createContext(typeof HTMLElement < "u" ? E4e({key: "css"}) : null);
Ve.env.NODE_ENV !== "production" && (eJ.displayName = "EmotionCacheContext");
var Iwt = eJ.Provider, ZN = function (e) {
    return W.forwardRef(function (r, n) {
        var i = W.useContext(eJ);
        return e(r, i, n)
    })
}, t1 = W.createContext({});
Ve.env.NODE_ENV !== "production" && (t1.displayName = "EmotionThemeContext");
var kwt = function (e, r) {
    if (typeof r == "function") {
        var n = r(e);
        if (Ve.env.NODE_ENV !== "production" && (n == null || typeof n != "object" || Array.isArray(n))) throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
        return n
    }
    if (Ve.env.NODE_ENV !== "production" && (r == null || typeof r != "object" || Array.isArray(r))) throw new Error("[ThemeProvider] Please make your theme prop a plain object");
    return dS({}, e, r)
}, Rwt = Tfe(function (t) {
    return Tfe(function (e) {
        return kwt(t, e)
    })
}), Dwt = function (e) {
    var r = W.useContext(t1);
    return e.theme !== r && (r = Rwt(r)(e.theme)), W.createElement(t1.Provider, {value: r}, e.children)
}, Nfe = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Lfe = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", Mwt = function (e) {
    var r = e.cache, n = e.serialized, i = e.isStringTag;
    return XN(r, n, i), JZ(function () {
        return QN(r, n, i)
    }), null
}, Owt = ZN(function (t, e, r) {
    var n = t.css;
    typeof n == "string" && e.registered[n] !== void 0 && (n = e.registered[n]);
    var i = t[Nfe], a = [n], o = "";
    typeof t.className == "string" ? o = QZ(e.registered, a, t.className) : t.className != null && (o = t.className + " ");
    var s = Q4(a, void 0, W.useContext(t1));
    if (Ve.env.NODE_ENV !== "production" && s.name.indexOf("-") === -1) {
        var l = t[Lfe];
        l && (s = Q4([s, "label:" + l + ";"]))
    }
    o += e.key + "-" + s.name;
    var f = {};
    for (var d in t) Awt.call(t, d) && d !== "css" && d !== Nfe && (Ve.env.NODE_ENV === "production" || d !== Lfe) && (f[d] = t[d]);
    return f.ref = r, f.className = o, W.createElement(W.Fragment, null, W.createElement(Mwt, {
        cache: e,
        serialized: s,
        isStringTag: typeof i == "string"
    }), W.createElement(i, f))
});
Ve.env.NODE_ENV !== "production" && (Owt.displayName = "EmotionCssPropInternal");
var Pwt = {
    name: "@emotion/react",
    version: "11.11.3",
    main: "dist/emotion-react.cjs.js",
    module: "dist/emotion-react.esm.js",
    browser: {"./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"},
    exports: {
        ".": {
            module: {
                worker: "./dist/emotion-react.worker.esm.js",
                browser: "./dist/emotion-react.browser.esm.js",
                default: "./dist/emotion-react.esm.js"
            }, import: "./dist/emotion-react.cjs.mjs", default: "./dist/emotion-react.cjs.js"
        },
        "./jsx-runtime": {
            module: {
                worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
                browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
                default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
            },
            import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
            default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
        },
        "./_isolated-hnrs": {
            module: {
                worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
                browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
                default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
            },
            import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
            default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
        },
        "./jsx-dev-runtime": {
            module: {
                worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
                browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
                default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
            },
            import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
            default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
        },
        "./package.json": "./package.json",
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {types: {import: "./macro.d.mts", default: "./macro.d.ts"}, default: "./macro.js"}
    },
    types: "types/index.d.ts",
    files: ["src", "dist", "jsx-runtime", "jsx-dev-runtime", "_isolated-hnrs", "types/*.d.ts", "macro.*"],
    sideEffects: !1,
    author: "Emotion Contributors",
    license: "MIT",
    scripts: {"test:typescript": "dtslint types"},
    dependencies: {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.11.0",
        "@emotion/cache": "^11.11.0",
        "@emotion/serialize": "^1.1.3",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
        "@emotion/utils": "^1.2.1",
        "@emotion/weak-memoize": "^0.3.1",
        "hoist-non-react-statics": "^3.3.1"
    },
    peerDependencies: {react: ">=16.8.0"},
    peerDependenciesMeta: {"@types/react": {optional: !0}},
    devDependencies: {
        "@definitelytyped/dtslint": "0.0.112",
        "@emotion/css": "11.11.2",
        "@emotion/css-prettifier": "1.1.3",
        "@emotion/server": "11.11.0",
        "@emotion/styled": "11.11.0",
        "html-tag-names": "^1.1.2",
        react: "16.14.0",
        "svg-tag-names": "^1.1.1",
        typescript: "^4.5.5"
    },
    repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
    publishConfig: {access: "public"},
    "umd:main": "dist/emotion-react.umd.min.js",
    preconstruct: {
        entrypoints: ["./index.js", "./jsx-runtime.js", "./jsx-dev-runtime.js", "./_isolated-hnrs.js"],
        umdName: "emotionReact",
        exports: {
            envConditions: ["browser", "worker"],
            extra: {
                "./types/css-prop": "./types/css-prop.d.ts",
                "./macro": {types: {import: "./macro.d.mts", default: "./macro.d.ts"}, default: "./macro.js"}
            }
        }
    }
}, Bfe = !1, Z8 = ZN(function (t, e) {
    Ve.env.NODE_ENV !== "production" && !Bfe && (t.className || t.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), Bfe = !0);
    var r = t.styles, n = Q4([r], void 0, W.useContext(t1)), i = W.useRef();
    return Pfe(function () {
        var a = e.key + "-global", o = new e.sheet.constructor({
            key: a,
            nonce: e.sheet.nonce,
            container: e.sheet.container,
            speedy: e.sheet.isSpeedy
        }), s = !1, l = document.querySelector('style[data-emotion="' + a + " " + n.name + '"]');
        return e.sheet.tags.length && (o.before = e.sheet.tags[0]), l !== null && (s = !0, l.setAttribute("data-emotion", a), o.hydrate([l])), i.current = [o, s], function () {
            o.flush()
        }
    }, [e]), Pfe(function () {
        var a = i.current, o = a[0], s = a[1];
        if (s) {
            a[1] = !1;
            return
        }
        if (n.next !== void 0 && QN(e, n.next, !0), o.tags.length) {
            var l = o.tags[o.tags.length - 1].nextElementSibling;
            o.before = l, o.flush()
        }
        e.insert("", n, o, !1)
    }, [e, n.name]), null
});
Ve.env.NODE_ENV !== "production" && (Z8.displayName = "EmotionGlobal");

function Nwt() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
    return Q4(e)
}

var Lwt = function () {
    var e = Nwt.apply(void 0, arguments), r = "animation-" + e.name;
    return {
        name: r, styles: "@keyframes " + r + "{" + e.styles + "}", anim: 1, toString: function () {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
}, Bwt = function t(e) {
    for (var r = e.length, n = 0, i = ""; n < r; n++) {
        var a = e[n];
        if (a != null) {
            var o = void 0;
            switch (typeof a) {
                case"boolean":
                    break;
                case"object": {
                    if (Array.isArray(a)) o = t(a); else {
                        Ve.env.NODE_ENV !== "production" && a.styles !== void 0 && a.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), o = "";
                        for (var s in a) a[s] && s && (o && (o += " "), o += s)
                    }
                    break
                }
                default:
                    o = a
            }
            o && (i && (i += " "), i += o)
        }
    }
    return i
};

function $wt(t, e, r) {
    var n = [], i = QZ(t, n, r);
    return n.length < 2 ? r : i + e(n)
}

var Fwt = function (e) {
    var r = e.cache, n = e.serializedArr;
    return JZ(function () {
        for (var i = 0; i < n.length; i++) QN(r, n[i], !1)
    }), null
}, Uwt = ZN(function (t, e) {
    var r = !1, n = [], i = function () {
        if (r && Ve.env.NODE_ENV !== "production") throw new Error("css can only be used during render");
        for (var f = arguments.length, d = new Array(f), p = 0; p < f; p++) d[p] = arguments[p];
        var g = Q4(d, e.registered);
        return n.push(g), XN(e, g, !1), e.key + "-" + g.name
    }, a = function () {
        if (r && Ve.env.NODE_ENV !== "production") throw new Error("cx can only be used during render");
        for (var f = arguments.length, d = new Array(f), p = 0; p < f; p++) d[p] = arguments[p];
        return $wt(e.registered, i, Bwt(d))
    }, o = {css: i, cx: a, theme: W.useContext(t1)}, s = t.children(o);
    return r = !0, W.createElement(W.Fragment, null, W.createElement(Fwt, {cache: e, serializedArr: n}), s)
});
Ve.env.NODE_ENV !== "production" && (Uwt.displayName = "EmotionClassNames");
if (Ve.env.NODE_ENV !== "production") {
    var $fe = !0, jwt = typeof jest < "u" || typeof vi < "u";
    if ($fe && !jwt) {
        var Ffe = typeof globalThis < "u" ? globalThis : $fe ? window : Os,
            Ufe = "__EMOTION_REACT_" + Pwt.version.split(".")[0] + "__";
        Ffe[Ufe] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), Ffe[Ufe] = !0
    }
}
var R4e = String.raw, D4e = R4e`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, zwt = () => ie.jsx(Z8, {styles: D4e}), Vwt = ({scope: t = ""}) => ie.jsx(Z8, {
    styles: R4e`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${D4e}
    `
});

function Hwt(t, e) {
    return `${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`
}

function rd(t = {}) {
    const {
        name: e,
        strict: r = !0,
        hookName: n = "useContext",
        providerName: i = "Provider",
        errorMessage: a,
        defaultValue: o
    } = t, s = W.createContext(o);
    s.displayName = e;

    function l() {
        var f;
        const d = W.useContext(s);
        if (!d && r) {
            const p = new Error(a ?? Hwt(n, i));
            throw p.name = "ContextError", (f = Error.captureStackTrace) == null || f.call(Error, p, l), p
        }
        return d
    }

    return [s.Provider, l, s]
}

var [Wwt, qwt] = rd({strict: !1, name: "PortalManagerContext"});

function M4e(t) {
    const {children: e, zIndex: r} = t;
    return ie.jsx(Wwt, {value: {zIndex: r}, children: e})
}

M4e.displayName = "PortalManager";
var Z4 = globalThis != null && globalThis.document ? W.useLayoutEffect : W.useEffect, [O4e, Gwt] = rd({
    strict: !1,
    name: "PortalContext"
}), tJ = "chakra-portal", Kwt = ".chakra-portal", Ywt = t => ie.jsx("div", {
    className: "chakra-portal-zIndex",
    style: {position: "absolute", zIndex: t.zIndex, top: 0, left: 0, right: 0},
    children: t.children
}), Xwt = t => {
    const {appendToParentPortal: e, children: r} = t, [n, i] = W.useState(null),
        a = W.useRef(null), [, o] = W.useState({});
    W.useEffect(() => o({}), []);
    const s = Gwt(), l = qwt();
    Z4(() => {
        if (!n) return;
        const d = n.ownerDocument, p = e ? s ?? d.body : d.body;
        if (!p) return;
        a.current = d.createElement("div"), a.current.className = tJ, p.appendChild(a.current), o({});
        const g = a.current;
        return () => {
            p.contains(g) && p.removeChild(g)
        }
    }, [n]);
    const f = l != null && l.zIndex ? ie.jsx(Ywt, {zIndex: l == null ? void 0 : l.zIndex, children: r}) : r;
    return a.current ? Jh.createPortal(ie.jsx(O4e, {
        value: a.current,
        children: f
    }), a.current) : ie.jsx("span", {
        ref: d => {
            d && i(d)
        }
    })
}, Qwt = t => {
    const {children: e, containerRef: r, appendToParentPortal: n} = t, i = r.current,
        a = i ?? (typeof window < "u" ? document.body : void 0), o = W.useMemo(() => {
            const l = i == null ? void 0 : i.ownerDocument.createElement("div");
            return l && (l.className = tJ), l
        }, [i]), [, s] = W.useState({});
    return Z4(() => s({}), []), Z4(() => {
        if (!(!o || !a)) return a.appendChild(o), () => {
            a.removeChild(o)
        }
    }, [o, a]), a && o ? Jh.createPortal(ie.jsx(O4e, {value: n ? o : null, children: e}), o) : null
};

function GS(t) {
    const e = {appendToParentPortal: !0, ...t}, {containerRef: r, ...n} = e;
    return r ? ie.jsx(Qwt, {containerRef: r, ...n}) : ie.jsx(Xwt, {...n})
}

GS.className = tJ;
GS.selector = Kwt;
GS.displayName = "Portal";

function n3() {
    const t = W.useContext(t1);
    if (!t) throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");
    return t
}

var J8 = W.createContext({});
J8.displayName = "ColorModeContext";

function S1() {
    const t = W.useContext(J8);
    if (t === void 0) throw new Error("useColorMode must be used within a ColorModeProvider");
    return t
}

function hS(t, e) {
    const {colorMode: r} = S1();
    return r === "dark" ? e : t
}

var x7 = {light: "chakra-ui-light", dark: "chakra-ui-dark"};

function Zwt(t = {}) {
    const {preventTransition: e = !0} = t, r = {
        setDataset: n => {
            const i = e ? r.preventTransition() : void 0;
            document.documentElement.dataset.theme = n, document.documentElement.style.colorScheme = n, i == null || i()
        }, setClassName(n) {
            document.body.classList.add(n ? x7.dark : x7.light), document.body.classList.remove(n ? x7.light : x7.dark)
        }, query() {
            return window.matchMedia("(prefers-color-scheme: dark)")
        }, getSystemTheme(n) {
            var i;
            return ((i = r.query().matches) != null ? i : n === "dark") ? "dark" : "light"
        }, addListener(n) {
            const i = r.query(), a = o => {
                n(o.matches ? "dark" : "light")
            };
            return typeof i.addListener == "function" ? i.addListener(a) : i.addEventListener("change", a), () => {
                typeof i.removeListener == "function" ? i.removeListener(a) : i.removeEventListener("change", a)
            }
        }, preventTransition() {
            const n = document.createElement("style");
            return n.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(n), () => {
                window.getComputedStyle(document.body), requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        document.head.removeChild(n)
                    })
                })
            }
        }
    };
    return r
}

var Jwt = "chakra-ui-color-mode";

function eSt(t) {
    return {
        ssr: !1, type: "localStorage", get(e) {
            if (!(globalThis != null && globalThis.document)) return e;
            let r;
            try {
                r = localStorage.getItem(t) || e
            } catch {
            }
            return r || e
        }, set(e) {
            try {
                localStorage.setItem(t, e)
            } catch {
            }
        }
    }
}

var tSt = eSt(Jwt), J4 = () => {
};

function jfe(t, e) {
    return t.type === "cookie" && t.ssr ? t.get(e) : e
}

function P4e(t) {
    const {
            value: e,
            children: r,
            options: {useSystemColorMode: n, initialColorMode: i, disableTransitionOnChange: a} = {},
            colorModeManager: o = tSt
        } = t,
        s = i === "dark" ? "dark" : "light", [l, f] = W.useState(() => jfe(o, s)), [d, p] = W.useState(() => jfe(o)), {
            getSystemTheme: g,
            setClassName: b,
            setDataset: S,
            addListener: T
        } = W.useMemo(() => Zwt({preventTransition: a}), [a]), I = i === "system" && !l ? d : l, N = W.useCallback(V => {
            const Y = V === "system" ? g() : V;
            f(Y), b(Y === "dark"), S(Y), o.set(Y)
        }, [o, g, b, S]);
    Z4(() => {
        i === "system" && p(g())
    }, []), W.useEffect(() => {
        const V = o.get();
        if (V) {
            N(V);
            return
        }
        if (i === "system") {
            N("system");
            return
        }
        N(s)
    }, [o, s, i, N]);
    const P = W.useCallback(() => {
        N(I === "dark" ? "light" : "dark")
    }, [I, N]);
    W.useEffect(() => {
        if (n) return T(N)
    }, [n, T, N]);
    const F = W.useMemo(() => ({
        colorMode: e ?? I,
        toggleColorMode: e ? J4 : P,
        setColorMode: e ? J4 : N,
        forced: e !== void 0
    }), [I, P, N, e]);
    return ie.jsx(J8.Provider, {value: F, children: r})
}

P4e.displayName = "ColorModeProvider";

function rSt(t) {
    const e = W.useMemo(() => ({colorMode: "dark", toggleColorMode: J4, setColorMode: J4, forced: !0}), []);
    return ie.jsx(J8.Provider, {value: e, ...t})
}

rSt.displayName = "DarkMode";

function nSt(t) {
    const e = W.useMemo(() => ({colorMode: "light", toggleColorMode: J4, setColorMode: J4, forced: !0}), []);
    return ie.jsx(J8.Provider, {value: e, ...t})
}

nSt.displayName = "LightMode";

function N4e() {
    const t = S1(), e = n3();
    return {...t, theme: e}
}

function iSt(t, e, r) {
    var n, i;
    if (e == null) return e;
    const a = o => {
        var s, l;
        return (l = (s = t.__breakpoints) == null ? void 0 : s.asArray) == null ? void 0 : l[o]
    };
    return (i = (n = a(e)) != null ? n : a(r)) != null ? i : r
}

function aSt(t, e, r) {
    var n, i;
    if (e == null) return e;
    const a = o => {
        var s, l;
        return (l = (s = t.__cssMap) == null ? void 0 : s[o]) == null ? void 0 : l.value
    };
    return (i = (n = a(e)) != null ? n : a(r)) != null ? i : r
}

function zfe(t, e, r) {
    const n = n3();
    return oSt(t, e, r)(n)
}

function oSt(t, e, r) {
    const n = Array.isArray(e) ? e : [e], i = Array.isArray(r) ? r : [r];
    return a => {
        const o = i.filter(Boolean), s = n.map((l, f) => {
            var d, p;
            if (t === "breakpoints") return iSt(a, l, (d = o[f]) != null ? d : l);
            const g = `${t}.${l}`;
            return aSt(a, g, (p = o[f]) != null ? p : l)
        });
        return Array.isArray(e) ? s : s[0]
    }
}

var mi = (...t) => t.filter(Boolean).join(" ");

function sSt() {
    return Ve.env.NODE_ENV !== "production"
}

function rf(t) {
    const e = typeof t;
    return t != null && (e === "object" || e === "function") && !Array.isArray(t)
}

var YJt = t => {
    const {condition: e, message: r} = t;
    e && sSt() && console.warn(r)
};

function tp(t, ...e) {
    return cSt(t) ? t(...e) : t
}

var cSt = t => typeof t == "function", Ry = t => t ? "" : void 0, DV = t => t ? !0 : void 0;

function iu(...t) {
    return function (r) {
        t.some(n => (n == null || n(r), r == null ? void 0 : r.defaultPrevented))
    }
}

function lSt(...t) {
    return function (r) {
        t.forEach(n => {
            n == null || n(r)
        })
    }
}

var aK = {exports: {}};
(function (t, e) {
    var r = 200, n = "__lodash_hash_undefined__", i = 800, a = 16, o = 9007199254740991, s = "[object Arguments]",
        l = "[object Array]", f = "[object AsyncFunction]", d = "[object Boolean]", p = "[object Date]",
        g = "[object Error]", b = "[object Function]", S = "[object GeneratorFunction]", T = "[object Map]",
        I = "[object Number]", N = "[object Null]", P = "[object Object]", F = "[object Proxy]", V = "[object RegExp]",
        Y = "[object Set]", ee = "[object String]", oe = "[object Undefined]", G = "[object WeakMap]",
        J = "[object ArrayBuffer]", ce = "[object DataView]", re = "[object Float32Array]", M = "[object Float64Array]",
        D = "[object Int8Array]", x = "[object Int16Array]", A = "[object Int32Array]", B = "[object Uint8Array]",
        z = "[object Uint8ClampedArray]", j = "[object Uint16Array]", $ = "[object Uint32Array]",
        C = /[\\^$.*+?()[\]{}|]/g, R = /^\[object .+?Constructor\]$/, k = /^(?:0|[1-9]\d*)$/, Q = {};
    Q[re] = Q[M] = Q[D] = Q[x] = Q[A] = Q[B] = Q[z] = Q[j] = Q[$] = !0, Q[s] = Q[l] = Q[J] = Q[d] = Q[ce] = Q[p] = Q[g] = Q[b] = Q[T] = Q[I] = Q[P] = Q[V] = Q[Y] = Q[ee] = Q[G] = !1;
    var fe = typeof tn == "object" && tn && tn.Object === Object && tn,
        ye = typeof self == "object" && self && self.Object === Object && self,
        ue = fe || ye || Function("return this")(), me = e && !e.nodeType && e, Se = me && !0 && t && !t.nodeType && t,
        Ce = Se && Se.exports === me, Me = Ce && fe.process, ve = function () {
            try {
                var Te = Se && Se.require && Se.require("util").types;
                return Te || Me && Me.binding && Me.binding("util")
            } catch {
            }
        }(), ne = ve && ve.isTypedArray;

    function be(Te, Ne, Xe) {
        switch (Xe.length) {
            case 0:
                return Te.call(Ne);
            case 1:
                return Te.call(Ne, Xe[0]);
            case 2:
                return Te.call(Ne, Xe[0], Xe[1]);
            case 3:
                return Te.call(Ne, Xe[0], Xe[1], Xe[2])
        }
        return Te.apply(Ne, Xe)
    }

    function Ee(Te, Ne) {
        for (var Xe = -1, Vt = Array(Te); ++Xe < Te;) Vt[Xe] = Ne(Xe);
        return Vt
    }

    function Oe(Te) {
        return function (Ne) {
            return Te(Ne)
        }
    }

    function ze(Te, Ne) {
        return Te == null ? void 0 : Te[Ne]
    }

    function Be(Te, Ne) {
        return function (Xe) {
            return Te(Ne(Xe))
        }
    }

    var it = Array.prototype, Ue = Function.prototype, bt = Object.prototype, gt = ue["__core-js_shared__"],
        Ot = Ue.toString, zt = bt.hasOwnProperty, _t = function () {
            var Te = /[^.]+$/.exec(gt && gt.keys && gt.keys.IE_PROTO || "");
            return Te ? "Symbol(src)_1." + Te : ""
        }(), Dt = bt.toString, rr = Ot.call(Object),
        pe = RegExp("^" + Ot.call(zt).replace(C, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        te = Ce ? ue.Buffer : void 0, X = ue.Symbol, H = ue.Uint8Array, U = te ? te.allocUnsafe : void 0,
        q = Be(Object.getPrototypeOf, Object), le = Object.create, xe = bt.propertyIsEnumerable, Ae = it.splice,
        De = X ? X.toStringTag : void 0, Ze = function () {
            try {
                var Te = fs(Object, "defineProperty");
                return Te({}, "", {}), Te
            } catch {
            }
        }(), ft = te ? te.isBuffer : void 0, ht = Math.max, cr = Date.now, Rt = fs(ue, "Map"), Gt = fs(Object, "create"),
        sn = function () {
            function Te() {
            }

            return function (Ne) {
                if (!ds(Ne)) return {};
                if (le) return le(Ne);
                Te.prototype = Ne;
                var Xe = new Te;
                return Te.prototype = void 0, Xe
            }
        }();

    function Yr(Te) {
        var Ne = -1, Xe = Te == null ? 0 : Te.length;
        for (this.clear(); ++Ne < Xe;) {
            var Vt = Te[Ne];
            this.set(Vt[0], Vt[1])
        }
    }

    function br() {
        this.__data__ = Gt ? Gt(null) : {}, this.size = 0
    }

    function hn(Te) {
        var Ne = this.has(Te) && delete this.__data__[Te];
        return this.size -= Ne ? 1 : 0, Ne
    }

    function En(Te) {
        var Ne = this.__data__;
        if (Gt) {
            var Xe = Ne[Te];
            return Xe === n ? void 0 : Xe
        }
        return zt.call(Ne, Te) ? Ne[Te] : void 0
    }

    function _r(Te) {
        var Ne = this.__data__;
        return Gt ? Ne[Te] !== void 0 : zt.call(Ne, Te)
    }

    function _n(Te, Ne) {
        var Xe = this.__data__;
        return this.size += this.has(Te) ? 0 : 1, Xe[Te] = Gt && Ne === void 0 ? n : Ne, this
    }

    Yr.prototype.clear = br, Yr.prototype.delete = hn, Yr.prototype.get = En, Yr.prototype.has = _r, Yr.prototype.set = _n;

    function Nr(Te) {
        var Ne = -1, Xe = Te == null ? 0 : Te.length;
        for (this.clear(); ++Ne < Xe;) {
            var Vt = Te[Ne];
            this.set(Vt[0], Vt[1])
        }
    }

    function mr() {
        this.__data__ = [], this.size = 0
    }

    function fn(Te) {
        var Ne = this.__data__, Xe = Pt(Ne, Te);
        if (Xe < 0) return !1;
        var Vt = Ne.length - 1;
        return Xe == Vt ? Ne.pop() : Ae.call(Ne, Xe, 1), --this.size, !0
    }

    function Hn(Te) {
        var Ne = this.__data__, Xe = Pt(Ne, Te);
        return Xe < 0 ? void 0 : Ne[Xe][1]
    }

    function Cr(Te) {
        return Pt(this.__data__, Te) > -1
    }

    function An(Te, Ne) {
        var Xe = this.__data__, Vt = Pt(Xe, Te);
        return Vt < 0 ? (++this.size, Xe.push([Te, Ne])) : Xe[Vt][1] = Ne, this
    }

    Nr.prototype.clear = mr, Nr.prototype.delete = fn, Nr.prototype.get = Hn, Nr.prototype.has = Cr, Nr.prototype.set = An;

    function pn(Te) {
        var Ne = -1, Xe = Te == null ? 0 : Te.length;
        for (this.clear(); ++Ne < Xe;) {
            var Vt = Te[Ne];
            this.set(Vt[0], Vt[1])
        }
    }

    function wr() {
        this.size = 0, this.__data__ = {hash: new Yr, map: new (Rt || Nr), string: new Yr}
    }

    function ke(Te) {
        var Ne = Nl(this, Te).delete(Te);
        return this.size -= Ne ? 1 : 0, Ne
    }

    function st(Te) {
        return Nl(this, Te).get(Te)
    }

    function ot(Te) {
        return Nl(this, Te).has(Te)
    }

    function xt(Te, Ne) {
        var Xe = Nl(this, Te), Vt = Xe.size;
        return Xe.set(Te, Ne), this.size += Xe.size == Vt ? 0 : 1, this
    }

    pn.prototype.clear = wr, pn.prototype.delete = ke, pn.prototype.get = st, pn.prototype.has = ot, pn.prototype.set = xt;

    function Yt(Te) {
        var Ne = this.__data__ = new Nr(Te);
        this.size = Ne.size
    }

    function vr() {
        this.__data__ = new Nr, this.size = 0
    }

    function Vr(Te) {
        var Ne = this.__data__, Xe = Ne.delete(Te);
        return this.size = Ne.size, Xe
    }

    function Ur(Te) {
        return this.__data__.get(Te)
    }

    function fi(Te) {
        return this.__data__.has(Te)
    }

    function In(Te, Ne) {
        var Xe = this.__data__;
        if (Xe instanceof Nr) {
            var Vt = Xe.__data__;
            if (!Rt || Vt.length < r - 1) return Vt.push([Te, Ne]), this.size = ++Xe.size, this;
            Xe = this.__data__ = new pn(Vt)
        }
        return Xe.set(Te, Ne), this.size = Xe.size, this
    }

    Yt.prototype.clear = vr, Yt.prototype.delete = Vr, Yt.prototype.get = Ur, Yt.prototype.has = fi, Yt.prototype.set = In;

    function kn(Te, Ne) {
        var Xe = Fn(Te), Vt = !Xe && Ii(Te), bn = !Xe && !Vt && ba(Te), di = !Xe && !Vt && !bn && od(Te),
            Qn = Xe || Vt || bn || di, de = Qn ? Ee(Te.length, String) : [], Ie = de.length;
        for (var Ye in Te) (Ne || zt.call(Te, Ye)) && !(Qn && (Ye == "length" || bn && (Ye == "offset" || Ye == "parent") || di && (Ye == "buffer" || Ye == "byteLength" || Ye == "byteOffset") || Bl(Ye, Ie))) && de.push(Ye);
        return de
    }

    function Ai(Te, Ne, Xe) {
        (Xe !== void 0 && !No(Te[Ne], Xe) || Xe === void 0 && !(Ne in Te)) && Wn(Te, Ne, Xe)
    }

    function Fi(Te, Ne, Xe) {
        var Vt = Te[Ne];
        (!(zt.call(Te, Ne) && No(Vt, Xe)) || Xe === void 0 && !(Ne in Te)) && Wn(Te, Ne, Xe)
    }

    function Pt(Te, Ne) {
        for (var Xe = Te.length; Xe--;) if (No(Te[Xe][0], Ne)) return Xe;
        return -1
    }

    function Wn(Te, Ne, Xe) {
        Ne == "__proto__" && Ze ? Ze(Te, Ne, {configurable: !0, enumerable: !0, value: Xe, writable: !0}) : Te[Ne] = Xe
    }

    var Da = Pl();

    function Ma(Te) {
        return Te == null ? Te === void 0 ? oe : N : De && De in Object(Te) ? lh(Te) : pf(Te)
    }

    function Oa(Te) {
        return ad(Te) && Ma(Te) == s
    }

    function Za(Te) {
        if (!ds(Te) || Bn(Te)) return !1;
        var Ne = dc(Te) ? pe : R;
        return Ne.test(fc(Te))
    }

    function Po(Te) {
        return ad(Te) && kp(Te.length) && !!Q[Ma(Te)]
    }

    function Ja(Te) {
        if (!ds(Te)) return Eu(Te);
        var Ne = $n(Te), Xe = [];
        for (var Vt in Te) Vt == "constructor" && (Ne || !zt.call(Te, Vt)) || Xe.push(Vt);
        return Xe
    }

    function qi(Te, Ne, Xe, Vt, bn) {
        Te !== Ne && Da(Ne, function (di, Qn) {
            if (bn || (bn = new Yt), ds(di)) Ko(Te, Ne, Qn, Xe, qi, Vt, bn); else {
                var de = Vt ? Vt(Yc(Te, Qn), di, Qn + "", Te, Ne, bn) : void 0;
                de === void 0 && (de = di), Ai(Te, Qn, de)
            }
        }, ug)
    }

    function Ko(Te, Ne, Xe, Vt, bn, di, Qn) {
        var de = Yc(Te, Xe), Ie = Yc(Ne, Xe), Ye = Qn.get(Ie);
        if (Ye) {
            Ai(Te, Xe, Ye);
            return
        }
        var rt = di ? di(de, Ie, Xe + "", Te, Ne, Qn) : void 0, Et = rt === void 0;
        if (Et) {
            var Dr = Fn(Ie), Nt = !Dr && ba(Ie), Br = !Dr && !Nt && od(Ie);
            rt = Ie, Dr || Nt || Br ? Fn(de) ? rt = de : Lo(de) ? rt = Ml(de) : Nt ? (Et = !1, rt = df(Ie, !0)) : Br ? (Et = !1, rt = Yo(Ie, !0)) : rt = [] : cm(Ie) || Ii(Ie) ? (rt = de, Ii(de) ? rt = fh(de) : (!ds(de) || dc(de)) && (rt = Ll(Ie))) : Et = !1
        }
        Et && (Qn.set(Ie, rt), bn(rt, Ie, Vt, di, Qn), Qn.delete(Ie)), Ai(Te, Xe, rt)
    }

    function Pa(Te, Ne) {
        return Va(Lr(Te, Ne, hc), Te + "")
    }

    var Dl = Ze ? function (Te, Ne) {
        return Ze(Te, "toString", {configurable: !0, enumerable: !1, value: mf(Ne), writable: !0})
    } : hc;

    function df(Te, Ne) {
        if (Ne) return Te.slice();
        var Xe = Te.length, Vt = U ? U(Xe) : new Te.constructor(Xe);
        return Te.copy(Vt), Vt
    }

    function hf(Te) {
        var Ne = new Te.constructor(Te.byteLength);
        return new H(Ne).set(new H(Te)), Ne
    }

    function Yo(Te, Ne) {
        var Xe = Ne ? hf(Te.buffer) : Te.buffer;
        return new Te.constructor(Xe, Te.byteOffset, Te.length)
    }

    function Ml(Te, Ne) {
        var Xe = -1, Vt = Te.length;
        for (Ne || (Ne = Array(Vt)); ++Xe < Vt;) Ne[Xe] = Te[Xe];
        return Ne
    }

    function us(Te, Ne, Xe, Vt) {
        var bn = !Xe;
        Xe || (Xe = {});
        for (var di = -1, Qn = Ne.length; ++di < Qn;) {
            var de = Ne[di], Ie = Vt ? Vt(Xe[de], Te[de], de, Xe, Te) : void 0;
            Ie === void 0 && (Ie = Te[de]), bn ? Wn(Xe, de, Ie) : Fi(Xe, de, Ie)
        }
        return Xe
    }

    function Ol(Te) {
        return Pa(function (Ne, Xe) {
            var Vt = -1, bn = Xe.length, di = bn > 1 ? Xe[bn - 1] : void 0, Qn = bn > 2 ? Xe[2] : void 0;
            for (di = Te.length > 3 && typeof di == "function" ? (bn--, di) : void 0, Qn && uh(Xe[0], Xe[1], Qn) && (di = bn < 3 ? void 0 : di, bn = 1), Ne = Object(Ne); ++Vt < bn;) {
                var de = Xe[Vt];
                de && Te(Ne, de, Vt, di)
            }
            return Ne
        })
    }

    function Pl(Te) {
        return function (Ne, Xe, Vt) {
            for (var bn = -1, di = Object(Ne), Qn = Vt(Ne), de = Qn.length; de--;) {
                var Ie = Qn[Te ? de : ++bn];
                if (Xe(di[Ie], Ie, di) === !1) break
            }
            return Ne
        }
    }

    function Nl(Te, Ne) {
        var Xe = Te.__data__;
        return $l(Ne) ? Xe[typeof Ne == "string" ? "string" : "hash"] : Xe.map
    }

    function fs(Te, Ne) {
        var Xe = ze(Te, Ne);
        return Za(Xe) ? Xe : void 0
    }

    function lh(Te) {
        var Ne = zt.call(Te, De), Xe = Te[De];
        try {
            Te[De] = void 0;
            var Vt = !0
        } catch {
        }
        var bn = Dt.call(Te);
        return Vt && (Ne ? Te[De] = Xe : delete Te[De]), bn
    }

    function Ll(Te) {
        return typeof Te.constructor == "function" && !$n(Te) ? sn(q(Te)) : {}
    }

    function Bl(Te, Ne) {
        var Xe = typeof Te;
        return Ne = Ne ?? o, !!Ne && (Xe == "number" || Xe != "symbol" && k.test(Te)) && Te > -1 && Te % 1 == 0 && Te < Ne
    }

    function uh(Te, Ne, Xe) {
        if (!ds(Xe)) return !1;
        var Vt = typeof Ne;
        return (Vt == "number" ? Tu(Xe) && Bl(Ne, Xe.length) : Vt == "string" && Ne in Xe) ? No(Xe[Ne], Te) : !1
    }

    function $l(Te) {
        var Ne = typeof Te;
        return Ne == "string" || Ne == "number" || Ne == "symbol" || Ne == "boolean" ? Te !== "__proto__" : Te === null
    }

    function Bn(Te) {
        return !!_t && _t in Te
    }

    function $n(Te) {
        var Ne = Te && Te.constructor, Xe = typeof Ne == "function" && Ne.prototype || bt;
        return Te === Xe
    }

    function Eu(Te) {
        var Ne = [];
        if (Te != null) for (var Xe in Object(Te)) Ne.push(Xe);
        return Ne
    }

    function pf(Te) {
        return Dt.call(Te)
    }

    function Lr(Te, Ne, Xe) {
        return Ne = ht(Ne === void 0 ? Te.length - 1 : Ne, 0), function () {
            for (var Vt = arguments, bn = -1, di = ht(Vt.length - Ne, 0), Qn = Array(di); ++bn < di;) Qn[bn] = Vt[Ne + bn];
            bn = -1;
            for (var de = Array(Ne + 1); ++bn < Ne;) de[bn] = Vt[bn];
            return de[Ne] = Xe(Qn), be(Te, this, de)
        }
    }

    function Yc(Te, Ne) {
        if (!(Ne === "constructor" && typeof Te[Ne] == "function") && Ne != "__proto__") return Te[Ne]
    }

    var Va = Xc(Dl);

    function Xc(Te) {
        var Ne = 0, Xe = 0;
        return function () {
            var Vt = cr(), bn = a - (Vt - Xe);
            if (Xe = Vt, bn > 0) {
                if (++Ne >= i) return arguments[0]
            } else Ne = 0;
            return Te.apply(void 0, arguments)
        }
    }

    function fc(Te) {
        if (Te != null) {
            try {
                return Ot.call(Te)
            } catch {
            }
            try {
                return Te + ""
            } catch {
            }
        }
        return ""
    }

    function No(Te, Ne) {
        return Te === Ne || Te !== Te && Ne !== Ne
    }

    var Ii = Oa(function () {
        return arguments
    }()) ? Oa : function (Te) {
        return ad(Te) && zt.call(Te, "callee") && !xe.call(Te, "callee")
    }, Fn = Array.isArray;

    function Tu(Te) {
        return Te != null && kp(Te.length) && !dc(Te)
    }

    function Lo(Te) {
        return ad(Te) && Tu(Te)
    }

    var ba = ft || Cu;

    function dc(Te) {
        if (!ds(Te)) return !1;
        var Ne = Ma(Te);
        return Ne == b || Ne == S || Ne == f || Ne == F
    }

    function kp(Te) {
        return typeof Te == "number" && Te > -1 && Te % 1 == 0 && Te <= o
    }

    function ds(Te) {
        var Ne = typeof Te;
        return Te != null && (Ne == "object" || Ne == "function")
    }

    function ad(Te) {
        return Te != null && typeof Te == "object"
    }

    function cm(Te) {
        if (!ad(Te) || Ma(Te) != P) return !1;
        var Ne = q(Te);
        if (Ne === null) return !0;
        var Xe = zt.call(Ne, "constructor") && Ne.constructor;
        return typeof Xe == "function" && Xe instanceof Xe && Ot.call(Xe) == rr
    }

    var od = ne ? Oe(ne) : Po;

    function fh(Te) {
        return us(Te, ug(Te))
    }

    function ug(Te) {
        return Tu(Te) ? kn(Te, !0) : Ja(Te)
    }

    var hs = Ol(function (Te, Ne, Xe, Vt) {
        qi(Te, Ne, Xe, Vt)
    });

    function mf(Te) {
        return function () {
            return Te
        }
    }

    function hc(Te) {
        return Te
    }

    function Cu() {
        return !1
    }

    t.exports = hs
})(aK, aK.exports);
var uSt = aK.exports;
const qd = za(uSt);
var fSt = t => /!(important)?$/.test(t), Vfe = t => typeof t == "string" ? t.replace(/!(important)?$/, "").trim() : t,
    dSt = (t, e) => r => {
        const n = String(e), i = fSt(n), a = Vfe(n), o = t ? `${t}.${a}` : a;
        let s = rf(r.__cssMap) && o in r.__cssMap ? r.__cssMap[o].varRef : e;
        return s = Vfe(s), i ? `${s} !important` : s
    };

function rJ(t) {
    const {scale: e, transform: r, compose: n} = t;
    return (a, o) => {
        var s;
        const l = dSt(e, a)(o);
        let f = (s = r == null ? void 0 : r(l, o)) != null ? s : l;
        return n && (f = n(f, o)), f
    }
}

var E7 = (...t) => e => t.reduce((r, n) => n(r), e);

function Rd(t, e) {
    return r => {
        const n = {property: r, scale: t};
        return n.transform = rJ({scale: t, transform: e}), n
    }
}

var hSt = ({rtl: t, ltr: e}) => r => r.direction === "rtl" ? t : e;

function pSt(t) {
    const {property: e, scale: r, transform: n} = t;
    return {scale: r, property: hSt(e), transform: r ? rJ({scale: r, compose: n}) : n}
}

var L4e = ["rotate(var(--chakra-rotate, 0))", "scaleX(var(--chakra-scale-x, 1))", "scaleY(var(--chakra-scale-y, 1))", "skewX(var(--chakra-skew-x, 0))", "skewY(var(--chakra-skew-y, 0))"];

function mSt() {
    return ["translateX(var(--chakra-translate-x, 0))", "translateY(var(--chakra-translate-y, 0))", ...L4e].join(" ")
}

function vSt() {
    return ["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)", ...L4e].join(" ")
}

var gSt = {
    "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
    filter: ["var(--chakra-blur)", "var(--chakra-brightness)", "var(--chakra-contrast)", "var(--chakra-grayscale)", "var(--chakra-hue-rotate)", "var(--chakra-invert)", "var(--chakra-saturate)", "var(--chakra-sepia)", "var(--chakra-drop-shadow)"].join(" ")
}, ySt = {
    backdropFilter: ["var(--chakra-backdrop-blur)", "var(--chakra-backdrop-brightness)", "var(--chakra-backdrop-contrast)", "var(--chakra-backdrop-grayscale)", "var(--chakra-backdrop-hue-rotate)", "var(--chakra-backdrop-invert)", "var(--chakra-backdrop-opacity)", "var(--chakra-backdrop-saturate)", "var(--chakra-backdrop-sepia)"].join(" "),
    "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};

function bSt(t) {
    return {
        "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
        "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
        "--chakra-ring-width": t,
        boxShadow: ["var(--chakra-ring-offset-shadow)", "var(--chakra-ring-shadow)", "var(--chakra-shadow, 0 0 #0000)"].join(", ")
    }
}

var wSt = {
        "row-reverse": {space: "--chakra-space-x-reverse", divide: "--chakra-divide-x-reverse"},
        "column-reverse": {space: "--chakra-space-y-reverse", divide: "--chakra-divide-y-reverse"}
    }, oK = {
        "to-t": "to top",
        "to-tr": "to top right",
        "to-r": "to right",
        "to-br": "to bottom right",
        "to-b": "to bottom",
        "to-bl": "to bottom left",
        "to-l": "to left",
        "to-tl": "to top left"
    }, SSt = new Set(Object.values(oK)), sK = new Set(["none", "-moz-initial", "inherit", "initial", "revert", "unset"]),
    _St = t => t.trim();

function xSt(t, e) {
    if (t == null || sK.has(t)) return t;
    if (!(cK(t) || sK.has(t))) return `url('${t}')`;
    const i = /(^[a-z-A-Z]+)\((.*)\)/g.exec(t), a = i == null ? void 0 : i[1], o = i == null ? void 0 : i[2];
    if (!a || !o) return t;
    const s = a.includes("-gradient") ? a : `${a}-gradient`, [l, ...f] = o.split(",").map(_St).filter(Boolean);
    if ((f == null ? void 0 : f.length) === 0) return t;
    const d = l in oK ? oK[l] : l;
    f.unshift(d);
    const p = f.map(g => {
        if (SSt.has(g)) return g;
        const b = g.indexOf(" "), [S, T] = b !== -1 ? [g.substr(0, b), g.substr(b + 1)] : [g],
            I = cK(T) ? T : T && T.split(" "), N = `colors.${S}`, P = N in e.__cssMap ? e.__cssMap[N].varRef : S;
        return I ? [P, ...Array.isArray(I) ? I : [I]].join(" ") : P
    });
    return `${s}(${p.join(", ")})`
}

var cK = t => typeof t == "string" && t.includes("(") && t.includes(")"), ESt = (t, e) => xSt(t, e ?? {});

function TSt(t) {
    return /^var\(--.+\)$/.test(t)
}

var CSt = t => {
    const e = parseFloat(t.toString()), r = t.toString().replace(String(e), "");
    return {unitless: !r, value: e, unit: r}
}, d0 = t => e => `${t}(${e})`, Pi = {
    filter(t) {
        return t !== "auto" ? t : gSt
    },
    backdropFilter(t) {
        return t !== "auto" ? t : ySt
    },
    ring(t) {
        return bSt(Pi.px(t))
    },
    bgClip(t) {
        return t === "text" ? {color: "transparent", backgroundClip: "text"} : {backgroundClip: t}
    },
    transform(t) {
        return t === "auto" ? mSt() : t === "auto-gpu" ? vSt() : t
    },
    vh(t) {
        return t === "$100vh" ? "var(--chakra-vh)" : t
    },
    px(t) {
        if (t == null) return t;
        const {unitless: e} = CSt(t);
        return e || typeof t == "number" ? `${t}px` : t
    },
    fraction(t) {
        return typeof t != "number" || t > 1 ? t : `${t * 100}%`
    },
    float(t, e) {
        const r = {left: "right", right: "left"};
        return e.direction === "rtl" ? r[t] : t
    },
    degree(t) {
        if (TSt(t) || t == null) return t;
        const e = typeof t == "string" && !t.endsWith("deg");
        return typeof t == "number" || e ? `${t}deg` : t
    },
    gradient: ESt,
    blur: d0("blur"),
    opacity: d0("opacity"),
    brightness: d0("brightness"),
    contrast: d0("contrast"),
    dropShadow: d0("drop-shadow"),
    grayscale: d0("grayscale"),
    hueRotate: d0("hue-rotate"),
    invert: d0("invert"),
    saturate: d0("saturate"),
    sepia: d0("sepia"),
    bgImage(t) {
        return t == null || cK(t) || sK.has(t) ? t : `url(${t})`
    },
    outline(t) {
        const e = String(t) === "0" || String(t) === "none";
        return t !== null && e ? {outline: "2px solid transparent", outlineOffset: "2px"} : {outline: t}
    },
    flexDirection(t) {
        var e;
        const {space: r, divide: n} = (e = wSt[t]) != null ? e : {}, i = {flexDirection: t};
        return r && (i[r] = 1), n && (i[n] = 1), i
    }
}, je = {
    borderWidths: Rd("borderWidths"),
    borderStyles: Rd("borderStyles"),
    colors: Rd("colors"),
    borders: Rd("borders"),
    gradients: Rd("gradients", Pi.gradient),
    radii: Rd("radii", Pi.px),
    space: Rd("space", E7(Pi.vh, Pi.px)),
    spaceT: Rd("space", E7(Pi.vh, Pi.px)),
    degreeT(t) {
        return {property: t, transform: Pi.degree}
    },
    prop(t, e, r) {
        return {property: t, scale: e, ...e && {transform: rJ({scale: e, transform: r})}}
    },
    propT(t, e) {
        return {property: t, transform: e}
    },
    sizes: Rd("sizes", E7(Pi.vh, Pi.px)),
    sizesT: Rd("sizes", E7(Pi.vh, Pi.fraction)),
    shadows: Rd("shadows"),
    logical: pSt,
    blur: Rd("blur", Pi.blur)
}, VD = {
    background: je.colors("background"),
    backgroundColor: je.colors("backgroundColor"),
    backgroundImage: je.gradients("backgroundImage"),
    backgroundSize: !0,
    backgroundPosition: !0,
    backgroundRepeat: !0,
    backgroundAttachment: !0,
    backgroundClip: {transform: Pi.bgClip},
    bgSize: je.prop("backgroundSize"),
    bgPosition: je.prop("backgroundPosition"),
    bg: je.colors("background"),
    bgColor: je.colors("backgroundColor"),
    bgPos: je.prop("backgroundPosition"),
    bgRepeat: je.prop("backgroundRepeat"),
    bgAttachment: je.prop("backgroundAttachment"),
    bgGradient: je.gradients("backgroundImage"),
    bgClip: {transform: Pi.bgClip}
};
Object.assign(VD, {bgImage: VD.backgroundImage, bgImg: VD.backgroundImage});
var ji = {
    border: je.borders("border"),
    borderWidth: je.borderWidths("borderWidth"),
    borderStyle: je.borderStyles("borderStyle"),
    borderColor: je.colors("borderColor"),
    borderRadius: je.radii("borderRadius"),
    borderTop: je.borders("borderTop"),
    borderBlockStart: je.borders("borderBlockStart"),
    borderTopLeftRadius: je.radii("borderTopLeftRadius"),
    borderStartStartRadius: je.logical({
        scale: "radii",
        property: {ltr: "borderTopLeftRadius", rtl: "borderTopRightRadius"}
    }),
    borderEndStartRadius: je.logical({
        scale: "radii",
        property: {ltr: "borderBottomLeftRadius", rtl: "borderBottomRightRadius"}
    }),
    borderTopRightRadius: je.radii("borderTopRightRadius"),
    borderStartEndRadius: je.logical({
        scale: "radii",
        property: {ltr: "borderTopRightRadius", rtl: "borderTopLeftRadius"}
    }),
    borderEndEndRadius: je.logical({
        scale: "radii",
        property: {ltr: "borderBottomRightRadius", rtl: "borderBottomLeftRadius"}
    }),
    borderRight: je.borders("borderRight"),
    borderInlineEnd: je.borders("borderInlineEnd"),
    borderBottom: je.borders("borderBottom"),
    borderBlockEnd: je.borders("borderBlockEnd"),
    borderBottomLeftRadius: je.radii("borderBottomLeftRadius"),
    borderBottomRightRadius: je.radii("borderBottomRightRadius"),
    borderLeft: je.borders("borderLeft"),
    borderInlineStart: {property: "borderInlineStart", scale: "borders"},
    borderInlineStartRadius: je.logical({
        scale: "radii",
        property: {
            ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
            rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
        }
    }),
    borderInlineEndRadius: je.logical({
        scale: "radii",
        property: {
            ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
            rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
        }
    }),
    borderX: je.borders(["borderLeft", "borderRight"]),
    borderInline: je.borders("borderInline"),
    borderY: je.borders(["borderTop", "borderBottom"]),
    borderBlock: je.borders("borderBlock"),
    borderTopWidth: je.borderWidths("borderTopWidth"),
    borderBlockStartWidth: je.borderWidths("borderBlockStartWidth"),
    borderTopColor: je.colors("borderTopColor"),
    borderBlockStartColor: je.colors("borderBlockStartColor"),
    borderTopStyle: je.borderStyles("borderTopStyle"),
    borderBlockStartStyle: je.borderStyles("borderBlockStartStyle"),
    borderBottomWidth: je.borderWidths("borderBottomWidth"),
    borderBlockEndWidth: je.borderWidths("borderBlockEndWidth"),
    borderBottomColor: je.colors("borderBottomColor"),
    borderBlockEndColor: je.colors("borderBlockEndColor"),
    borderBottomStyle: je.borderStyles("borderBottomStyle"),
    borderBlockEndStyle: je.borderStyles("borderBlockEndStyle"),
    borderLeftWidth: je.borderWidths("borderLeftWidth"),
    borderInlineStartWidth: je.borderWidths("borderInlineStartWidth"),
    borderLeftColor: je.colors("borderLeftColor"),
    borderInlineStartColor: je.colors("borderInlineStartColor"),
    borderLeftStyle: je.borderStyles("borderLeftStyle"),
    borderInlineStartStyle: je.borderStyles("borderInlineStartStyle"),
    borderRightWidth: je.borderWidths("borderRightWidth"),
    borderInlineEndWidth: je.borderWidths("borderInlineEndWidth"),
    borderRightColor: je.colors("borderRightColor"),
    borderInlineEndColor: je.colors("borderInlineEndColor"),
    borderRightStyle: je.borderStyles("borderRightStyle"),
    borderInlineEndStyle: je.borderStyles("borderInlineEndStyle"),
    borderTopRadius: je.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
    borderBottomRadius: je.radii(["borderBottomLeftRadius", "borderBottomRightRadius"]),
    borderLeftRadius: je.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
    borderRightRadius: je.radii(["borderTopRightRadius", "borderBottomRightRadius"])
};
Object.assign(ji, {
    rounded: ji.borderRadius,
    roundedTop: ji.borderTopRadius,
    roundedTopLeft: ji.borderTopLeftRadius,
    roundedTopRight: ji.borderTopRightRadius,
    roundedTopStart: ji.borderStartStartRadius,
    roundedTopEnd: ji.borderStartEndRadius,
    roundedBottom: ji.borderBottomRadius,
    roundedBottomLeft: ji.borderBottomLeftRadius,
    roundedBottomRight: ji.borderBottomRightRadius,
    roundedBottomStart: ji.borderEndStartRadius,
    roundedBottomEnd: ji.borderEndEndRadius,
    roundedLeft: ji.borderLeftRadius,
    roundedRight: ji.borderRightRadius,
    roundedStart: ji.borderInlineStartRadius,
    roundedEnd: ji.borderInlineEndRadius,
    borderStart: ji.borderInlineStart,
    borderEnd: ji.borderInlineEnd,
    borderTopStartRadius: ji.borderStartStartRadius,
    borderTopEndRadius: ji.borderStartEndRadius,
    borderBottomStartRadius: ji.borderEndStartRadius,
    borderBottomEndRadius: ji.borderEndEndRadius,
    borderStartRadius: ji.borderInlineStartRadius,
    borderEndRadius: ji.borderInlineEndRadius,
    borderStartWidth: ji.borderInlineStartWidth,
    borderEndWidth: ji.borderInlineEndWidth,
    borderStartColor: ji.borderInlineStartColor,
    borderEndColor: ji.borderInlineEndColor,
    borderStartStyle: ji.borderInlineStartStyle,
    borderEndStyle: ji.borderInlineEndStyle
});
var ASt = {
    color: je.colors("color"),
    textColor: je.colors("color"),
    fill: je.colors("fill"),
    stroke: je.colors("stroke")
}, lK = {
    boxShadow: je.shadows("boxShadow"),
    mixBlendMode: !0,
    blendMode: je.prop("mixBlendMode"),
    backgroundBlendMode: !0,
    bgBlendMode: je.prop("backgroundBlendMode"),
    opacity: !0
};
Object.assign(lK, {shadow: lK.boxShadow});
var ISt = {
    filter: {transform: Pi.filter},
    blur: je.blur("--chakra-blur"),
    brightness: je.propT("--chakra-brightness", Pi.brightness),
    contrast: je.propT("--chakra-contrast", Pi.contrast),
    hueRotate: je.degreeT("--chakra-hue-rotate"),
    invert: je.propT("--chakra-invert", Pi.invert),
    saturate: je.propT("--chakra-saturate", Pi.saturate),
    dropShadow: je.propT("--chakra-drop-shadow", Pi.dropShadow),
    backdropFilter: {transform: Pi.backdropFilter},
    backdropBlur: je.blur("--chakra-backdrop-blur"),
    backdropBrightness: je.propT("--chakra-backdrop-brightness", Pi.brightness),
    backdropContrast: je.propT("--chakra-backdrop-contrast", Pi.contrast),
    backdropHueRotate: je.degreeT("--chakra-backdrop-hue-rotate"),
    backdropInvert: je.propT("--chakra-backdrop-invert", Pi.invert),
    backdropSaturate: je.propT("--chakra-backdrop-saturate", Pi.saturate)
}, RO = {
    alignItems: !0,
    alignContent: !0,
    justifyItems: !0,
    justifyContent: !0,
    flexWrap: !0,
    flexDirection: {transform: Pi.flexDirection},
    flex: !0,
    flexFlow: !0,
    flexGrow: !0,
    flexShrink: !0,
    flexBasis: je.sizes("flexBasis"),
    justifySelf: !0,
    alignSelf: !0,
    order: !0,
    placeItems: !0,
    placeContent: !0,
    placeSelf: !0,
    gap: je.space("gap"),
    rowGap: je.space("rowGap"),
    columnGap: je.space("columnGap")
};
Object.assign(RO, {flexDir: RO.flexDirection});
var B4e = {
    gridGap: je.space("gridGap"),
    gridColumnGap: je.space("gridColumnGap"),
    gridRowGap: je.space("gridRowGap"),
    gridColumn: !0,
    gridRow: !0,
    gridAutoFlow: !0,
    gridAutoColumns: !0,
    gridColumnStart: !0,
    gridColumnEnd: !0,
    gridRowStart: !0,
    gridRowEnd: !0,
    gridAutoRows: !0,
    gridTemplate: !0,
    gridTemplateColumns: !0,
    gridTemplateRows: !0,
    gridTemplateAreas: !0,
    gridArea: !0
}, kSt = {
    appearance: !0,
    cursor: !0,
    resize: !0,
    userSelect: !0,
    pointerEvents: !0,
    outline: {transform: Pi.outline},
    outlineOffset: !0,
    outlineColor: je.colors("outlineColor")
}, Nd = {
    width: je.sizesT("width"),
    inlineSize: je.sizesT("inlineSize"),
    height: je.sizes("height"),
    blockSize: je.sizes("blockSize"),
    boxSize: je.sizes(["width", "height"]),
    minWidth: je.sizes("minWidth"),
    minInlineSize: je.sizes("minInlineSize"),
    minHeight: je.sizes("minHeight"),
    minBlockSize: je.sizes("minBlockSize"),
    maxWidth: je.sizes("maxWidth"),
    maxInlineSize: je.sizes("maxInlineSize"),
    maxHeight: je.sizes("maxHeight"),
    maxBlockSize: je.sizes("maxBlockSize"),
    overflow: !0,
    overflowX: !0,
    overflowY: !0,
    overscrollBehavior: !0,
    overscrollBehaviorX: !0,
    overscrollBehaviorY: !0,
    display: !0,
    aspectRatio: !0,
    hideFrom: {
        scale: "breakpoints", transform: (t, e) => {
            var r, n, i;
            return {[`@media screen and (min-width: ${(i = (n = (r = e.__breakpoints) == null ? void 0 : r.get(t)) == null ? void 0 : n.minW) != null ? i : t})`]: {display: "none"}}
        }
    },
    hideBelow: {
        scale: "breakpoints", transform: (t, e) => {
            var r, n, i;
            return {[`@media screen and (max-width: ${(i = (n = (r = e.__breakpoints) == null ? void 0 : r.get(t)) == null ? void 0 : n._minW) != null ? i : t})`]: {display: "none"}}
        }
    },
    verticalAlign: !0,
    boxSizing: !0,
    boxDecorationBreak: !0,
    float: je.propT("float", Pi.float),
    objectFit: !0,
    objectPosition: !0,
    visibility: !0,
    isolation: !0
};
Object.assign(Nd, {
    w: Nd.width,
    h: Nd.height,
    minW: Nd.minWidth,
    maxW: Nd.maxWidth,
    minH: Nd.minHeight,
    maxH: Nd.maxHeight,
    overscroll: Nd.overscrollBehavior,
    overscrollX: Nd.overscrollBehaviorX,
    overscrollY: Nd.overscrollBehaviorY
});
var RSt = {
    listStyleType: !0,
    listStylePosition: !0,
    listStylePos: je.prop("listStylePosition"),
    listStyleImage: !0,
    listStyleImg: je.prop("listStyleImage")
};

function DSt(t, e, r, n) {
    const i = typeof e == "string" ? e.split(".") : [e];
    for (n = 0; n < i.length && t; n += 1) t = t[i[n]];
    return t === void 0 ? r : t
}

var MSt = t => {
    const e = new WeakMap;
    return (n, i, a, o) => {
        if (typeof n > "u") return t(n, i, a);
        e.has(n) || e.set(n, new Map);
        const s = e.get(n);
        if (s.has(i)) return s.get(i);
        const l = t(n, i, a, o);
        return s.set(i, l), l
    }
}, OSt = MSt(DSt), PSt = {
    border: "0px",
    clip: "rect(0, 0, 0, 0)",
    width: "1px",
    height: "1px",
    margin: "-1px",
    padding: "0px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    position: "absolute"
}, NSt = {
    position: "static",
    width: "auto",
    height: "auto",
    clip: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal"
}, MV = (t, e, r) => {
    const n = {}, i = OSt(t, e, {});
    for (const a in i) a in r && r[a] != null || (n[a] = i[a]);
    return n
}, LSt = {
    srOnly: {
        transform(t) {
            return t === !0 ? PSt : t === "focusable" ? NSt : {}
        }
    },
    layerStyle: {processResult: !0, transform: (t, e, r) => MV(e, `layerStyles.${t}`, r)},
    textStyle: {processResult: !0, transform: (t, e, r) => MV(e, `textStyles.${t}`, r)},
    apply: {processResult: !0, transform: (t, e, r) => MV(e, t, r)}
}, cC = {
    position: !0,
    pos: je.prop("position"),
    zIndex: je.prop("zIndex", "zIndices"),
    inset: je.spaceT("inset"),
    insetX: je.spaceT(["left", "right"]),
    insetInline: je.spaceT("insetInline"),
    insetY: je.spaceT(["top", "bottom"]),
    insetBlock: je.spaceT("insetBlock"),
    top: je.spaceT("top"),
    insetBlockStart: je.spaceT("insetBlockStart"),
    bottom: je.spaceT("bottom"),
    insetBlockEnd: je.spaceT("insetBlockEnd"),
    left: je.spaceT("left"),
    insetInlineStart: je.logical({scale: "space", property: {ltr: "left", rtl: "right"}}),
    right: je.spaceT("right"),
    insetInlineEnd: je.logical({scale: "space", property: {ltr: "right", rtl: "left"}})
};
Object.assign(cC, {insetStart: cC.insetInlineStart, insetEnd: cC.insetInlineEnd});
var BSt = {
    ring: {transform: Pi.ring},
    ringColor: je.colors("--chakra-ring-color"),
    ringOffset: je.prop("--chakra-ring-offset-width"),
    ringOffsetColor: je.colors("--chakra-ring-offset-color"),
    ringInset: je.prop("--chakra-ring-inset")
}, Fa = {
    margin: je.spaceT("margin"),
    marginTop: je.spaceT("marginTop"),
    marginBlockStart: je.spaceT("marginBlockStart"),
    marginRight: je.spaceT("marginRight"),
    marginInlineEnd: je.spaceT("marginInlineEnd"),
    marginBottom: je.spaceT("marginBottom"),
    marginBlockEnd: je.spaceT("marginBlockEnd"),
    marginLeft: je.spaceT("marginLeft"),
    marginInlineStart: je.spaceT("marginInlineStart"),
    marginX: je.spaceT(["marginInlineStart", "marginInlineEnd"]),
    marginInline: je.spaceT("marginInline"),
    marginY: je.spaceT(["marginTop", "marginBottom"]),
    marginBlock: je.spaceT("marginBlock"),
    padding: je.space("padding"),
    paddingTop: je.space("paddingTop"),
    paddingBlockStart: je.space("paddingBlockStart"),
    paddingRight: je.space("paddingRight"),
    paddingBottom: je.space("paddingBottom"),
    paddingBlockEnd: je.space("paddingBlockEnd"),
    paddingLeft: je.space("paddingLeft"),
    paddingInlineStart: je.space("paddingInlineStart"),
    paddingInlineEnd: je.space("paddingInlineEnd"),
    paddingX: je.space(["paddingInlineStart", "paddingInlineEnd"]),
    paddingInline: je.space("paddingInline"),
    paddingY: je.space(["paddingTop", "paddingBottom"]),
    paddingBlock: je.space("paddingBlock")
};
Object.assign(Fa, {
    m: Fa.margin,
    mt: Fa.marginTop,
    mr: Fa.marginRight,
    me: Fa.marginInlineEnd,
    marginEnd: Fa.marginInlineEnd,
    mb: Fa.marginBottom,
    ml: Fa.marginLeft,
    ms: Fa.marginInlineStart,
    marginStart: Fa.marginInlineStart,
    mx: Fa.marginX,
    my: Fa.marginY,
    p: Fa.padding,
    pt: Fa.paddingTop,
    py: Fa.paddingY,
    px: Fa.paddingX,
    pb: Fa.paddingBottom,
    pl: Fa.paddingLeft,
    ps: Fa.paddingInlineStart,
    paddingStart: Fa.paddingInlineStart,
    pr: Fa.paddingRight,
    pe: Fa.paddingInlineEnd,
    paddingEnd: Fa.paddingInlineEnd
});
var $St = {
    textDecorationColor: je.colors("textDecorationColor"),
    textDecoration: !0,
    textDecor: {property: "textDecoration"},
    textDecorationLine: !0,
    textDecorationStyle: !0,
    textDecorationThickness: !0,
    textUnderlineOffset: !0,
    textShadow: je.shadows("textShadow")
}, FSt = {
    clipPath: !0,
    transform: je.propT("transform", Pi.transform),
    transformOrigin: !0,
    translateX: je.spaceT("--chakra-translate-x"),
    translateY: je.spaceT("--chakra-translate-y"),
    skewX: je.degreeT("--chakra-skew-x"),
    skewY: je.degreeT("--chakra-skew-y"),
    scaleX: je.prop("--chakra-scale-x"),
    scaleY: je.prop("--chakra-scale-y"),
    scale: je.prop(["--chakra-scale-x", "--chakra-scale-y"]),
    rotate: je.degreeT("--chakra-rotate")
}, USt = {
    transition: !0,
    transitionDelay: !0,
    animation: !0,
    willChange: !0,
    transitionDuration: je.prop("transitionDuration", "transition.duration"),
    transitionProperty: je.prop("transitionProperty", "transition.property"),
    transitionTimingFunction: je.prop("transitionTimingFunction", "transition.easing")
}, jSt = {
    fontFamily: je.prop("fontFamily", "fonts"),
    fontSize: je.prop("fontSize", "fontSizes", Pi.px),
    fontWeight: je.prop("fontWeight", "fontWeights"),
    lineHeight: je.prop("lineHeight", "lineHeights"),
    letterSpacing: je.prop("letterSpacing", "letterSpacings"),
    textAlign: !0,
    fontStyle: !0,
    textIndent: !0,
    wordBreak: !0,
    overflowWrap: !0,
    textOverflow: !0,
    textTransform: !0,
    whiteSpace: !0,
    isTruncated: {
        transform(t) {
            if (t === !0) return {overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap"}
        }
    },
    noOfLines: {
        static: {
            overflow: "hidden",
            textOverflow: "ellipsis",
            display: "-webkit-box",
            WebkitBoxOrient: "vertical",
            WebkitLineClamp: "var(--chakra-line-clamp)"
        }, property: "--chakra-line-clamp"
    }
}, zSt = {
    scrollBehavior: !0,
    scrollSnapAlign: !0,
    scrollSnapStop: !0,
    scrollSnapType: !0,
    scrollMargin: je.spaceT("scrollMargin"),
    scrollMarginTop: je.spaceT("scrollMarginTop"),
    scrollMarginBottom: je.spaceT("scrollMarginBottom"),
    scrollMarginLeft: je.spaceT("scrollMarginLeft"),
    scrollMarginRight: je.spaceT("scrollMarginRight"),
    scrollMarginX: je.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
    scrollMarginY: je.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
    scrollPadding: je.spaceT("scrollPadding"),
    scrollPaddingTop: je.spaceT("scrollPaddingTop"),
    scrollPaddingBottom: je.spaceT("scrollPaddingBottom"),
    scrollPaddingLeft: je.spaceT("scrollPaddingLeft"),
    scrollPaddingRight: je.spaceT("scrollPaddingRight"),
    scrollPaddingX: je.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
    scrollPaddingY: je.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};

function $4e(t) {
    return rf(t) && t.reference ? t.reference : String(t)
}

var JN = (t, ...e) => e.map($4e).join(` ${t} `).replace(/calc/g, ""), Hfe = (...t) => `calc(${JN("+", ...t)})`,
    Wfe = (...t) => `calc(${JN("-", ...t)})`, uK = (...t) => `calc(${JN("*", ...t)})`,
    qfe = (...t) => `calc(${JN("/", ...t)})`, Gfe = t => {
        const e = $4e(t);
        return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : uK(e, -1)
    }, mw = Object.assign(t => ({
        add: (...e) => mw(Hfe(t, ...e)),
        subtract: (...e) => mw(Wfe(t, ...e)),
        multiply: (...e) => mw(uK(t, ...e)),
        divide: (...e) => mw(qfe(t, ...e)),
        negate: () => mw(Gfe(t)),
        toString: () => t.toString()
    }), {add: Hfe, subtract: Wfe, multiply: uK, divide: qfe, negate: Gfe});

function VSt(t, e = "-") {
    return t.replace(/\s+/g, e)
}

function HSt(t) {
    const e = VSt(t.toString());
    return qSt(WSt(e))
}

function WSt(t) {
    return t.includes("\\.") ? t : !Number.isInteger(parseFloat(t.toString())) ? t.replace(".", "\\.") : t
}

function qSt(t) {
    return t.replace(/[!-,/:-@[-^`{-~]/g, "\\$&")
}

function GSt(t, e = "") {
    return [e, t].filter(Boolean).join("-")
}

function KSt(t, e) {
    return `var(${t}${e ? `, ${e}` : ""})`
}

function YSt(t, e = "") {
    return HSt(`--${GSt(t, e)}`)
}

function Kr(t, e, r) {
    const n = YSt(t, r);
    return {variable: n, reference: KSt(n, e)}
}

function XSt(t, e) {
    const r = {};
    for (const n of e) {
        if (Array.isArray(n)) {
            const [i, a] = n;
            r[i] = Kr(`${t}-${i}`, a);
            continue
        }
        r[n] = Kr(`${t}-${n}`)
    }
    return r
}

function QSt(t) {
    const e = t == null ? 0 : t.length;
    return e ? t[e - 1] : void 0
}

function ZSt(t) {
    const e = parseFloat(t.toString()), r = t.toString().replace(String(e), "");
    return {unitless: !r, value: e, unit: r}
}

function fK(t) {
    if (t == null) return t;
    const {unitless: e} = ZSt(t);
    return e || typeof t == "number" ? `${t}px` : t
}

var F4e = (t, e) => parseInt(t[1], 10) > parseInt(e[1], 10) ? 1 : -1,
    nJ = t => Object.fromEntries(Object.entries(t).sort(F4e));

function Kfe(t) {
    const e = nJ(t);
    return Object.assign(Object.values(e), e)
}

function JSt(t) {
    const e = Object.keys(nJ(t));
    return new Set(e)
}

function Yfe(t) {
    var e;
    if (!t) return t;
    t = (e = fK(t)) != null ? e : t;
    const r = -.02;
    return typeof t == "number" ? `${t + r}` : t.replace(/(\d+\.?\d*)/u, n => `${parseFloat(n) + r}`)
}

function MT(t, e) {
    const r = ["@media screen"];
    return t && r.push("and", `(min-width: ${fK(t)})`), e && r.push("and", `(max-width: ${fK(e)})`), r.join(" ")
}

function e2t(t) {
    var e;
    if (!t) return null;
    t.base = (e = t.base) != null ? e : "0px";
    const r = Kfe(t), n = Object.entries(t).sort(F4e).map(([o, s], l, f) => {
        var d;
        let [, p] = (d = f[l + 1]) != null ? d : [];
        return p = parseFloat(p) > 0 ? Yfe(p) : void 0, {
            _minW: Yfe(s),
            breakpoint: o,
            minW: s,
            maxW: p,
            maxWQuery: MT(null, p),
            minWQuery: MT(s),
            minMaxQuery: MT(s, p)
        }
    }), i = JSt(t), a = Array.from(i.values());
    return {
        keys: i, normalized: r, isResponsive(o) {
            const s = Object.keys(o);
            return s.length > 0 && s.every(l => i.has(l))
        }, asObject: nJ(t), asArray: Kfe(t), details: n, get(o) {
            return n.find(s => s.breakpoint === o)
        }, media: [null, ...r.map(o => MT(o)).slice(1)], toArrayValue(o) {
            if (!rf(o)) throw new Error("toArrayValue: value must be an object");
            const s = a.map(l => {
                var f;
                return (f = o[l]) != null ? f : null
            });
            for (; QSt(s) === null;) s.pop();
            return s
        }, toObjectValue(o) {
            if (!Array.isArray(o)) throw new Error("toObjectValue: value must be an array");
            return o.reduce((s, l, f) => {
                const d = a[f];
                return d != null && l != null && (s[d] = l), s
            }, {})
        }
    }
}

var kc = {
        hover: (t, e) => `${t}:hover ${e}, ${t}[data-hover] ${e}`,
        focus: (t, e) => `${t}:focus ${e}, ${t}[data-focus] ${e}`,
        focusVisible: (t, e) => `${t}:focus-visible ${e}`,
        focusWithin: (t, e) => `${t}:focus-within ${e}`,
        active: (t, e) => `${t}:active ${e}, ${t}[data-active] ${e}`,
        disabled: (t, e) => `${t}:disabled ${e}, ${t}[data-disabled] ${e}`,
        invalid: (t, e) => `${t}:invalid ${e}, ${t}[data-invalid] ${e}`,
        checked: (t, e) => `${t}:checked ${e}, ${t}[data-checked] ${e}`,
        indeterminate: (t, e) => `${t}:indeterminate ${e}, ${t}[aria-checked=mixed] ${e}, ${t}[data-indeterminate] ${e}`,
        readOnly: (t, e) => `${t}:read-only ${e}, ${t}[readonly] ${e}, ${t}[data-read-only] ${e}`,
        expanded: (t, e) => `${t}:read-only ${e}, ${t}[aria-expanded=true] ${e}, ${t}[data-expanded] ${e}`,
        placeholderShown: (t, e) => `${t}:placeholder-shown ${e}`
    }, cy = t => U4e(e => t(e, "&"), "[role=group]", "[data-group]", ".group"),
    ev = t => U4e(e => t(e, "~ &"), "[data-peer]", ".peer"), U4e = (t, ...e) => e.map(t).join(", "), eL = {
        _hover: "&:hover, &[data-hover]",
        _active: "&:active, &[data-active]",
        _focus: "&:focus, &[data-focus]",
        _highlighted: "&[data-highlighted]",
        _focusWithin: "&:focus-within",
        _focusVisible: "&:focus-visible, &[data-focus-visible]",
        _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
        _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
        _before: "&::before",
        _after: "&::after",
        _empty: "&:empty",
        _expanded: "&[aria-expanded=true], &[data-expanded]",
        _checked: "&[aria-checked=true], &[data-checked]",
        _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
        _pressed: "&[aria-pressed=true], &[data-pressed]",
        _invalid: "&[aria-invalid=true], &[data-invalid]",
        _valid: "&[data-valid], &[data-state=valid]",
        _loading: "&[data-loading], &[aria-busy=true]",
        _selected: "&[aria-selected=true], &[data-selected]",
        _hidden: "&[hidden], &[data-hidden]",
        _autofill: "&:-webkit-autofill",
        _even: "&:nth-of-type(even)",
        _odd: "&:nth-of-type(odd)",
        _first: "&:first-of-type",
        _firstLetter: "&::first-letter",
        _last: "&:last-of-type",
        _notFirst: "&:not(:first-of-type)",
        _notLast: "&:not(:last-of-type)",
        _visited: "&:visited",
        _activeLink: "&[aria-current=page]",
        _activeStep: "&[aria-current=step]",
        _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
        _groupHover: cy(kc.hover),
        _peerHover: ev(kc.hover),
        _groupFocus: cy(kc.focus),
        _peerFocus: ev(kc.focus),
        _groupFocusVisible: cy(kc.focusVisible),
        _peerFocusVisible: ev(kc.focusVisible),
        _groupActive: cy(kc.active),
        _peerActive: ev(kc.active),
        _groupDisabled: cy(kc.disabled),
        _peerDisabled: ev(kc.disabled),
        _groupInvalid: cy(kc.invalid),
        _peerInvalid: ev(kc.invalid),
        _groupChecked: cy(kc.checked),
        _peerChecked: ev(kc.checked),
        _groupFocusWithin: cy(kc.focusWithin),
        _peerFocusWithin: ev(kc.focusWithin),
        _peerPlaceholderShown: ev(kc.placeholderShown),
        _placeholder: "&::placeholder",
        _placeholderShown: "&:placeholder-shown",
        _fullScreen: "&:fullscreen",
        _selection: "&::selection",
        _rtl: "[dir=rtl] &, &[dir=rtl]",
        _ltr: "[dir=ltr] &, &[dir=ltr]",
        _mediaDark: "@media (prefers-color-scheme: dark)",
        _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
        _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
        _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
        _horizontal: "&[data-orientation=horizontal]",
        _vertical: "&[data-orientation=vertical]"
    }, j4e = Object.keys(eL);

function Xfe(t, e) {
    return Kr(String(t).replace(/\./g, "-"), void 0, e)
}

function t2t(t, e) {
    let r = {};
    const n = {};
    for (const [i, a] of Object.entries(t)) {
        const {isSemantic: o, value: s} = a, {variable: l, reference: f} = Xfe(i, e == null ? void 0 : e.cssVarPrefix);
        if (!o) {
            if (i.startsWith("space")) {
                const g = i.split("."), [b, ...S] = g, T = `${b}.-${S.join(".")}`, I = mw.negate(s), N = mw.negate(f);
                n[T] = {value: I, var: l, varRef: N}
            }
            r[l] = s, n[i] = {value: s, var: l, varRef: f};
            continue
        }
        const d = g => {
            const S = [String(i).split(".")[0], g].join(".");
            if (!t[S]) return g;
            const {reference: I} = Xfe(S, e == null ? void 0 : e.cssVarPrefix);
            return I
        }, p = rf(s) ? s : {default: s};
        r = qd(r, Object.entries(p).reduce((g, [b, S]) => {
            var T, I;
            if (!S) return g;
            const N = d(`${S}`);
            if (b === "default") return g[l] = N, g;
            const P = (I = (T = eL) == null ? void 0 : T[b]) != null ? I : b;
            return g[P] = {[l]: N}, g
        }, {})), n[i] = {value: f, var: l, varRef: f}
    }
    return {cssVars: r, cssMap: n}
}

function r2t(t, e = []) {
    const r = Object.assign({}, t);
    for (const n of e) n in r && delete r[n];
    return r
}

function n2t(t, e) {
    const r = {};
    for (const n of e) n in t && (r[n] = t[n]);
    return r
}

function i2t(t) {
    return typeof t == "object" && t != null && !Array.isArray(t)
}

function Qfe(t, e, r = {}) {
    const {stop: n, getKey: i} = r;

    function a(o, s = []) {
        var l;
        if (i2t(o) || Array.isArray(o)) {
            const f = {};
            for (const [d, p] of Object.entries(o)) {
                const g = (l = i == null ? void 0 : i(d)) != null ? l : d, b = [...s, g];
                if (n != null && n(o, b)) return e(o, s);
                f[g] = a(p, b)
            }
            return f
        }
        return e(o, s)
    }

    return a(t)
}

var a2t = ["colors", "borders", "borderWidths", "borderStyles", "fonts", "fontSizes", "fontWeights", "gradients", "letterSpacings", "lineHeights", "radii", "space", "shadows", "sizes", "zIndices", "transition", "blur", "breakpoints"];

function o2t(t) {
    return n2t(t, a2t)
}

function s2t(t) {
    return t.semanticTokens
}

function c2t(t) {
    const {__cssMap: e, __cssVars: r, __breakpoints: n, ...i} = t;
    return i
}

var l2t = t => j4e.includes(t) || t === "default";

function u2t({tokens: t, semanticTokens: e}) {
    const r = {};
    return Qfe(t, (n, i) => {
        n != null && (r[i.join(".")] = {isSemantic: !1, value: n})
    }), Qfe(e, (n, i) => {
        n != null && (r[i.join(".")] = {isSemantic: !0, value: n})
    }, {stop: n => Object.keys(n).every(l2t)}), r
}

function f2t(t) {
    var e;
    const r = c2t(t), n = o2t(r), i = s2t(r), a = u2t({tokens: n, semanticTokens: i}),
        o = (e = r.config) == null ? void 0 : e.cssVarPrefix, {cssMap: s, cssVars: l} = t2t(a, {cssVarPrefix: o});
    return Object.assign(r, {
        __cssVars: {
            ...{
                "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
                "--chakra-ring-offset-width": "0px",
                "--chakra-ring-offset-color": "#fff",
                "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
                "--chakra-ring-offset-shadow": "0 0 #0000",
                "--chakra-ring-shadow": "0 0 #0000",
                "--chakra-space-x-reverse": "0",
                "--chakra-space-y-reverse": "0"
            }, ...l
        }, __cssMap: s, __breakpoints: e2t(r.breakpoints)
    }), r
}

var iJ = qd({}, VD, ji, ASt, RO, Nd, ISt, BSt, kSt, B4e, LSt, cC, lK, Fa, zSt, jSt, $St, FSt, RSt, USt),
    d2t = Object.assign({}, Fa, Nd, RO, B4e, cC), XJt = Object.keys(d2t), h2t = [...Object.keys(iJ), ...j4e],
    p2t = {...iJ, ...eL}, m2t = t => t in p2t, v2t = t => e => {
        if (!e.__breakpoints) return t;
        const {isResponsive: r, toArrayValue: n, media: i} = e.__breakpoints, a = {};
        for (const o in t) {
            let s = tp(t[o], e);
            if (s == null) continue;
            if (s = rf(s) && r(s) ? n(s) : s, !Array.isArray(s)) {
                a[o] = s;
                continue
            }
            const l = s.slice(0, i.length).length;
            for (let f = 0; f < l; f += 1) {
                const d = i == null ? void 0 : i[f];
                if (!d) {
                    a[o] = s[f];
                    continue
                }
                a[d] = a[d] || {}, s[f] != null && (a[d][o] = s[f])
            }
        }
        return a
    };

function g2t(t) {
    const e = [];
    let r = "", n = !1;
    for (let i = 0; i < t.length; i++) {
        const a = t[i];
        a === "(" ? (n = !0, r += a) : a === ")" ? (n = !1, r += a) : a === "," && !n ? (e.push(r), r = "") : r += a
    }
    return r = r.trim(), r && e.push(r), e
}

function y2t(t) {
    return /^var\(--.+\)$/.test(t)
}

var b2t = (t, e) => t.startsWith("--") && typeof e == "string" && !y2t(e), w2t = (t, e) => {
    var r, n;
    if (e == null) return e;
    const i = l => {
        var f, d;
        return (d = (f = t.__cssMap) == null ? void 0 : f[l]) == null ? void 0 : d.varRef
    }, a = l => {
        var f;
        return (f = i(l)) != null ? f : l
    }, [o, s] = g2t(e);
    return e = (n = (r = i(o)) != null ? r : a(s)) != null ? n : a(e), e
};

function S2t(t) {
    const {configs: e = {}, pseudos: r = {}, theme: n} = t, i = (a, o = !1) => {
        var s, l, f;
        const d = tp(a, n), p = v2t(d)(n);
        let g = {};
        for (let b in p) {
            const S = p[b];
            let T = tp(S, n);
            b in r && (b = r[b]), b2t(b, T) && (T = w2t(n, T));
            let I = e[b];
            if (I === !0 && (I = {property: b}), rf(T)) {
                g[b] = (s = g[b]) != null ? s : {}, g[b] = qd({}, g[b], i(T, !0));
                continue
            }
            let N = (f = (l = I == null ? void 0 : I.transform) == null ? void 0 : l.call(I, T, n, d)) != null ? f : T;
            N = I != null && I.processResult ? i(N, !0) : N;
            const P = tp(I == null ? void 0 : I.property, n);
            if (!o && (I != null && I.static)) {
                const F = tp(I.static, n);
                g = qd({}, g, F)
            }
            if (P && Array.isArray(P)) {
                for (const F of P) g[F] = N;
                continue
            }
            if (P) {
                P === "&" && rf(N) ? g = qd({}, g, N) : g[P] = N;
                continue
            }
            if (rf(N)) {
                g = qd({}, g, N);
                continue
            }
            g[b] = N
        }
        return g
    };
    return i
}

var z4e = t => e => S2t({theme: e, pseudos: eL, configs: iJ})(t);

function ka(t) {
    return {
        definePartsStyle(e) {
            return e
        }, defineMultiStyleConfig(e) {
            return {parts: t, ...e}
        }
    }
}

function _2t(t, e) {
    if (Array.isArray(t)) return t;
    if (rf(t)) return e(t);
    if (t != null) return [t]
}

function x2t(t, e) {
    for (let r = e + 1; r < t.length; r++) if (t[r] != null) return r;
    return -1
}

function E2t(t) {
    const e = t.__breakpoints;
    return function (n, i, a, o) {
        var s, l;
        if (!e) return;
        const f = {}, d = _2t(a, e.toArrayValue);
        if (!d) return f;
        const p = d.length, g = p === 1, b = !!n.parts;
        for (let S = 0; S < p; S++) {
            const T = e.details[S], I = e.details[x2t(d, S)], N = MT(T.minW, I == null ? void 0 : I._minW),
                P = tp((s = n[i]) == null ? void 0 : s[d[S]], o);
            if (P) {
                if (b) {
                    (l = n.parts) == null || l.forEach(F => {
                        qd(f, {[F]: g ? P[F] : {[N]: P[F]}})
                    });
                    continue
                }
                if (!b) {
                    g ? qd(f, P) : f[N] = P;
                    continue
                }
                f[N] = P
            }
        }
        return f
    }
}

function T2t(t) {
    return e => {
        var r;
        const {variant: n, size: i, theme: a} = e, o = E2t(a);
        return qd({}, tp((r = t.baseStyle) != null ? r : {}, e), o(t, "sizes", i, e), o(t, "variants", n, e))
    }
}

function C2t(t, e, r) {
    var n, i, a;
    return (a = (i = (n = t.__cssMap) == null ? void 0 : n[`${e}.${r}`]) == null ? void 0 : i.varRef) != null ? a : r
}

function Cp(t) {
    return r2t(t, ["styleConfig", "size", "variant", "colorScheme"])
}

var A2t = ["borders", "breakpoints", "colors", "components", "config", "direction", "fonts", "fontSizes", "fontWeights", "letterSpacings", "lineHeights", "radii", "shadows", "sizes", "space", "styles", "transition", "zIndices"];

function I2t(t) {
    return rf(t) ? A2t.every(e => Object.prototype.hasOwnProperty.call(t, e)) : !1
}

var k2t = {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
        colors: "background-color, border-color, color, fill, stroke",
        dimensions: "width, height",
        position: "left, right, top, bottom",
        background: "background-color, background-image, background-position"
    }, R2t = {
        "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
        "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
        "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    }, D2t = {
        "ultra-fast": "50ms",
        faster: "100ms",
        fast: "150ms",
        normal: "200ms",
        slow: "300ms",
        slower: "400ms",
        "ultra-slow": "500ms"
    }, M2t = {property: k2t, easing: R2t, duration: D2t}, O2t = M2t, P2t = {
        hide: -1,
        auto: "auto",
        base: 0,
        docked: 10,
        dropdown: 1e3,
        sticky: 1100,
        banner: 1200,
        overlay: 1300,
        modal: 1400,
        popover: 1500,
        skipLink: 1600,
        toast: 1700,
        tooltip: 1800
    }, N2t = P2t, L2t = {none: 0, "1px": "1px solid", "2px": "2px solid", "4px": "4px solid", "8px": "8px solid"},
    B2t = L2t, $2t = {base: "0em", sm: "30em", md: "48em", lg: "62em", xl: "80em", "2xl": "96em"}, F2t = $2t, U2t = {
        transparent: "transparent",
        current: "currentColor",
        black: "#000000",
        white: "#FFFFFF",
        whiteAlpha: {
            50: "rgba(255, 255, 255, 0.04)",
            100: "rgba(255, 255, 255, 0.06)",
            200: "rgba(255, 255, 255, 0.08)",
            300: "rgba(255, 255, 255, 0.16)",
            400: "rgba(255, 255, 255, 0.24)",
            500: "rgba(255, 255, 255, 0.36)",
            600: "rgba(255, 255, 255, 0.48)",
            700: "rgba(255, 255, 255, 0.64)",
            800: "rgba(255, 255, 255, 0.80)",
            900: "rgba(255, 255, 255, 0.92)"
        },
        blackAlpha: {
            50: "rgba(0, 0, 0, 0.04)",
            100: "rgba(0, 0, 0, 0.06)",
            200: "rgba(0, 0, 0, 0.08)",
            300: "rgba(0, 0, 0, 0.16)",
            400: "rgba(0, 0, 0, 0.24)",
            500: "rgba(0, 0, 0, 0.36)",
            600: "rgba(0, 0, 0, 0.48)",
            700: "rgba(0, 0, 0, 0.64)",
            800: "rgba(0, 0, 0, 0.80)",
            900: "rgba(0, 0, 0, 0.92)"
        },
        gray: {
            50: "#F7FAFC",
            100: "#EDF2F7",
            200: "#E2E8F0",
            300: "#CBD5E0",
            400: "#A0AEC0",
            500: "#718096",
            600: "#4A5568",
            700: "#2D3748",
            800: "#1A202C",
            900: "#171923"
        },
        red: {
            50: "#FFF5F5",
            100: "#FED7D7",
            200: "#FEB2B2",
            300: "#FC8181",
            400: "#F56565",
            500: "#E53E3E",
            600: "#C53030",
            700: "#9B2C2C",
            800: "#822727",
            900: "#63171B"
        },
        orange: {
            50: "#FFFAF0",
            100: "#FEEBC8",
            200: "#FBD38D",
            300: "#F6AD55",
            400: "#ED8936",
            500: "#DD6B20",
            600: "#C05621",
            700: "#9C4221",
            800: "#7B341E",
            900: "#652B19"
        },
        yellow: {
            50: "#FFFFF0",
            100: "#FEFCBF",
            200: "#FAF089",
            300: "#F6E05E",
            400: "#ECC94B",
            500: "#D69E2E",
            600: "#B7791F",
            700: "#975A16",
            800: "#744210",
            900: "#5F370E"
        },
        green: {
            50: "#F0FFF4",
            100: "#C6F6D5",
            200: "#9AE6B4",
            300: "#68D391",
            400: "#48BB78",
            500: "#38A169",
            600: "#2F855A",
            700: "#276749",
            800: "#22543D",
            900: "#1C4532"
        },
        teal: {
            50: "#E6FFFA",
            100: "#B2F5EA",
            200: "#81E6D9",
            300: "#4FD1C5",
            400: "#38B2AC",
            500: "#319795",
            600: "#2C7A7B",
            700: "#285E61",
            800: "#234E52",
            900: "#1D4044"
        },
        blue: {
            50: "#ebf8ff",
            100: "#bee3f8",
            200: "#90cdf4",
            300: "#63b3ed",
            400: "#4299e1",
            500: "#3182ce",
            600: "#2b6cb0",
            700: "#2c5282",
            800: "#2a4365",
            900: "#1A365D"
        },
        cyan: {
            50: "#EDFDFD",
            100: "#C4F1F9",
            200: "#9DECF9",
            300: "#76E4F7",
            400: "#0BC5EA",
            500: "#00B5D8",
            600: "#00A3C4",
            700: "#0987A0",
            800: "#086F83",
            900: "#065666"
        },
        purple: {
            50: "#FAF5FF",
            100: "#E9D8FD",
            200: "#D6BCFA",
            300: "#B794F4",
            400: "#9F7AEA",
            500: "#805AD5",
            600: "#6B46C1",
            700: "#553C9A",
            800: "#44337A",
            900: "#322659"
        },
        pink: {
            50: "#FFF5F7",
            100: "#FED7E2",
            200: "#FBB6CE",
            300: "#F687B3",
            400: "#ED64A6",
            500: "#D53F8C",
            600: "#B83280",
            700: "#97266D",
            800: "#702459",
            900: "#521B41"
        },
        linkedin: {
            50: "#E8F4F9",
            100: "#CFEDFB",
            200: "#9BDAF3",
            300: "#68C7EC",
            400: "#34B3E4",
            500: "#00A0DC",
            600: "#008CC9",
            700: "#0077B5",
            800: "#005E93",
            900: "#004471"
        },
        facebook: {
            50: "#E8F4F9",
            100: "#D9DEE9",
            200: "#B7C2DA",
            300: "#6482C0",
            400: "#4267B2",
            500: "#385898",
            600: "#314E89",
            700: "#29487D",
            800: "#223B67",
            900: "#1E355B"
        },
        messenger: {
            50: "#D0E6FF",
            100: "#B9DAFF",
            200: "#A2CDFF",
            300: "#7AB8FF",
            400: "#2E90FF",
            500: "#0078FF",
            600: "#0063D1",
            700: "#0052AC",
            800: "#003C7E",
            900: "#002C5C"
        },
        whatsapp: {
            50: "#dffeec",
            100: "#b9f5d0",
            200: "#90edb3",
            300: "#65e495",
            400: "#3cdd78",
            500: "#22c35e",
            600: "#179848",
            700: "#0c6c33",
            800: "#01421c",
            900: "#001803"
        },
        twitter: {
            50: "#E5F4FD",
            100: "#C8E9FB",
            200: "#A8DCFA",
            300: "#83CDF7",
            400: "#57BBF5",
            500: "#1DA1F2",
            600: "#1A94DA",
            700: "#1681BF",
            800: "#136B9E",
            900: "#0D4D71"
        },
        telegram: {
            50: "#E3F2F9",
            100: "#C5E4F3",
            200: "#A2D4EC",
            300: "#7AC1E4",
            400: "#47A9DA",
            500: "#0088CC",
            600: "#007AB8",
            700: "#006BA1",
            800: "#005885",
            900: "#003F5E"
        }
    }, j2t = U2t, z2t = {
        none: "0",
        sm: "0.125rem",
        base: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    }, V2t = z2t, H2t = {
        xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
        sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
        base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
        md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
        lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
        xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
        "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
        outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
        inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
        none: "none",
        "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
    }, W2t = H2t, q2t = {none: 0, sm: "4px", base: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px"},
    G2t = q2t, K2t = {
        letterSpacings: {
            tighter: "-0.05em",
            tight: "-0.025em",
            normal: "0",
            wide: "0.025em",
            wider: "0.05em",
            widest: "0.1em"
        },
        lineHeights: {
            normal: "normal",
            none: 1,
            shorter: 1.25,
            short: 1.375,
            base: 1.5,
            tall: 1.625,
            taller: "2",
            3: ".75rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem"
        },
        fontWeights: {
            hairline: 100,
            thin: 200,
            light: 300,
            normal: 400,
            medium: 500,
            semibold: 600,
            bold: 700,
            extrabold: 800,
            black: 900
        },
        fonts: {
            heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
            body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
            mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
        },
        fontSizes: {
            "3xs": "0.45rem",
            "2xs": "0.625rem",
            xs: "0.75rem",
            sm: "0.875rem",
            md: "1rem",
            lg: "1.125rem",
            xl: "1.25rem",
            "2xl": "1.5rem",
            "3xl": "1.875rem",
            "4xl": "2.25rem",
            "5xl": "3rem",
            "6xl": "3.75rem",
            "7xl": "4.5rem",
            "8xl": "6rem",
            "9xl": "8rem"
        }
    }, V4e = K2t, H4e = {
        px: "1px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    }, Y2t = {
        max: "max-content",
        min: "min-content",
        full: "100%",
        "3xs": "14rem",
        "2xs": "16rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        "8xl": "90rem",
        prose: "60ch"
    }, X2t = {sm: "640px", md: "768px", lg: "1024px", xl: "1280px"}, Q2t = {...H4e, ...Y2t, container: X2t}, W4e = Q2t,
    Z2t = {
        breakpoints: F2t,
        zIndices: N2t,
        radii: V2t,
        blur: G2t,
        colors: j2t, ...V4e,
        sizes: W4e,
        shadows: W2t,
        space: H4e,
        borders: B2t,
        transition: O2t
    }, {
        defineMultiStyleConfig: J2t,
        definePartsStyle: OT
    } = ka(["stepper", "step", "title", "description", "indicator", "separator", "icon", "number"]),
    av = Kr("stepper-indicator-size"), Dx = Kr("stepper-icon-size"), Mx = Kr("stepper-title-font-size"),
    PT = Kr("stepper-description-font-size"), nT = Kr("stepper-accent-color"), e_t = OT(({colorScheme: t}) => ({
        stepper: {
            display: "flex",
            justifyContent: "space-between",
            gap: "4",
            "&[data-orientation=vertical]": {flexDirection: "column", alignItems: "flex-start"},
            "&[data-orientation=horizontal]": {flexDirection: "row", alignItems: "center"},
            [nT.variable]: `colors.${t}.500`,
            _dark: {[nT.variable]: `colors.${t}.200`}
        },
        title: {fontSize: Mx.reference, fontWeight: "medium"},
        description: {fontSize: PT.reference, color: "chakra-subtle-text"},
        number: {fontSize: Mx.reference},
        step: {
            flexShrink: 0,
            position: "relative",
            display: "flex",
            gap: "2",
            "&[data-orientation=horizontal]": {alignItems: "center"},
            flex: "1",
            "&:last-of-type:not([data-stretch])": {flex: "initial"}
        },
        icon: {flexShrink: 0, width: Dx.reference, height: Dx.reference},
        indicator: {
            flexShrink: 0,
            borderRadius: "full",
            width: av.reference,
            height: av.reference,
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&[data-status=active]": {borderWidth: "2px", borderColor: nT.reference},
            "&[data-status=complete]": {bg: nT.reference, color: "chakra-inverse-text"},
            "&[data-status=incomplete]": {borderWidth: "2px"}
        },
        separator: {
            bg: "chakra-border-color",
            flex: "1",
            "&[data-status=complete]": {bg: nT.reference},
            "&[data-orientation=horizontal]": {width: "100%", height: "2px", marginStart: "2"},
            "&[data-orientation=vertical]": {
                width: "2px",
                position: "absolute",
                height: "100%",
                maxHeight: `calc(100% - ${av.reference} - 8px)`,
                top: `calc(${av.reference} + 4px)`,
                insetStart: `calc(${av.reference} / 2 - 1px)`
            }
        }
    })), t_t = J2t({
        baseStyle: e_t,
        sizes: {
            xs: OT({
                stepper: {
                    [av.variable]: "sizes.4",
                    [Dx.variable]: "sizes.3",
                    [Mx.variable]: "fontSizes.xs",
                    [PT.variable]: "fontSizes.xs"
                }
            }),
            sm: OT({
                stepper: {
                    [av.variable]: "sizes.6",
                    [Dx.variable]: "sizes.4",
                    [Mx.variable]: "fontSizes.sm",
                    [PT.variable]: "fontSizes.xs"
                }
            }),
            md: OT({
                stepper: {
                    [av.variable]: "sizes.8",
                    [Dx.variable]: "sizes.5",
                    [Mx.variable]: "fontSizes.md",
                    [PT.variable]: "fontSizes.sm"
                }
            }),
            lg: OT({
                stepper: {
                    [av.variable]: "sizes.10",
                    [Dx.variable]: "sizes.6",
                    [Mx.variable]: "fontSizes.lg",
                    [PT.variable]: "fontSizes.md"
                }
            })
        },
        defaultProps: {size: "md", colorScheme: "blue"}
    });

function Zi(t, e = {}) {
    let r = !1;

    function n() {
        if (!r) {
            r = !0;
            return
        }
        throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?")
    }

    function i(...d) {
        n();
        for (const p of d) e[p] = l(p);
        return Zi(t, e)
    }

    function a(...d) {
        for (const p of d) p in e || (e[p] = l(p));
        return Zi(t, e)
    }

    function o() {
        return Object.fromEntries(Object.entries(e).map(([p, g]) => [p, g.selector]))
    }

    function s() {
        return Object.fromEntries(Object.entries(e).map(([p, g]) => [p, g.className]))
    }

    function l(d) {
        const b = `chakra-${(["container", "root"].includes(d ?? "") ? [t] : [t, d]).filter(Boolean).join("__")}`;
        return {className: b, selector: `.${b}`, toString: () => d}
    }

    return {
        parts: i, toPart: l, extend: a, selectors: o, classnames: s, get keys() {
            return Object.keys(e)
        }, __type: {}
    }
}

var r_t = Zi("accordion").parts("root", "container", "button", "panel").extend("icon"),
    n_t = Zi("alert").parts("title", "description", "container").extend("icon", "spinner"),
    i_t = Zi("avatar").parts("label", "badge", "container").extend("excessLabel", "group"),
    a_t = Zi("breadcrumb").parts("link", "item", "container").extend("separator");
Zi("button").parts();
var o_t = Zi("checkbox").parts("control", "icon", "container").extend("label");
Zi("progress").parts("track", "filledTrack").extend("label");
var s_t = Zi("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer"),
    c_t = Zi("editable").parts("preview", "input", "textarea"),
    l_t = Zi("form").parts("container", "requiredIndicator", "helperText"), u_t = Zi("formError").parts("text", "icon"),
    f_t = Zi("input").parts("addon", "field", "element", "group"), d_t = Zi("list").parts("container", "item", "icon"),
    h_t = Zi("menu").parts("button", "list", "item").extend("groupTitle", "icon", "command", "divider"),
    p_t = Zi("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer"),
    m_t = Zi("numberinput").parts("root", "field", "stepperGroup", "stepper");
Zi("pininput").parts("field");
var v_t = Zi("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton"),
    g_t = Zi("progress").parts("label", "filledTrack", "track"),
    y_t = Zi("radio").parts("container", "control", "label"), b_t = Zi("select").parts("field", "icon"),
    w_t = Zi("slider").parts("container", "track", "thumb", "filledTrack", "mark"),
    S_t = Zi("stat").parts("container", "label", "helpText", "number", "icon"),
    __t = Zi("switch").parts("container", "track", "thumb"),
    x_t = Zi("table").parts("table", "thead", "tbody", "tr", "th", "td", "tfoot", "caption"),
    E_t = Zi("tabs").parts("root", "tab", "tablist", "tabpanel", "tabpanels", "indicator"),
    T_t = Zi("tag").parts("container", "label", "closeButton"),
    C_t = Zi("card").parts("container", "header", "body", "footer");

function kw(t, e, r) {
    return Math.min(Math.max(t, r), e)
}

class A_t extends Error {
    constructor(e) {
        super(`Failed to parse color: "${e}"`)
    }
}

var NT = A_t;

function aJ(t) {
    if (typeof t != "string") throw new NT(t);
    if (t.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
    let e = t.trim();
    e = N_t.test(t) ? R_t(t) : t;
    const r = D_t.exec(e);
    if (r) {
        const o = Array.from(r).slice(1);
        return [...o.slice(0, 3).map(s => parseInt(CA(s, 2), 16)), parseInt(CA(o[3] || "f", 2), 16) / 255]
    }
    const n = M_t.exec(e);
    if (n) {
        const o = Array.from(n).slice(1);
        return [...o.slice(0, 3).map(s => parseInt(s, 16)), parseInt(o[3] || "ff", 16) / 255]
    }
    const i = O_t.exec(e);
    if (i) {
        const o = Array.from(i).slice(1);
        return [...o.slice(0, 3).map(s => parseInt(s, 10)), parseFloat(o[3] || "1")]
    }
    const a = P_t.exec(e);
    if (a) {
        const [o, s, l, f] = Array.from(a).slice(1).map(parseFloat);
        if (kw(0, 100, s) !== s) throw new NT(t);
        if (kw(0, 100, l) !== l) throw new NT(t);
        return [...L_t(o, s, l), Number.isNaN(f) ? 1 : f]
    }
    throw new NT(t)
}

function I_t(t) {
    let e = 5381, r = t.length;
    for (; r;) e = e * 33 ^ t.charCodeAt(--r);
    return (e >>> 0) % 2341
}

const Zfe = t => parseInt(t.replace(/_/g, ""), 36),
    k_t = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t, e) => {
        const r = Zfe(e.substring(0, 3)), n = Zfe(e.substring(3)).toString(16);
        let i = "";
        for (let a = 0; a < 6 - n.length; a++) i += "0";
        return t[r] = `${i}${n}`, t
    }, {});

function R_t(t) {
    const e = t.toLowerCase().trim(), r = k_t[I_t(e)];
    if (!r) throw new NT(t);
    return `#${r}`
}

const CA = (t, e) => Array.from(Array(e)).map(() => t).join(""),
    D_t = new RegExp(`^#${CA("([a-f0-9])", 3)}([a-f0-9])?$`, "i"),
    M_t = new RegExp(`^#${CA("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"),
    O_t = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${CA(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"),
    P_t = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, N_t = /^[a-z]+$/i,
    Jfe = t => Math.round(t * 255), L_t = (t, e, r) => {
        let n = r / 100;
        if (e === 0) return [n, n, n].map(Jfe);
        const i = (t % 360 + 360) % 360 / 60, a = (1 - Math.abs(2 * n - 1)) * (e / 100), o = a * (1 - Math.abs(i % 2 - 1));
        let s = 0, l = 0, f = 0;
        i >= 0 && i < 1 ? (s = a, l = o) : i >= 1 && i < 2 ? (s = o, l = a) : i >= 2 && i < 3 ? (l = a, f = o) : i >= 3 && i < 4 ? (l = o, f = a) : i >= 4 && i < 5 ? (s = o, f = a) : i >= 5 && i < 6 && (s = a, f = o);
        const d = n - a / 2, p = s + d, g = l + d, b = f + d;
        return [p, g, b].map(Jfe)
    };

function B_t(t, e, r, n) {
    return `rgba(${kw(0, 255, t).toFixed()}, ${kw(0, 255, e).toFixed()}, ${kw(0, 255, r).toFixed()}, ${parseFloat(kw(0, 1, n).toFixed(3))})`
}

function $_t(t, e) {
    const [r, n, i, a] = aJ(t);
    return B_t(r, n, i, a - e)
}

function F_t(t) {
    const [e, r, n, i] = aJ(t);
    let a = o => {
        const s = kw(0, 255, o).toString(16);
        return s.length === 1 ? `0${s}` : s
    };
    return `#${a(e)}${a(r)}${a(n)}${i < 1 ? a(Math.round(i * 255)) : ""}`
}

function U_t(t, e, r, n, i) {
    for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++) t = t ? t[e[n]] : i;
    return t === i ? r : t
}

var j_t = t => Object.keys(t).length === 0, su = (t, e, r) => {
    const n = U_t(t, `colors.${e}`, e);
    try {
        return F_t(n), n
    } catch {
        return r ?? "#000000"
    }
}, z_t = t => {
    const [e, r, n] = aJ(t);
    return (e * 299 + r * 587 + n * 114) / 1e3
}, V_t = t => e => {
    const r = su(e, t);
    return z_t(r) < 128 ? "dark" : "light"
}, H_t = t => e => V_t(t)(e) === "dark", eE = (t, e) => r => {
    const n = su(r, t);
    return $_t(n, 1 - e)
};

function ede(t = "1rem", e = "rgba(255, 255, 255, 0.15)") {
    return {
        backgroundImage: `linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`, backgroundSize: `${t} ${t}`
    }
}

var W_t = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;

function q_t(t) {
    const e = W_t();
    return !t || j_t(t) ? e : t.string && t.colors ? K_t(t.string, t.colors) : t.string && !t.colors ? G_t(t.string) : t.colors && !t.string ? Y_t(t.colors) : e
}

function G_t(t) {
    let e = 0;
    if (t.length === 0) return e.toString();
    for (let n = 0; n < t.length; n += 1) e = t.charCodeAt(n) + ((e << 5) - e), e = e & e;
    let r = "#";
    for (let n = 0; n < 3; n += 1) {
        const i = e >> n * 8 & 255;
        r += `00${i.toString(16)}`.substr(-2)
    }
    return r
}

function K_t(t, e) {
    let r = 0;
    if (t.length === 0) return e[0];
    for (let n = 0; n < t.length; n += 1) r = t.charCodeAt(n) + ((r << 5) - r), r = r & r;
    return r = (r % e.length + e.length) % e.length, e[r]
}

function Y_t(t) {
    return t[Math.floor(Math.random() * t.length)]
}

function Zr(t, e) {
    return r => r.colorMode === "dark" ? e : t
}

function oJ(t) {
    const {orientation: e, vertical: r, horizontal: n} = t;
    return e ? e === "vertical" ? r : n : {}
}

function q4e(t) {
    return rf(t) && t.reference ? t.reference : String(t)
}

var tL = (t, ...e) => e.map(q4e).join(` ${t} `).replace(/calc/g, ""), tde = (...t) => `calc(${tL("+", ...t)})`,
    rde = (...t) => `calc(${tL("-", ...t)})`, dK = (...t) => `calc(${tL("*", ...t)})`,
    nde = (...t) => `calc(${tL("/", ...t)})`, ide = t => {
        const e = q4e(t);
        return e != null && !Number.isNaN(parseFloat(e)) ? String(e).startsWith("-") ? String(e).slice(1) : `-${e}` : dK(e, -1)
    }, ov = Object.assign(t => ({
        add: (...e) => ov(tde(t, ...e)),
        subtract: (...e) => ov(rde(t, ...e)),
        multiply: (...e) => ov(dK(t, ...e)),
        divide: (...e) => ov(nde(t, ...e)),
        negate: () => ov(ide(t)),
        toString: () => t.toString()
    }), {add: tde, subtract: rde, multiply: dK, divide: nde, negate: ide});

function X_t(t) {
    return !Number.isInteger(parseFloat(t.toString()))
}

function Q_t(t, e = "-") {
    return t.replace(/\s+/g, e)
}

function G4e(t) {
    const e = Q_t(t.toString());
    return e.includes("\\.") ? t : X_t(t) ? e.replace(".", "\\.") : t
}

function Z_t(t, e = "") {
    return [e, G4e(t)].filter(Boolean).join("-")
}

function J_t(t, e) {
    return `var(${G4e(t)}${e ? `, ${e}` : ""})`
}

function ext(t, e = "") {
    return `--${Z_t(t, e)}`
}

function js(t, e) {
    const r = ext(t, e == null ? void 0 : e.prefix);
    return {variable: r, reference: J_t(r, txt(e == null ? void 0 : e.fallback))}
}

function txt(t) {
    return typeof t == "string" ? t : t == null ? void 0 : t.reference
}

var {defineMultiStyleConfig: rxt, definePartsStyle: HD} = ka(__t.keys), lC = js("switch-track-width"),
    zw = js("switch-track-height"), OV = js("switch-track-diff"), nxt = ov.subtract(lC, zw), hK = js("switch-thumb-x"),
    iT = js("switch-bg"), ixt = t => {
        const {colorScheme: e} = t;
        return {
            borderRadius: "full",
            p: "0.5",
            width: [lC.reference],
            height: [zw.reference],
            transitionProperty: "common",
            transitionDuration: "fast",
            [iT.variable]: "colors.gray.300",
            _dark: {[iT.variable]: "colors.whiteAlpha.400"},
            _focusVisible: {boxShadow: "outline"},
            _disabled: {opacity: .4, cursor: "not-allowed"},
            _checked: {[iT.variable]: `colors.${e}.500`, _dark: {[iT.variable]: `colors.${e}.200`}},
            bg: iT.reference
        }
    }, axt = {
        bg: "white",
        transitionProperty: "transform",
        transitionDuration: "normal",
        borderRadius: "inherit",
        width: [zw.reference],
        height: [zw.reference],
        _checked: {transform: `translateX(${hK.reference})`}
    }, oxt = HD(t => ({
        container: {
            [OV.variable]: nxt,
            [hK.variable]: OV.reference,
            _rtl: {[hK.variable]: ov(OV).negate().toString()}
        }, track: ixt(t), thumb: axt
    })), sxt = {
        sm: HD({container: {[lC.variable]: "1.375rem", [zw.variable]: "sizes.3"}}),
        md: HD({container: {[lC.variable]: "1.875rem", [zw.variable]: "sizes.4"}}),
        lg: HD({container: {[lC.variable]: "2.875rem", [zw.variable]: "sizes.6"}})
    }, cxt = rxt({
        baseStyle: oxt,
        sizes: sxt,
        defaultProps: {size: "md", colorScheme: "blue"}
    }), {defineMultiStyleConfig: lxt, definePartsStyle: c4} = ka(x_t.keys), uxt = c4({
        table: {fontVariantNumeric: "lining-nums tabular-nums", borderCollapse: "collapse", width: "full"},
        th: {
            fontFamily: "heading",
            fontWeight: "bold",
            textTransform: "uppercase",
            letterSpacing: "wider",
            textAlign: "start"
        },
        td: {textAlign: "start"},
        caption: {mt: 4, fontFamily: "heading", textAlign: "center", fontWeight: "medium"}
    }), DO = {"&[data-is-numeric=true]": {textAlign: "end"}}, fxt = c4(t => {
        const {colorScheme: e} = t;
        return {
            th: {
                color: Zr("gray.600", "gray.400")(t),
                borderBottom: "1px",
                borderColor: Zr(`${e}.100`, `${e}.700`)(t), ...DO
            },
            td: {borderBottom: "1px", borderColor: Zr(`${e}.100`, `${e}.700`)(t), ...DO},
            caption: {color: Zr("gray.600", "gray.100")(t)},
            tfoot: {tr: {"&:last-of-type": {th: {borderBottomWidth: 0}}}}
        }
    }), dxt = c4(t => {
        const {colorScheme: e} = t;
        return {
            th: {
                color: Zr("gray.600", "gray.400")(t),
                borderBottom: "1px",
                borderColor: Zr(`${e}.100`, `${e}.700`)(t), ...DO
            },
            td: {borderBottom: "1px", borderColor: Zr(`${e}.100`, `${e}.700`)(t), ...DO},
            caption: {color: Zr("gray.600", "gray.100")(t)},
            tbody: {
                tr: {
                    "&:nth-of-type(odd)": {
                        "th, td": {
                            borderBottomWidth: "1px",
                            borderColor: Zr(`${e}.100`, `${e}.700`)(t)
                        }, td: {background: Zr(`${e}.100`, `${e}.700`)(t)}
                    }
                }
            },
            tfoot: {tr: {"&:last-of-type": {th: {borderBottomWidth: 0}}}}
        }
    }), hxt = {simple: fxt, striped: dxt, unstyled: {}}, pxt = {
        sm: c4({
            th: {px: "4", py: "1", lineHeight: "4", fontSize: "xs"},
            td: {px: "4", py: "2", fontSize: "sm", lineHeight: "4"},
            caption: {px: "4", py: "2", fontSize: "xs"}
        }),
        md: c4({
            th: {px: "6", py: "3", lineHeight: "4", fontSize: "xs"},
            td: {px: "6", py: "4", lineHeight: "5"},
            caption: {px: "6", py: "2", fontSize: "sm"}
        }),
        lg: c4({
            th: {px: "8", py: "4", lineHeight: "5", fontSize: "sm"},
            td: {px: "8", py: "5", lineHeight: "6"},
            caption: {px: "6", py: "2", fontSize: "md"}
        })
    }, mxt = lxt({
        baseStyle: uxt,
        variants: hxt,
        sizes: pxt,
        defaultProps: {variant: "simple", size: "md", colorScheme: "gray"}
    }), Yu = Kr("tabs-color"), Xh = Kr("tabs-bg"), T7 = Kr("tabs-border-color"), {
        defineMultiStyleConfig: vxt,
        definePartsStyle: N0
    } = ka(E_t.keys), gxt = t => {
        const {orientation: e} = t;
        return {display: e === "vertical" ? "flex" : "block"}
    }, yxt = t => {
        const {isFitted: e} = t;
        return {
            flex: e ? 1 : void 0,
            transitionProperty: "common",
            transitionDuration: "normal",
            _focusVisible: {zIndex: 1, boxShadow: "outline"},
            _disabled: {cursor: "not-allowed", opacity: .4}
        }
    }, bxt = t => {
        const {align: e = "start", orientation: r} = t;
        return {
            justifyContent: {end: "flex-end", center: "center", start: "flex-start"}[e],
            flexDirection: r === "vertical" ? "column" : "row"
        }
    }, wxt = {p: 4}, Sxt = N0(t => ({root: gxt(t), tab: yxt(t), tablist: bxt(t), tabpanel: wxt})), _xt = {
        sm: N0({tab: {py: 1, px: 4, fontSize: "sm"}}),
        md: N0({tab: {fontSize: "md", py: 2, px: 4}}),
        lg: N0({tab: {fontSize: "lg", py: 3, px: 4}})
    }, xxt = N0(t => {
        const {colorScheme: e, orientation: r} = t, n = r === "vertical", i = n ? "borderStart" : "borderBottom",
            a = n ? "marginStart" : "marginBottom";
        return {
            tablist: {[i]: "2px solid", borderColor: "inherit"},
            tab: {
                [i]: "2px solid",
                borderColor: "transparent",
                [a]: "-2px",
                _selected: {
                    [Yu.variable]: `colors.${e}.600`,
                    _dark: {[Yu.variable]: `colors.${e}.300`},
                    borderColor: "currentColor"
                },
                _active: {[Xh.variable]: "colors.gray.200", _dark: {[Xh.variable]: "colors.whiteAlpha.300"}},
                _disabled: {_active: {bg: "none"}},
                color: Yu.reference,
                bg: Xh.reference
            }
        }
    }), Ext = N0(t => {
        const {colorScheme: e} = t;
        return {
            tab: {
                borderTopRadius: "md",
                border: "1px solid",
                borderColor: "transparent",
                mb: "-1px",
                [T7.variable]: "transparent",
                _selected: {
                    [Yu.variable]: `colors.${e}.600`,
                    [T7.variable]: "colors.white",
                    _dark: {[Yu.variable]: `colors.${e}.300`, [T7.variable]: "colors.gray.800"},
                    borderColor: "inherit",
                    borderBottomColor: T7.reference
                },
                color: Yu.reference
            }, tablist: {mb: "-1px", borderBottom: "1px solid", borderColor: "inherit"}
        }
    }), Txt = N0(t => {
        const {colorScheme: e} = t;
        return {
            tab: {
                border: "1px solid",
                borderColor: "inherit",
                [Xh.variable]: "colors.gray.50",
                _dark: {[Xh.variable]: "colors.whiteAlpha.50"},
                mb: "-1px",
                _notLast: {marginEnd: "-1px"},
                _selected: {
                    [Xh.variable]: "colors.white",
                    [Yu.variable]: `colors.${e}.600`,
                    _dark: {[Xh.variable]: "colors.gray.800", [Yu.variable]: `colors.${e}.300`},
                    borderColor: "inherit",
                    borderTopColor: "currentColor",
                    borderBottomColor: "transparent"
                },
                color: Yu.reference,
                bg: Xh.reference
            }, tablist: {mb: "-1px", borderBottom: "1px solid", borderColor: "inherit"}
        }
    }), Cxt = N0(t => {
        const {colorScheme: e, theme: r} = t;
        return {
            tab: {
                borderRadius: "full",
                fontWeight: "semibold",
                color: "gray.600",
                _selected: {color: su(r, `${e}.700`), bg: su(r, `${e}.100`)}
            }
        }
    }), Axt = N0(t => {
        const {colorScheme: e} = t;
        return {
            tab: {
                borderRadius: "full",
                fontWeight: "semibold",
                [Yu.variable]: "colors.gray.600",
                _dark: {[Yu.variable]: "inherit"},
                _selected: {
                    [Yu.variable]: "colors.white",
                    [Xh.variable]: `colors.${e}.600`,
                    _dark: {[Yu.variable]: "colors.gray.800", [Xh.variable]: `colors.${e}.300`}
                },
                color: Yu.reference,
                bg: Xh.reference
            }
        }
    }), Ixt = N0({}),
    kxt = {line: xxt, enclosed: Ext, "enclosed-colored": Txt, "soft-rounded": Cxt, "solid-rounded": Axt, unstyled: Ixt},
    Rxt = vxt({
        baseStyle: Sxt,
        sizes: _xt,
        variants: kxt,
        defaultProps: {size: "md", variant: "line", colorScheme: "blue"}
    }), Ho = XSt("badge", ["bg", "color", "shadow"]), Dxt = {
        px: 1,
        textTransform: "uppercase",
        fontSize: "xs",
        borderRadius: "sm",
        fontWeight: "bold",
        bg: Ho.bg.reference,
        color: Ho.color.reference,
        boxShadow: Ho.shadow.reference
    }, Mxt = t => {
        const {colorScheme: e, theme: r} = t, n = eE(`${e}.500`, .6)(r);
        return {
            [Ho.bg.variable]: `colors.${e}.500`,
            [Ho.color.variable]: "colors.white",
            _dark: {[Ho.bg.variable]: n, [Ho.color.variable]: "colors.whiteAlpha.800"}
        }
    }, Oxt = t => {
        const {colorScheme: e, theme: r} = t, n = eE(`${e}.200`, .16)(r);
        return {
            [Ho.bg.variable]: `colors.${e}.100`,
            [Ho.color.variable]: `colors.${e}.800`,
            _dark: {[Ho.bg.variable]: n, [Ho.color.variable]: `colors.${e}.200`}
        }
    }, Pxt = t => {
        const {colorScheme: e, theme: r} = t, n = eE(`${e}.200`, .8)(r);
        return {
            [Ho.color.variable]: `colors.${e}.500`,
            _dark: {[Ho.color.variable]: n},
            [Ho.shadow.variable]: `inset 0 0 0px 1px ${Ho.color.reference}`
        }
    }, Nxt = {solid: Mxt, subtle: Oxt, outline: Pxt}, uC = {
        baseStyle: Dxt,
        variants: Nxt,
        defaultProps: {variant: "subtle", colorScheme: "gray"}
    }, {defineMultiStyleConfig: Lxt, definePartsStyle: Vw} = ka(T_t.keys), ade = Kr("tag-bg"), ode = Kr("tag-color"),
    PV = Kr("tag-shadow"), WD = Kr("tag-min-height"), qD = Kr("tag-min-width"), GD = Kr("tag-font-size"),
    KD = Kr("tag-padding-inline"), Bxt = {
        fontWeight: "medium",
        lineHeight: 1.2,
        outline: 0,
        [ode.variable]: Ho.color.reference,
        [ade.variable]: Ho.bg.reference,
        [PV.variable]: Ho.shadow.reference,
        color: ode.reference,
        bg: ade.reference,
        boxShadow: PV.reference,
        borderRadius: "md",
        minH: WD.reference,
        minW: qD.reference,
        fontSize: GD.reference,
        px: KD.reference,
        _focusVisible: {[PV.variable]: "shadows.outline"}
    }, $xt = {lineHeight: 1.2, overflow: "visible"}, Fxt = {
        fontSize: "lg",
        w: "5",
        h: "5",
        transitionProperty: "common",
        transitionDuration: "normal",
        borderRadius: "full",
        marginStart: "1.5",
        marginEnd: "-1",
        opacity: .5,
        _disabled: {opacity: .4},
        _focusVisible: {boxShadow: "outline", bg: "rgba(0, 0, 0, 0.14)"},
        _hover: {opacity: .8},
        _active: {opacity: 1}
    }, Uxt = Vw({container: Bxt, label: $xt, closeButton: Fxt}), jxt = {
        sm: Vw({
            container: {
                [WD.variable]: "sizes.5",
                [qD.variable]: "sizes.5",
                [GD.variable]: "fontSizes.xs",
                [KD.variable]: "space.2"
            }, closeButton: {marginEnd: "-2px", marginStart: "0.35rem"}
        }),
        md: Vw({
            container: {
                [WD.variable]: "sizes.6",
                [qD.variable]: "sizes.6",
                [GD.variable]: "fontSizes.sm",
                [KD.variable]: "space.2"
            }
        }),
        lg: Vw({
            container: {
                [WD.variable]: "sizes.8",
                [qD.variable]: "sizes.8",
                [GD.variable]: "fontSizes.md",
                [KD.variable]: "space.3"
            }
        })
    }, zxt = {
        subtle: Vw(t => {
            var e;
            return {container: (e = uC.variants) == null ? void 0 : e.subtle(t)}
        }), solid: Vw(t => {
            var e;
            return {container: (e = uC.variants) == null ? void 0 : e.solid(t)}
        }), outline: Vw(t => {
            var e;
            return {container: (e = uC.variants) == null ? void 0 : e.outline(t)}
        })
    }, Vxt = Lxt({
        variants: zxt,
        baseStyle: Uxt,
        sizes: jxt,
        defaultProps: {size: "md", variant: "subtle", colorScheme: "gray"}
    }), {definePartsStyle: hv, defineMultiStyleConfig: Hxt} = ka(f_t.keys), Ox = Kr("input-height"),
    Px = Kr("input-font-size"), Nx = Kr("input-padding"), Lx = Kr("input-border-radius"), Wxt = hv({
        addon: {height: Ox.reference, fontSize: Px.reference, px: Nx.reference, borderRadius: Lx.reference},
        field: {
            width: "100%",
            height: Ox.reference,
            fontSize: Px.reference,
            px: Nx.reference,
            borderRadius: Lx.reference,
            minWidth: 0,
            outline: 0,
            position: "relative",
            appearance: "none",
            transitionProperty: "common",
            transitionDuration: "normal",
            _disabled: {opacity: .4, cursor: "not-allowed"}
        }
    }), ly = {
        lg: {
            [Px.variable]: "fontSizes.lg",
            [Nx.variable]: "space.4",
            [Lx.variable]: "radii.md",
            [Ox.variable]: "sizes.12"
        },
        md: {[Px.variable]: "fontSizes.md", [Nx.variable]: "space.4", [Lx.variable]: "radii.md", [Ox.variable]: "sizes.10"},
        sm: {[Px.variable]: "fontSizes.sm", [Nx.variable]: "space.3", [Lx.variable]: "radii.sm", [Ox.variable]: "sizes.8"},
        xs: {[Px.variable]: "fontSizes.xs", [Nx.variable]: "space.2", [Lx.variable]: "radii.sm", [Ox.variable]: "sizes.6"}
    }, qxt = {
        lg: hv({field: ly.lg, group: ly.lg}),
        md: hv({field: ly.md, group: ly.md}),
        sm: hv({field: ly.sm, group: ly.sm}),
        xs: hv({field: ly.xs, group: ly.xs})
    };

function sJ(t) {
    const {focusBorderColor: e, errorBorderColor: r} = t;
    return {focusBorderColor: e || Zr("blue.500", "blue.300")(t), errorBorderColor: r || Zr("red.500", "red.300")(t)}
}

var Gxt = hv(t => {
        const {theme: e} = t, {focusBorderColor: r, errorBorderColor: n} = sJ(t);
        return {
            field: {
                border: "1px solid",
                borderColor: "inherit",
                bg: "inherit",
                _hover: {borderColor: Zr("gray.300", "whiteAlpha.400")(t)},
                _readOnly: {boxShadow: "none !important", userSelect: "all"},
                _invalid: {borderColor: su(e, n), boxShadow: `0 0 0 1px ${su(e, n)}`},
                _focusVisible: {zIndex: 1, borderColor: su(e, r), boxShadow: `0 0 0 1px ${su(e, r)}`}
            },
            addon: {
                border: "1px solid",
                borderColor: Zr("inherit", "whiteAlpha.50")(t),
                bg: Zr("gray.100", "whiteAlpha.300")(t)
            }
        }
    }), Kxt = hv(t => {
        const {theme: e} = t, {focusBorderColor: r, errorBorderColor: n} = sJ(t);
        return {
            field: {
                border: "2px solid",
                borderColor: "transparent",
                bg: Zr("gray.100", "whiteAlpha.50")(t),
                _hover: {bg: Zr("gray.200", "whiteAlpha.100")(t)},
                _readOnly: {boxShadow: "none !important", userSelect: "all"},
                _invalid: {borderColor: su(e, n)},
                _focusVisible: {bg: "transparent", borderColor: su(e, r)}
            }, addon: {border: "2px solid", borderColor: "transparent", bg: Zr("gray.100", "whiteAlpha.50")(t)}
        }
    }), Yxt = hv(t => {
        const {theme: e} = t, {focusBorderColor: r, errorBorderColor: n} = sJ(t);
        return {
            field: {
                borderBottom: "1px solid",
                borderColor: "inherit",
                borderRadius: "0",
                px: "0",
                bg: "transparent",
                _readOnly: {boxShadow: "none !important", userSelect: "all"},
                _invalid: {borderColor: su(e, n), boxShadow: `0px 1px 0px 0px ${su(e, n)}`},
                _focusVisible: {borderColor: su(e, r), boxShadow: `0px 1px 0px 0px ${su(e, r)}`}
            }, addon: {borderBottom: "2px solid", borderColor: "inherit", borderRadius: "0", px: "0", bg: "transparent"}
        }
    }), Xxt = hv({
        field: {bg: "transparent", px: "0", height: "auto"},
        addon: {bg: "transparent", px: "0", height: "auto"}
    }), Qxt = {outline: Gxt, filled: Kxt, flushed: Yxt, unstyled: Xxt},
    Hi = Hxt({baseStyle: Wxt, sizes: qxt, variants: Qxt, defaultProps: {size: "md", variant: "outline"}}), sde, Zxt = {
        ...(sde = Hi.baseStyle) == null ? void 0 : sde.field,
        paddingY: "2",
        minHeight: "20",
        lineHeight: "short",
        verticalAlign: "top"
    }, cde, lde, Jxt = {
        outline: t => {
            var e, r;
            return (r = (e = Hi.variants) == null ? void 0 : e.outline(t).field) != null ? r : {}
        }, flushed: t => {
            var e, r;
            return (r = (e = Hi.variants) == null ? void 0 : e.flushed(t).field) != null ? r : {}
        }, filled: t => {
            var e, r;
            return (r = (e = Hi.variants) == null ? void 0 : e.filled(t).field) != null ? r : {}
        }, unstyled: (lde = (cde = Hi.variants) == null ? void 0 : cde.unstyled.field) != null ? lde : {}
    }, ude, fde, dde, hde, pde, mde, vde, gde, e4t = {
        xs: (fde = (ude = Hi.sizes) == null ? void 0 : ude.xs.field) != null ? fde : {},
        sm: (hde = (dde = Hi.sizes) == null ? void 0 : dde.sm.field) != null ? hde : {},
        md: (mde = (pde = Hi.sizes) == null ? void 0 : pde.md.field) != null ? mde : {},
        lg: (gde = (vde = Hi.sizes) == null ? void 0 : vde.lg.field) != null ? gde : {}
    }, t4t = {baseStyle: Zxt, sizes: e4t, variants: Jxt, defaultProps: {size: "md", variant: "outline"}},
    C7 = js("tooltip-bg"), NV = js("tooltip-fg"), r4t = js("popper-arrow-bg"), n4t = {
        bg: C7.reference,
        color: NV.reference,
        [C7.variable]: "colors.gray.700",
        [NV.variable]: "colors.whiteAlpha.900",
        _dark: {[C7.variable]: "colors.gray.300", [NV.variable]: "colors.gray.900"},
        [r4t.variable]: C7.reference,
        px: "2",
        py: "0.5",
        borderRadius: "sm",
        fontWeight: "medium",
        fontSize: "sm",
        boxShadow: "md",
        maxW: "xs",
        zIndex: "tooltip"
    }, i4t = {baseStyle: n4t}, {defineMultiStyleConfig: a4t, definePartsStyle: LT} = ka(g_t.keys), o4t = t => {
        const {colorScheme: e, theme: r, isIndeterminate: n, hasStripe: i} = t,
            a = Zr(ede(), ede("1rem", "rgba(0,0,0,0.1)"))(t), o = Zr(`${e}.500`, `${e}.200`)(t), s = `linear-gradient(
    to right,
    transparent 0%,
    ${su(r, o)} 50%,
    transparent 100%
  )`;
        return {...!n && i && a, ...n ? {bgImage: s} : {bgColor: o}}
    }, s4t = {lineHeight: "1", fontSize: "0.25em", fontWeight: "bold", color: "white"},
    c4t = t => ({bg: Zr("gray.100", "whiteAlpha.300")(t)}),
    l4t = t => ({transitionProperty: "common", transitionDuration: "slow", ...o4t(t)}),
    u4t = LT(t => ({label: s4t, filledTrack: l4t(t), track: c4t(t)})),
    f4t = {xs: LT({track: {h: "1"}}), sm: LT({track: {h: "2"}}), md: LT({track: {h: "3"}}), lg: LT({track: {h: "4"}})},
    d4t = a4t({sizes: f4t, baseStyle: u4t, defaultProps: {size: "md", colorScheme: "blue"}}),
    h4t = t => typeof t == "function";

function uu(t, ...e) {
    return h4t(t) ? t(...e) : t
}

var {definePartsStyle: YD, defineMultiStyleConfig: p4t} = ka(o_t.keys), fC = Kr("checkbox-size"), m4t = t => {
        const {colorScheme: e} = t;
        return {
            w: fC.reference,
            h: fC.reference,
            transitionProperty: "box-shadow",
            transitionDuration: "normal",
            border: "2px solid",
            borderRadius: "sm",
            borderColor: "inherit",
            color: "white",
            _checked: {
                bg: Zr(`${e}.500`, `${e}.200`)(t),
                borderColor: Zr(`${e}.500`, `${e}.200`)(t),
                color: Zr("white", "gray.900")(t),
                _hover: {bg: Zr(`${e}.600`, `${e}.300`)(t), borderColor: Zr(`${e}.600`, `${e}.300`)(t)},
                _disabled: {
                    borderColor: Zr("gray.200", "transparent")(t),
                    bg: Zr("gray.200", "whiteAlpha.300")(t),
                    color: Zr("gray.500", "whiteAlpha.500")(t)
                }
            },
            _indeterminate: {
                bg: Zr(`${e}.500`, `${e}.200`)(t),
                borderColor: Zr(`${e}.500`, `${e}.200`)(t),
                color: Zr("white", "gray.900")(t)
            },
            _disabled: {bg: Zr("gray.100", "whiteAlpha.100")(t), borderColor: Zr("gray.100", "transparent")(t)},
            _focusVisible: {boxShadow: "outline"},
            _invalid: {borderColor: Zr("red.500", "red.300")(t)}
        }
    }, v4t = {_disabled: {cursor: "not-allowed"}}, g4t = {userSelect: "none", _disabled: {opacity: .4}},
    y4t = {transitionProperty: "transform", transitionDuration: "normal"},
    b4t = YD(t => ({icon: y4t, container: v4t, control: uu(m4t, t), label: g4t})), w4t = {
        sm: YD({control: {[fC.variable]: "sizes.3"}, label: {fontSize: "sm"}, icon: {fontSize: "3xs"}}),
        md: YD({control: {[fC.variable]: "sizes.4"}, label: {fontSize: "md"}, icon: {fontSize: "2xs"}}),
        lg: YD({control: {[fC.variable]: "sizes.5"}, label: {fontSize: "lg"}, icon: {fontSize: "2xs"}})
    }, MO = p4t({
        baseStyle: b4t,
        sizes: w4t,
        defaultProps: {size: "md", colorScheme: "blue"}
    }), {defineMultiStyleConfig: S4t, definePartsStyle: XD} = ka(y_t.keys), _4t = t => {
        var e;
        const r = (e = uu(MO.baseStyle, t)) == null ? void 0 : e.control;
        return {
            ...r,
            borderRadius: "full",
            _checked: {
                ...r == null ? void 0 : r._checked,
                _before: {
                    content: '""',
                    display: "inline-block",
                    pos: "relative",
                    w: "50%",
                    h: "50%",
                    borderRadius: "50%",
                    bg: "currentColor"
                }
            }
        }
    }, x4t = XD(t => {
        var e, r, n, i;
        return {
            label: (r = (e = MO).baseStyle) == null ? void 0 : r.call(e, t).label,
            container: (i = (n = MO).baseStyle) == null ? void 0 : i.call(n, t).container,
            control: _4t(t)
        }
    }), E4t = {
        md: XD({control: {w: "4", h: "4"}, label: {fontSize: "md"}}),
        lg: XD({control: {w: "5", h: "5"}, label: {fontSize: "lg"}}),
        sm: XD({control: {width: "3", height: "3"}, label: {fontSize: "sm"}})
    }, T4t = S4t({
        baseStyle: x4t,
        sizes: E4t,
        defaultProps: {size: "md", colorScheme: "blue"}
    }), {defineMultiStyleConfig: C4t, definePartsStyle: A4t} = ka(b_t.keys), A7 = Kr("select-bg"), yde, I4t = {
        ...(yde = Hi.baseStyle) == null ? void 0 : yde.field,
        appearance: "none",
        paddingBottom: "1px",
        lineHeight: "normal",
        bg: A7.reference,
        [A7.variable]: "colors.white",
        _dark: {[A7.variable]: "colors.gray.700"},
        "> option, > optgroup": {bg: A7.reference}
    }, k4t = {
        width: "6",
        height: "100%",
        insetEnd: "2",
        position: "relative",
        color: "currentColor",
        fontSize: "xl",
        _disabled: {opacity: .5}
    }, R4t = A4t({field: I4t, icon: k4t}), I7 = {paddingInlineEnd: "8"}, bde, wde, Sde, _de, xde, Ede, Tde, Cde, D4t = {
        lg: {
            ...(bde = Hi.sizes) == null ? void 0 : bde.lg,
            field: {...(wde = Hi.sizes) == null ? void 0 : wde.lg.field, ...I7}
        },
        md: {
            ...(Sde = Hi.sizes) == null ? void 0 : Sde.md,
            field: {...(_de = Hi.sizes) == null ? void 0 : _de.md.field, ...I7}
        },
        sm: {
            ...(xde = Hi.sizes) == null ? void 0 : xde.sm,
            field: {...(Ede = Hi.sizes) == null ? void 0 : Ede.sm.field, ...I7}
        },
        xs: {
            ...(Tde = Hi.sizes) == null ? void 0 : Tde.xs,
            field: {...(Cde = Hi.sizes) == null ? void 0 : Cde.xs.field, ...I7},
            icon: {insetEnd: "1"}
        }
    }, M4t = C4t({baseStyle: R4t, sizes: D4t, variants: Hi.variants, defaultProps: Hi.defaultProps}),
    LV = Kr("skeleton-start-color"), BV = Kr("skeleton-end-color"), O4t = {
        [LV.variable]: "colors.gray.100",
        [BV.variable]: "colors.gray.400",
        _dark: {[LV.variable]: "colors.gray.800", [BV.variable]: "colors.gray.600"},
        background: LV.reference,
        borderColor: BV.reference,
        opacity: .7,
        borderRadius: "sm"
    }, P4t = {baseStyle: O4t}, $V = Kr("skip-link-bg"), N4t = {
        borderRadius: "md",
        fontWeight: "semibold",
        _focusVisible: {
            boxShadow: "outline",
            padding: "4",
            position: "fixed",
            top: "6",
            insetStart: "6",
            [$V.variable]: "colors.white",
            _dark: {[$V.variable]: "colors.gray.700"},
            bg: $V.reference
        }
    }, L4t = {baseStyle: N4t}, {defineMultiStyleConfig: B4t, definePartsStyle: rL} = ka(w_t.keys),
    AA = Kr("slider-thumb-size"), IA = Kr("slider-track-size"), _y = Kr("slider-bg"), $4t = t => {
        const {orientation: e} = t;
        return {
            display: "inline-block",
            position: "relative",
            cursor: "pointer",
            _disabled: {opacity: .6, cursor: "default", pointerEvents: "none"}, ...oJ({
                orientation: e,
                vertical: {h: "100%"},
                horizontal: {w: "100%"}
            })
        }
    }, F4t = t => ({
        ...oJ({orientation: t.orientation, horizontal: {h: IA.reference}, vertical: {w: IA.reference}}),
        overflow: "hidden",
        borderRadius: "sm",
        [_y.variable]: "colors.gray.200",
        _dark: {[_y.variable]: "colors.whiteAlpha.200"},
        _disabled: {[_y.variable]: "colors.gray.300", _dark: {[_y.variable]: "colors.whiteAlpha.300"}},
        bg: _y.reference
    }), U4t = t => {
        const {orientation: e} = t;
        return {
            ...oJ({
                orientation: e,
                vertical: {
                    left: "50%",
                    transform: "translateX(-50%)",
                    _active: {transform: "translateX(-50%) scale(1.15)"}
                },
                horizontal: {
                    top: "50%",
                    transform: "translateY(-50%)",
                    _active: {transform: "translateY(-50%) scale(1.15)"}
                }
            }),
            w: AA.reference,
            h: AA.reference,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "absolute",
            outline: 0,
            zIndex: 1,
            borderRadius: "full",
            bg: "white",
            boxShadow: "base",
            border: "1px solid",
            borderColor: "transparent",
            transitionProperty: "transform",
            transitionDuration: "normal",
            _focusVisible: {boxShadow: "outline"},
            _disabled: {bg: "gray.300"}
        }
    }, j4t = t => {
        const {colorScheme: e} = t;
        return {
            width: "inherit",
            height: "inherit",
            [_y.variable]: `colors.${e}.500`,
            _dark: {[_y.variable]: `colors.${e}.200`},
            bg: _y.reference
        }
    }, z4t = rL(t => ({container: $4t(t), track: F4t(t), thumb: U4t(t), filledTrack: j4t(t)})),
    V4t = rL({container: {[AA.variable]: "sizes.4", [IA.variable]: "sizes.1"}}),
    H4t = rL({container: {[AA.variable]: "sizes.3.5", [IA.variable]: "sizes.1"}}),
    W4t = rL({container: {[AA.variable]: "sizes.2.5", [IA.variable]: "sizes.0.5"}}), q4t = {lg: V4t, md: H4t, sm: W4t},
    G4t = B4t({baseStyle: z4t, sizes: q4t, defaultProps: {size: "md", colorScheme: "blue"}}), vw = js("spinner-size"),
    K4t = {width: [vw.reference], height: [vw.reference]}, Y4t = {
        xs: {[vw.variable]: "sizes.3"},
        sm: {[vw.variable]: "sizes.4"},
        md: {[vw.variable]: "sizes.6"},
        lg: {[vw.variable]: "sizes.8"},
        xl: {[vw.variable]: "sizes.12"}
    }, X4t = {baseStyle: K4t, sizes: Y4t, defaultProps: {size: "md"}}, {
        defineMultiStyleConfig: Q4t,
        definePartsStyle: K4e
    } = ka(S_t.keys), Z4t = {fontWeight: "medium"}, J4t = {opacity: .8, marginBottom: "2"},
    eEt = {verticalAlign: "baseline", fontWeight: "semibold"},
    tEt = {marginEnd: 1, w: "3.5", h: "3.5", verticalAlign: "middle"},
    rEt = K4e({container: {}, label: Z4t, helpText: J4t, number: eEt, icon: tEt}),
    nEt = {md: K4e({label: {fontSize: "sm"}, helpText: {fontSize: "sm"}, number: {fontSize: "2xl"}})},
    iEt = Q4t({baseStyle: rEt, sizes: nEt, defaultProps: {size: "md"}}), FV = Kr("kbd-bg"), aEt = {
        [FV.variable]: "colors.gray.100",
        _dark: {[FV.variable]: "colors.whiteAlpha.100"},
        bg: FV.reference,
        borderRadius: "md",
        borderWidth: "1px",
        borderBottomWidth: "3px",
        fontSize: "0.8em",
        fontWeight: "bold",
        lineHeight: "normal",
        px: "0.4em",
        whiteSpace: "nowrap"
    }, oEt = {baseStyle: aEt}, sEt = {
        transitionProperty: "common",
        transitionDuration: "fast",
        transitionTimingFunction: "ease-out",
        cursor: "pointer",
        textDecoration: "none",
        outline: "none",
        color: "inherit",
        _hover: {textDecoration: "underline"},
        _focusVisible: {boxShadow: "outline"}
    }, cEt = {baseStyle: sEt}, {defineMultiStyleConfig: lEt, definePartsStyle: uEt} = ka(d_t.keys),
    fEt = {marginEnd: "2", display: "inline", verticalAlign: "text-bottom"}, dEt = uEt({icon: fEt}),
    hEt = lEt({baseStyle: dEt}), {defineMultiStyleConfig: pEt, definePartsStyle: mEt} = ka(h_t.keys),
    v0 = Kr("menu-bg"), UV = Kr("menu-shadow"), vEt = {
        [v0.variable]: "#fff",
        [UV.variable]: "shadows.sm",
        _dark: {[v0.variable]: "colors.gray.700", [UV.variable]: "shadows.dark-lg"},
        color: "inherit",
        minW: "3xs",
        py: "2",
        zIndex: 1,
        borderRadius: "md",
        borderWidth: "1px",
        bg: v0.reference,
        boxShadow: UV.reference
    }, gEt = {
        py: "1.5",
        px: "3",
        transitionProperty: "background",
        transitionDuration: "ultra-fast",
        transitionTimingFunction: "ease-in",
        _focus: {[v0.variable]: "colors.gray.100", _dark: {[v0.variable]: "colors.whiteAlpha.100"}},
        _active: {[v0.variable]: "colors.gray.200", _dark: {[v0.variable]: "colors.whiteAlpha.200"}},
        _expanded: {[v0.variable]: "colors.gray.100", _dark: {[v0.variable]: "colors.whiteAlpha.100"}},
        _disabled: {opacity: .4, cursor: "not-allowed"},
        bg: v0.reference
    }, yEt = {mx: 4, my: 2, fontWeight: "semibold", fontSize: "sm"},
    bEt = {display: "inline-flex", alignItems: "center", justifyContent: "center", flexShrink: 0}, wEt = {opacity: .6},
    SEt = {border: 0, borderBottom: "1px solid", borderColor: "inherit", my: "2", opacity: .6},
    _Et = {transitionProperty: "common", transitionDuration: "normal"},
    xEt = mEt({button: _Et, list: vEt, item: gEt, groupTitle: yEt, icon: bEt, command: wEt, divider: SEt}),
    EEt = pEt({baseStyle: xEt}), {defineMultiStyleConfig: TEt, definePartsStyle: pK} = ka(p_t.keys),
    jV = Kr("modal-bg"), zV = Kr("modal-shadow"), CEt = {bg: "blackAlpha.600", zIndex: "modal"}, AEt = t => {
        const {isCentered: e, scrollBehavior: r} = t;
        return {
            display: "flex",
            zIndex: "modal",
            justifyContent: "center",
            alignItems: e ? "center" : "flex-start",
            overflow: r === "inside" ? "hidden" : "auto",
            overscrollBehaviorY: "none"
        }
    }, IEt = t => {
        const {isCentered: e, scrollBehavior: r} = t;
        return {
            borderRadius: "md",
            color: "inherit",
            my: e ? "auto" : "16",
            mx: e ? "auto" : void 0,
            zIndex: "modal",
            maxH: r === "inside" ? "calc(100% - 7.5rem)" : void 0,
            [jV.variable]: "colors.white",
            [zV.variable]: "shadows.lg",
            _dark: {[jV.variable]: "colors.gray.700", [zV.variable]: "shadows.dark-lg"},
            bg: jV.reference,
            boxShadow: zV.reference
        }
    }, kEt = {px: "6", py: "4", fontSize: "xl", fontWeight: "semibold"},
    REt = {position: "absolute", top: "2", insetEnd: "3"}, DEt = t => {
        const {scrollBehavior: e} = t;
        return {px: "6", py: "2", flex: "1", overflow: e === "inside" ? "auto" : void 0}
    }, MEt = {px: "6", py: "4"}, OEt = pK(t => ({
        overlay: CEt,
        dialogContainer: uu(AEt, t),
        dialog: uu(IEt, t),
        header: kEt,
        closeButton: REt,
        body: uu(DEt, t),
        footer: MEt
    }));

function zh(t) {
    return pK(t === "full" ? {
        dialog: {
            maxW: "100vw",
            minH: "$100vh",
            my: "0",
            borderRadius: "0"
        }
    } : {dialog: {maxW: t}})
}

var PEt = {
        xs: zh("xs"),
        sm: zh("sm"),
        md: zh("md"),
        lg: zh("lg"),
        xl: zh("xl"),
        "2xl": zh("2xl"),
        "3xl": zh("3xl"),
        "4xl": zh("4xl"),
        "5xl": zh("5xl"),
        "6xl": zh("6xl"),
        full: zh("full")
    }, NEt = TEt({baseStyle: OEt, sizes: PEt, defaultProps: {size: "md"}}), {
        defineMultiStyleConfig: LEt,
        definePartsStyle: Y4e
    } = ka(m_t.keys), cJ = js("number-input-stepper-width"), X4e = js("number-input-input-padding"),
    BEt = ov(cJ).add("0.5rem").toString(), VV = js("number-input-bg"), HV = js("number-input-color"),
    WV = js("number-input-border-color"), $Et = {[cJ.variable]: "sizes.6", [X4e.variable]: BEt}, FEt = t => {
        var e, r;
        return (r = (e = uu(Hi.baseStyle, t)) == null ? void 0 : e.field) != null ? r : {}
    }, UEt = {width: cJ.reference}, jEt = {
        borderStart: "1px solid",
        borderStartColor: WV.reference,
        color: HV.reference,
        bg: VV.reference,
        [HV.variable]: "colors.chakra-body-text",
        [WV.variable]: "colors.chakra-border-color",
        _dark: {[HV.variable]: "colors.whiteAlpha.800", [WV.variable]: "colors.whiteAlpha.300"},
        _active: {[VV.variable]: "colors.gray.200", _dark: {[VV.variable]: "colors.whiteAlpha.300"}},
        _disabled: {opacity: .4, cursor: "not-allowed"}
    }, zEt = Y4e(t => {
        var e;
        return {root: $Et, field: (e = uu(FEt, t)) != null ? e : {}, stepperGroup: UEt, stepper: jEt}
    });

function k7(t) {
    var e, r, n;
    const i = (e = Hi.sizes) == null ? void 0 : e[t], a = {lg: "md", md: "md", sm: "sm", xs: "sm"},
        o = (n = (r = i.field) == null ? void 0 : r.fontSize) != null ? n : "md", s = V4e.fontSizes[o];
    return Y4e({
        field: {...i.field, paddingInlineEnd: X4e.reference, verticalAlign: "top"},
        stepper: {
            fontSize: ov(s).multiply(.75).toString(),
            _first: {borderTopEndRadius: a[t]},
            _last: {borderBottomEndRadius: a[t], mt: "-1px", borderTopWidth: 1}
        }
    })
}

var VEt = {xs: k7("xs"), sm: k7("sm"), md: k7("md"), lg: k7("lg")},
    HEt = LEt({baseStyle: zEt, sizes: VEt, variants: Hi.variants, defaultProps: Hi.defaultProps}), Ade,
    WEt = {...(Ade = Hi.baseStyle) == null ? void 0 : Ade.field, textAlign: "center"}, qEt = {
        lg: {fontSize: "lg", w: 12, h: 12, borderRadius: "md"},
        md: {fontSize: "md", w: 10, h: 10, borderRadius: "md"},
        sm: {fontSize: "sm", w: 8, h: 8, borderRadius: "sm"},
        xs: {fontSize: "xs", w: 6, h: 6, borderRadius: "sm"}
    }, Ide, kde, GEt = {
        outline: t => {
            var e, r, n;
            return (n = (r = uu((e = Hi.variants) == null ? void 0 : e.outline, t)) == null ? void 0 : r.field) != null ? n : {}
        }, flushed: t => {
            var e, r, n;
            return (n = (r = uu((e = Hi.variants) == null ? void 0 : e.flushed, t)) == null ? void 0 : r.field) != null ? n : {}
        }, filled: t => {
            var e, r, n;
            return (n = (r = uu((e = Hi.variants) == null ? void 0 : e.filled, t)) == null ? void 0 : r.field) != null ? n : {}
        }, unstyled: (kde = (Ide = Hi.variants) == null ? void 0 : Ide.unstyled.field) != null ? kde : {}
    }, KEt = {baseStyle: WEt, sizes: qEt, variants: GEt, defaultProps: Hi.defaultProps}, {
        defineMultiStyleConfig: YEt,
        definePartsStyle: XEt
    } = ka(v_t.keys), R7 = js("popper-bg"), QEt = js("popper-arrow-bg"), Rde = js("popper-arrow-shadow-color"),
    ZEt = {zIndex: 10}, JEt = {
        [R7.variable]: "colors.white",
        bg: R7.reference,
        [QEt.variable]: R7.reference,
        [Rde.variable]: "colors.gray.200",
        _dark: {[R7.variable]: "colors.gray.700", [Rde.variable]: "colors.whiteAlpha.300"},
        width: "xs",
        border: "1px solid",
        borderColor: "inherit",
        borderRadius: "md",
        boxShadow: "sm",
        zIndex: "inherit",
        _focusVisible: {outline: 0, boxShadow: "outline"}
    }, e3t = {px: 3, py: 2, borderBottomWidth: "1px"}, t3t = {px: 3, py: 2}, r3t = {px: 3, py: 2, borderTopWidth: "1px"},
    n3t = {position: "absolute", borderRadius: "md", top: 1, insetEnd: 2, padding: 2},
    i3t = XEt({popper: ZEt, content: JEt, header: e3t, body: t3t, footer: r3t, closeButton: n3t}),
    a3t = YEt({baseStyle: i3t}), {definePartsStyle: mK, defineMultiStyleConfig: o3t} = ka(s_t.keys),
    qV = Kr("drawer-bg"), GV = Kr("drawer-box-shadow");

function rx(t) {
    return mK(t === "full" ? {dialog: {maxW: "100vw", h: "100vh"}} : {dialog: {maxW: t}})
}

var s3t = {bg: "blackAlpha.600", zIndex: "modal"}, c3t = {display: "flex", zIndex: "modal", justifyContent: "center"},
    l3t = t => {
        const {isFullHeight: e} = t;
        return {
            ...e && {height: "100vh"},
            zIndex: "modal",
            maxH: "100vh",
            color: "inherit",
            [qV.variable]: "colors.white",
            [GV.variable]: "shadows.lg",
            _dark: {[qV.variable]: "colors.gray.700", [GV.variable]: "shadows.dark-lg"},
            bg: qV.reference,
            boxShadow: GV.reference
        }
    }, u3t = {px: "6", py: "4", fontSize: "xl", fontWeight: "semibold"},
    f3t = {position: "absolute", top: "2", insetEnd: "3"}, d3t = {px: "6", py: "2", flex: "1", overflow: "auto"},
    h3t = {px: "6", py: "4"}, p3t = mK(t => ({
        overlay: s3t,
        dialogContainer: c3t,
        dialog: uu(l3t, t),
        header: u3t,
        closeButton: f3t,
        body: d3t,
        footer: h3t
    })), m3t = {xs: rx("xs"), sm: rx("md"), md: rx("lg"), lg: rx("2xl"), xl: rx("4xl"), full: rx("full")},
    v3t = o3t({baseStyle: p3t, sizes: m3t, defaultProps: {size: "xs"}}), {
        definePartsStyle: g3t,
        defineMultiStyleConfig: y3t
    } = ka(c_t.keys), b3t = {borderRadius: "md", py: "1", transitionProperty: "common", transitionDuration: "normal"},
    w3t = {
        borderRadius: "md",
        py: "1",
        transitionProperty: "common",
        transitionDuration: "normal",
        width: "full",
        _focusVisible: {boxShadow: "outline"},
        _placeholder: {opacity: .6}
    }, S3t = {
        borderRadius: "md",
        py: "1",
        transitionProperty: "common",
        transitionDuration: "normal",
        width: "full",
        _focusVisible: {boxShadow: "outline"},
        _placeholder: {opacity: .6}
    }, _3t = g3t({preview: b3t, input: w3t, textarea: S3t}), x3t = y3t({baseStyle: _3t}), {
        definePartsStyle: E3t,
        defineMultiStyleConfig: T3t
    } = ka(l_t.keys), l4 = Kr("form-control-color"), C3t = {
        marginStart: "1",
        [l4.variable]: "colors.red.500",
        _dark: {[l4.variable]: "colors.red.300"},
        color: l4.reference
    }, A3t = {
        mt: "2",
        [l4.variable]: "colors.gray.600",
        _dark: {[l4.variable]: "colors.whiteAlpha.600"},
        color: l4.reference,
        lineHeight: "normal",
        fontSize: "sm"
    }, I3t = E3t({container: {width: "100%", position: "relative"}, requiredIndicator: C3t, helperText: A3t}),
    k3t = T3t({baseStyle: I3t}), {definePartsStyle: R3t, defineMultiStyleConfig: D3t} = ka(u_t.keys),
    u4 = Kr("form-error-color"), M3t = {
        [u4.variable]: "colors.red.500",
        _dark: {[u4.variable]: "colors.red.300"},
        color: u4.reference,
        mt: "2",
        fontSize: "sm",
        lineHeight: "normal"
    }, O3t = {
        marginEnd: "0.5em",
        [u4.variable]: "colors.red.500",
        _dark: {[u4.variable]: "colors.red.300"},
        color: u4.reference
    }, P3t = R3t({text: M3t, icon: O3t}), N3t = D3t({baseStyle: P3t}), L3t = {
        fontSize: "md",
        marginEnd: "3",
        mb: "2",
        fontWeight: "medium",
        transitionProperty: "common",
        transitionDuration: "normal",
        opacity: 1,
        _disabled: {opacity: .4}
    }, B3t = {baseStyle: L3t}, $3t = {fontFamily: "heading", fontWeight: "bold"}, F3t = {
        "4xl": {fontSize: ["6xl", null, "7xl"], lineHeight: 1},
        "3xl": {fontSize: ["5xl", null, "6xl"], lineHeight: 1},
        "2xl": {fontSize: ["4xl", null, "5xl"], lineHeight: [1.2, null, 1]},
        xl: {fontSize: ["3xl", null, "4xl"], lineHeight: [1.33, null, 1.2]},
        lg: {fontSize: ["2xl", null, "3xl"], lineHeight: [1.33, null, 1.2]},
        md: {fontSize: "xl", lineHeight: 1.2},
        sm: {fontSize: "md", lineHeight: 1.2},
        xs: {fontSize: "sm", lineHeight: 1.2}
    }, U3t = {baseStyle: $3t, sizes: F3t, defaultProps: {size: "xl"}}, {
        defineMultiStyleConfig: j3t,
        definePartsStyle: z3t
    } = ka(a_t.keys), KV = Kr("breadcrumb-link-decor"), V3t = {
        transitionProperty: "common",
        transitionDuration: "fast",
        transitionTimingFunction: "ease-out",
        outline: "none",
        color: "inherit",
        textDecoration: KV.reference,
        [KV.variable]: "none",
        "&:not([aria-current=page])": {
            cursor: "pointer",
            _hover: {[KV.variable]: "underline"},
            _focusVisible: {boxShadow: "outline"}
        }
    }, H3t = z3t({link: V3t}), W3t = j3t({baseStyle: H3t}), q3t = {
        lineHeight: "1.2",
        borderRadius: "md",
        fontWeight: "semibold",
        transitionProperty: "common",
        transitionDuration: "normal",
        _focusVisible: {boxShadow: "outline"},
        _disabled: {opacity: .4, cursor: "not-allowed", boxShadow: "none"},
        _hover: {_disabled: {bg: "initial"}}
    }, Q4e = t => {
        const {colorScheme: e, theme: r} = t;
        if (e === "gray") return {
            color: Zr("gray.800", "whiteAlpha.900")(t),
            _hover: {bg: Zr("gray.100", "whiteAlpha.200")(t)},
            _active: {bg: Zr("gray.200", "whiteAlpha.300")(t)}
        };
        const n = eE(`${e}.200`, .12)(r), i = eE(`${e}.200`, .24)(r);
        return {
            color: Zr(`${e}.600`, `${e}.200`)(t),
            bg: "transparent",
            _hover: {bg: Zr(`${e}.50`, n)(t)},
            _active: {bg: Zr(`${e}.100`, i)(t)}
        }
    }, G3t = t => {
        const {colorScheme: e} = t, r = Zr("gray.200", "whiteAlpha.300")(t);
        return {
            border: "1px solid",
            borderColor: e === "gray" ? r : "currentColor",
            ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": {marginEnd: "-1px"},
            ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": {marginBottom: "-1px"}, ...uu(Q4e, t)
        }
    }, K3t = {
        yellow: {bg: "yellow.400", color: "black", hoverBg: "yellow.500", activeBg: "yellow.600"},
        cyan: {bg: "cyan.400", color: "black", hoverBg: "cyan.500", activeBg: "cyan.600"}
    }, Y3t = t => {
        var e;
        const {colorScheme: r} = t;
        if (r === "gray") {
            const l = Zr("gray.100", "whiteAlpha.200")(t);
            return {
                bg: l,
                color: Zr("gray.800", "whiteAlpha.900")(t),
                _hover: {bg: Zr("gray.200", "whiteAlpha.300")(t), _disabled: {bg: l}},
                _active: {bg: Zr("gray.300", "whiteAlpha.400")(t)}
            }
        }
        const {
            bg: n = `${r}.500`,
            color: i = "white",
            hoverBg: a = `${r}.600`,
            activeBg: o = `${r}.700`
        } = (e = K3t[r]) != null ? e : {}, s = Zr(n, `${r}.200`)(t);
        return {
            bg: s,
            color: Zr(i, "gray.800")(t),
            _hover: {bg: Zr(a, `${r}.300`)(t), _disabled: {bg: s}},
            _active: {bg: Zr(o, `${r}.400`)(t)}
        }
    }, X3t = t => {
        const {colorScheme: e} = t;
        return {
            padding: 0,
            height: "auto",
            lineHeight: "normal",
            verticalAlign: "baseline",
            color: Zr(`${e}.500`, `${e}.200`)(t),
            _hover: {textDecoration: "underline", _disabled: {textDecoration: "none"}},
            _active: {color: Zr(`${e}.700`, `${e}.500`)(t)}
        }
    }, Q3t = {bg: "none", color: "inherit", display: "inline", lineHeight: "inherit", m: "0", p: "0"},
    Z3t = {ghost: Q4e, outline: G3t, solid: Y3t, link: X3t, unstyled: Q3t}, J3t = {
        lg: {h: "12", minW: "12", fontSize: "lg", px: "6"},
        md: {h: "10", minW: "10", fontSize: "md", px: "4"},
        sm: {h: "8", minW: "8", fontSize: "sm", px: "3"},
        xs: {h: "6", minW: "6", fontSize: "xs", px: "2"}
    }, e6t = {
        baseStyle: q3t,
        variants: Z3t,
        sizes: J3t,
        defaultProps: {variant: "solid", size: "md", colorScheme: "gray"}
    }, {definePartsStyle: Hw, defineMultiStyleConfig: t6t} = ka(C_t.keys), OO = Kr("card-bg"), xv = Kr("card-padding"),
    Z4e = Kr("card-shadow"), QD = Kr("card-radius"), J4e = Kr("card-border-width", "0"), eEe = Kr("card-border-color"),
    r6t = Hw({
        container: {
            [OO.variable]: "colors.chakra-body-bg",
            backgroundColor: OO.reference,
            boxShadow: Z4e.reference,
            borderRadius: QD.reference,
            color: "chakra-body-text",
            borderWidth: J4e.reference,
            borderColor: eEe.reference
        },
        body: {padding: xv.reference, flex: "1 1 0%"},
        header: {padding: xv.reference},
        footer: {padding: xv.reference}
    }), n6t = {
        sm: Hw({container: {[QD.variable]: "radii.base", [xv.variable]: "space.3"}}),
        md: Hw({container: {[QD.variable]: "radii.md", [xv.variable]: "space.5"}}),
        lg: Hw({container: {[QD.variable]: "radii.xl", [xv.variable]: "space.7"}})
    }, i6t = {
        elevated: Hw({container: {[Z4e.variable]: "shadows.base", _dark: {[OO.variable]: "colors.gray.700"}}}),
        outline: Hw({container: {[J4e.variable]: "1px", [eEe.variable]: "colors.chakra-border-color"}}),
        filled: Hw({container: {[OO.variable]: "colors.chakra-subtle-bg"}}),
        unstyled: {body: {[xv.variable]: 0}, header: {[xv.variable]: 0}, footer: {[xv.variable]: 0}}
    }, a6t = t6t({baseStyle: r6t, variants: i6t, sizes: n6t, defaultProps: {variant: "elevated", size: "md"}}),
    dC = js("close-button-size"), aT = js("close-button-bg"), o6t = {
        w: [dC.reference],
        h: [dC.reference],
        borderRadius: "md",
        transitionProperty: "common",
        transitionDuration: "normal",
        _disabled: {opacity: .4, cursor: "not-allowed", boxShadow: "none"},
        _hover: {[aT.variable]: "colors.blackAlpha.100", _dark: {[aT.variable]: "colors.whiteAlpha.100"}},
        _active: {[aT.variable]: "colors.blackAlpha.200", _dark: {[aT.variable]: "colors.whiteAlpha.200"}},
        _focusVisible: {boxShadow: "outline"},
        bg: aT.reference
    }, s6t = {
        lg: {[dC.variable]: "sizes.10", fontSize: "md"},
        md: {[dC.variable]: "sizes.8", fontSize: "xs"},
        sm: {[dC.variable]: "sizes.6", fontSize: "2xs"}
    }, c6t = {baseStyle: o6t, sizes: s6t, defaultProps: {size: "md"}}, {variants: l6t, defaultProps: u6t} = uC, f6t = {
        fontFamily: "mono",
        fontSize: "sm",
        px: "0.2em",
        borderRadius: "sm",
        bg: Ho.bg.reference,
        color: Ho.color.reference,
        boxShadow: Ho.shadow.reference
    }, d6t = {baseStyle: f6t, variants: l6t, defaultProps: u6t}, h6t = {w: "100%", mx: "auto", maxW: "prose", px: "4"},
    p6t = {baseStyle: h6t}, m6t = {opacity: .6, borderColor: "inherit"}, v6t = {borderStyle: "solid"},
    g6t = {borderStyle: "dashed"}, y6t = {solid: v6t, dashed: g6t},
    b6t = {baseStyle: m6t, variants: y6t, defaultProps: {variant: "solid"}}, {
        definePartsStyle: w6t,
        defineMultiStyleConfig: S6t
    } = ka(r_t.keys), _6t = {borderTopWidth: "1px", borderColor: "inherit", _last: {borderBottomWidth: "1px"}}, x6t = {
        transitionProperty: "common",
        transitionDuration: "normal",
        fontSize: "md",
        _focusVisible: {boxShadow: "outline"},
        _hover: {bg: "blackAlpha.50"},
        _disabled: {opacity: .4, cursor: "not-allowed"},
        px: "4",
        py: "2"
    }, E6t = {pt: "2", px: "4", pb: "5"}, T6t = {fontSize: "1.25em"},
    C6t = w6t({container: _6t, button: x6t, panel: E6t, icon: T6t}), A6t = S6t({baseStyle: C6t}), {
        definePartsStyle: eI,
        defineMultiStyleConfig: I6t
    } = ka(n_t.keys), jf = Kr("alert-fg"), Uv = Kr("alert-bg"), k6t = eI({
        container: {bg: Uv.reference, px: "4", py: "3"},
        title: {fontWeight: "bold", lineHeight: "6", marginEnd: "2"},
        description: {lineHeight: "6"},
        icon: {color: jf.reference, flexShrink: 0, marginEnd: "3", w: "5", h: "6"},
        spinner: {color: jf.reference, flexShrink: 0, marginEnd: "3", w: "5", h: "5"}
    });

function lJ(t) {
    const {theme: e, colorScheme: r} = t, n = eE(`${r}.200`, .16)(e);
    return {light: `colors.${r}.100`, dark: n}
}

var R6t = eI(t => {
        const {colorScheme: e} = t, r = lJ(t);
        return {
            container: {
                [jf.variable]: `colors.${e}.500`,
                [Uv.variable]: r.light,
                _dark: {[jf.variable]: `colors.${e}.200`, [Uv.variable]: r.dark}
            }
        }
    }), D6t = eI(t => {
        const {colorScheme: e} = t, r = lJ(t);
        return {
            container: {
                [jf.variable]: `colors.${e}.500`,
                [Uv.variable]: r.light,
                _dark: {[jf.variable]: `colors.${e}.200`, [Uv.variable]: r.dark},
                paddingStart: "3",
                borderStartWidth: "4px",
                borderStartColor: jf.reference
            }
        }
    }), M6t = eI(t => {
        const {colorScheme: e} = t, r = lJ(t);
        return {
            container: {
                [jf.variable]: `colors.${e}.500`,
                [Uv.variable]: r.light,
                _dark: {[jf.variable]: `colors.${e}.200`, [Uv.variable]: r.dark},
                pt: "2",
                borderTopWidth: "4px",
                borderTopColor: jf.reference
            }
        }
    }), O6t = eI(t => {
        const {colorScheme: e} = t;
        return {
            container: {
                [jf.variable]: "colors.white",
                [Uv.variable]: `colors.${e}.500`,
                _dark: {[jf.variable]: "colors.gray.900", [Uv.variable]: `colors.${e}.200`},
                color: jf.reference
            }
        }
    }), P6t = {subtle: R6t, "left-accent": D6t, "top-accent": M6t, solid: O6t}, N6t = I6t({
        baseStyle: k6t,
        variants: P6t,
        defaultProps: {variant: "subtle", colorScheme: "blue"}
    }), {definePartsStyle: tEe, defineMultiStyleConfig: L6t} = ka(i_t.keys), f4 = Kr("avatar-border-color"),
    hC = Kr("avatar-bg"), kA = Kr("avatar-font-size"), tE = Kr("avatar-size"), B6t = {
        borderRadius: "full",
        border: "0.2em solid",
        borderColor: f4.reference,
        [f4.variable]: "white",
        _dark: {[f4.variable]: "colors.gray.800"}
    }, $6t = {
        bg: hC.reference,
        fontSize: kA.reference,
        width: tE.reference,
        height: tE.reference,
        lineHeight: "1",
        [hC.variable]: "colors.gray.200",
        _dark: {[hC.variable]: "colors.whiteAlpha.400"}
    }, F6t = t => {
        const {name: e, theme: r} = t, n = e ? q_t({string: e}) : "colors.gray.400", i = H_t(n)(r);
        let a = "white";
        return i || (a = "gray.800"), {
            bg: hC.reference,
            fontSize: kA.reference,
            color: a,
            borderColor: f4.reference,
            verticalAlign: "top",
            width: tE.reference,
            height: tE.reference,
            "&:not([data-loaded])": {[hC.variable]: n},
            [f4.variable]: "colors.white",
            _dark: {[f4.variable]: "colors.gray.800"}
        }
    }, U6t = {fontSize: kA.reference, lineHeight: "1"},
    j6t = tEe(t => ({badge: uu(B6t, t), excessLabel: uu($6t, t), container: uu(F6t, t), label: U6t}));

function uy(t) {
    const e = t !== "100%" ? W4e[t] : void 0;
    return tEe({
        container: {[tE.variable]: e ?? t, [kA.variable]: `calc(${e ?? t} / 2.5)`},
        excessLabel: {[tE.variable]: e ?? t, [kA.variable]: `calc(${e ?? t} / 2.5)`}
    })
}

var z6t = {"2xs": uy(4), xs: uy(6), sm: uy(8), md: uy(12), lg: uy(16), xl: uy(24), "2xl": uy(32), full: uy("100%")},
    V6t = L6t({baseStyle: j6t, sizes: z6t, defaultProps: {size: "md"}}), H6t = {
        Accordion: A6t,
        Alert: N6t,
        Avatar: V6t,
        Badge: uC,
        Breadcrumb: W3t,
        Button: e6t,
        Checkbox: MO,
        CloseButton: c6t,
        Code: d6t,
        Container: p6t,
        Divider: b6t,
        Drawer: v3t,
        Editable: x3t,
        Form: k3t,
        FormError: N3t,
        FormLabel: B3t,
        Heading: U3t,
        Input: Hi,
        Kbd: oEt,
        Link: cEt,
        List: hEt,
        Menu: EEt,
        Modal: NEt,
        NumberInput: HEt,
        PinInput: KEt,
        Popover: a3t,
        Progress: d4t,
        Radio: T4t,
        Select: M4t,
        Skeleton: P4t,
        SkipLink: L4t,
        Slider: G4t,
        Spinner: X4t,
        Stat: iEt,
        Switch: cxt,
        Table: mxt,
        Tabs: Rxt,
        Tag: Vxt,
        Textarea: t4t,
        Tooltip: i4t,
        Card: a6t,
        Stepper: t_t
    }, W6t = {
        colors: {
            "chakra-body-text": {_light: "gray.800", _dark: "whiteAlpha.900"},
            "chakra-body-bg": {_light: "white", _dark: "gray.800"},
            "chakra-border-color": {_light: "gray.200", _dark: "whiteAlpha.300"},
            "chakra-inverse-text": {_light: "white", _dark: "gray.800"},
            "chakra-subtle-bg": {_light: "gray.100", _dark: "gray.700"},
            "chakra-subtle-text": {_light: "gray.600", _dark: "gray.400"},
            "chakra-placeholder-color": {_light: "gray.500", _dark: "whiteAlpha.400"}
        }
    }, q6t = {
        global: {
            body: {
                fontFamily: "body",
                color: "chakra-body-text",
                bg: "chakra-body-bg",
                transitionProperty: "background-color",
                transitionDuration: "normal",
                lineHeight: "base"
            },
            "*::placeholder": {color: "chakra-placeholder-color"},
            "*, *::before, &::after": {borderColor: "chakra-border-color"}
        }
    }, G6t = "ltr", K6t = {useSystemColorMode: !1, initialColorMode: "light", cssVarPrefix: "chakra"},
    pC = {semanticTokens: W6t, direction: G6t, ...Z2t, components: H6t, styles: q6t, config: K6t};

function BT(t) {
    return typeof t == "function"
}

function Y6t(...t) {
    return e => t.reduce((r, n) => n(r), e)
}

var X6t = t => function (...r) {
    let n = [...r], i = r[r.length - 1];
    return I2t(i) && n.length > 1 ? n = n.slice(0, n.length - 1) : i = t, Y6t(...n.map(a => o => BT(a) ? a(o) : Z6t(o, a)))(i)
}, Q6t = X6t(pC);

function Z6t(...t) {
    return qd({}, ...t, rEe)
}

function rEe(t, e, r, n) {
    if ((BT(t) || BT(e)) && Object.prototype.hasOwnProperty.call(n, r)) return (...i) => {
        const a = BT(t) ? t(...i) : t, o = BT(e) ? e(...i) : e;
        return qd({}, a, o, rEe)
    }
}

function J6t() {
    return !!(typeof window < "u" && window.document && window.document.createElement)
}

var e5t = J6t();

function t5t(t, e) {
    const r = {};
    return Object.keys(t).forEach(n => {
        e.includes(n) || (r[n] = t[n])
    }), r
}

function r5t(t, e, r, n) {
    const i = typeof e == "string" ? e.split(".") : [e];
    for (n = 0; n < i.length && t; n += 1) t = t[i[n]];
    return t === void 0 ? r : t
}

var n5t = t => {
    const e = new WeakMap;
    return (n, i, a, o) => {
        if (typeof n > "u") return t(n, i, a);
        e.has(n) || e.set(n, new Map);
        const s = e.get(n);
        if (s.has(i)) return s.get(i);
        const l = t(n, i, a, o);
        return s.set(i, l), l
    }
}, nEe = n5t(r5t);

function iEe(t, e) {
    const r = {};
    return Object.keys(t).forEach(n => {
        const i = t[n];
        e(i, n, t) && (r[n] = i)
    }), r
}

var aEe = t => iEe(t, e => e != null);

function i5t(t) {
    return typeof t == "function"
}

function oEe(t, ...e) {
    return i5t(t) ? t(...e) : t
}

function a5t(...t) {
    return function (r) {
        t.some(n => (n == null || n(r), r == null ? void 0 : r.defaultPrevented))
    }
}

var o5t = typeof Element < "u", s5t = typeof Map == "function", c5t = typeof Set == "function",
    l5t = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;

function ZD(t, e) {
    if (t === e) return !0;
    if (t && e && typeof t == "object" && typeof e == "object") {
        if (t.constructor !== e.constructor) return !1;
        var r, n, i;
        if (Array.isArray(t)) {
            if (r = t.length, r != e.length) return !1;
            for (n = r; n-- !== 0;) if (!ZD(t[n], e[n])) return !1;
            return !0
        }
        var a;
        if (s5t && t instanceof Map && e instanceof Map) {
            if (t.size !== e.size) return !1;
            for (a = t.entries(); !(n = a.next()).done;) if (!e.has(n.value[0])) return !1;
            for (a = t.entries(); !(n = a.next()).done;) if (!ZD(n.value[1], e.get(n.value[0]))) return !1;
            return !0
        }
        if (c5t && t instanceof Set && e instanceof Set) {
            if (t.size !== e.size) return !1;
            for (a = t.entries(); !(n = a.next()).done;) if (!e.has(n.value[0])) return !1;
            return !0
        }
        if (l5t && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
            if (r = t.length, r != e.length) return !1;
            for (n = r; n-- !== 0;) if (t[n] !== e[n]) return !1;
            return !0
        }
        if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;
        if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function") return t.valueOf() === e.valueOf();
        if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function") return t.toString() === e.toString();
        if (i = Object.keys(t), r = i.length, r !== Object.keys(e).length) return !1;
        for (n = r; n-- !== 0;) if (!Object.prototype.hasOwnProperty.call(e, i[n])) return !1;
        if (o5t && t instanceof Element) return !1;
        for (n = r; n-- !== 0;) if (!((i[n] === "_owner" || i[n] === "__v" || i[n] === "__o") && t.$$typeof) && !ZD(t[i[n]], e[i[n]])) return !1;
        return !0
    }
    return t !== t && e !== e
}

var u5t = function (e, r) {
    try {
        return ZD(e, r)
    } catch (n) {
        if ((n.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
        throw n
    }
};
const sEe = za(u5t);

function cEe(t, e = {}) {
    var r;
    const {styleConfig: n, ...i} = e, {theme: a, colorMode: o} = N4e(), s = t ? nEe(a, `components.${t}`) : void 0,
        l = n || s, f = qd({
            theme: a,
            colorMode: o
        }, (r = l == null ? void 0 : l.defaultProps) != null ? r : {}, aEe(t5t(i, ["children"]))), d = W.useRef({});
    if (l) {
        const g = T2t(l)(f);
        sEe(d.current, g) || (d.current = g)
    }
    return d.current
}

function _1(t, e = {}) {
    return cEe(t, e)
}

function tI(t, e = {}) {
    return cEe(t, e)
}

var f5t = new Set([...h2t, "textStyle", "layerStyle", "apply", "noOfLines", "focusBorderColor", "errorBorderColor", "as", "__css", "css", "sx"]),
    d5t = new Set(["htmlWidth", "htmlHeight", "htmlSize", "htmlTranslate"]);

function h5t(t) {
    return d5t.has(t) || !f5t.has(t)
}

function p5t(t, ...e) {
    if (t == null) throw new TypeError("Cannot convert undefined or null to object");
    const r = {...t};
    for (const n of e) if (n != null) for (const i in n) Object.prototype.hasOwnProperty.call(n, i) && (i in r && delete r[i], r[i] = n[i]);
    return r
}

function m5t(t) {
    const e = Object.assign({}, t);
    for (let r in e) e[r] === void 0 && delete e[r];
    return e
}

var v5t = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
    g5t = S4e(function (t) {
        return v5t.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91
    }), y5t = g5t, b5t = function (e) {
        return e !== "theme"
    }, Dde = function (e) {
        return typeof e == "string" && e.charCodeAt(0) > 96 ? y5t : b5t
    }, Mde = function (e, r, n) {
        var i;
        if (r) {
            var a = r.shouldForwardProp;
            i = e.__emotion_forwardProp && a ? function (o) {
                return e.__emotion_forwardProp(o) && a(o)
            } : a
        }
        return typeof i != "function" && n && (i = e.__emotion_forwardProp), i
    }, Ode = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`,
    w5t = function (e) {
        var r = e.cache, n = e.serialized, i = e.isStringTag;
        return XN(r, n, i), JZ(function () {
            return QN(r, n, i)
        }), null
    }, S5t = function t(e, r) {
        if (Ve.env.NODE_ENV !== "production" && e === void 0) throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
        var n = e.__emotion_real === e, i = n && e.__emotion_base || e, a, o;
        r !== void 0 && (a = r.label, o = r.target);
        var s = Mde(e, r, n), l = s || Dde(i), f = !l("as");
        return function () {
            var d = arguments, p = n && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
            if (a !== void 0 && p.push("label:" + a + ";"), d[0] == null || d[0].raw === void 0) p.push.apply(p, d); else {
                Ve.env.NODE_ENV !== "production" && d[0][0] === void 0 && console.error(Ode), p.push(d[0][0]);
                for (var g = d.length, b = 1; b < g; b++) Ve.env.NODE_ENV !== "production" && d[0][b] === void 0 && console.error(Ode), p.push(d[b], d[0][b])
            }
            var S = ZN(function (T, I, N) {
                var P = f && T.as || i, F = "", V = [], Y = T;
                if (T.theme == null) {
                    Y = {};
                    for (var ee in T) Y[ee] = T[ee];
                    Y.theme = W.useContext(t1)
                }
                typeof T.className == "string" ? F = QZ(I.registered, V, T.className) : T.className != null && (F = T.className + " ");
                var oe = Q4(p.concat(V), I.registered, Y);
                F += I.key + "-" + oe.name, o !== void 0 && (F += " " + o);
                var G = f && s === void 0 ? Dde(P) : l, J = {};
                for (var ce in T) f && ce === "as" || G(ce) && (J[ce] = T[ce]);
                return J.className = F, J.ref = N, W.createElement(W.Fragment, null, W.createElement(w5t, {
                    cache: I,
                    serialized: oe,
                    isStringTag: typeof P == "string"
                }), W.createElement(P, J))
            });
            return S.displayName = a !== void 0 ? a : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", S.defaultProps = e.defaultProps, S.__emotion_real = S, S.__emotion_base = i, S.__emotion_styles = p, S.__emotion_forwardProp = s, Object.defineProperty(S, "toString", {
                value: function () {
                    return o === void 0 && Ve.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + o
                }
            }), S.withComponent = function (T, I) {
                return t(T, dS({}, r, I, {shouldForwardProp: Mde(S, I, !0)})).apply(void 0, p)
            }, S
        }
    },
    _5t = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"],
    PO = S5t.bind();
_5t.forEach(function (t) {
    PO[t] = PO(t)
});
var Pde, x5t = (Pde = PO.default) != null ? Pde : PO, E5t = ({baseStyle: t}) => e => {
    const {theme: r, css: n, __css: i, sx: a, ...o} = e, s = iEe(o, (p, g) => m2t(g)), l = oEe(t, e),
        f = p5t({}, i, l, aEe(s), a), d = z4e(f)(e.theme);
    return n ? [d, n] : d
};

function YV(t, e) {
    const {baseStyle: r, ...n} = e ?? {};
    n.shouldForwardProp || (n.shouldForwardProp = h5t);
    const i = E5t({baseStyle: r}), a = x5t(t, n)(i);
    return ar.forwardRef(function (l, f) {
        const {colorMode: d, forced: p} = S1();
        return ar.createElement(a, {ref: f, "data-theme": p ? d : void 0, ...l})
    })
}

function T5t() {
    const t = new Map;
    return new Proxy(YV, {
        apply(e, r, n) {
            return YV(...n)
        }, get(e, r) {
            return t.has(r) || t.set(r, YV(r)), t.get(r)
        }
    })
}

var on = T5t();

function Jn(t) {
    return W.forwardRef(t)
}

function lEe(t = {}) {
    const {
        strict: e = !0,
        errorMessage: r = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
        name: n
    } = t, i = W.createContext(void 0);
    i.displayName = n;

    function a() {
        var o;
        const s = W.useContext(i);
        if (!s && e) {
            const l = new Error(r);
            throw l.name = "ContextError", (o = Error.captureStackTrace) == null || o.call(Error, l, a), l
        }
        return s
    }

    return [i.Provider, a, i]
}

function C5t(t) {
    const {cssVarsRoot: e, theme: r, children: n} = t, i = W.useMemo(() => f2t(r), [r]);
    return ie.jsxs(Dwt, {theme: i, children: [ie.jsx(A5t, {root: e}), n]})
}

function A5t({root: t = ":host, :root"}) {
    const e = [t, "[data-theme]"].join(",");
    return ie.jsx(Z8, {styles: r => ({[e]: r.__cssVars})})
}

lEe({
    name: "StylesContext",
    errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});

function QJt(t) {
    return lEe({
        name: `${t}StylesContext`,
        errorMessage: `useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${t} />" `
    })
}

function I5t() {
    const {colorMode: t} = S1();
    return ie.jsx(Z8, {
        styles: e => {
            const r = nEe(e, "styles.global"), n = oEe(r, {theme: e, colorMode: t});
            return n ? z4e(n)(e) : void 0
        }
    })
}

var uJ = W.createContext({
    getDocument() {
        return document
    }, getWindow() {
        return window
    }
});
uJ.displayName = "EnvironmentContext";

function k5t({defer: t} = {}) {
    const [, e] = W.useReducer(r => r + 1, 0);
    return Z4(() => {
        t && e()
    }, [t]), W.useContext(uJ)
}

function uEe(t) {
    const {children: e, environment: r, disabled: n} = t, i = W.useRef(null), a = W.useMemo(() => r || {
        getDocument: () => {
            var s, l;
            return (l = (s = i.current) == null ? void 0 : s.ownerDocument) != null ? l : document
        }, getWindow: () => {
            var s, l;
            return (l = (s = i.current) == null ? void 0 : s.ownerDocument.defaultView) != null ? l : window
        }
    }, [r]), o = !n || !r;
    return ie.jsxs(uJ.Provider, {
        value: a,
        children: [e, o && ie.jsx("span", {id: "__chakra_env", hidden: !0, ref: i})]
    })
}

uEe.displayName = "EnvironmentProvider";
var R5t = t => {
    const {
        children: e,
        colorModeManager: r,
        portalZIndex: n,
        resetScope: i,
        resetCSS: a = !0,
        theme: o = {},
        environment: s,
        cssVarsRoot: l,
        disableEnvironment: f,
        disableGlobalStyle: d
    } = t, p = ie.jsx(uEe, {environment: s, disabled: f, children: e});
    return ie.jsx(C5t, {
        theme: o,
        cssVarsRoot: l,
        children: ie.jsxs(P4e, {
            colorModeManager: r,
            options: o.config,
            children: [a ? ie.jsx(Vwt, {scope: i}) : ie.jsx(zwt, {}), !d && ie.jsx(I5t, {}), n ? ie.jsx(M4e, {
                zIndex: n,
                children: p
            }) : p]
        })
    })
}, D5t = (t, e) => t.find(r => r.id === e);

function Nde(t, e) {
    const r = fEe(t, e), n = r ? t[r].findIndex(i => i.id === e) : -1;
    return {position: r, index: n}
}

function fEe(t, e) {
    for (const [r, n] of Object.entries(t)) if (D5t(n, e)) return r
}

function M5t(t) {
    const e = t.includes("right"), r = t.includes("left");
    let n = "center";
    return e && (n = "flex-end"), r && (n = "flex-start"), {display: "flex", flexDirection: "column", alignItems: n}
}

function O5t(t) {
    const r = t === "top" || t === "bottom" ? "0 auto" : void 0,
        n = t.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0,
        i = t.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0,
        a = t.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)",
        o = t.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
    return {
        position: "fixed",
        zIndex: "var(--toast-z-index, 5500)",
        pointerEvents: "none",
        display: "flex",
        flexDirection: "column",
        margin: r,
        top: n,
        bottom: i,
        right: a,
        left: o
    }
}

function Uy(t, e = []) {
    const r = W.useRef(t);
    return W.useEffect(() => {
        r.current = t
    }), W.useCallback((...n) => {
        var i;
        return (i = r.current) == null ? void 0 : i.call(r, ...n)
    }, e)
}

function P5t(t, e) {
    const r = Uy(t);
    W.useEffect(() => {
        if (e == null) return;
        let n = null;
        return n = window.setTimeout(() => {
            r()
        }, e), () => {
            n && window.clearTimeout(n)
        }
    }, [e, r])
}

function rE(t, e) {
    const r = W.useRef(!1), n = W.useRef(!1);
    W.useEffect(() => {
        if (r.current && n.current) return t();
        n.current = !0
    }, e), W.useEffect(() => (r.current = !0, () => {
        r.current = !1
    }), [])
}

const dEe = W.createContext({transformPagePoint: t => t, isStatic: !1, reducedMotion: "never"}),
    nL = W.createContext({}), rI = W.createContext(null), iL = typeof document < "u",
    fJ = iL ? W.useLayoutEffect : W.useEffect, hEe = W.createContext({strict: !1});

function N5t(t, e, r, n) {
    const {visualElement: i} = W.useContext(nL), a = W.useContext(hEe), o = W.useContext(rI),
        s = W.useContext(dEe).reducedMotion, l = W.useRef();
    n = n || a.renderer, !l.current && n && (l.current = n(t, {
        visualState: e,
        parent: i,
        props: r,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: s
    }));
    const f = l.current;
    W.useInsertionEffect(() => {
        f && f.update(r, o)
    });
    const d = W.useRef(!!window.HandoffAppearAnimations);
    return fJ(() => {
        f && (f.render(), d.current && f.animationState && f.animationState.animateChanges())
    }), W.useEffect(() => {
        f && (f.updateFeatures(), !d.current && f.animationState && f.animationState.animateChanges(), window.HandoffAppearAnimations = void 0, d.current = !1)
    }), f
}

function Bx(t) {
    return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
}

function L5t(t, e, r) {
    return W.useCallback(n => {
        n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == "function" ? r(n) : Bx(r) && (r.current = n))
    }, [e])
}

function RA(t) {
    return typeof t == "string" || Array.isArray(t)
}

function aL(t) {
    return typeof t == "object" && typeof t.start == "function"
}

const dJ = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
    hJ = ["initial", ...dJ];

function oL(t) {
    return aL(t.animate) || hJ.some(e => RA(t[e]))
}

function pEe(t) {
    return !!(oL(t) || t.variants)
}

function B5t(t, e) {
    if (oL(t)) {
        const {initial: r, animate: n} = t;
        return {initial: r === !1 || RA(r) ? r : void 0, animate: RA(n) ? n : void 0}
    }
    return t.inherit !== !1 ? e : {}
}

function $5t(t) {
    const {initial: e, animate: r} = B5t(t, W.useContext(nL));
    return W.useMemo(() => ({initial: e, animate: r}), [Lde(e), Lde(r)])
}

function Lde(t) {
    return Array.isArray(t) ? t.join(" ") : t
}

const Bde = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}, DA = {};
for (const t in Bde) DA[t] = {isEnabled: e => Bde[t].some(r => !!e[r])};

function F5t(t) {
    for (const e in t) DA[e] = {...DA[e], ...t[e]}
}

const pJ = W.createContext({}), mEe = W.createContext({}), U5t = Symbol.for("motionComponentSymbol");

function j5t({preloadedFeatures: t, createVisualElement: e, useRender: r, useVisualState: n, Component: i}) {
    t && F5t(t);

    function a(s, l) {
        let f;
        const d = {...W.useContext(dEe), ...s, layoutId: z5t(s)}, {isStatic: p} = d, g = $5t(s), b = n(s, p);
        if (!p && iL) {
            g.visualElement = N5t(i, b, d, e);
            const S = W.useContext(mEe), T = W.useContext(hEe).strict;
            g.visualElement && (f = g.visualElement.loadFeatures(d, T, t, S))
        }
        return W.createElement(nL.Provider, {value: g}, f && g.visualElement ? W.createElement(f, {visualElement: g.visualElement, ...d}) : null, r(i, s, L5t(b, g.visualElement, l), b, p, g.visualElement))
    }

    const o = W.forwardRef(a);
    return o[U5t] = i, o
}

function z5t({layoutId: t}) {
    const e = W.useContext(pJ).id;
    return e && t !== void 0 ? e + "-" + t : t
}

function V5t(t) {
    function e(n, i = {}) {
        return j5t(t(n, i))
    }

    if (typeof Proxy > "u") return e;
    const r = new Map;
    return new Proxy(e, {get: (n, i) => (r.has(i) || r.set(i, e(i)), r.get(i))})
}

const H5t = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function mJ(t) {
    return typeof t != "string" || t.includes("-") ? !1 : !!(H5t.indexOf(t) > -1 || /[A-Z]/.test(t))
}

const NO = {};

function W5t(t) {
    Object.assign(NO, t)
}

const nI = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    KS = new Set(nI);

function vEe(t, {layout: e, layoutId: r}) {
    return KS.has(t) || t.startsWith("origin") || (e || r !== void 0) && (!!NO[t] || t === "opacity")
}

const uf = t => !!(t && t.getVelocity),
    q5t = {x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective"}, G5t = nI.length;

function K5t(t, {enableHardwareAcceleration: e = !0, allowTransformNone: r = !0}, n, i) {
    let a = "";
    for (let o = 0; o < G5t; o++) {
        const s = nI[o];
        if (t[s] !== void 0) {
            const l = q5t[s] || s;
            a += `${l}(${t[s]}) `
        }
    }
    return e && !t.z && (a += "translateZ(0)"), a = a.trim(), i ? a = i(t, n ? "" : a) : r && n && (a = "none"), a
}

const gEe = t => e => typeof e == "string" && e.startsWith(t), yEe = gEe("--"), vK = gEe("var(--"),
    Y5t = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
    X5t = (t, e) => e && typeof t == "number" ? e.transform(t) : t, r1 = (t, e, r) => Math.min(Math.max(r, t), e),
    YS = {test: t => typeof t == "number", parse: parseFloat, transform: t => t},
    mC = {...YS, transform: t => r1(0, 1, t)}, D7 = {...YS, default: 1}, vC = t => Math.round(t * 1e5) / 1e5,
    sL = /(-)?([\d]*\.?[\d])+/g,
    bEe = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
    Q5t = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;

function iI(t) {
    return typeof t == "string"
}

const aI = t => ({
        test: e => iI(e) && e.endsWith(t) && e.split(" ").length === 1,
        parse: parseFloat,
        transform: e => `${e}${t}`
    }), my = aI("deg"), L0 = aI("%"), nn = aI("px"), Z5t = aI("vh"), J5t = aI("vw"),
    $de = {...L0, parse: t => L0.parse(t) / 100, transform: t => L0.transform(t * 100)},
    Fde = {...YS, transform: Math.round}, wEe = {
        borderWidth: nn,
        borderTopWidth: nn,
        borderRightWidth: nn,
        borderBottomWidth: nn,
        borderLeftWidth: nn,
        borderRadius: nn,
        radius: nn,
        borderTopLeftRadius: nn,
        borderTopRightRadius: nn,
        borderBottomRightRadius: nn,
        borderBottomLeftRadius: nn,
        width: nn,
        maxWidth: nn,
        height: nn,
        maxHeight: nn,
        size: nn,
        top: nn,
        right: nn,
        bottom: nn,
        left: nn,
        padding: nn,
        paddingTop: nn,
        paddingRight: nn,
        paddingBottom: nn,
        paddingLeft: nn,
        margin: nn,
        marginTop: nn,
        marginRight: nn,
        marginBottom: nn,
        marginLeft: nn,
        rotate: my,
        rotateX: my,
        rotateY: my,
        rotateZ: my,
        scale: D7,
        scaleX: D7,
        scaleY: D7,
        scaleZ: D7,
        skew: my,
        skewX: my,
        skewY: my,
        distance: nn,
        translateX: nn,
        translateY: nn,
        translateZ: nn,
        x: nn,
        y: nn,
        z: nn,
        perspective: nn,
        transformPerspective: nn,
        opacity: mC,
        originX: $de,
        originY: $de,
        originZ: nn,
        zIndex: Fde,
        fillOpacity: mC,
        strokeOpacity: mC,
        numOctaves: Fde
    };

function vJ(t, e, r, n) {
    const {style: i, vars: a, transform: o, transformOrigin: s} = t;
    let l = !1, f = !1, d = !0;
    for (const p in e) {
        const g = e[p];
        if (yEe(p)) {
            a[p] = g;
            continue
        }
        const b = wEe[p], S = X5t(g, b);
        if (KS.has(p)) {
            if (l = !0, o[p] = S, !d) continue;
            g !== (b.default || 0) && (d = !1)
        } else p.startsWith("origin") ? (f = !0, s[p] = S) : i[p] = S
    }
    if (e.transform || (l || n ? i.transform = K5t(t.transform, r, d, n) : i.transform && (i.transform = "none")), f) {
        const {originX: p = "50%", originY: g = "50%", originZ: b = 0} = s;
        i.transformOrigin = `${p} ${g} ${b}`
    }
}

const gJ = () => ({style: {}, transform: {}, transformOrigin: {}, vars: {}});

function SEe(t, e, r) {
    for (const n in e) !uf(e[n]) && !vEe(n, r) && (t[n] = e[n])
}

function eTt({transformTemplate: t}, e, r) {
    return W.useMemo(() => {
        const n = gJ();
        return vJ(n, e, {enableHardwareAcceleration: !r}, t), Object.assign({}, n.vars, n.style)
    }, [e])
}

function tTt(t, e, r) {
    const n = t.style || {}, i = {};
    return SEe(i, n, t), Object.assign(i, eTt(t, e, r)), t.transformValues ? t.transformValues(i) : i
}

function rTt(t, e, r) {
    const n = {}, i = tTt(t, e, r);
    return t.drag && t.dragListener !== !1 && (n.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = i, n
}

const nTt = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);

function LO(t) {
    return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || nTt.has(t)
}

let _Ee = t => !LO(t);

function iTt(t) {
    t && (_Ee = e => e.startsWith("on") ? !LO(e) : t(e))
}

try {
    iTt(require("@emotion/is-prop-valid").default)
} catch {
}

function aTt(t, e, r) {
    const n = {};
    for (const i in t) i === "values" && typeof t.values == "object" || (_Ee(i) || r === !0 && LO(i) || !e && !LO(i) || t.draggable && i.startsWith("onDrag")) && (n[i] = t[i]);
    return n
}

function Ude(t, e, r) {
    return typeof t == "string" ? t : nn.transform(e + r * t)
}

function oTt(t, e, r) {
    const n = Ude(e, t.x, t.width), i = Ude(r, t.y, t.height);
    return `${n} ${i}`
}

const sTt = {offset: "stroke-dashoffset", array: "stroke-dasharray"},
    cTt = {offset: "strokeDashoffset", array: "strokeDasharray"};

function lTt(t, e, r = 1, n = 0, i = !0) {
    t.pathLength = 1;
    const a = i ? sTt : cTt;
    t[a.offset] = nn.transform(-n);
    const o = nn.transform(e), s = nn.transform(r);
    t[a.array] = `${o} ${s}`
}

function yJ(t, {
    attrX: e,
    attrY: r,
    attrScale: n,
    originX: i,
    originY: a,
    pathLength: o,
    pathSpacing: s = 1,
    pathOffset: l = 0,
    ...f
}, d, p, g) {
    if (vJ(t, f, d, g), p) {
        t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
        return
    }
    t.attrs = t.style, t.style = {};
    const {attrs: b, style: S, dimensions: T} = t;
    b.transform && (T && (S.transform = b.transform), delete b.transform), T && (i !== void 0 || a !== void 0 || S.transform) && (S.transformOrigin = oTt(T, i !== void 0 ? i : .5, a !== void 0 ? a : .5)), e !== void 0 && (b.x = e), r !== void 0 && (b.y = r), n !== void 0 && (b.scale = n), o !== void 0 && lTt(b, o, s, l, !1)
}

const xEe = () => ({...gJ(), attrs: {}}), bJ = t => typeof t == "string" && t.toLowerCase() === "svg";

function uTt(t, e, r, n) {
    const i = W.useMemo(() => {
        const a = xEe();
        return yJ(a, e, {enableHardwareAcceleration: !1}, bJ(n), t.transformTemplate), {...a.attrs, style: {...a.style}}
    }, [e]);
    if (t.style) {
        const a = {};
        SEe(a, t.style, t), i.style = {...a, ...i.style}
    }
    return i
}

function fTt(t = !1) {
    return (r, n, i, {latestValues: a}, o) => {
        const l = (mJ(r) ? uTt : rTt)(n, a, o, r),
            d = {...aTt(n, typeof r == "string", t), ...l, ref: i}, {children: p} = n,
            g = W.useMemo(() => uf(p) ? p.get() : p, [p]);
        return W.createElement(r, {...d, children: g})
    }
}

const wJ = t => t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

function EEe(t, {style: e, vars: r}, n, i) {
    Object.assign(t.style, e, i && i.getProjectionStyles(n));
    for (const a in r) t.style.setProperty(a, r[a])
}

const TEe = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function CEe(t, e, r, n) {
    EEe(t, e, void 0, n);
    for (const i in e.attrs) t.setAttribute(TEe.has(i) ? i : wJ(i), e.attrs[i])
}

function SJ(t, e) {
    const {style: r} = t, n = {};
    for (const i in r) (uf(r[i]) || e.style && uf(e.style[i]) || vEe(i, t)) && (n[i] = r[i]);
    return n
}

function AEe(t, e) {
    const r = SJ(t, e);
    for (const n in t) if (uf(t[n]) || uf(e[n])) {
        const i = nI.indexOf(n) !== -1 ? "attr" + n.charAt(0).toUpperCase() + n.substring(1) : n;
        r[i] = t[n]
    }
    return r
}

function _J(t, e, r, n = {}, i = {}) {
    return typeof e == "function" && (e = e(r !== void 0 ? r : t.custom, n, i)), typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function" && (e = e(r !== void 0 ? r : t.custom, n, i)), e
}

function IEe(t) {
    const e = W.useRef(null);
    return e.current === null && (e.current = t()), e.current
}

const BO = t => Array.isArray(t), dTt = t => !!(t && typeof t == "object" && t.mix && t.toValue),
    hTt = t => BO(t) ? t[t.length - 1] || 0 : t;

function JD(t) {
    const e = uf(t) ? t.get() : t;
    return dTt(e) ? e.toValue() : e
}

function pTt({scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r}, n, i, a) {
    const o = {latestValues: mTt(n, i, a, t), renderState: e()};
    return r && (o.mount = s => r(n, s, o)), o
}

const kEe = t => (e, r) => {
    const n = W.useContext(nL), i = W.useContext(rI), a = () => pTt(t, e, n, i);
    return r ? a() : IEe(a)
};

function mTt(t, e, r, n) {
    const i = {}, a = n(t, {});
    for (const g in a) i[g] = JD(a[g]);
    let {initial: o, animate: s} = t;
    const l = oL(t), f = pEe(t);
    e && f && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial), s === void 0 && (s = e.animate));
    let d = r ? r.initial === !1 : !1;
    d = d || o === !1;
    const p = d ? s : o;
    return p && typeof p != "boolean" && !aL(p) && (Array.isArray(p) ? p : [p]).forEach(b => {
        const S = _J(t, b);
        if (!S) return;
        const {transitionEnd: T, transition: I, ...N} = S;
        for (const P in N) {
            let F = N[P];
            if (Array.isArray(F)) {
                const V = d ? F.length - 1 : 0;
                F = F[V]
            }
            F !== null && (i[P] = F)
        }
        for (const P in T) i[P] = T[P]
    }), i
}

const Ao = t => t;

class jde {
    constructor() {
        this.order = [], this.scheduled = new Set
    }

    add(e) {
        if (!this.scheduled.has(e)) return this.scheduled.add(e), this.order.push(e), !0
    }

    remove(e) {
        const r = this.order.indexOf(e);
        r !== -1 && (this.order.splice(r, 1), this.scheduled.delete(e))
    }

    clear() {
        this.order.length = 0, this.scheduled.clear()
    }
}

function vTt(t) {
    let e = new jde, r = new jde, n = 0, i = !1, a = !1;
    const o = new WeakSet, s = {
        schedule: (l, f = !1, d = !1) => {
            const p = d && i, g = p ? e : r;
            return f && o.add(l), g.add(l) && p && i && (n = e.order.length), l
        }, cancel: l => {
            r.remove(l), o.delete(l)
        }, process: l => {
            if (i) {
                a = !0;
                return
            }
            if (i = !0, [e, r] = [r, e], r.clear(), n = e.order.length, n) for (let f = 0; f < n; f++) {
                const d = e.order[f];
                d(l), o.has(d) && (s.schedule(d), t())
            }
            i = !1, a && (a = !1, s.process(l))
        }
    };
    return s
}

const M7 = ["prepare", "read", "update", "preRender", "render", "postRender"], gTt = 40;

function yTt(t, e) {
    let r = !1, n = !0;
    const i = {delta: 0, timestamp: 0, isProcessing: !1}, a = M7.reduce((p, g) => (p[g] = vTt(() => r = !0), p), {}),
        o = p => a[p].process(i), s = () => {
            const p = performance.now();
            r = !1, i.delta = n ? 1e3 / 60 : Math.max(Math.min(p - i.timestamp, gTt), 1), i.timestamp = p, i.isProcessing = !0, M7.forEach(o), i.isProcessing = !1, r && e && (n = !1, t(s))
        }, l = () => {
            r = !0, n = !0, i.isProcessing || t(s)
        };
    return {
        schedule: M7.reduce((p, g) => {
            const b = a[g];
            return p[g] = (S, T = !1, I = !1) => (r || l(), b.schedule(S, T, I)), p
        }, {}), cancel: p => M7.forEach(g => a[g].cancel(p)), state: i, steps: a
    }
}

const {
    schedule: Ta,
    cancel: jv,
    state: Ks,
    steps: XV
} = yTt(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Ao, !0), bTt = {
    useVisualState: kEe({
        scrapeMotionValuesFromProps: AEe,
        createRenderState: xEe,
        onMount: (t, e, {renderState: r, latestValues: n}) => {
            Ta.read(() => {
                try {
                    r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
                } catch {
                    r.dimensions = {x: 0, y: 0, width: 0, height: 0}
                }
            }), Ta.render(() => {
                yJ(r, n, {enableHardwareAcceleration: !1}, bJ(e.tagName), t.transformTemplate), CEe(e, r)
            })
        }
    })
}, wTt = {useVisualState: kEe({scrapeMotionValuesFromProps: SJ, createRenderState: gJ})};

function STt(t, {forwardMotionProps: e = !1}, r, n) {
    return {...mJ(t) ? bTt : wTt, preloadedFeatures: r, useRender: fTt(e), createVisualElement: n, Component: t}
}

function pv(t, e, r, n = {passive: !0}) {
    return t.addEventListener(e, r, n), () => t.removeEventListener(e, r)
}

const REe = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;

function cL(t, e = "page") {
    return {point: {x: t[e + "X"], y: t[e + "Y"]}}
}

const _Tt = t => e => REe(e) && t(e, cL(e));

function Ev(t, e, r, n) {
    return pv(t, e, _Tt(r), n)
}

const xTt = (t, e) => r => e(t(r)), jy = (...t) => t.reduce(xTt);

function DEe(t) {
    let e = null;
    return () => {
        const r = () => {
            e = null
        };
        return e === null ? (e = t, r) : !1
    }
}

const zde = DEe("dragHorizontal"), Vde = DEe("dragVertical");

function MEe(t) {
    let e = !1;
    if (t === "y") e = Vde(); else if (t === "x") e = zde(); else {
        const r = zde(), n = Vde();
        r && n ? e = () => {
            r(), n()
        } : (r && r(), n && n())
    }
    return e
}

function OEe() {
    const t = MEe(!0);
    return t ? (t(), !1) : !0
}

class x1 {
    constructor(e) {
        this.isMounted = !1, this.node = e
    }

    update() {
    }
}

function Hde(t, e) {
    const r = "pointer" + (e ? "enter" : "leave"), n = "onHover" + (e ? "Start" : "End"), i = (a, o) => {
        if (a.type === "touch" || OEe()) return;
        const s = t.getProps();
        t.animationState && s.whileHover && t.animationState.setActive("whileHover", e), s[n] && Ta.update(() => s[n](a, o))
    };
    return Ev(t.current, r, i, {passive: !t.getProps()[n]})
}

class ETt extends x1 {
    mount() {
        this.unmount = jy(Hde(this.node, !0), Hde(this.node, !1))
    }

    unmount() {
    }
}

class TTt extends x1 {
    constructor() {
        super(...arguments), this.isActive = !1
    }

    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
    }

    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
    }

    mount() {
        this.unmount = jy(pv(this.node.current, "focus", () => this.onFocus()), pv(this.node.current, "blur", () => this.onBlur()))
    }

    unmount() {
    }
}

const PEe = (t, e) => e ? t === e ? !0 : PEe(t, e.parentElement) : !1;

function QV(t, e) {
    if (!e) return;
    const r = new PointerEvent("pointer" + t);
    e(r, cL(r))
}

class CTt extends x1 {
    constructor() {
        super(...arguments), this.removeStartListeners = Ao, this.removeEndListeners = Ao, this.removeAccessibleListeners = Ao, this.startPointerPress = (e, r) => {
            if (this.removeEndListeners(), this.isPressing) return;
            const n = this.node.getProps(), a = Ev(window, "pointerup", (s, l) => {
                    if (!this.checkPressEnd()) return;
                    const {onTap: f, onTapCancel: d} = this.node.getProps();
                    Ta.update(() => {
                        PEe(this.node.current, s.target) ? f && f(s, l) : d && d(s, l)
                    })
                }, {passive: !(n.onTap || n.onPointerUp)}),
                o = Ev(window, "pointercancel", (s, l) => this.cancelPress(s, l), {passive: !(n.onTapCancel || n.onPointerCancel)});
            this.removeEndListeners = jy(a, o), this.startPress(e, r)
        }, this.startAccessiblePress = () => {
            const e = a => {
                if (a.key !== "Enter" || this.isPressing) return;
                const o = s => {
                    s.key !== "Enter" || !this.checkPressEnd() || QV("up", (l, f) => {
                        const {onTap: d} = this.node.getProps();
                        d && Ta.update(() => d(l, f))
                    })
                };
                this.removeEndListeners(), this.removeEndListeners = pv(this.node.current, "keyup", o), QV("down", (s, l) => {
                    this.startPress(s, l)
                })
            }, r = pv(this.node.current, "keydown", e), n = () => {
                this.isPressing && QV("cancel", (a, o) => this.cancelPress(a, o))
            }, i = pv(this.node.current, "blur", n);
            this.removeAccessibleListeners = jy(r, i)
        }
    }

    startPress(e, r) {
        this.isPressing = !0;
        const {onTapStart: n, whileTap: i} = this.node.getProps();
        i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Ta.update(() => n(e, r))
    }

    checkPressEnd() {
        return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !OEe()
    }

    cancelPress(e, r) {
        if (!this.checkPressEnd()) return;
        const {onTapCancel: n} = this.node.getProps();
        n && Ta.update(() => n(e, r))
    }

    mount() {
        const e = this.node.getProps(),
            r = Ev(this.node.current, "pointerdown", this.startPointerPress, {passive: !(e.onTapStart || e.onPointerStart)}),
            n = pv(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = jy(r, n)
    }

    unmount() {
        this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
    }
}

const gK = new WeakMap, ZV = new WeakMap, ATt = t => {
    const e = gK.get(t.target);
    e && e(t)
}, ITt = t => {
    t.forEach(ATt)
};

function kTt({root: t, ...e}) {
    const r = t || document;
    ZV.has(r) || ZV.set(r, {});
    const n = ZV.get(r), i = JSON.stringify(e);
    return n[i] || (n[i] = new IntersectionObserver(ITt, {root: t, ...e})), n[i]
}

function RTt(t, e, r) {
    const n = kTt(e);
    return gK.set(t, r), n.observe(t), () => {
        gK.delete(t), n.unobserve(t)
    }
}

const DTt = {some: 0, all: 1};

class MTt extends x1 {
    constructor() {
        super(...arguments), this.hasEnteredView = !1, this.isInView = !1
    }

    startObserver() {
        this.unmount();
        const {viewport: e = {}} = this.node.getProps(), {root: r, margin: n, amount: i = "some", once: a} = e,
            o = {root: r ? r.current : void 0, rootMargin: n, threshold: typeof i == "number" ? i : DTt[i]}, s = l => {
                const {isIntersecting: f} = l;
                if (this.isInView === f || (this.isInView = f, a && !f && this.hasEnteredView)) return;
                f && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", f);
                const {onViewportEnter: d, onViewportLeave: p} = this.node.getProps(), g = f ? d : p;
                g && g(l)
            };
        return RTt(this.node.current, o, s)
    }

    mount() {
        this.startObserver()
    }

    update() {
        if (typeof IntersectionObserver > "u") return;
        const {props: e, prevProps: r} = this.node;
        ["amount", "margin", "root"].some(OTt(e, r)) && this.startObserver()
    }

    unmount() {
    }
}

function OTt({viewport: t = {}}, {viewport: e = {}} = {}) {
    return r => t[r] !== e[r]
}

const PTt = {inView: {Feature: MTt}, tap: {Feature: CTt}, focus: {Feature: TTt}, hover: {Feature: ETt}};

function NEe(t, e) {
    if (!Array.isArray(e)) return !1;
    const r = e.length;
    if (r !== t.length) return !1;
    for (let n = 0; n < r; n++) if (e[n] !== t[n]) return !1;
    return !0
}

function NTt(t) {
    const e = {};
    return t.values.forEach((r, n) => e[n] = r.get()), e
}

function LTt(t) {
    const e = {};
    return t.values.forEach((r, n) => e[n] = r.getVelocity()), e
}

function lL(t, e, r) {
    const n = t.getProps();
    return _J(n, e, r !== void 0 ? r : n.custom, NTt(t), LTt(t))
}

const BTt = "framerAppearId", $Tt = "data-" + wJ(BTt);
let oI = Ao, vp = Ao;
Ve.env.NODE_ENV !== "production" && (oI = (t, e) => {
    !t && typeof console < "u" && console.warn(e)
}, vp = (t, e) => {
    if (!t) throw new Error(e)
});
const zy = t => t * 1e3, Tv = t => t / 1e3, FTt = {current: !1}, LEe = t => Array.isArray(t) && typeof t[0] == "number";

function BEe(t) {
    return !!(!t || typeof t == "string" && $Ee[t] || LEe(t) || Array.isArray(t) && t.every(BEe))
}

const $T = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, $Ee = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: $T([0, .65, .55, 1]),
    circOut: $T([.55, 0, 1, .45]),
    backIn: $T([.31, .01, .66, -.59]),
    backOut: $T([.33, 1.53, .69, .99])
};

function FEe(t) {
    if (t) return LEe(t) ? $T(t) : Array.isArray(t) ? t.map(FEe) : $Ee[t]
}

function UTt(t, e, r, {delay: n = 0, duration: i, repeat: a = 0, repeatType: o = "loop", ease: s, times: l} = {}) {
    const f = {[e]: r};
    l && (f.offset = l);
    const d = FEe(s);
    return Array.isArray(d) && (f.easing = d), t.animate(f, {
        delay: n,
        duration: i,
        easing: Array.isArray(d) ? "linear" : d,
        fill: "both",
        iterations: a + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}

function jTt(t, {repeat: e, repeatType: r = "loop"}) {
    const n = e && r !== "loop" && e % 2 === 1 ? 0 : t.length - 1;
    return t[n]
}

const UEe = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, zTt = 1e-7, VTt = 12;

function HTt(t, e, r, n, i) {
    let a, o, s = 0;
    do o = e + (r - e) / 2, a = UEe(o, n, i) - t, a > 0 ? r = o : e = o; while (Math.abs(a) > zTt && ++s < VTt);
    return o
}

function sI(t, e, r, n) {
    if (t === e && r === n) return Ao;
    const i = a => HTt(a, 0, 1, t, r);
    return a => a === 0 || a === 1 ? a : UEe(i(a), e, n)
}

const WTt = sI(.42, 0, 1, 1), qTt = sI(0, 0, .58, 1), jEe = sI(.42, 0, .58, 1),
    GTt = t => Array.isArray(t) && typeof t[0] != "number",
    zEe = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, VEe = t => e => 1 - t(1 - e),
    HEe = t => 1 - Math.sin(Math.acos(t)), xJ = VEe(HEe), KTt = zEe(xJ), WEe = sI(.33, 1.53, .69, .99), EJ = VEe(WEe),
    YTt = zEe(EJ), XTt = t => (t *= 2) < 1 ? .5 * EJ(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), Wde = {
        linear: Ao,
        easeIn: WTt,
        easeInOut: jEe,
        easeOut: qTt,
        circIn: HEe,
        circInOut: KTt,
        circOut: xJ,
        backIn: EJ,
        backInOut: YTt,
        backOut: WEe,
        anticipate: XTt
    }, qde = t => {
        if (Array.isArray(t)) {
            vp(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
            const [e, r, n, i] = t;
            return sI(e, r, n, i)
        } else if (typeof t == "string") return vp(Wde[t] !== void 0, `Invalid easing type '${t}'`), Wde[t];
        return t
    }, TJ = (t, e) => r => !!(iI(r) && Q5t.test(r) && r.startsWith(t) || e && Object.prototype.hasOwnProperty.call(r, e)),
    qEe = (t, e, r) => n => {
        if (!iI(n)) return n;
        const [i, a, o, s] = n.match(sL);
        return {[t]: parseFloat(i), [e]: parseFloat(a), [r]: parseFloat(o), alpha: s !== void 0 ? parseFloat(s) : 1}
    }, QTt = t => r1(0, 255, t), JV = {...YS, transform: t => Math.round(QTt(t))}, Rw = {
        test: TJ("rgb", "red"),
        parse: qEe("red", "green", "blue"),
        transform: ({
                        red: t,
                        green: e,
                        blue: r,
                        alpha: n = 1
                    }) => "rgba(" + JV.transform(t) + ", " + JV.transform(e) + ", " + JV.transform(r) + ", " + vC(mC.transform(n)) + ")"
    };

function ZTt(t) {
    let e = "", r = "", n = "", i = "";
    return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {
        red: parseInt(e, 16),
        green: parseInt(r, 16),
        blue: parseInt(n, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}

const yK = {test: TJ("#"), parse: ZTt, transform: Rw.transform}, $x = {
    test: TJ("hsl", "hue"),
    parse: qEe("hue", "saturation", "lightness"),
    transform: ({
                    hue: t,
                    saturation: e,
                    lightness: r,
                    alpha: n = 1
                }) => "hsla(" + Math.round(t) + ", " + L0.transform(vC(e)) + ", " + L0.transform(vC(r)) + ", " + vC(mC.transform(n)) + ")"
}, eu = {
    test: t => Rw.test(t) || yK.test(t) || $x.test(t),
    parse: t => Rw.test(t) ? Rw.parse(t) : $x.test(t) ? $x.parse(t) : yK.parse(t),
    transform: t => iI(t) ? t : t.hasOwnProperty("red") ? Rw.transform(t) : $x.transform(t)
}, lo = (t, e, r) => -r * t + r * e + t;

function eH(t, e, r) {
    return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t
}

function JTt({hue: t, saturation: e, lightness: r, alpha: n}) {
    t /= 360, e /= 100, r /= 100;
    let i = 0, a = 0, o = 0;
    if (!e) i = a = o = r; else {
        const s = r < .5 ? r * (1 + e) : r + e - r * e, l = 2 * r - s;
        i = eH(l, s, t + 1 / 3), a = eH(l, s, t), o = eH(l, s, t - 1 / 3)
    }
    return {red: Math.round(i * 255), green: Math.round(a * 255), blue: Math.round(o * 255), alpha: n}
}

const tH = (t, e, r) => {
    const n = t * t;
    return Math.sqrt(Math.max(0, r * (e * e - n) + n))
}, eCt = [yK, Rw, $x], tCt = t => eCt.find(e => e.test(t));

function Gde(t) {
    const e = tCt(t);
    vp(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`);
    let r = e.parse(t);
    return e === $x && (r = JTt(r)), r
}

const GEe = (t, e) => {
    const r = Gde(t), n = Gde(e), i = {...r};
    return a => (i.red = tH(r.red, n.red, a), i.green = tH(r.green, n.green, a), i.blue = tH(r.blue, n.blue, a), i.alpha = lo(r.alpha, n.alpha, a), Rw.transform(i))
};

function rCt(t) {
    var e, r;
    return isNaN(t) && iI(t) && (((e = t.match(sL)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(bEe)) === null || r === void 0 ? void 0 : r.length) || 0) > 0
}

const KEe = {regex: Y5t, countKey: "Vars", token: "${v}", parse: Ao},
    YEe = {regex: bEe, countKey: "Colors", token: "${c}", parse: eu.parse},
    XEe = {regex: sL, countKey: "Numbers", token: "${n}", parse: YS.parse};

function rH(t, {regex: e, countKey: r, token: n, parse: i}) {
    const a = t.tokenised.match(e);
    a && (t["num" + r] = a.length, t.tokenised = t.tokenised.replace(e, n), t.values.push(...a.map(i)))
}

function $O(t) {
    const e = t.toString(), r = {value: e, tokenised: e, values: [], numVars: 0, numColors: 0, numNumbers: 0};
    return r.value.includes("var(--") && rH(r, KEe), rH(r, YEe), rH(r, XEe), r
}

function QEe(t) {
    return $O(t).values
}

function ZEe(t) {
    const {values: e, numColors: r, numVars: n, tokenised: i} = $O(t), a = e.length;
    return o => {
        let s = i;
        for (let l = 0; l < a; l++) l < n ? s = s.replace(KEe.token, o[l]) : l < n + r ? s = s.replace(YEe.token, eu.transform(o[l])) : s = s.replace(XEe.token, vC(o[l]));
        return s
    }
}

const nCt = t => typeof t == "number" ? 0 : t;

function iCt(t) {
    const e = QEe(t);
    return ZEe(t)(e.map(nCt))
}

const n1 = {test: rCt, parse: QEe, createTransformer: ZEe, getAnimatableNone: iCt},
    JEe = (t, e) => r => `${r > 0 ? e : t}`;

function e3e(t, e) {
    return typeof t == "number" ? r => lo(t, e, r) : eu.test(t) ? GEe(t, e) : t.startsWith("var(") ? JEe(t, e) : r3e(t, e)
}

const t3e = (t, e) => {
    const r = [...t], n = r.length, i = t.map((a, o) => e3e(a, e[o]));
    return a => {
        for (let o = 0; o < n; o++) r[o] = i[o](a);
        return r
    }
}, aCt = (t, e) => {
    const r = {...t, ...e}, n = {};
    for (const i in r) t[i] !== void 0 && e[i] !== void 0 && (n[i] = e3e(t[i], e[i]));
    return i => {
        for (const a in n) r[a] = n[a](i);
        return r
    }
}, r3e = (t, e) => {
    const r = n1.createTransformer(e), n = $O(t), i = $O(e);
    return n.numVars === i.numVars && n.numColors === i.numColors && n.numNumbers >= i.numNumbers ? jy(t3e(n.values, i.values), r) : (oI(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), JEe(t, e))
}, MA = (t, e, r) => {
    const n = e - t;
    return n === 0 ? 1 : (r - t) / n
}, Kde = (t, e) => r => lo(t, e, r);

function oCt(t) {
    return typeof t == "number" ? Kde : typeof t == "string" ? eu.test(t) ? GEe : r3e : Array.isArray(t) ? t3e : typeof t == "object" ? aCt : Kde
}

function sCt(t, e, r) {
    const n = [], i = r || oCt(t[0]), a = t.length - 1;
    for (let o = 0; o < a; o++) {
        let s = i(t[o], t[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] || Ao : e;
            s = jy(l, s)
        }
        n.push(s)
    }
    return n
}

function n3e(t, e, {clamp: r = !0, ease: n, mixer: i} = {}) {
    const a = t.length;
    if (vp(a === e.length, "Both input and output ranges must be the same length"), a === 1) return () => e[0];
    t[0] > t[a - 1] && (t = [...t].reverse(), e = [...e].reverse());
    const o = sCt(e, n, i), s = o.length, l = f => {
        let d = 0;
        if (s > 1) for (; d < t.length - 2 && !(f < t[d + 1]); d++) ;
        const p = MA(t[d], t[d + 1], f);
        return o[d](p)
    };
    return r ? f => l(r1(t[0], t[a - 1], f)) : l
}

function cCt(t, e) {
    const r = t[t.length - 1];
    for (let n = 1; n <= e; n++) {
        const i = MA(0, e, n);
        t.push(lo(r, 1, i))
    }
}

function lCt(t) {
    const e = [0];
    return cCt(e, t.length - 1), e
}

function uCt(t, e) {
    return t.map(r => r * e)
}

function fCt(t, e) {
    return t.map(() => e || jEe).splice(0, t.length - 1)
}

function FO({duration: t = 300, keyframes: e, times: r, ease: n = "easeInOut"}) {
    const i = GTt(n) ? n.map(qde) : qde(n), a = {done: !1, value: e[0]},
        o = uCt(r && r.length === e.length ? r : lCt(e), t), s = n3e(o, e, {ease: Array.isArray(i) ? i : fCt(e, i)});
    return {calculatedDuration: t, next: l => (a.value = s(l), a.done = l >= t, a)}
}

function i3e(t, e) {
    return e ? t * (1e3 / e) : 0
}

const dCt = 5;

function a3e(t, e, r) {
    const n = Math.max(e - dCt, 0);
    return i3e(r - t(n), e - n)
}

const nH = .001, hCt = .01, Yde = 10, pCt = .05, mCt = 1;

function vCt({duration: t = 800, bounce: e = .25, velocity: r = 0, mass: n = 1}) {
    let i, a;
    oI(t <= zy(Yde), "Spring duration must be 10 seconds or less");
    let o = 1 - e;
    o = r1(pCt, mCt, o), t = r1(hCt, Yde, Tv(t)), o < 1 ? (i = f => {
        const d = f * o, p = d * t, g = d - r, b = bK(f, o), S = Math.exp(-p);
        return nH - g / b * S
    }, a = f => {
        const p = f * o * t, g = p * r + r, b = Math.pow(o, 2) * Math.pow(f, 2) * t, S = Math.exp(-p),
            T = bK(Math.pow(f, 2), o);
        return (-i(f) + nH > 0 ? -1 : 1) * ((g - b) * S) / T
    }) : (i = f => {
        const d = Math.exp(-f * t), p = (f - r) * t + 1;
        return -nH + d * p
    }, a = f => {
        const d = Math.exp(-f * t), p = (r - f) * (t * t);
        return d * p
    });
    const s = 5 / t, l = yCt(i, a, s);
    if (t = zy(t), isNaN(l)) return {stiffness: 100, damping: 10, duration: t};
    {
        const f = Math.pow(l, 2) * n;
        return {stiffness: f, damping: o * 2 * Math.sqrt(n * f), duration: t}
    }
}

const gCt = 12;

function yCt(t, e, r) {
    let n = r;
    for (let i = 1; i < gCt; i++) n = n - t(n) / e(n);
    return n
}

function bK(t, e) {
    return t * Math.sqrt(1 - e * e)
}

const bCt = ["duration", "bounce"], wCt = ["stiffness", "damping", "mass"];

function Xde(t, e) {
    return e.some(r => t[r] !== void 0)
}

function SCt(t) {
    let e = {velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...t};
    if (!Xde(t, wCt) && Xde(t, bCt)) {
        const r = vCt(t);
        e = {...e, ...r, velocity: 0, mass: 1}, e.isResolvedFromDuration = !0
    }
    return e
}

function o3e({keyframes: t, restDelta: e, restSpeed: r, ...n}) {
    const i = t[0], a = t[t.length - 1], o = {done: !1, value: i}, {
            stiffness: s,
            damping: l,
            mass: f,
            velocity: d,
            duration: p,
            isResolvedFromDuration: g
        } = SCt(n), b = d ? -Tv(d) : 0, S = l / (2 * Math.sqrt(s * f)), T = a - i, I = Tv(Math.sqrt(s / f)),
        N = Math.abs(T) < 5;
    r || (r = N ? .01 : 2), e || (e = N ? .005 : .5);
    let P;
    if (S < 1) {
        const F = bK(I, S);
        P = V => {
            const Y = Math.exp(-S * I * V);
            return a - Y * ((b + S * I * T) / F * Math.sin(F * V) + T * Math.cos(F * V))
        }
    } else if (S === 1) P = F => a - Math.exp(-I * F) * (T + (b + I * T) * F); else {
        const F = I * Math.sqrt(S * S - 1);
        P = V => {
            const Y = Math.exp(-S * I * V), ee = Math.min(F * V, 300);
            return a - Y * ((b + S * I * T) * Math.sinh(ee) + F * T * Math.cosh(ee)) / F
        }
    }
    return {
        calculatedDuration: g && p || null, next: F => {
            const V = P(F);
            if (g) o.done = F >= p; else {
                let Y = b;
                F !== 0 && (S < 1 ? Y = a3e(P, F, V) : Y = 0);
                const ee = Math.abs(Y) <= r, oe = Math.abs(a - V) <= e;
                o.done = ee && oe
            }
            return o.value = o.done ? a : V, o
        }
    }
}

function Qde({
                 keyframes: t,
                 velocity: e = 0,
                 power: r = .8,
                 timeConstant: n = 325,
                 bounceDamping: i = 10,
                 bounceStiffness: a = 500,
                 modifyTarget: o,
                 min: s,
                 max: l,
                 restDelta: f = .5,
                 restSpeed: d
             }) {
    const p = t[0], g = {done: !1, value: p}, b = G => s !== void 0 && G < s || l !== void 0 && G > l,
        S = G => s === void 0 ? l : l === void 0 || Math.abs(s - G) < Math.abs(l - G) ? s : l;
    let T = r * e;
    const I = p + T, N = o === void 0 ? I : o(I);
    N !== I && (T = N - p);
    const P = G => -T * Math.exp(-G / n), F = G => N + P(G), V = G => {
        const J = P(G), ce = F(G);
        g.done = Math.abs(J) <= f, g.value = g.done ? N : ce
    };
    let Y, ee;
    const oe = G => {
        b(g.value) && (Y = G, ee = o3e({
            keyframes: [g.value, S(g.value)],
            velocity: a3e(F, G, g.value),
            damping: i,
            stiffness: a,
            restDelta: f,
            restSpeed: d
        }))
    };
    return oe(0), {
        calculatedDuration: null, next: G => {
            let J = !1;
            return !ee && Y === void 0 && (J = !0, V(G), oe(G)), Y !== void 0 && G > Y ? ee.next(G - Y) : (!J && V(G), g)
        }
    }
}

const _Ct = t => {
    const e = ({timestamp: r}) => t(r);
    return {
        start: () => Ta.update(e, !0),
        stop: () => jv(e),
        now: () => Ks.isProcessing ? Ks.timestamp : performance.now()
    }
}, Zde = 2e4;

function Jde(t) {
    let e = 0;
    const r = 50;
    let n = t.next(e);
    for (; !n.done && e < Zde;) e += r, n = t.next(e);
    return e >= Zde ? 1 / 0 : e
}

const xCt = {decay: Qde, inertia: Qde, tween: FO, keyframes: FO, spring: o3e};

function UO({
                autoplay: t = !0,
                delay: e = 0,
                driver: r = _Ct,
                keyframes: n,
                type: i = "keyframes",
                repeat: a = 0,
                repeatDelay: o = 0,
                repeatType: s = "loop",
                onPlay: l,
                onStop: f,
                onComplete: d,
                onUpdate: p,
                ...g
            }) {
    let b = 1, S = !1, T, I;
    const N = () => {
        I = new Promise(R => {
            T = R
        })
    };
    N();
    let P;
    const F = xCt[i] || FO;
    let V;
    F !== FO && typeof n[0] != "number" && (V = n3e([0, 100], n, {clamp: !1}), n = [0, 100]);
    const Y = F({...g, keyframes: n});
    let ee;
    s === "mirror" && (ee = F({...g, keyframes: [...n].reverse(), velocity: -(g.velocity || 0)}));
    let oe = "idle", G = null, J = null, ce = null;
    Y.calculatedDuration === null && a && (Y.calculatedDuration = Jde(Y));
    const {calculatedDuration: re} = Y;
    let M = 1 / 0, D = 1 / 0;
    re !== null && (M = re + o, D = M * (a + 1) - o);
    let x = 0;
    const A = R => {
        if (J === null) return;
        b > 0 && (J = Math.min(J, R)), b < 0 && (J = Math.min(R - D / b, J)), G !== null ? x = G : x = Math.round(R - J) * b;
        const k = x - e * (b >= 0 ? 1 : -1), Q = b >= 0 ? k < 0 : k > D;
        x = Math.max(k, 0), oe === "finished" && G === null && (x = D);
        let fe = x, ye = Y;
        if (a) {
            const Ce = x / M;
            let Me = Math.floor(Ce), ve = Ce % 1;
            !ve && Ce >= 1 && (ve = 1), ve === 1 && Me--, Me = Math.min(Me, a + 1);
            const ne = !!(Me % 2);
            ne && (s === "reverse" ? (ve = 1 - ve, o && (ve -= o / M)) : s === "mirror" && (ye = ee));
            let be = r1(0, 1, ve);
            x > D && (be = s === "reverse" && ne ? 1 : 0), fe = be * M
        }
        const ue = Q ? {done: !1, value: n[0]} : ye.next(fe);
        V && (ue.value = V(ue.value));
        let {done: me} = ue;
        !Q && re !== null && (me = b >= 0 ? x >= D : x <= 0);
        const Se = G === null && (oe === "finished" || oe === "running" && me);
        return p && p(ue.value), Se && j(), ue
    }, B = () => {
        P && P.stop(), P = void 0
    }, z = () => {
        oe = "idle", B(), T(), N(), J = ce = null
    }, j = () => {
        oe = "finished", d && d(), B(), T()
    }, $ = () => {
        if (S) return;
        P || (P = r(A));
        const R = P.now();
        l && l(), G !== null ? J = R - G : (!J || oe === "finished") && (J = R), oe === "finished" && N(), ce = J, G = null, oe = "running", P.start()
    };
    t && $();
    const C = {
        then(R, k) {
            return I.then(R, k)
        }, get time() {
            return Tv(x)
        }, set time(R) {
            R = zy(R), x = R, G !== null || !P || b === 0 ? G = R : J = P.now() - R / b
        }, get duration() {
            const R = Y.calculatedDuration === null ? Jde(Y) : Y.calculatedDuration;
            return Tv(R)
        }, get speed() {
            return b
        }, set speed(R) {
            R === b || !P || (b = R, C.time = Tv(x))
        }, get state() {
            return oe
        }, play: $, pause: () => {
            oe = "paused", G = x
        }, stop: () => {
            S = !0, oe !== "idle" && (oe = "idle", f && f(), z())
        }, cancel: () => {
            ce !== null && A(ce), z()
        }, complete: () => {
            oe = "finished"
        }, sample: R => (J = 0, A(R))
    };
    return C
}

function ECt(t) {
    let e;
    return () => (e === void 0 && (e = t()), e)
}

const TCt = ECt(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
    CCt = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]), O7 = 10, ACt = 2e4,
    ICt = (t, e) => e.type === "spring" || t === "backgroundColor" || !BEe(e.ease);

function kCt(t, e, {onUpdate: r, onComplete: n, ...i}) {
    if (!(TCt() && CCt.has(e) && !i.repeatDelay && i.repeatType !== "mirror" && i.damping !== 0 && i.type !== "inertia")) return !1;
    let o = !1, s, l;
    const f = () => {
        l = new Promise(P => {
            s = P
        })
    };
    f();
    let {keyframes: d, duration: p = 300, ease: g, times: b} = i;
    if (ICt(e, i)) {
        const P = UO({...i, repeat: 0, delay: 0});
        let F = {done: !1, value: d[0]};
        const V = [];
        let Y = 0;
        for (; !F.done && Y < ACt;) F = P.sample(Y), V.push(F.value), Y += O7;
        b = void 0, d = V, p = Y - O7, g = "linear"
    }
    const S = UTt(t.owner.current, e, d, {...i, duration: p, ease: g, times: b});
    i.syncStart && (S.startTime = Ks.isProcessing ? Ks.timestamp : document.timeline ? document.timeline.currentTime : performance.now());
    const T = () => S.cancel(), I = () => {
        Ta.update(T), s(), f()
    };
    return S.onfinish = () => {
        t.set(jTt(d, i)), n && n(), I()
    }, {
        then(P, F) {
            return l.then(P, F)
        }, attachTimeline(P) {
            return S.timeline = P, S.onfinish = null, Ao
        }, get time() {
            return Tv(S.currentTime || 0)
        }, set time(P) {
            S.currentTime = zy(P)
        }, get speed() {
            return S.playbackRate
        }, set speed(P) {
            S.playbackRate = P
        }, get duration() {
            return Tv(p)
        }, play: () => {
            o || (S.play(), jv(T))
        }, pause: () => S.pause(), stop: () => {
            if (o = !0, S.playState === "idle") return;
            const {currentTime: P} = S;
            if (P) {
                const F = UO({...i, autoplay: !1});
                t.setWithVelocity(F.sample(P - O7).value, F.sample(P).value, O7)
            }
            I()
        }, complete: () => S.finish(), cancel: I
    }
}

function RCt({keyframes: t, delay: e, onUpdate: r, onComplete: n}) {
    const i = () => (r && r(t[t.length - 1]), n && n(), {
        time: 0,
        speed: 1,
        duration: 0,
        play: Ao,
        pause: Ao,
        stop: Ao,
        then: a => (a(), Promise.resolve()),
        cancel: Ao,
        complete: Ao
    });
    return e ? UO({keyframes: [0, 1], duration: 0, delay: e, onComplete: i}) : i()
}

const DCt = {type: "spring", stiffness: 500, damping: 25, restSpeed: 10},
    MCt = t => ({type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10}),
    OCt = {type: "keyframes", duration: .8}, PCt = {type: "keyframes", ease: [.25, .1, .35, 1], duration: .3},
    NCt = (t, {keyframes: e}) => e.length > 2 ? OCt : KS.has(t) ? t.startsWith("scale") ? MCt(e[1]) : DCt : PCt,
    wK = (t, e) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (n1.test(e) || e === "0") && !e.startsWith("url(")),
    LCt = new Set(["brightness", "contrast", "saturate", "opacity"]);

function BCt(t) {
    const [e, r] = t.slice(0, -1).split("(");
    if (e === "drop-shadow") return t;
    const [n] = r.match(sL) || [];
    if (!n) return t;
    const i = r.replace(n, "");
    let a = LCt.has(e) ? 1 : 0;
    return n !== r && (a *= 100), e + "(" + a + i + ")"
}

const $Ct = /([a-z-]*)\(.*?\)/g, SK = {
    ...n1, getAnimatableNone: t => {
        const e = t.match($Ct);
        return e ? e.map(BCt).join(" ") : t
    }
}, FCt = {
    ...wEe,
    color: eu,
    backgroundColor: eu,
    outlineColor: eu,
    fill: eu,
    stroke: eu,
    borderColor: eu,
    borderTopColor: eu,
    borderRightColor: eu,
    borderBottomColor: eu,
    borderLeftColor: eu,
    filter: SK,
    WebkitFilter: SK
}, CJ = t => FCt[t];

function s3e(t, e) {
    let r = CJ(t);
    return r !== SK && (r = n1), r.getAnimatableNone ? r.getAnimatableNone(e) : void 0
}

const c3e = t => /^0[^.\s]+$/.test(t);

function UCt(t) {
    if (typeof t == "number") return t === 0;
    if (t !== null) return t === "none" || t === "0" || c3e(t)
}

function jCt(t, e, r, n) {
    const i = wK(e, r);
    let a;
    Array.isArray(r) ? a = [...r] : a = [null, r];
    const o = n.from !== void 0 ? n.from : t.get();
    let s;
    const l = [];
    for (let f = 0; f < a.length; f++) a[f] === null && (a[f] = f === 0 ? o : a[f - 1]), UCt(a[f]) && l.push(f), typeof a[f] == "string" && a[f] !== "none" && a[f] !== "0" && (s = a[f]);
    if (i && l.length && s) for (let f = 0; f < l.length; f++) {
        const d = l[f];
        a[d] = s3e(e, s)
    }
    return a
}

function zCt({
                 when: t,
                 delay: e,
                 delayChildren: r,
                 staggerChildren: n,
                 staggerDirection: i,
                 repeat: a,
                 repeatType: o,
                 repeatDelay: s,
                 from: l,
                 elapsed: f,
                 ...d
             }) {
    return !!Object.keys(d).length
}

function l3e(t, e) {
    return t[e] || t.default || t
}

const AJ = (t, e, r, n = {}) => i => {
    const a = l3e(n, t) || {}, o = a.delay || n.delay || 0;
    let {elapsed: s = 0} = n;
    s = s - zy(o);
    const l = jCt(e, t, r, a), f = l[0], d = l[l.length - 1], p = wK(t, f), g = wK(t, d);
    oI(p === g, `You are trying to animate ${t} from "${f}" to "${d}". ${f} is not an animatable value - to enable this animation set ${f} to a value animatable to ${d} via the \`style\` property.`);
    let b = {
        keyframes: l, velocity: e.getVelocity(), ease: "easeOut", ...a, delay: -s, onUpdate: S => {
            e.set(S), a.onUpdate && a.onUpdate(S)
        }, onComplete: () => {
            i(), a.onComplete && a.onComplete()
        }
    };
    if (zCt(a) || (b = {...b, ...NCt(t, b)}), b.duration && (b.duration = zy(b.duration)), b.repeatDelay && (b.repeatDelay = zy(b.repeatDelay)), !p || !g || FTt.current || a.type === !1) return RCt(b);
    if (e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
        const S = kCt(e, t, b);
        if (S) return S
    }
    return UO(b)
};

function jO(t) {
    return !!(uf(t) && t.add)
}

const u3e = t => /^\-?\d*\.?\d+$/.test(t);

function IJ(t, e) {
    t.indexOf(e) === -1 && t.push(e)
}

function kJ(t, e) {
    const r = t.indexOf(e);
    r > -1 && t.splice(r, 1)
}

class RJ {
    constructor() {
        this.subscriptions = []
    }

    add(e) {
        return IJ(this.subscriptions, e), () => kJ(this.subscriptions, e)
    }

    notify(e, r, n) {
        const i = this.subscriptions.length;
        if (i) if (i === 1) this.subscriptions[0](e, r, n); else for (let a = 0; a < i; a++) {
            const o = this.subscriptions[a];
            o && o(e, r, n)
        }
    }

    getSize() {
        return this.subscriptions.length
    }

    clear() {
        this.subscriptions.length = 0
    }
}

const ehe = new Set;

function DJ(t, e, r) {
    t || ehe.has(e) || (console.warn(e), r && console.warn(r), ehe.add(e))
}

const VCt = t => !isNaN(parseFloat(t)), the = {current: void 0};

class HCt {
    constructor(e, r = {}) {
        this.version = "10.16.4", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (n, i = !0) => {
            this.prev = this.current, this.current = n;
            const {delta: a, timestamp: o} = Ks;
            this.lastUpdated !== o && (this.timeDelta = a, this.lastUpdated = o, Ta.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), i && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }, this.scheduleVelocityCheck = () => Ta.postRender(this.velocityCheck), this.velocityCheck = ({timestamp: n}) => {
            n !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
        }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = VCt(this.current), this.owner = r.owner
    }

    onChange(e) {
        return Ve.env.NODE_ENV !== "production" && DJ(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e)
    }

    on(e, r) {
        this.events[e] || (this.events[e] = new RJ);
        const n = this.events[e].add(r);
        return e === "change" ? () => {
            n(), Ta.read(() => {
                this.events.change.getSize() || this.stop()
            })
        } : n
    }

    clearListeners() {
        for (const e in this.events) this.events[e].clear()
    }

    attach(e, r) {
        this.passiveEffect = e, this.stopPassiveEffect = r
    }

    set(e, r = !0) {
        !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify)
    }

    setWithVelocity(e, r, n) {
        this.set(r), this.prev = e, this.timeDelta = n
    }

    jump(e) {
        this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }

    get() {
        return the.current && the.current.push(this), this.current
    }

    getPrevious() {
        return this.prev
    }

    getVelocity() {
        return this.canTrackVelocity ? i3e(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
    }

    start(e) {
        return this.stop(), new Promise(r => {
            this.hasAnimated = !0, this.animation = e(r), this.events.animationStart && this.events.animationStart.notify()
        }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
        })
    }

    stop() {
        this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }

    isAnimating() {
        return !!this.animation
    }

    clearAnimation() {
        delete this.animation
    }

    destroy() {
        this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
}

function nE(t, e) {
    return new HCt(t, e)
}

const f3e = t => e => e.test(t), WCt = {test: t => t === "auto", parse: t => t}, d3e = [YS, nn, L0, my, J5t, Z5t, WCt],
    oT = t => d3e.find(f3e(t)), qCt = [...d3e, eu, n1], GCt = t => qCt.find(f3e(t));

function KCt(t, e, r) {
    t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, nE(r))
}

function YCt(t, e) {
    const r = lL(t, e);
    let {transitionEnd: n = {}, transition: i = {}, ...a} = r ? t.makeTargetAnimatable(r, !1) : {};
    a = {...a, ...n};
    for (const o in a) {
        const s = hTt(a[o]);
        KCt(t, o, s)
    }
}

function XCt(t, e, r) {
    var n, i;
    const a = Object.keys(e).filter(s => !t.hasValue(s)), o = a.length;
    if (o) for (let s = 0; s < o; s++) {
        const l = a[s], f = e[l];
        let d = null;
        Array.isArray(f) && (d = f[0]), d === null && (d = (i = (n = r[l]) !== null && n !== void 0 ? n : t.readValue(l)) !== null && i !== void 0 ? i : e[l]), d != null && (typeof d == "string" && (u3e(d) || c3e(d)) ? d = parseFloat(d) : !GCt(d) && n1.test(f) && (d = s3e(l, f)), t.addValue(l, nE(d, {owner: t})), r[l] === void 0 && (r[l] = d), d !== null && t.setBaseTarget(l, d))
    }
}

function QCt(t, e) {
    return e ? (e[t] || e.default || e).from : void 0
}

function ZCt(t, e, r) {
    const n = {};
    for (const i in t) {
        const a = QCt(i, e);
        if (a !== void 0) n[i] = a; else {
            const o = r.getValue(i);
            o && (n[i] = o.get())
        }
    }
    return n
}

function JCt({protectedKeys: t, needsAnimating: e}, r) {
    const n = t.hasOwnProperty(r) && e[r] !== !0;
    return e[r] = !1, n
}

function h3e(t, e, {delay: r = 0, transitionOverride: n, type: i} = {}) {
    let {transition: a = t.getDefaultTransition(), transitionEnd: o, ...s} = t.makeTargetAnimatable(e);
    const l = t.getValue("willChange");
    n && (a = n);
    const f = [], d = i && t.animationState && t.animationState.getState()[i];
    for (const p in s) {
        const g = t.getValue(p), b = s[p];
        if (!g || b === void 0 || d && JCt(d, p)) continue;
        const S = {delay: r, elapsed: 0, ...a};
        if (window.HandoffAppearAnimations && !g.hasAnimated) {
            const I = t.getProps()[$Tt];
            I && (S.elapsed = window.HandoffAppearAnimations(I, p, g, Ta), S.syncStart = !0)
        }
        g.start(AJ(p, g, b, t.shouldReduceMotion && KS.has(p) ? {type: !1} : S));
        const T = g.animation;
        jO(l) && (l.add(p), T.then(() => l.remove(p))), f.push(T)
    }
    return o && Promise.all(f).then(() => {
        o && YCt(t, o)
    }), f
}

function _K(t, e, r = {}) {
    const n = lL(t, e, r.custom);
    let {transition: i = t.getDefaultTransition() || {}} = n || {};
    r.transitionOverride && (i = r.transitionOverride);
    const a = n ? () => Promise.all(h3e(t, n, r)) : () => Promise.resolve(),
        o = t.variantChildren && t.variantChildren.size ? (l = 0) => {
            const {delayChildren: f = 0, staggerChildren: d, staggerDirection: p} = i;
            return eAt(t, e, f + l, d, p, r)
        } : () => Promise.resolve(), {when: s} = i;
    if (s) {
        const [l, f] = s === "beforeChildren" ? [a, o] : [o, a];
        return l().then(() => f())
    } else return Promise.all([a(), o(r.delay)])
}

function eAt(t, e, r = 0, n = 0, i = 1, a) {
    const o = [], s = (t.variantChildren.size - 1) * n, l = i === 1 ? (f = 0) => f * n : (f = 0) => s - f * n;
    return Array.from(t.variantChildren).sort(tAt).forEach((f, d) => {
        f.notify("AnimationStart", e), o.push(_K(f, e, {
            ...a,
            delay: r + l(d)
        }).then(() => f.notify("AnimationComplete", e)))
    }), Promise.all(o)
}

function tAt(t, e) {
    return t.sortNodePosition(e)
}

function rAt(t, e, r = {}) {
    t.notify("AnimationStart", e);
    let n;
    if (Array.isArray(e)) {
        const i = e.map(a => _K(t, a, r));
        n = Promise.all(i)
    } else if (typeof e == "string") n = _K(t, e, r); else {
        const i = typeof e == "function" ? lL(t, e, r.custom) : e;
        n = Promise.all(h3e(t, i, r))
    }
    return n.then(() => t.notify("AnimationComplete", e))
}

const nAt = [...dJ].reverse(), iAt = dJ.length;

function aAt(t) {
    return e => Promise.all(e.map(({animation: r, options: n}) => rAt(t, r, n)))
}

function oAt(t) {
    let e = aAt(t);
    const r = cAt();
    let n = !0;
    const i = (l, f) => {
        const d = lL(t, f);
        if (d) {
            const {transition: p, transitionEnd: g, ...b} = d;
            l = {...l, ...b, ...g}
        }
        return l
    };

    function a(l) {
        e = l(t)
    }

    function o(l, f) {
        const d = t.getProps(), p = t.getVariantContext(!0) || {}, g = [], b = new Set;
        let S = {}, T = 1 / 0;
        for (let N = 0; N < iAt; N++) {
            const P = nAt[N], F = r[P], V = d[P] !== void 0 ? d[P] : p[P], Y = RA(V), ee = P === f ? F.isActive : null;
            ee === !1 && (T = N);
            let oe = V === p[P] && V !== d[P] && Y;
            if (oe && n && t.manuallyAnimateOnMount && (oe = !1), F.protectedKeys = {...S}, !F.isActive && ee === null || !V && !F.prevProp || aL(V) || typeof V == "boolean") continue;
            const G = sAt(F.prevProp, V);
            let J = G || P === f && F.isActive && !oe && Y || N > T && Y;
            const ce = Array.isArray(V) ? V : [V];
            let re = ce.reduce(i, {});
            ee === !1 && (re = {});
            const {prevResolvedValues: M = {}} = F, D = {...M, ...re}, x = A => {
                J = !0, b.delete(A), F.needsAnimating[A] = !0
            };
            for (const A in D) {
                const B = re[A], z = M[A];
                S.hasOwnProperty(A) || (B !== z ? BO(B) && BO(z) ? !NEe(B, z) || G ? x(A) : F.protectedKeys[A] = !0 : B !== void 0 ? x(A) : b.add(A) : B !== void 0 && b.has(A) ? x(A) : F.protectedKeys[A] = !0)
            }
            F.prevProp = V, F.prevResolvedValues = re, F.isActive && (S = {...S, ...re}), n && t.blockInitialAnimation && (J = !1), J && !oe && g.push(...ce.map(A => ({
                animation: A,
                options: {type: P, ...l}
            })))
        }
        if (b.size) {
            const N = {};
            b.forEach(P => {
                const F = t.getBaseTarget(P);
                F !== void 0 && (N[P] = F)
            }), g.push({animation: N})
        }
        let I = !!g.length;
        return n && d.initial === !1 && !t.manuallyAnimateOnMount && (I = !1), n = !1, I ? e(g) : Promise.resolve()
    }

    function s(l, f, d) {
        var p;
        if (r[l].isActive === f) return Promise.resolve();
        (p = t.variantChildren) === null || p === void 0 || p.forEach(b => {
            var S;
            return (S = b.animationState) === null || S === void 0 ? void 0 : S.setActive(l, f)
        }), r[l].isActive = f;
        const g = o(d, l);
        for (const b in r) r[b].protectedKeys = {};
        return g
    }

    return {animateChanges: o, setActive: s, setAnimateFunction: a, getState: () => r}
}

function sAt(t, e) {
    return typeof e == "string" ? e !== t : Array.isArray(e) ? !NEe(e, t) : !1
}

function Xb(t = !1) {
    return {isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {}}
}

function cAt() {
    return {
        animate: Xb(!0),
        whileInView: Xb(),
        whileHover: Xb(),
        whileTap: Xb(),
        whileDrag: Xb(),
        whileFocus: Xb(),
        exit: Xb()
    }
}

class lAt extends x1 {
    constructor(e) {
        super(e), e.animationState || (e.animationState = oAt(e))
    }

    updateAnimationControlsSubscription() {
        const {animate: e} = this.node.getProps();
        this.unmount(), aL(e) && (this.unmount = e.subscribe(this.node))
    }

    mount() {
        this.updateAnimationControlsSubscription()
    }

    update() {
        const {animate: e} = this.node.getProps(), {animate: r} = this.node.prevProps || {};
        e !== r && this.updateAnimationControlsSubscription()
    }

    unmount() {
    }
}

let uAt = 0;

class fAt extends x1 {
    constructor() {
        super(...arguments), this.id = uAt++
    }

    update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: e,
            onExitComplete: r,
            custom: n
        } = this.node.presenceContext, {isPresent: i} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === i) return;
        const a = this.node.animationState.setActive("exit", !e, {custom: n ?? this.node.getProps().custom});
        r && !e && a.then(() => r(this.id))
    }

    mount() {
        const {register: e} = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }

    unmount() {
    }
}

const dAt = {animation: {Feature: lAt}, exit: {Feature: fAt}}, rhe = (t, e) => Math.abs(t - e);

function hAt(t, e) {
    const r = rhe(t.x, e.x), n = rhe(t.y, e.y);
    return Math.sqrt(r ** 2 + n ** 2)
}

class p3e {
    constructor(e, r, {transformPagePoint: n} = {}) {
        if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
            const f = aH(this.lastMoveEventInfo, this.history), d = this.startEvent !== null,
                p = hAt(f.offset, {x: 0, y: 0}) >= 3;
            if (!d && !p) return;
            const {point: g} = f, {timestamp: b} = Ks;
            this.history.push({...g, timestamp: b});
            const {onStart: S, onMove: T} = this.handlers;
            d || (S && S(this.lastMoveEvent, f), this.startEvent = this.lastMoveEvent), T && T(this.lastMoveEvent, f)
        }, this.handlePointerMove = (f, d) => {
            this.lastMoveEvent = f, this.lastMoveEventInfo = iH(d, this.transformPagePoint), Ta.update(this.updatePoint, !0)
        }, this.handlePointerUp = (f, d) => {
            if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
            const {onEnd: p, onSessionEnd: g} = this.handlers,
                b = aH(f.type === "pointercancel" ? this.lastMoveEventInfo : iH(d, this.transformPagePoint), this.history);
            this.startEvent && p && p(f, b), g && g(f, b)
        }, !REe(e)) return;
        this.handlers = r, this.transformPagePoint = n;
        const i = cL(e), a = iH(i, this.transformPagePoint), {point: o} = a, {timestamp: s} = Ks;
        this.history = [{...o, timestamp: s}];
        const {onSessionStart: l} = r;
        l && l(e, aH(a, this.history)), this.removeListeners = jy(Ev(window, "pointermove", this.handlePointerMove), Ev(window, "pointerup", this.handlePointerUp), Ev(window, "pointercancel", this.handlePointerUp))
    }

    updateHandlers(e) {
        this.handlers = e
    }

    end() {
        this.removeListeners && this.removeListeners(), jv(this.updatePoint)
    }
}

function iH(t, e) {
    return e ? {point: e(t.point)} : t
}

function nhe(t, e) {
    return {x: t.x - e.x, y: t.y - e.y}
}

function aH({point: t}, e) {
    return {point: t, delta: nhe(t, m3e(e)), offset: nhe(t, pAt(e)), velocity: mAt(e, .1)}
}

function pAt(t) {
    return t[0]
}

function m3e(t) {
    return t[t.length - 1]
}

function mAt(t, e) {
    if (t.length < 2) return {x: 0, y: 0};
    let r = t.length - 1, n = null;
    const i = m3e(t);
    for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > zy(e)));) r--;
    if (!n) return {x: 0, y: 0};
    const a = Tv(i.timestamp - n.timestamp);
    if (a === 0) return {x: 0, y: 0};
    const o = {x: (i.x - n.x) / a, y: (i.y - n.y) / a};
    return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}

function Gf(t) {
    return t.max - t.min
}

function xK(t, e = 0, r = .01) {
    return Math.abs(t - e) <= r
}

function ihe(t, e, r, n = .5) {
    t.origin = n, t.originPoint = lo(e.min, e.max, t.origin), t.scale = Gf(r) / Gf(e), (xK(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = lo(r.min, r.max, t.origin) - t.originPoint, (xK(t.translate) || isNaN(t.translate)) && (t.translate = 0)
}

function gC(t, e, r, n) {
    ihe(t.x, e.x, r.x, n ? n.originX : void 0), ihe(t.y, e.y, r.y, n ? n.originY : void 0)
}

function ahe(t, e, r) {
    t.min = r.min + e.min, t.max = t.min + Gf(e)
}

function vAt(t, e, r) {
    ahe(t.x, e.x, r.x), ahe(t.y, e.y, r.y)
}

function ohe(t, e, r) {
    t.min = e.min - r.min, t.max = t.min + Gf(e)
}

function yC(t, e, r) {
    ohe(t.x, e.x, r.x), ohe(t.y, e.y, r.y)
}

function gAt(t, {min: e, max: r}, n) {
    return e !== void 0 && t < e ? t = n ? lo(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? lo(r, t, n.max) : Math.min(t, r)), t
}

function she(t, e, r) {
    return {min: e !== void 0 ? t.min + e : void 0, max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0}
}

function yAt(t, {top: e, left: r, bottom: n, right: i}) {
    return {x: she(t.x, r, i), y: she(t.y, e, n)}
}

function che(t, e) {
    let r = e.min - t.min, n = e.max - t.max;
    return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), {min: r, max: n}
}

function bAt(t, e) {
    return {x: che(t.x, e.x), y: che(t.y, e.y)}
}

function wAt(t, e) {
    let r = .5;
    const n = Gf(t), i = Gf(e);
    return i > n ? r = MA(e.min, e.max - n, t.min) : n > i && (r = MA(t.min, t.max - i, e.min)), r1(0, 1, r)
}

function SAt(t, e) {
    const r = {};
    return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r
}

const EK = .35;

function _At(t = EK) {
    return t === !1 ? t = 0 : t === !0 && (t = EK), {x: lhe(t, "left", "right"), y: lhe(t, "top", "bottom")}
}

function lhe(t, e, r) {
    return {min: uhe(t, e), max: uhe(t, r)}
}

function uhe(t, e) {
    return typeof t == "number" ? t : t[e] || 0
}

const fhe = () => ({translate: 0, scale: 1, origin: 0, originPoint: 0}), Fx = () => ({x: fhe(), y: fhe()}),
    dhe = () => ({min: 0, max: 0}), ns = () => ({x: dhe(), y: dhe()});

function p0(t) {
    return [t("x"), t("y")]
}

function v3e({top: t, left: e, right: r, bottom: n}) {
    return {x: {min: e, max: r}, y: {min: t, max: n}}
}

function xAt({x: t, y: e}) {
    return {top: e.min, right: t.max, bottom: e.max, left: t.min}
}

function EAt(t, e) {
    if (!e) return t;
    const r = e({x: t.left, y: t.top}), n = e({x: t.right, y: t.bottom});
    return {top: r.y, left: r.x, bottom: n.y, right: n.x}
}

function oH(t) {
    return t === void 0 || t === 1
}

function TK({scale: t, scaleX: e, scaleY: r}) {
    return !oH(t) || !oH(e) || !oH(r)
}

function iw(t) {
    return TK(t) || g3e(t) || t.z || t.rotate || t.rotateX || t.rotateY
}

function g3e(t) {
    return hhe(t.x) || hhe(t.y)
}

function hhe(t) {
    return t && t !== "0%"
}

function zO(t, e, r) {
    const n = t - r, i = e * n;
    return r + i
}

function phe(t, e, r, n, i) {
    return i !== void 0 && (t = zO(t, i, n)), zO(t, r, n) + e
}

function CK(t, e = 0, r = 1, n, i) {
    t.min = phe(t.min, e, r, n, i), t.max = phe(t.max, e, r, n, i)
}

function y3e(t, {x: e, y: r}) {
    CK(t.x, e.translate, e.scale, e.originPoint), CK(t.y, r.translate, r.scale, r.originPoint)
}

function TAt(t, e, r, n = !1) {
    const i = r.length;
    if (!i) return;
    e.x = e.y = 1;
    let a, o;
    for (let s = 0; s < i; s++) {
        a = r[s], o = a.projectionDelta;
        const l = a.instance;
        l && l.style && l.style.display === "contents" || (n && a.options.layoutScroll && a.scroll && a !== a.root && Ux(t, {
            x: -a.scroll.offset.x,
            y: -a.scroll.offset.y
        }), o && (e.x *= o.x.scale, e.y *= o.y.scale, y3e(t, o)), n && iw(a.latestValues) && Ux(t, a.latestValues))
    }
    e.x = mhe(e.x), e.y = mhe(e.y)
}

function mhe(t) {
    return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1
}

function by(t, e) {
    t.min = t.min + e, t.max = t.max + e
}

function vhe(t, e, [r, n, i]) {
    const a = e[i] !== void 0 ? e[i] : .5, o = lo(t.min, t.max, a);
    CK(t, e[r], e[n], o, e.scale)
}

const CAt = ["x", "scaleX", "originX"], AAt = ["y", "scaleY", "originY"];

function Ux(t, e) {
    vhe(t.x, e, CAt), vhe(t.y, e, AAt)
}

function b3e(t, e) {
    return v3e(EAt(t.getBoundingClientRect(), e))
}

function IAt(t, e, r) {
    const n = b3e(t, r), {scroll: i} = e;
    return i && (by(n.x, i.offset.x), by(n.y, i.offset.y)), n
}

const kAt = new WeakMap;

class RAt {
    constructor(e) {
        this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
        }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ns(), this.visualElement = e
    }

    start(e, {snapToCursor: r = !1} = {}) {
        const {presenceContext: n} = this.visualElement;
        if (n && n.isPresent === !1) return;
        const i = l => {
            this.stopAnimation(), r && this.snapToCursor(cL(l, "page").point)
        }, a = (l, f) => {
            const {drag: d, dragPropagation: p, onDragStart: g} = this.getProps();
            if (d && !p && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = MEe(d), !this.openGlobalLock)) return;
            this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), p0(S => {
                let T = this.getAxisMotionValue(S).get() || 0;
                if (L0.test(T)) {
                    const {projection: I} = this.visualElement;
                    if (I && I.layout) {
                        const N = I.layout.layoutBox[S];
                        N && (T = Gf(N) * (parseFloat(T) / 100))
                    }
                }
                this.originPoint[S] = T
            }), g && Ta.update(() => g(l, f), !1, !0);
            const {animationState: b} = this.visualElement;
            b && b.setActive("whileDrag", !0)
        }, o = (l, f) => {
            const {dragPropagation: d, dragDirectionLock: p, onDirectionLock: g, onDrag: b} = this.getProps();
            if (!d && !this.openGlobalLock) return;
            const {offset: S} = f;
            if (p && this.currentDirection === null) {
                this.currentDirection = DAt(S), this.currentDirection !== null && g && g(this.currentDirection);
                return
            }
            this.updateAxis("x", f.point, S), this.updateAxis("y", f.point, S), this.visualElement.render(), b && b(l, f)
        }, s = (l, f) => this.stop(l, f);
        this.panSession = new p3e(e, {
            onSessionStart: i,
            onStart: a,
            onMove: o,
            onSessionEnd: s
        }, {transformPagePoint: this.visualElement.getTransformPagePoint()})
    }

    stop(e, r) {
        const n = this.isDragging;
        if (this.cancel(), !n) return;
        const {velocity: i} = r;
        this.startAnimation(i);
        const {onDragEnd: a} = this.getProps();
        a && Ta.update(() => a(e, r))
    }

    cancel() {
        this.isDragging = !1;
        const {projection: e, animationState: r} = this.visualElement;
        e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
        const {dragPropagation: n} = this.getProps();
        !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), r && r.setActive("whileDrag", !1)
    }

    updateAxis(e, r, n) {
        const {drag: i} = this.getProps();
        if (!n || !P7(e, i, this.currentDirection)) return;
        const a = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + n[e];
        this.constraints && this.constraints[e] && (o = gAt(o, this.constraints[e], this.elastic[e])), a.set(o)
    }

    resolveConstraints() {
        const {dragConstraints: e, dragElastic: r} = this.getProps(), {layout: n} = this.visualElement.projection || {},
            i = this.constraints;
        e && Bx(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && n ? this.constraints = yAt(n.layoutBox, e) : this.constraints = !1, this.elastic = _At(r), i !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && p0(a => {
            this.getAxisMotionValue(a) && (this.constraints[a] = SAt(n.layoutBox[a], this.constraints[a]))
        })
    }

    resolveRefConstraints() {
        const {dragConstraints: e, onMeasureDragConstraints: r} = this.getProps();
        if (!e || !Bx(e)) return !1;
        const n = e.current;
        vp(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
        const {projection: i} = this.visualElement;
        if (!i || !i.layout) return !1;
        const a = IAt(n, i.root, this.visualElement.getTransformPagePoint());
        let o = bAt(i.layout.layoutBox, a);
        if (r) {
            const s = r(xAt(o));
            this.hasMutatedConstraints = !!s, s && (o = v3e(s))
        }
        return o
    }

    startAnimation(e) {
        const {
            drag: r,
            dragMomentum: n,
            dragElastic: i,
            dragTransition: a,
            dragSnapToOrigin: o,
            onDragTransitionEnd: s
        } = this.getProps(), l = this.constraints || {}, f = p0(d => {
            if (!P7(d, r, this.currentDirection)) return;
            let p = l && l[d] || {};
            o && (p = {min: 0, max: 0});
            const g = i ? 200 : 1e6, b = i ? 40 : 1e7, S = {
                type: "inertia",
                velocity: n ? e[d] : 0,
                bounceStiffness: g,
                bounceDamping: b,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10, ...a, ...p
            };
            return this.startAxisValueAnimation(d, S)
        });
        return Promise.all(f).then(s)
    }

    startAxisValueAnimation(e, r) {
        const n = this.getAxisMotionValue(e);
        return n.start(AJ(e, n, 0, r))
    }

    stopAnimation() {
        p0(e => this.getAxisMotionValue(e).stop())
    }

    getAxisMotionValue(e) {
        const r = "_drag" + e.toUpperCase(), n = this.visualElement.getProps(), i = n[r];
        return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
    }

    snapToCursor(e) {
        p0(r => {
            const {drag: n} = this.getProps();
            if (!P7(r, n, this.currentDirection)) return;
            const {projection: i} = this.visualElement, a = this.getAxisMotionValue(r);
            if (i && i.layout) {
                const {min: o, max: s} = i.layout.layoutBox[r];
                a.set(e[r] - lo(o, s, .5))
            }
        })
    }

    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const {drag: e, dragConstraints: r} = this.getProps(), {projection: n} = this.visualElement;
        if (!Bx(r) || !n || !this.constraints) return;
        this.stopAnimation();
        const i = {x: 0, y: 0};
        p0(o => {
            const s = this.getAxisMotionValue(o);
            if (s) {
                const l = s.get();
                i[o] = wAt({min: l, max: l}, this.constraints[o])
            }
        });
        const {transformTemplate: a} = this.visualElement.getProps();
        this.visualElement.current.style.transform = a ? a({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), p0(o => {
            if (!P7(o, e, null)) return;
            const s = this.getAxisMotionValue(o), {min: l, max: f} = this.constraints[o];
            s.set(lo(l, f, i[o]))
        })
    }

    addListeners() {
        if (!this.visualElement.current) return;
        kAt.set(this.visualElement, this);
        const e = this.visualElement.current, r = Ev(e, "pointerdown", l => {
            const {drag: f, dragListener: d = !0} = this.getProps();
            f && d && this.start(l)
        }), n = () => {
            const {dragConstraints: l} = this.getProps();
            Bx(l) && (this.constraints = this.resolveRefConstraints())
        }, {projection: i} = this.visualElement, a = i.addEventListener("measure", n);
        i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), n();
        const o = pv(window, "resize", () => this.scalePositionWithinConstraints()),
            s = i.addEventListener("didUpdate", ({delta: l, hasLayoutChanged: f}) => {
                this.isDragging && f && (p0(d => {
                    const p = this.getAxisMotionValue(d);
                    p && (this.originPoint[d] += l[d].translate, p.set(p.get() + l[d].translate))
                }), this.visualElement.render())
            });
        return () => {
            o(), r(), a(), s && s()
        }
    }

    getProps() {
        const e = this.visualElement.getProps(), {
            drag: r = !1,
            dragDirectionLock: n = !1,
            dragPropagation: i = !1,
            dragConstraints: a = !1,
            dragElastic: o = EK,
            dragMomentum: s = !0
        } = e;
        return {
            ...e,
            drag: r,
            dragDirectionLock: n,
            dragPropagation: i,
            dragConstraints: a,
            dragElastic: o,
            dragMomentum: s
        }
    }
}

function P7(t, e, r) {
    return (e === !0 || e === t) && (r === null || r === t)
}

function DAt(t, e = 10) {
    let r = null;
    return Math.abs(t.y) > e ? r = "y" : Math.abs(t.x) > e && (r = "x"), r
}

class MAt extends x1 {
    constructor(e) {
        super(e), this.removeGroupControls = Ao, this.removeListeners = Ao, this.controls = new RAt(e)
    }

    mount() {
        const {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Ao
    }

    unmount() {
        this.removeGroupControls(), this.removeListeners()
    }
}

const ghe = t => (e, r) => {
    t && Ta.update(() => t(e, r))
};

class OAt extends x1 {
    constructor() {
        super(...arguments), this.removePointerDownListener = Ao
    }

    onPointerDown(e) {
        this.session = new p3e(e, this.createPanHandlers(), {transformPagePoint: this.node.getTransformPagePoint()})
    }

    createPanHandlers() {
        const {onPanSessionStart: e, onPanStart: r, onPan: n, onPanEnd: i} = this.node.getProps();
        return {
            onSessionStart: ghe(e), onStart: ghe(r), onMove: n, onEnd: (a, o) => {
                delete this.session, i && Ta.update(() => i(a, o))
            }
        }
    }

    mount() {
        this.removePointerDownListener = Ev(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }

    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }

    unmount() {
        this.removePointerDownListener(), this.session && this.session.end()
    }
}

function w3e() {
    const t = W.useContext(rI);
    if (t === null) return [!0, null];
    const {isPresent: e, onExitComplete: r, register: n} = t, i = W.useId();
    return W.useEffect(() => n(i), []), !e && r ? [!1, () => r && r(i)] : [!0]
}

function PAt() {
    return NAt(W.useContext(rI))
}

function NAt(t) {
    return t === null ? !0 : t.isPresent
}

const eM = {hasAnimatedSinceResize: !0, hasEverUpdated: !1};

function yhe(t, e) {
    return e.max === e.min ? 0 : t / (e.max - e.min) * 100
}

const sT = {
    correct: (t, e) => {
        if (!e.target) return t;
        if (typeof t == "string") if (nn.test(t)) t = parseFloat(t); else return t;
        const r = yhe(t, e.target.x), n = yhe(t, e.target.y);
        return `${r}% ${n}%`
    }
}, LAt = {
    correct: (t, {treeScale: e, projectionDelta: r}) => {
        const n = t, i = n1.parse(t);
        if (i.length > 5) return n;
        const a = n1.createTransformer(t), o = typeof i[0] != "number" ? 1 : 0, s = r.x.scale * e.x,
            l = r.y.scale * e.y;
        i[0 + o] /= s, i[1 + o] /= l;
        const f = lo(s, l, .5);
        return typeof i[2 + o] == "number" && (i[2 + o] /= f), typeof i[3 + o] == "number" && (i[3 + o] /= f), a(i)
    }
};

class BAt extends ar.Component {
    componentDidMount() {
        const {visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i} = this.props, {projection: a} = e;
        W5t($At), a && (r.group && r.group.add(a), n && n.register && i && n.register(a), a.root.didUpdate(), a.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }), a.setOptions({...a.options, onExitComplete: () => this.safeToRemove()})), eM.hasEverUpdated = !0
    }

    getSnapshotBeforeUpdate(e) {
        const {layoutDependency: r, visualElement: n, drag: i, isPresent: a} = this.props, o = n.projection;
        return o && (o.isPresent = a, i || e.layoutDependency !== r || r === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== a && (a ? o.promote() : o.relegate() || Ta.postRender(() => {
            const s = o.getStack();
            (!s || !s.members.length) && this.safeToRemove()
        }))), null
    }

    componentDidUpdate() {
        const {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(), queueMicrotask(() => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }))
    }

    componentWillUnmount() {
        const {visualElement: e, layoutGroup: r, switchLayoutGroup: n} = this.props, {projection: i} = e;
        i && (i.scheduleCheckAfterUnmount(), r && r.group && r.group.remove(i), n && n.deregister && n.deregister(i))
    }

    safeToRemove() {
        const {safeToRemove: e} = this.props;
        e && e()
    }

    render() {
        return null
    }
}

function S3e(t) {
    const [e, r] = w3e(), n = W.useContext(pJ);
    return ar.createElement(BAt, {
        ...t,
        layoutGroup: n,
        switchLayoutGroup: W.useContext(mEe),
        isPresent: e,
        safeToRemove: r
    })
}

const $At = {
        borderRadius: {
            ...sT,
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
        },
        borderTopLeftRadius: sT,
        borderTopRightRadius: sT,
        borderBottomLeftRadius: sT,
        borderBottomRightRadius: sT,
        boxShadow: LAt
    }, _3e = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], FAt = _3e.length,
    bhe = t => typeof t == "string" ? parseFloat(t) : t, whe = t => typeof t == "number" || nn.test(t);

function UAt(t, e, r, n, i, a) {
    i ? (t.opacity = lo(0, r.opacity !== void 0 ? r.opacity : 1, jAt(n)), t.opacityExit = lo(e.opacity !== void 0 ? e.opacity : 1, 0, zAt(n))) : a && (t.opacity = lo(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));
    for (let o = 0; o < FAt; o++) {
        const s = `border${_3e[o]}Radius`;
        let l = She(e, s), f = She(r, s);
        if (l === void 0 && f === void 0) continue;
        l || (l = 0), f || (f = 0), l === 0 || f === 0 || whe(l) === whe(f) ? (t[s] = Math.max(lo(bhe(l), bhe(f), n), 0), (L0.test(f) || L0.test(l)) && (t[s] += "%")) : t[s] = f
    }
    (e.rotate || r.rotate) && (t.rotate = lo(e.rotate || 0, r.rotate || 0, n))
}

function She(t, e) {
    return t[e] !== void 0 ? t[e] : t.borderRadius
}

const jAt = x3e(0, .5, xJ), zAt = x3e(.5, .95, Ao);

function x3e(t, e, r) {
    return n => n < t ? 0 : n > e ? 1 : r(MA(t, e, n))
}

function _he(t, e) {
    t.min = e.min, t.max = e.max
}

function Dd(t, e) {
    _he(t.x, e.x), _he(t.y, e.y)
}

function xhe(t, e, r, n, i) {
    return t -= e, t = zO(t, 1 / r, n), i !== void 0 && (t = zO(t, 1 / i, n)), t
}

function VAt(t, e = 0, r = 1, n = .5, i, a = t, o = t) {
    if (L0.test(e) && (e = parseFloat(e), e = lo(o.min, o.max, e / 100) - o.min), typeof e != "number") return;
    let s = lo(a.min, a.max, n);
    t === a && (s -= e), t.min = xhe(t.min, e, r, s, i), t.max = xhe(t.max, e, r, s, i)
}

function Ehe(t, e, [r, n, i], a, o) {
    VAt(t, e[r], e[n], e[i], e.scale, a, o)
}

const HAt = ["x", "scaleX", "originX"], WAt = ["y", "scaleY", "originY"];

function The(t, e, r, n) {
    Ehe(t.x, e, HAt, r ? r.x : void 0, n ? n.x : void 0), Ehe(t.y, e, WAt, r ? r.y : void 0, n ? n.y : void 0)
}

function Che(t) {
    return t.translate === 0 && t.scale === 1
}

function E3e(t) {
    return Che(t.x) && Che(t.y)
}

function qAt(t, e) {
    return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max
}

function T3e(t, e) {
    return Math.round(t.x.min) === Math.round(e.x.min) && Math.round(t.x.max) === Math.round(e.x.max) && Math.round(t.y.min) === Math.round(e.y.min) && Math.round(t.y.max) === Math.round(e.y.max)
}

function Ahe(t) {
    return Gf(t.x) / Gf(t.y)
}

class GAt {
    constructor() {
        this.members = []
    }

    add(e) {
        IJ(this.members, e), e.scheduleRender()
    }

    remove(e) {
        if (kJ(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            const r = this.members[this.members.length - 1];
            r && this.promote(r)
        }
    }

    relegate(e) {
        const r = this.members.findIndex(i => e === i);
        if (r === 0) return !1;
        let n;
        for (let i = r; i >= 0; i--) {
            const a = this.members[i];
            if (a.isPresent !== !1) {
                n = a;
                break
            }
        }
        return n ? (this.promote(n), !0) : !1
    }

    promote(e, r) {
        const n = this.lead;
        if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
            n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, r && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {crossfade: i} = e.options;
            i === !1 && n.hide()
        }
    }

    exitAnimationComplete() {
        this.members.forEach(e => {
            const {options: r, resumingFrom: n} = e;
            r.onExitComplete && r.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete()
        })
    }

    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        })
    }

    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}

function Ihe(t, e, r) {
    let n = "";
    const i = t.x.translate / e.x, a = t.y.translate / e.y;
    if ((i || a) && (n = `translate3d(${i}px, ${a}px, 0) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {
        const {rotate: l, rotateX: f, rotateY: d} = r;
        l && (n += `rotate(${l}deg) `), f && (n += `rotateX(${f}deg) `), d && (n += `rotateY(${d}deg) `)
    }
    const o = t.x.scale * e.x, s = t.y.scale * e.y;
    return (o !== 1 || s !== 1) && (n += `scale(${o}, ${s})`), n || "none"
}

const KAt = (t, e) => t.depth - e.depth;

class YAt {
    constructor() {
        this.children = [], this.isDirty = !1
    }

    add(e) {
        IJ(this.children, e), this.isDirty = !0
    }

    remove(e) {
        kJ(this.children, e), this.isDirty = !0
    }

    forEach(e) {
        this.isDirty && this.children.sort(KAt), this.isDirty = !1, this.children.forEach(e)
    }
}

function XAt(t, e) {
    const r = performance.now(), n = ({timestamp: i}) => {
        const a = i - r;
        a >= e && (jv(n), t(a - e))
    };
    return Ta.read(n, !0), () => jv(n)
}

function QAt(t) {
    window.MotionDebug && window.MotionDebug.record(t)
}

function ZAt(t) {
    return t instanceof SVGElement && t.tagName !== "svg"
}

function JAt(t, e, r) {
    const n = uf(t) ? t : nE(t);
    return n.start(AJ("", n, e, r)), n.animation
}

const khe = ["", "X", "Y", "Z"], Rhe = 1e3;
let e8t = 0;
const aw = {type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0};

function C3e({attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i}) {
    return class {
        constructor(o = {}, s = e == null ? void 0 : e()) {
            this.id = e8t++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {
                x: 1,
                y: 1
            }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
                aw.totalNodes = aw.resolvedTargetDeltas = aw.recalculatedProjection = 0, this.nodes.forEach(n8t), this.nodes.forEach(c8t), this.nodes.forEach(l8t), this.nodes.forEach(i8t), QAt(aw)
            }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = s ? s.root || s : this, this.path = s ? [...s.path, s] : [], this.parent = s, this.depth = s ? s.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new YAt)
        }

        addEventListener(o, s) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new RJ), this.eventHandlers.get(o).add(s)
        }

        notifyListeners(o, ...s) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...s)
        }

        hasListeners(o) {
            return this.eventHandlers.has(o)
        }

        mount(o, s = this.root.hasTreeAnimated) {
            if (this.instance) return;
            this.isSVG = ZAt(o), this.instance = o;
            const {layoutId: l, layout: f, visualElement: d} = this.options;
            if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), s && (f || l) && (this.isLayoutDirty = !0), t) {
                let p;
                const g = () => this.root.updateBlockedByResize = !1;
                t(o, () => {
                    this.root.updateBlockedByResize = !0, p && p(), p = XAt(g, 250), eM.hasAnimatedSinceResize && (eM.hasAnimatedSinceResize = !1, this.nodes.forEach(Mhe))
                })
            }
            l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && d && (l || f) && this.addEventListener("didUpdate", ({
                                                                                                                                                delta: p,
                                                                                                                                                hasLayoutChanged: g,
                                                                                                                                                hasRelativeTargetChanged: b,
                                                                                                                                                layout: S
                                                                                                                                            }) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0, this.relativeTarget = void 0;
                    return
                }
                const T = this.options.transition || d.getDefaultTransition() || p8t, {
                    onLayoutAnimationStart: I,
                    onLayoutAnimationComplete: N
                } = d.getProps(), P = !this.targetLayout || !T3e(this.targetLayout, S) || b, F = !g && b;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || F || g && (P || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(p, F);
                    const V = {...l3e(T, "layout"), onPlay: I, onComplete: N};
                    (d.shouldReduceMotion || this.options.layoutRoot) && (V.delay = 0, V.type = !1), this.startAnimation(V)
                } else g || Mhe(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = S
            })
        }

        unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, jv(this.updateProjection)
        }

        blockUpdate() {
            this.updateManuallyBlocked = !0
        }

        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }

        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }

        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }

        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(u8t), this.animationId++)
        }

        getTransformTemplate() {
            const {visualElement: o} = this.options;
            return o && o.getProps().transformTemplate
        }

        willUpdate(o = !0) {
            if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let d = 0; d < this.path.length; d++) {
                const p = this.path[d];
                p.shouldResetTransform = !0, p.updateScroll("snapshot"), p.options.layoutRoot && p.willUpdate(!1)
            }
            const {layoutId: s, layout: l} = this.options;
            if (s === void 0 && !l) return;
            const f = this.getTransformTemplate();
            this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
        }

        update() {
            if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Dhe);
                return
            }
            this.isUpdating || this.nodes.forEach(o8t), this.isUpdating = !1, this.nodes.forEach(s8t), this.nodes.forEach(t8t), this.nodes.forEach(r8t), this.clearAllSnapshots();
            const s = performance.now();
            Ks.delta = r1(0, 1e3 / 60, s - Ks.timestamp), Ks.timestamp = s, Ks.isProcessing = !0, XV.update.process(Ks), XV.preRender.process(Ks), XV.render.process(Ks), Ks.isProcessing = !1
        }

        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()))
        }

        clearAllSnapshots() {
            this.nodes.forEach(a8t), this.sharedNodes.forEach(f8t)
        }

        scheduleUpdateProjection() {
            Ta.preRender(this.updateProjection, !1, !0)
        }

        scheduleCheckAfterUnmount() {
            Ta.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
        }

        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }

        updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = ns(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: s} = this.options;
            s && s.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }

        updateScroll(o = "measure") {
            let s = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (s = !1), s && (this.scroll = {
                animationId: this.root.animationId,
                phase: o,
                isRoot: n(this.instance),
                offset: r(this.instance)
            })
        }

        resetTransform() {
            if (!i) return;
            const o = this.isLayoutDirty || this.shouldResetTransform,
                s = this.projectionDelta && !E3e(this.projectionDelta), l = this.getTransformTemplate(),
                f = l ? l(this.latestValues, "") : void 0, d = f !== this.prevTransformTemplateValue;
            o && (s || iw(this.latestValues) || d) && (i(this.instance, f), this.shouldResetTransform = !1, this.scheduleRender())
        }

        measure(o = !0) {
            const s = this.measurePageBox();
            let l = this.removeElementScroll(s);
            return o && (l = this.removeTransform(l)), m8t(l), {
                animationId: this.root.animationId,
                measuredBox: s,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }

        measurePageBox() {
            const {visualElement: o} = this.options;
            if (!o) return ns();
            const s = o.measureViewportBox(), {scroll: l} = this.root;
            return l && (by(s.x, l.offset.x), by(s.y, l.offset.y)), s
        }

        removeElementScroll(o) {
            const s = ns();
            Dd(s, o);
            for (let l = 0; l < this.path.length; l++) {
                const f = this.path[l], {scroll: d, options: p} = f;
                if (f !== this.root && d && p.layoutScroll) {
                    if (d.isRoot) {
                        Dd(s, o);
                        const {scroll: g} = this.root;
                        g && (by(s.x, -g.offset.x), by(s.y, -g.offset.y))
                    }
                    by(s.x, d.offset.x), by(s.y, d.offset.y)
                }
            }
            return s
        }

        applyTransform(o, s = !1) {
            const l = ns();
            Dd(l, o);
            for (let f = 0; f < this.path.length; f++) {
                const d = this.path[f];
                !s && d.options.layoutScroll && d.scroll && d !== d.root && Ux(l, {
                    x: -d.scroll.offset.x,
                    y: -d.scroll.offset.y
                }), iw(d.latestValues) && Ux(l, d.latestValues)
            }
            return iw(this.latestValues) && Ux(l, this.latestValues), l
        }

        removeTransform(o) {
            const s = ns();
            Dd(s, o);
            for (let l = 0; l < this.path.length; l++) {
                const f = this.path[l];
                if (!f.instance || !iw(f.latestValues)) continue;
                TK(f.latestValues) && f.updateSnapshot();
                const d = ns(), p = f.measurePageBox();
                Dd(d, p), The(s, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, d)
            }
            return iw(this.latestValues) && The(s, this.latestValues), s
        }

        setTargetDelta(o) {
            this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
        }

        setOptions(o) {
            this.options = {...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0}
        }

        clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
        }

        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ks.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }

        resolveTargetDelta(o = !1) {
            var s;
            const l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const f = !!this.resumingFrom || this !== l;
            if (!(o || f && this.isSharedProjectionDirty || this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty || this.attemptToResolveRelativeTarget)) return;
            const {layout: p, layoutId: g} = this.options;
            if (!(!this.layout || !(p || g))) {
                if (this.resolvedRelativeTargetAt = Ks.timestamp, !this.targetDelta && !this.relativeTarget) {
                    const b = this.getClosestProjectingParent();
                    b && b.layout && this.animationProgress !== 1 ? (this.relativeParent = b, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ns(), this.relativeTargetOrigin = ns(), yC(this.relativeTargetOrigin, this.layout.layoutBox, b.layout.layoutBox), Dd(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = ns(), this.targetWithTransforms = ns()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), vAt(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Dd(this.target, this.layout.layoutBox), y3e(this.target, this.targetDelta)) : Dd(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const b = this.getClosestProjectingParent();
                        b && !!b.resumingFrom == !!this.resumingFrom && !b.options.layoutScroll && b.target && this.animationProgress !== 1 ? (this.relativeParent = b, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ns(), this.relativeTargetOrigin = ns(), yC(this.relativeTargetOrigin, this.target, b.target), Dd(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    aw.resolvedTargetDeltas++
                }
            }
        }

        getClosestProjectingParent() {
            if (!(!this.parent || TK(this.parent.latestValues) || g3e(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }

        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }

        calcProjection() {
            var o;
            const s = this.getLead(), l = !!this.resumingFrom || this !== s;
            let f = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (f = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1), this.resolvedRelativeTargetAt === Ks.timestamp && (f = !1), f) return;
            const {layout: d, layoutId: p} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || p)) return;
            Dd(this.layoutCorrected, this.layout.layoutBox);
            const g = this.treeScale.x, b = this.treeScale.y;
            TAt(this.layoutCorrected, this.treeScale, this.path, l), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox);
            const {target: S} = s;
            if (!S) {
                this.projectionTransform && (this.projectionDelta = Fx(), this.projectionTransform = "none", this.scheduleRender());
                return
            }
            this.projectionDelta || (this.projectionDelta = Fx(), this.projectionDeltaWithTransform = Fx());
            const T = this.projectionTransform;
            gC(this.projectionDelta, this.layoutCorrected, S, this.latestValues), this.projectionTransform = Ihe(this.projectionDelta, this.treeScale), (this.projectionTransform !== T || this.treeScale.x !== g || this.treeScale.y !== b) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", S)), aw.recalculatedProjection++
        }

        hide() {
            this.isVisible = !1
        }

        show() {
            this.isVisible = !0
        }

        scheduleRender(o = !0) {
            if (this.options.scheduleRender && this.options.scheduleRender(), o) {
                const s = this.getStack();
                s && s.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }

        setAnimationOrigin(o, s = !1) {
            const l = this.snapshot, f = l ? l.latestValues : {}, d = {...this.latestValues}, p = Fx();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !s;
            const g = ns(), b = l ? l.source : void 0, S = this.layout ? this.layout.source : void 0, T = b !== S,
                I = this.getStack(), N = !I || I.members.length <= 1,
                P = !!(T && !N && this.options.crossfade === !0 && !this.path.some(h8t));
            this.animationProgress = 0;
            let F;
            this.mixTargetDelta = V => {
                const Y = V / 1e3;
                Ohe(p.x, o.x, Y), Ohe(p.y, o.y, Y), this.setTargetDelta(p), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (yC(g, this.layout.layoutBox, this.relativeParent.layout.layoutBox), d8t(this.relativeTarget, this.relativeTargetOrigin, g, Y), F && qAt(this.relativeTarget, F) && (this.isProjectionDirty = !1), F || (F = ns()), Dd(F, this.relativeTarget)), T && (this.animationValues = d, UAt(d, f, this.latestValues, Y, P, N)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = Y
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }

        startAnimation(o) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (jv(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ta.update(() => {
                eM.hasAnimatedSinceResize = !0, this.currentAnimation = JAt(0, Rhe, {
                    ...o, onUpdate: s => {
                        this.mixTargetDelta(s), o.onUpdate && o.onUpdate(s)
                    }, onComplete: () => {
                        o.onComplete && o.onComplete(), this.completeAnimation()
                    }
                }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
        }

        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
        }

        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Rhe), this.currentAnimation.stop()), this.completeAnimation()
        }

        applyTransformsToTarget() {
            const o = this.getLead();
            let {targetWithTransforms: s, target: l, layout: f, latestValues: d} = o;
            if (!(!s || !l || !f)) {
                if (this !== o && this.layout && f && A3e(this.options.animationType, this.layout.layoutBox, f.layoutBox)) {
                    l = this.target || ns();
                    const p = Gf(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min, l.x.max = l.x.min + p;
                    const g = Gf(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min, l.y.max = l.y.min + g
                }
                Dd(s, l), Ux(s, d), gC(this.projectionDeltaWithTransform, this.layoutCorrected, s, d)
            }
        }

        registerSharedNode(o, s) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new GAt), this.sharedNodes.get(o).add(s);
            const f = s.options.initialPromotionConfig;
            s.promote({
                transition: f ? f.transition : void 0,
                preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(s) : void 0
            })
        }

        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }

        getLead() {
            var o;
            const {layoutId: s} = this.options;
            return s ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }

        getPrevLead() {
            var o;
            const {layoutId: s} = this.options;
            return s ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }

        getStack() {
            const {layoutId: o} = this.options;
            if (o) return this.root.sharedNodes.get(o)
        }

        promote({needsReset: o, transition: s, preserveFollowOpacity: l} = {}) {
            const f = this.getStack();
            f && f.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), s && this.setOptions({transition: s})
        }

        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }

        resetRotation() {
            const {visualElement: o} = this.options;
            if (!o) return;
            let s = !1;
            const {latestValues: l} = o;
            if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (s = !0), !s) return;
            const f = {};
            for (let d = 0; d < khe.length; d++) {
                const p = "rotate" + khe[d];
                l[p] && (f[p] = l[p], o.setStaticValue(p, 0))
            }
            o.render();
            for (const d in f) o.setStaticValue(d, f[d]);
            o.scheduleRender()
        }

        getProjectionStyles(o = {}) {
            var s, l;
            const f = {};
            if (!this.instance || this.isSVG) return f;
            if (this.isVisible) f.visibility = ""; else return {visibility: "hidden"};
            const d = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, f.opacity = "", f.pointerEvents = JD(o.pointerEvents) || "", f.transform = d ? d(this.latestValues, "") : "none", f;
            const p = this.getLead();
            if (!this.projectionDelta || !this.layout || !p.target) {
                const T = {};
                return this.options.layoutId && (T.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, T.pointerEvents = JD(o.pointerEvents) || ""), this.hasProjected && !iw(this.latestValues) && (T.transform = d ? d({}, "") : "none", this.hasProjected = !1), T
            }
            const g = p.animationValues || p.latestValues;
            this.applyTransformsToTarget(), f.transform = Ihe(this.projectionDeltaWithTransform, this.treeScale, g), d && (f.transform = d(g, f.transform));
            const {x: b, y: S} = this.projectionDelta;
            f.transformOrigin = `${b.origin * 100}% ${S.origin * 100}% 0`, p.animationValues ? f.opacity = p === this ? (l = (s = g.opacity) !== null && s !== void 0 ? s : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : g.opacityExit : f.opacity = p === this ? g.opacity !== void 0 ? g.opacity : "" : g.opacityExit !== void 0 ? g.opacityExit : 0;
            for (const T in NO) {
                if (g[T] === void 0) continue;
                const {correct: I, applyTo: N} = NO[T], P = f.transform === "none" ? g[T] : I(g[T], p);
                if (N) {
                    const F = N.length;
                    for (let V = 0; V < F; V++) f[N[V]] = P
                } else f[T] = P
            }
            return this.options.layoutId && (f.pointerEvents = p === this ? JD(o.pointerEvents) || "" : "none"), f
        }

        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }

        resetTree() {
            this.root.nodes.forEach(o => {
                var s;
                return (s = o.currentAnimation) === null || s === void 0 ? void 0 : s.stop()
            }), this.root.nodes.forEach(Dhe), this.root.sharedNodes.clear()
        }
    }
}

function t8t(t) {
    t.updateLayout()
}

function r8t(t) {
    var e;
    const r = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
    if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) {
        const {layoutBox: n, measuredBox: i} = t.layout, {animationType: a} = t.options,
            o = r.source !== t.layout.source;
        a === "size" ? p0(p => {
            const g = o ? r.measuredBox[p] : r.layoutBox[p], b = Gf(g);
            g.min = n[p].min, g.max = g.min + b
        }) : A3e(a, r.layoutBox, n) && p0(p => {
            const g = o ? r.measuredBox[p] : r.layoutBox[p], b = Gf(n[p]);
            g.max = g.min + b, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[p].max = t.relativeTarget[p].min + b)
        });
        const s = Fx();
        gC(s, n, r.layoutBox);
        const l = Fx();
        o ? gC(l, t.applyTransform(i, !0), r.measuredBox) : gC(l, n, r.layoutBox);
        const f = !E3e(s);
        let d = !1;
        if (!t.resumeFrom) {
            const p = t.getClosestProjectingParent();
            if (p && !p.resumeFrom) {
                const {snapshot: g, layout: b} = p;
                if (g && b) {
                    const S = ns();
                    yC(S, r.layoutBox, g.layoutBox);
                    const T = ns();
                    yC(T, n, b.layoutBox), T3e(S, T) || (d = !0), p.options.layoutRoot && (t.relativeTarget = T, t.relativeTargetOrigin = S, t.relativeParent = p)
                }
            }
        }
        t.notifyListeners("didUpdate", {
            layout: n,
            snapshot: r,
            delta: l,
            layoutDelta: s,
            hasLayoutChanged: f,
            hasRelativeTargetChanged: d
        })
    } else if (t.isLead()) {
        const {onExitComplete: n} = t.options;
        n && n()
    }
    t.options.transition = void 0
}

function n8t(t) {
    aw.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
}

function i8t(t) {
    t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}

function a8t(t) {
    t.clearSnapshot()
}

function Dhe(t) {
    t.clearMeasurements()
}

function o8t(t) {
    t.isLayoutDirty = !1
}

function s8t(t) {
    const {visualElement: e} = t.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform()
}

function Mhe(t) {
    t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0
}

function c8t(t) {
    t.resolveTargetDelta()
}

function l8t(t) {
    t.calcProjection()
}

function u8t(t) {
    t.resetRotation()
}

function f8t(t) {
    t.removeLeadSnapshot()
}

function Ohe(t, e, r) {
    t.translate = lo(e.translate, 0, r), t.scale = lo(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint
}

function Phe(t, e, r, n) {
    t.min = lo(e.min, r.min, n), t.max = lo(e.max, r.max, n)
}

function d8t(t, e, r, n) {
    Phe(t.x, e.x, r.x, n), Phe(t.y, e.y, r.y, n)
}

function h8t(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0
}

const p8t = {duration: .45, ease: [.4, 0, .1, 1]},
    Nhe = t => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(t),
    Lhe = Nhe("applewebkit/") && !Nhe("chrome/") ? Math.round : Ao;

function Bhe(t) {
    t.min = Lhe(t.min), t.max = Lhe(t.max)
}

function m8t(t) {
    Bhe(t.x), Bhe(t.y)
}

function A3e(t, e, r) {
    return t === "position" || t === "preserve-aspect" && !xK(Ahe(e), Ahe(r), .2)
}

const v8t = C3e({
        attachResizeListener: (t, e) => pv(t, "resize", e),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }), sH = {current: void 0}, I3e = C3e({
        measureScroll: t => ({x: t.scrollLeft, y: t.scrollTop}), defaultParent: () => {
            if (!sH.current) {
                const t = new v8t({});
                t.mount(window), t.setOptions({layoutScroll: !0}), sH.current = t
            }
            return sH.current
        }, resetTransform: (t, e) => {
            t.style.transform = e !== void 0 ? e : "none"
        }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed"
    }), g8t = {pan: {Feature: OAt}, drag: {Feature: MAt, ProjectionNode: I3e, MeasureLayout: S3e}},
    y8t = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

function b8t(t) {
    const e = y8t.exec(t);
    if (!e) return [,];
    const [, r, n] = e;
    return [r, n]
}

const w8t = 4;

function AK(t, e, r = 1) {
    vp(r <= w8t, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
    const [n, i] = b8t(t);
    if (!n) return;
    const a = window.getComputedStyle(e).getPropertyValue(n);
    if (a) {
        const o = a.trim();
        return u3e(o) ? parseFloat(o) : o
    } else return vK(i) ? AK(i, e, r + 1) : i
}

function S8t(t, {...e}, r) {
    const n = t.current;
    if (!(n instanceof Element)) return {target: e, transitionEnd: r};
    r && (r = {...r}), t.values.forEach(i => {
        const a = i.get();
        if (!vK(a)) return;
        const o = AK(a, n);
        o && i.set(o)
    });
    for (const i in e) {
        const a = e[i];
        if (!vK(a)) continue;
        const o = AK(a, n);
        o && (e[i] = o, r || (r = {}), r[i] === void 0 && (r[i] = a))
    }
    return {target: e, transitionEnd: r}
}

const _8t = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
    k3e = t => _8t.has(t), x8t = t => Object.keys(t).some(k3e), N7 = t => t === YS || t === nn,
    $he = (t, e) => parseFloat(t.split(", ")[e]), Fhe = (t, e) => (r, {transform: n}) => {
        if (n === "none" || !n) return 0;
        const i = n.match(/^matrix3d\((.+)\)$/);
        if (i) return $he(i[1], e);
        {
            const a = n.match(/^matrix\((.+)\)$/);
            return a ? $he(a[1], t) : 0
        }
    }, E8t = new Set(["x", "y", "z"]), T8t = nI.filter(t => !E8t.has(t));

function C8t(t) {
    const e = [];
    return T8t.forEach(r => {
        const n = t.getValue(r);
        n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0))
    }), e.length && t.render(), e
}

const iE = {
    width: ({x: t}, {
        paddingLeft: e = "0",
        paddingRight: r = "0"
    }) => t.max - t.min - parseFloat(e) - parseFloat(r),
    height: ({y: t}, {paddingTop: e = "0", paddingBottom: r = "0"}) => t.max - t.min - parseFloat(e) - parseFloat(r),
    top: (t, {top: e}) => parseFloat(e),
    left: (t, {left: e}) => parseFloat(e),
    bottom: ({y: t}, {top: e}) => parseFloat(e) + (t.max - t.min),
    right: ({x: t}, {left: e}) => parseFloat(e) + (t.max - t.min),
    x: Fhe(4, 13),
    y: Fhe(5, 14)
};
iE.translateX = iE.x;
iE.translateY = iE.y;
const A8t = (t, e, r) => {
    const n = e.measureViewportBox(), i = e.current, a = getComputedStyle(i), {display: o} = a, s = {};
    o === "none" && e.setStaticValue("display", t.display || "block"), r.forEach(f => {
        s[f] = iE[f](n, a)
    }), e.render();
    const l = e.measureViewportBox();
    return r.forEach(f => {
        const d = e.getValue(f);
        d && d.jump(s[f]), t[f] = iE[f](l, a)
    }), t
}, I8t = (t, e, r = {}, n = {}) => {
    e = {...e}, n = {...n};
    const i = Object.keys(e).filter(k3e);
    let a = [], o = !1;
    const s = [];
    if (i.forEach(l => {
        const f = t.getValue(l);
        if (!t.hasValue(l)) return;
        let d = r[l], p = oT(d);
        const g = e[l];
        let b;
        if (BO(g)) {
            const S = g.length, T = g[0] === null ? 1 : 0;
            d = g[T], p = oT(d);
            for (let I = T; I < S && g[I] !== null; I++) b ? vp(oT(g[I]) === b, "All keyframes must be of the same type") : (b = oT(g[I]), vp(b === p || N7(p) && N7(b), "Keyframes must be of the same dimension as the current value"))
        } else b = oT(g);
        if (p !== b) if (N7(p) && N7(b)) {
            const S = f.get();
            typeof S == "string" && f.set(parseFloat(S)), typeof g == "string" ? e[l] = parseFloat(g) : Array.isArray(g) && b === nn && (e[l] = g.map(parseFloat))
        } else p != null && p.transform && (b != null && b.transform) && (d === 0 || g === 0) ? d === 0 ? f.set(b.transform(d)) : e[l] = p.transform(g) : (o || (a = C8t(t), o = !0), s.push(l), n[l] = n[l] !== void 0 ? n[l] : e[l], f.jump(g))
    }), s.length) {
        const l = s.indexOf("height") >= 0 ? window.pageYOffset : null, f = A8t(e, t, s);
        return a.length && a.forEach(([d, p]) => {
            t.getValue(d).set(p)
        }), t.render(), iL && l !== null && window.scrollTo({top: l}), {target: f, transitionEnd: n}
    } else return {target: e, transitionEnd: n}
};

function k8t(t, e, r, n) {
    return x8t(e) ? I8t(t, e, r, n) : {target: e, transitionEnd: n}
}

const R8t = (t, e, r, n) => {
    const i = S8t(t, e, n);
    return e = i.target, n = i.transitionEnd, k8t(t, e, r, n)
}, IK = {current: null}, R3e = {current: !1};

function D8t() {
    if (R3e.current = !0, !!iL) if (window.matchMedia) {
        const t = window.matchMedia("(prefers-reduced-motion)"), e = () => IK.current = t.matches;
        t.addListener(e), e()
    } else IK.current = !1
}

function M8t(t, e, r) {
    const {willChange: n} = e;
    for (const i in e) {
        const a = e[i], o = r[i];
        if (uf(a)) t.addValue(i, a), jO(n) && n.add(i), Ve.env.NODE_ENV === "development" && DJ(a.version === "10.16.4", `Attempting to mix Framer Motion versions ${a.version} with 10.16.4 may not work as expected.`); else if (uf(o)) t.addValue(i, nE(a, {owner: t})), jO(n) && n.remove(i); else if (o !== a) if (t.hasValue(i)) {
            const s = t.getValue(i);
            !s.hasAnimated && s.set(a)
        } else {
            const s = t.getStaticValue(i);
            t.addValue(i, nE(s !== void 0 ? s : a, {owner: t}))
        }
    }
    for (const i in r) e[i] === void 0 && t.removeValue(i);
    return e
}

const Uhe = new WeakMap, D3e = Object.keys(DA), O8t = D3e.length,
    jhe = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
    P8t = hJ.length;

class N8t {
    constructor({parent: e, props: r, presenceContext: n, reducedMotionConfig: i, visualState: a}, o = {}) {
        this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }, this.scheduleRender = () => Ta.render(this.render, !1, !0);
        const {latestValues: s, renderState: l} = a;
        this.latestValues = s, this.baseTarget = {...s}, this.initialValues = r.initial ? {...s} : {}, this.renderState = l, this.parent = e, this.props = r, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = o, this.isControllingVariants = oL(r), this.isVariantNode = pEe(r), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current);
        const {willChange: f, ...d} = this.scrapeMotionValuesFromProps(r, {});
        for (const p in d) {
            const g = d[p];
            s[p] !== void 0 && uf(g) && (g.set(s[p], !1), jO(f) && f.add(p))
        }
    }

    scrapeMotionValuesFromProps(e, r) {
        return {}
    }

    mount(e) {
        this.current = e, Uhe.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, n) => this.bindToMotionValue(n, r)), R3e.current || D8t(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : IK.current, Ve.env.NODE_ENV !== "production" && DJ(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }

    unmount() {
        Uhe.delete(this.current), this.projection && this.projection.unmount(), jv(this.notifyUpdate), jv(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
        for (const e in this.events) this.events[e].clear();
        for (const e in this.features) this.features[e].unmount();
        this.current = null
    }

    bindToMotionValue(e, r) {
        const n = KS.has(e), i = r.on("change", o => {
            this.latestValues[e] = o, this.props.onUpdate && Ta.update(this.notifyUpdate, !1, !0), n && this.projection && (this.projection.isTransformDirty = !0)
        }), a = r.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(e, () => {
            i(), a()
        })
    }

    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }

    loadFeatures({children: e, ...r}, n, i, a) {
        let o, s;
        if (Ve.env.NODE_ENV !== "production" && i && n) {
            const l = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
            r.ignoreStrict ? oI(!1, l) : vp(!1, l)
        }
        for (let l = 0; l < O8t; l++) {
            const f = D3e[l], {isEnabled: d, Feature: p, ProjectionNode: g, MeasureLayout: b} = DA[f];
            g && (o = g), d(r) && (!this.features[f] && p && (this.features[f] = new p(this)), b && (s = b))
        }
        if (!this.projection && o) {
            this.projection = new o(this.latestValues, this.parent && this.parent.projection);
            const {layoutId: l, layout: f, drag: d, dragConstraints: p, layoutScroll: g, layoutRoot: b} = r;
            this.projection.setOptions({
                layoutId: l,
                layout: f,
                alwaysMeasureLayout: !!d || p && Bx(p),
                visualElement: this,
                scheduleRender: () => this.scheduleRender(),
                animationType: typeof f == "string" ? f : "both",
                initialPromotionConfig: a,
                layoutScroll: g,
                layoutRoot: b
            })
        }
        return s
    }

    updateFeatures() {
        for (const e in this.features) {
            const r = this.features[e];
            r.isMounted ? r.update() : (r.mount(), r.isMounted = !0)
        }
    }

    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }

    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ns()
    }

    getStaticValue(e) {
        return this.latestValues[e]
    }

    setStaticValue(e, r) {
        this.latestValues[e] = r
    }

    makeTargetAnimatable(e, r = !0) {
        return this.makeTargetAnimatableFromInstance(e, this.props, r)
    }

    update(e, r) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = r;
        for (let n = 0; n < jhe.length; n++) {
            const i = jhe[n];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
            const a = e["on" + i];
            a && (this.propEventSubscriptions[i] = this.on(i, a))
        }
        this.prevMotionValues = M8t(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
    }

    getProps() {
        return this.props
    }

    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }

    getDefaultTransition() {
        return this.props.transition
    }

    getTransformPagePoint() {
        return this.props.transformPagePoint
    }

    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }

    getVariantContext(e = !1) {
        if (e) return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const n = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (n.initial = this.props.initial), n
        }
        const r = {};
        for (let n = 0; n < P8t; n++) {
            const i = hJ[n], a = this.props[i];
            (RA(a) || a === !1) && (r[i] = a)
        }
        return r
    }

    addVariantChild(e) {
        const r = this.getClosestVariantNode();
        if (r) return r.variantChildren && r.variantChildren.add(e), () => r.variantChildren.delete(e)
    }

    addValue(e, r) {
        r !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, r)), this.values.set(e, r), this.latestValues[e] = r.get()
    }

    removeValue(e) {
        this.values.delete(e);
        const r = this.valueSubscriptions.get(e);
        r && (r(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
    }

    hasValue(e) {
        return this.values.has(e)
    }

    getValue(e, r) {
        if (this.props.values && this.props.values[e]) return this.props.values[e];
        let n = this.values.get(e);
        return n === void 0 && r !== void 0 && (n = nE(r, {owner: this}), this.addValue(e, n)), n
    }

    readValue(e) {
        var r;
        return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options)
    }

    setBaseTarget(e, r) {
        this.baseTarget[e] = r
    }

    getBaseTarget(e) {
        var r;
        const {initial: n} = this.props,
            i = typeof n == "string" || typeof n == "object" ? (r = _J(this.props, n)) === null || r === void 0 ? void 0 : r[e] : void 0;
        if (n && i !== void 0) return i;
        const a = this.getBaseTargetFromProps(this.props, e);
        return a !== void 0 && !uf(a) ? a : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
    }

    on(e, r) {
        return this.events[e] || (this.events[e] = new RJ), this.events[e].add(r)
    }

    notify(e, ...r) {
        this.events[e] && this.events[e].notify(...r)
    }
}

class M3e extends N8t {
    sortInstanceNodePosition(e, r) {
        return e.compareDocumentPosition(r) & 2 ? 1 : -1
    }

    getBaseTargetFromProps(e, r) {
        return e.style ? e.style[r] : void 0
    }

    removeValueFromRenderState(e, {vars: r, style: n}) {
        delete r[e], delete n[e]
    }

    makeTargetAnimatableFromInstance({transition: e, transitionEnd: r, ...n}, {transformValues: i}, a) {
        let o = ZCt(n, e || {}, this);
        if (i && (r && (r = i(r)), n && (n = i(n)), o && (o = i(o))), a) {
            XCt(this, n, o);
            const s = R8t(this, n, o, r);
            r = s.transitionEnd, n = s.target
        }
        return {transition: e, transitionEnd: r, ...n}
    }
}

function L8t(t) {
    return window.getComputedStyle(t)
}

class B8t extends M3e {
    readValueFromInstance(e, r) {
        if (KS.has(r)) {
            const n = CJ(r);
            return n && n.default || 0
        } else {
            const n = L8t(e), i = (yEe(r) ? n.getPropertyValue(r) : n[r]) || 0;
            return typeof i == "string" ? i.trim() : i
        }
    }

    measureInstanceViewportBox(e, {transformPagePoint: r}) {
        return b3e(e, r)
    }

    build(e, r, n, i) {
        vJ(e, r, n, i.transformTemplate)
    }

    scrapeMotionValuesFromProps(e, r) {
        return SJ(e, r)
    }

    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(), delete this.childSubscription);
        const {children: e} = this.props;
        uf(e) && (this.childSubscription = e.on("change", r => {
            this.current && (this.current.textContent = `${r}`)
        }))
    }

    renderInstance(e, r, n, i) {
        EEe(e, r, n, i)
    }
}

class $8t extends M3e {
    constructor() {
        super(...arguments), this.isSVGTag = !1
    }

    getBaseTargetFromProps(e, r) {
        return e[r]
    }

    readValueFromInstance(e, r) {
        if (KS.has(r)) {
            const n = CJ(r);
            return n && n.default || 0
        }
        return r = TEe.has(r) ? r : wJ(r), e.getAttribute(r)
    }

    measureInstanceViewportBox() {
        return ns()
    }

    scrapeMotionValuesFromProps(e, r) {
        return AEe(e, r)
    }

    build(e, r, n, i) {
        yJ(e, r, n, this.isSVGTag, i.transformTemplate)
    }

    renderInstance(e, r, n, i) {
        CEe(e, r, n, i)
    }

    mount(e) {
        this.isSVGTag = bJ(e.tagName), super.mount(e)
    }
}

const F8t = (t, e) => mJ(t) ? new $8t(e, {enableHardwareAcceleration: !1}) : new B8t(e, {enableHardwareAcceleration: !0}),
    U8t = {layout: {ProjectionNode: I3e, MeasureLayout: S3e}}, j8t = {...dAt, ...PTt, ...g8t, ...U8t},
    E1 = V5t((t, e) => STt(t, e, j8t, F8t));

function O3e() {
    const t = W.useRef(!1);
    return fJ(() => (t.current = !0, () => {
        t.current = !1
    }), []), t
}

function z8t() {
    const t = O3e(), [e, r] = W.useState(0), n = W.useCallback(() => {
        t.current && r(e + 1)
    }, [e]);
    return [W.useCallback(() => Ta.postRender(n), [n]), e]
}

class V8t extends W.Component {
    getSnapshotBeforeUpdate(e) {
        const r = this.props.childRef.current;
        if (r && e.isPresent && !this.props.isPresent) {
            const n = this.props.sizeRef.current;
            n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft
        }
        return null
    }

    componentDidUpdate() {
    }

    render() {
        return this.props.children
    }
}

function H8t({children: t, isPresent: e}) {
    const r = W.useId(), n = W.useRef(null), i = W.useRef({width: 0, height: 0, top: 0, left: 0});
    return W.useInsertionEffect(() => {
        const {width: a, height: o, top: s, left: l} = i.current;
        if (e || !n.current || !a || !o) return;
        n.current.dataset.motionPopId = r;
        const f = document.createElement("style");
        return document.head.appendChild(f), f.sheet && f.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${o}px !important;
            top: ${s}px !important;
            left: ${l}px !important;
          }
        `), () => {
            document.head.removeChild(f)
        }
    }, [e]), W.createElement(V8t, {isPresent: e, childRef: n, sizeRef: i}, W.cloneElement(t, {ref: n}))
}

const cH = ({
                children: t,
                initial: e,
                isPresent: r,
                onExitComplete: n,
                custom: i,
                presenceAffectsLayout: a,
                mode: o
            }) => {
    const s = IEe(W8t), l = W.useId(), f = W.useMemo(() => ({
        id: l, initial: e, isPresent: r, custom: i, onExitComplete: d => {
            s.set(d, !0);
            for (const p of s.values()) if (!p) return;
            n && n()
        }, register: d => (s.set(d, !1), () => s.delete(d))
    }), a ? void 0 : [r]);
    return W.useMemo(() => {
        s.forEach((d, p) => s.set(p, !1))
    }, [r]), W.useEffect(() => {
        !r && !s.size && n && n()
    }, [r]), o === "popLayout" && (t = W.createElement(H8t, {isPresent: r}, t)), W.createElement(rI.Provider, {value: f}, t)
};

function W8t() {
    return new Map
}

function q8t(t) {
    return W.useEffect(() => () => t(), [])
}

const yx = t => t.key || "";

function G8t(t, e) {
    t.forEach(r => {
        const n = yx(r);
        e.set(n, r)
    })
}

function K8t(t) {
    const e = [];
    return W.Children.forEach(t, r => {
        W.isValidElement(r) && e.push(r)
    }), e
}

const i3 = ({
                children: t,
                custom: e,
                initial: r = !0,
                onExitComplete: n,
                exitBeforeEnter: i,
                presenceAffectsLayout: a = !0,
                mode: o = "sync"
            }) => {
    vp(!i, "Replace exitBeforeEnter with mode='wait'");
    const s = W.useContext(pJ).forceRender || z8t()[0], l = O3e(), f = K8t(t);
    let d = f;
    const p = W.useRef(new Map).current, g = W.useRef(d), b = W.useRef(new Map).current, S = W.useRef(!0);
    if (fJ(() => {
        S.current = !1, G8t(f, b), g.current = d
    }), q8t(() => {
        S.current = !0, b.clear(), p.clear()
    }), S.current) return W.createElement(W.Fragment, null, d.map(P => W.createElement(cH, {
        key: yx(P),
        isPresent: !0,
        initial: r ? void 0 : !1,
        presenceAffectsLayout: a,
        mode: o
    }, P)));
    d = [...d];
    const T = g.current.map(yx), I = f.map(yx), N = T.length;
    for (let P = 0; P < N; P++) {
        const F = T[P];
        I.indexOf(F) === -1 && !p.has(F) && p.set(F, void 0)
    }
    return o === "wait" && p.size && (d = []), p.forEach((P, F) => {
        if (I.indexOf(F) !== -1) return;
        const V = b.get(F);
        if (!V) return;
        const Y = T.indexOf(F);
        let ee = P;
        if (!ee) {
            const oe = () => {
                b.delete(F), p.delete(F);
                const G = g.current.findIndex(J => J.key === F);
                if (g.current.splice(G, 1), !p.size) {
                    if (g.current = f, l.current === !1) return;
                    s(), n && n()
                }
            };
            ee = W.createElement(cH, {
                key: yx(V),
                isPresent: !1,
                onExitComplete: oe,
                custom: e,
                presenceAffectsLayout: a,
                mode: o
            }, V), p.set(F, ee)
        }
        d.splice(Y, 0, ee)
    }), d = d.map(P => {
        const F = P.key;
        return p.has(F) ? P : W.createElement(cH, {key: yx(P), isPresent: !0, presenceAffectsLayout: a, mode: o}, P)
    }), Ve.env.NODE_ENV !== "production" && o === "wait" && d.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), W.createElement(W.Fragment, null, p.size ? d : d.map(P => W.cloneElement(P)))
};
var Y8t = {
    initial: t => {
        const {position: e} = t, r = ["top", "bottom"].includes(e) ? "y" : "x";
        let n = ["top-right", "bottom-right"].includes(e) ? 1 : -1;
        return e === "bottom" && (n = 1), {opacity: 0, [r]: n * 24}
    },
    animate: {opacity: 1, y: 0, x: 0, scale: 1, transition: {duration: .4, ease: [.4, 0, .2, 1]}},
    exit: {opacity: 0, scale: .85, transition: {duration: .2, ease: [.4, 0, 1, 1]}}
}, P3e = W.memo(t => {
    const {
        id: e,
        message: r,
        onCloseComplete: n,
        onRequestRemove: i,
        requestClose: a = !1,
        position: o = "bottom",
        duration: s = 5e3,
        containerStyle: l,
        motionVariants: f = Y8t,
        toastSpacing: d = "0.5rem"
    } = t, [p, g] = W.useState(s), b = PAt();
    rE(() => {
        b || n == null || n()
    }, [b]), rE(() => {
        g(s)
    }, [s]);
    const S = () => g(null), T = () => g(s), I = () => {
        b && i()
    };
    W.useEffect(() => {
        b && a && i()
    }, [b, a, i]), P5t(I, p);
    const N = W.useMemo(() => ({pointerEvents: "auto", maxWidth: 560, minWidth: 300, margin: d, ...l}), [l, d]),
        P = W.useMemo(() => M5t(o), [o]);
    return ie.jsx(E1.div, {
        layout: !0,
        className: "chakra-toast",
        variants: f,
        initial: "initial",
        animate: "animate",
        exit: "exit",
        onHoverStart: S,
        onHoverEnd: T,
        custom: {position: o},
        style: P,
        children: ie.jsx(on.div, {
            role: "status",
            "aria-atomic": "true",
            className: "chakra-toast__inner",
            __css: N,
            children: tp(r, {id: e, onClose: I})
        })
    })
});
P3e.displayName = "ToastComponent";

function X8t(t, e) {
    var r;
    const n = t ?? "bottom", a = {
        "top-start": {ltr: "top-left", rtl: "top-right"},
        "top-end": {ltr: "top-right", rtl: "top-left"},
        "bottom-start": {ltr: "bottom-left", rtl: "bottom-right"},
        "bottom-end": {ltr: "bottom-right", rtl: "bottom-left"}
    }[n];
    return (r = a == null ? void 0 : a[e]) != null ? r : n
}

var zhe = {
    path: ie.jsxs("g", {
        stroke: "currentColor",
        strokeWidth: "1.5",
        children: [ie.jsx("path", {
            strokeLinecap: "round",
            fill: "none",
            d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
        }), ie.jsx("path", {
            fill: "currentColor",
            strokeLinecap: "round",
            d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
        }), ie.jsx("circle", {fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25"})]
    }), viewBox: "0 0 24 24"
}, Wi = Jn((t, e) => {
    const {
            as: r,
            viewBox: n,
            color: i = "currentColor",
            focusable: a = !1,
            children: o,
            className: s,
            __css: l,
            ...f
        } = t, d = mi("chakra-icon", s), p = _1("Icon", t),
        g = {w: "1em", h: "1em", display: "inline-block", lineHeight: "1em", flexShrink: 0, color: i, ...l, ...p},
        b = {ref: e, focusable: a, className: d, __css: g}, S = n ?? zhe.viewBox;
    if (r && typeof r != "string") return ie.jsx(on.svg, {as: r, ...b, ...f});
    const T = o ?? zhe.path;
    return ie.jsx(on.svg, {verticalAlign: "middle", viewBox: S, ...b, ...f, children: T})
});
Wi.displayName = "Icon";

function Q8t(t) {
    return ie.jsx(Wi, {
        viewBox: "0 0 24 24", ...t,
        children: ie.jsx("path", {
            fill: "currentColor",
            d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
        })
    })
}

function Z8t(t) {
    return ie.jsx(Wi, {
        viewBox: "0 0 24 24", ...t,
        children: ie.jsx("path", {
            fill: "currentColor",
            d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
        })
    })
}

function Vhe(t) {
    return ie.jsx(Wi, {
        viewBox: "0 0 24 24", ...t,
        children: ie.jsx("path", {
            fill: "currentColor",
            d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
        })
    })
}

var J8t = Lwt({"0%": {transform: "rotate(0deg)"}, "100%": {transform: "rotate(360deg)"}}), aE = Jn((t, e) => {
    const r = _1("Spinner", t), {
        label: n = "Loading...",
        thickness: i = "2px",
        speed: a = "0.45s",
        emptyColor: o = "transparent",
        className: s,
        ...l
    } = Cp(t), f = mi("chakra-spinner", s), d = {
        display: "inline-block",
        borderColor: "currentColor",
        borderStyle: "solid",
        borderRadius: "99999px",
        borderWidth: i,
        borderBottomColor: o,
        borderLeftColor: o,
        animation: `${J8t} ${a} linear infinite`, ...r
    };
    return ie.jsx(on.div, {
        ref: e,
        __css: d,
        className: f, ...l,
        children: n && ie.jsx(on.span, {srOnly: !0, children: n})
    })
});
aE.displayName = "Spinner";
var [eIt, MJ] = rd({
    name: "AlertContext",
    hookName: "useAlertContext",
    providerName: "<Alert />"
}), [tIt, OJ] = rd({name: "AlertStylesContext", hookName: "useAlertStyles", providerName: "<Alert />"}), N3e = {
    info: {icon: Z8t, colorScheme: "blue"},
    warning: {icon: Vhe, colorScheme: "orange"},
    success: {icon: Q8t, colorScheme: "green"},
    error: {icon: Vhe, colorScheme: "red"},
    loading: {icon: aE, colorScheme: "blue"}
};

function rIt(t) {
    return N3e[t].colorScheme
}

function nIt(t) {
    return N3e[t].icon
}

var L3e = Jn(function (e, r) {
    const n = OJ(), {status: i} = MJ(), a = {display: "inline", ...n.description};
    return ie.jsx(on.div, {ref: r, "data-status": i, ...e, className: mi("chakra-alert__desc", e.className), __css: a})
});
L3e.displayName = "AlertDescription";

function B3e(t) {
    const {status: e} = MJ(), r = nIt(e), n = OJ(), i = e === "loading" ? n.spinner : n.icon;
    return ie.jsx(on.span, {
        display: "inherit",
        "data-status": e, ...t,
        className: mi("chakra-alert__icon", t.className),
        __css: i,
        children: t.children || ie.jsx(r, {h: "100%", w: "100%"})
    })
}

B3e.displayName = "AlertIcon";
var $3e = Jn(function (e, r) {
    const n = OJ(), {status: i} = MJ();
    return ie.jsx(on.div, {
        ref: r,
        "data-status": i, ...e,
        className: mi("chakra-alert__title", e.className),
        __css: n.title
    })
});
$3e.displayName = "AlertTitle";
var F3e = Jn(function (e, r) {
    var n;
    const {status: i = "info", addRole: a = !0, ...o} = Cp(e), s = (n = e.colorScheme) != null ? n : rIt(i),
        l = tI("Alert", {...e, colorScheme: s}), f = {
            width: "100%",
            display: "flex",
            alignItems: "center",
            position: "relative",
            overflow: "hidden", ...l.container
        };
    return ie.jsx(eIt, {
        value: {status: i},
        children: ie.jsx(tIt, {
            value: l,
            children: ie.jsx(on.div, {
                "data-status": i,
                role: a ? "alert" : void 0,
                ref: r, ...o,
                className: mi("chakra-alert", e.className),
                __css: f
            })
        })
    })
});
F3e.displayName = "Alert";

function iIt(t) {
    return ie.jsx(Wi, {
        focusable: "false",
        "aria-hidden": !0, ...t,
        children: ie.jsx("path", {
            fill: "currentColor",
            d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
        })
    })
}

var PJ = Jn(function (e, r) {
    const n = _1("CloseButton", e), {children: i, isDisabled: a, __css: o, ...s} = Cp(e),
        l = {outline: 0, display: "flex", alignItems: "center", justifyContent: "center", flexShrink: 0};
    return ie.jsx(on.button, {
        type: "button",
        "aria-label": "Close",
        ref: r,
        disabled: a,
        __css: {...l, ...n, ...o}, ...s,
        children: i || ie.jsx(iIt, {width: "1em", height: "1em"})
    })
});
PJ.displayName = "CloseButton";
var aIt = {top: [], "top-left": [], "top-right": [], "bottom-left": [], bottom: [], "bottom-right": []}, S0 = oIt(aIt);

function oIt(t) {
    let e = t;
    const r = new Set, n = i => {
        e = i(e), r.forEach(a => a())
    };
    return {
        getState: () => e, subscribe: i => (r.add(i), () => {
            n(() => t), r.delete(i)
        }), removeToast: (i, a) => {
            n(o => ({...o, [a]: o[a].filter(s => s.id != i)}))
        }, notify: (i, a) => {
            const o = sIt(i, a), {position: s, id: l} = o;
            return n(f => {
                var d, p;
                const b = s.includes("top") ? [o, ...(d = f[s]) != null ? d : []] : [...(p = f[s]) != null ? p : [], o];
                return {...f, [s]: b}
            }), l
        }, update: (i, a) => {
            i && n(o => {
                const s = {...o}, {position: l, index: f} = Nde(s, i);
                return l && f !== -1 && (s[l][f] = {...s[l][f], ...a, message: U3e(a)}), s
            })
        }, closeAll: ({positions: i} = {}) => {
            n(a => (i ?? ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"]).reduce((l, f) => (l[f] = a[f].map(d => ({
                ...d,
                requestClose: !0
            })), l), {...a}))
        }, close: i => {
            n(a => {
                const o = fEe(a, i);
                return o ? {...a, [o]: a[o].map(s => s.id == i ? {...s, requestClose: !0} : s)} : a
            })
        }, isActive: i => !!Nde(S0.getState(), i).position
    }
}

var Hhe = 0;

function sIt(t, e = {}) {
    var r, n;
    Hhe += 1;
    const i = (r = e.id) != null ? r : Hhe, a = (n = e.position) != null ? n : "bottom";
    return {
        id: i,
        message: t,
        position: a,
        duration: e.duration,
        onCloseComplete: e.onCloseComplete,
        onRequestRemove: () => S0.removeToast(String(i), a),
        status: e.status,
        requestClose: !1,
        containerStyle: e.containerStyle
    }
}

var cIt = t => {
    const {
        status: e,
        variant: r = "solid",
        id: n,
        title: i,
        isClosable: a,
        onClose: o,
        description: s,
        colorScheme: l,
        icon: f
    } = t, d = n ? {root: `toast-${n}`, title: `toast-${n}-title`, description: `toast-${n}-description`} : void 0;
    return ie.jsxs(F3e, {
        addRole: !1,
        status: e,
        variant: r,
        id: d == null ? void 0 : d.root,
        alignItems: "start",
        borderRadius: "md",
        boxShadow: "lg",
        paddingEnd: 8,
        textAlign: "start",
        width: "auto",
        colorScheme: l,
        children: [ie.jsx(B3e, {children: f}), ie.jsxs(on.div, {
            flex: "1",
            maxWidth: "100%",
            children: [i && ie.jsx($3e, {
                id: d == null ? void 0 : d.title,
                children: i
            }), s && ie.jsx(L3e, {id: d == null ? void 0 : d.description, display: "block", children: s})]
        }), a && ie.jsx(PJ, {size: "sm", onClick: o, position: "absolute", insetEnd: 1, top: 1})]
    })
};

function U3e(t = {}) {
    const {render: e, toastComponent: r = cIt} = t;
    return i => typeof e == "function" ? e({...i, ...t}) : ie.jsx(r, {...i, ...t})
}

function lIt(t, e) {
    const r = i => {
        var a;
        return {
            ...e, ...i,
            position: X8t((a = i == null ? void 0 : i.position) != null ? a : e == null ? void 0 : e.position, t)
        }
    }, n = i => {
        const a = r(i), o = U3e(a);
        return S0.notify(o, a)
    };
    return n.update = (i, a) => {
        S0.update(i, r(a))
    }, n.promise = (i, a) => {
        const o = n({...a.loading, status: "loading", duration: null});
        i.then(s => n.update(o, {
            status: "success",
            duration: 5e3, ...tp(a.success, s)
        })).catch(s => n.update(o, {status: "error", duration: 5e3, ...tp(a.error, s)}))
    }, n.closeAll = S0.closeAll, n.close = S0.close, n.isActive = S0.isActive, n
}

var [uIt, fIt] = rd({name: "ToastOptionsContext", strict: !1}), dIt = t => {
    const e = W.useSyncExternalStore(S0.subscribe, S0.getState, S0.getState), {
        motionVariants: r,
        component: n = P3e,
        portalProps: i
    } = t, o = Object.keys(e).map(s => {
        const l = e[s];
        return ie.jsx("div", {
            role: "region",
            "aria-live": "polite",
            "aria-label": "Notifications",
            id: `chakra-toast-manager-${s}`,
            style: O5t(s),
            children: ie.jsx(i3, {initial: !1, children: l.map(f => ie.jsx(n, {motionVariants: r, ...f}, f.id))})
        }, s)
    });
    return ie.jsx(GS, {...i, children: o})
};

function NJ(t) {
    const {theme: e} = N4e(), r = fIt();
    return W.useMemo(() => lIt(e.direction, {...r, ...t}), [t, e.direction, r])
}

var hIt = t => function ({children: r, theme: n = t, toastOptions: i, ...a}) {
        return ie.jsxs(R5t, {
            theme: n, ...a,
            children: [ie.jsx(uIt, {value: i == null ? void 0 : i.defaultOptions, children: r}), ie.jsx(dIt, {...i})]
        })
    }, pIt = hIt(pC), mIt = Object.defineProperty,
    vIt = (t, e, r) => e in t ? mIt(t, e, {enumerable: !0, configurable: !0, writable: !0, value: r}) : t[e] = r,
    _o = (t, e, r) => (vIt(t, typeof e != "symbol" ? e + "" : e, r), r);

function Whe(t) {
    return t.sort((e, r) => {
        const n = e.compareDocumentPosition(r);
        if (n & Node.DOCUMENT_POSITION_FOLLOWING || n & Node.DOCUMENT_POSITION_CONTAINED_BY) return -1;
        if (n & Node.DOCUMENT_POSITION_PRECEDING || n & Node.DOCUMENT_POSITION_CONTAINS) return 1;
        if (n & Node.DOCUMENT_POSITION_DISCONNECTED || n & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) throw Error("Cannot sort the given nodes.");
        return 0
    })
}

var gIt = t => typeof t == "object" && "nodeType" in t && t.nodeType === Node.ELEMENT_NODE;

function qhe(t, e, r) {
    let n = t + 1;
    return r && n >= e && (n = 0), n
}

function Ghe(t, e, r) {
    let n = t - 1;
    return r && n < 0 && (n = e), n
}

var kK = typeof window < "u" ? W.useLayoutEffect : W.useEffect, VO = t => t, yIt = class {
    constructor() {
        _o(this, "descendants", new Map), _o(this, "register", t => {
            if (t != null) return gIt(t) ? this.registerNode(t) : e => {
                this.registerNode(e, t)
            }
        }), _o(this, "unregister", t => {
            this.descendants.delete(t);
            const e = Whe(Array.from(this.descendants.keys()));
            this.assignIndex(e)
        }), _o(this, "destroy", () => {
            this.descendants.clear()
        }), _o(this, "assignIndex", t => {
            this.descendants.forEach(e => {
                const r = t.indexOf(e.node);
                e.index = r, e.node.dataset.index = e.index.toString()
            })
        }), _o(this, "count", () => this.descendants.size), _o(this, "enabledCount", () => this.enabledValues().length), _o(this, "values", () => Array.from(this.descendants.values()).sort((e, r) => e.index - r.index)), _o(this, "enabledValues", () => this.values().filter(t => !t.disabled)), _o(this, "item", t => {
            if (this.count() !== 0) return this.values()[t]
        }), _o(this, "enabledItem", t => {
            if (this.enabledCount() !== 0) return this.enabledValues()[t]
        }), _o(this, "first", () => this.item(0)), _o(this, "firstEnabled", () => this.enabledItem(0)), _o(this, "last", () => this.item(this.descendants.size - 1)), _o(this, "lastEnabled", () => {
            const t = this.enabledValues().length - 1;
            return this.enabledItem(t)
        }), _o(this, "indexOf", t => {
            var e, r;
            return t && (r = (e = this.descendants.get(t)) == null ? void 0 : e.index) != null ? r : -1
        }), _o(this, "enabledIndexOf", t => t == null ? -1 : this.enabledValues().findIndex(e => e.node.isSameNode(t))), _o(this, "next", (t, e = !0) => {
            const r = qhe(t, this.count(), e);
            return this.item(r)
        }), _o(this, "nextEnabled", (t, e = !0) => {
            const r = this.item(t);
            if (!r) return;
            const n = this.enabledIndexOf(r.node), i = qhe(n, this.enabledCount(), e);
            return this.enabledItem(i)
        }), _o(this, "prev", (t, e = !0) => {
            const r = Ghe(t, this.count() - 1, e);
            return this.item(r)
        }), _o(this, "prevEnabled", (t, e = !0) => {
            const r = this.item(t);
            if (!r) return;
            const n = this.enabledIndexOf(r.node), i = Ghe(n, this.enabledCount() - 1, e);
            return this.enabledItem(i)
        }), _o(this, "registerNode", (t, e) => {
            if (!t || this.descendants.has(t)) return;
            const r = Array.from(this.descendants.keys()).concat(t), n = Whe(r);
            e != null && e.disabled && (e.disabled = !!e.disabled);
            const i = {node: t, index: -1, ...e};
            this.descendants.set(t, i), this.assignIndex(n)
        })
    }
};

function bIt(t, e) {
    if (t != null) {
        if (typeof t == "function") {
            t(e);
            return
        }
        try {
            t.current = e
        } catch {
            throw new Error(`Cannot assign value '${e}' to ref '${t}'`)
        }
    }
}

function Kf(...t) {
    return e => {
        t.forEach(r => {
            bIt(r, e)
        })
    }
}

function wIt(...t) {
    return W.useMemo(() => Kf(...t), t)
}

function SIt() {
    const t = W.useRef(new yIt);
    return kK(() => () => t.current.destroy()), t.current
}

var [_It, j3e] = rd({
    name: "DescendantsProvider",
    errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});

function xIt(t) {
    const e = j3e(), [r, n] = W.useState(-1), i = W.useRef(null);
    kK(() => () => {
        i.current && e.unregister(i.current)
    }, []), kK(() => {
        if (!i.current) return;
        const o = Number(i.current.dataset.index);
        r != o && !Number.isNaN(o) && n(o)
    });
    const a = VO(t ? e.register(t) : e.register);
    return {descendants: e, index: r, enabledIndex: e.enabledIndexOf(i.current), register: Kf(a, i)}
}

function EIt() {
    return [VO(_It), () => VO(j3e()), () => SIt(), i => xIt(i)]
}

function TIt(t) {
    const {value: e, defaultValue: r, onChange: n, shouldUpdate: i = (g, b) => g !== b} = t, a = Uy(n),
        o = Uy(i), [s, l] = W.useState(r), f = e !== void 0, d = f ? e : s, p = Uy(g => {
            const S = typeof g == "function" ? g(d) : g;
            o(d, S) && (f || l(S), a(S))
        }, [f, a, d, o]);
    return [d, p]
}

var Khe = {ease: [.25, .1, .25, 1], easeIn: [.4, 0, 1, 1], easeOut: [0, 0, .2, 1], easeInOut: [.4, 0, .2, 1]}, cT = {
    scale: {enter: {scale: 1}, exit: {scale: .95}},
    fade: {enter: {opacity: 1}, exit: {opacity: 0}},
    pushLeft: {enter: {x: "100%"}, exit: {x: "-30%"}},
    pushRight: {enter: {x: "-100%"}, exit: {x: "30%"}},
    pushUp: {enter: {y: "100%"}, exit: {y: "-30%"}},
    pushDown: {enter: {y: "-100%"}, exit: {y: "30%"}},
    slideLeft: {position: {left: 0, top: 0, bottom: 0, width: "100%"}, enter: {x: 0, y: 0}, exit: {x: "-100%", y: 0}},
    slideRight: {position: {right: 0, top: 0, bottom: 0, width: "100%"}, enter: {x: 0, y: 0}, exit: {x: "100%", y: 0}},
    slideUp: {position: {top: 0, left: 0, right: 0, maxWidth: "100vw"}, enter: {x: 0, y: 0}, exit: {x: 0, y: "-100%"}},
    slideDown: {
        position: {bottom: 0, left: 0, right: 0, maxWidth: "100vw"},
        enter: {x: 0, y: 0},
        exit: {x: 0, y: "100%"}
    }
};

function JJt(t) {
    var e;
    switch ((e = t == null ? void 0 : t.direction) != null ? e : "right") {
        case"right":
            return cT.slideRight;
        case"left":
            return cT.slideLeft;
        case"bottom":
            return cT.slideDown;
        case"top":
            return cT.slideUp;
        default:
            return cT.slideRight
    }
}

var Ww = {enter: {duration: .2, ease: Khe.easeOut}, exit: {duration: .1, ease: Khe.easeIn}}, qw = {
    enter: (t, e) => ({...t, delay: typeof e == "number" ? e : e == null ? void 0 : e.enter}),
    exit: (t, e) => ({...t, delay: typeof e == "number" ? e : e == null ? void 0 : e.exit})
}, CIt = {
    enter: ({transition: t, transitionEnd: e, delay: r} = {}) => {
        var n;
        return {
            opacity: 1,
            transition: (n = t == null ? void 0 : t.enter) != null ? n : qw.enter(Ww.enter, r),
            transitionEnd: e == null ? void 0 : e.enter
        }
    }, exit: ({transition: t, transitionEnd: e, delay: r} = {}) => {
        var n;
        return {
            opacity: 0,
            transition: (n = t == null ? void 0 : t.exit) != null ? n : qw.exit(Ww.exit, r),
            transitionEnd: e == null ? void 0 : e.exit
        }
    }
}, z3e = {initial: "exit", animate: "enter", exit: "exit", variants: CIt}, AIt = W.forwardRef(function (e, r) {
    const {unmountOnExit: n, in: i, className: a, transition: o, transitionEnd: s, delay: l, ...f} = e,
        d = i || n ? "enter" : "exit", p = n ? i && n : !0, g = {transition: o, transitionEnd: s, delay: l};
    return ie.jsx(i3, {
        custom: g,
        children: p && ie.jsx(E1.div, {ref: r, className: mi("chakra-fade", a), custom: g, ...z3e, animate: d, ...f})
    })
});
AIt.displayName = "Fade";
var IIt = {
    exit: ({reverse: t, initialScale: e, transition: r, transitionEnd: n, delay: i}) => {
        var a;
        return {
            opacity: 0, ...t ? {
                scale: e,
                transitionEnd: n == null ? void 0 : n.exit
            } : {transitionEnd: {scale: e, ...n == null ? void 0 : n.exit}},
            transition: (a = r == null ? void 0 : r.exit) != null ? a : qw.exit(Ww.exit, i)
        }
    }, enter: ({transitionEnd: t, transition: e, delay: r}) => {
        var n;
        return {
            opacity: 1,
            scale: 1,
            transition: (n = e == null ? void 0 : e.enter) != null ? n : qw.enter(Ww.enter, r),
            transitionEnd: t == null ? void 0 : t.enter
        }
    }
}, V3e = {initial: "exit", animate: "enter", exit: "exit", variants: IIt}, kIt = W.forwardRef(function (e, r) {
    const {
            unmountOnExit: n,
            in: i,
            reverse: a = !0,
            initialScale: o = .95,
            className: s,
            transition: l,
            transitionEnd: f,
            delay: d,
            ...p
        } = e, g = n ? i && n : !0, b = i || n ? "enter" : "exit",
        S = {initialScale: o, reverse: a, transition: l, transitionEnd: f, delay: d};
    return ie.jsx(i3, {
        custom: S,
        children: g && ie.jsx(E1.div, {
            ref: r,
            className: mi("chakra-offset-slide", s), ...V3e,
            animate: b,
            custom: S, ...p
        })
    })
});
kIt.displayName = "ScaleFade";
var RIt = {
    initial: ({offsetX: t, offsetY: e, transition: r, transitionEnd: n, delay: i}) => {
        var a;
        return {
            opacity: 0,
            x: t,
            y: e,
            transition: (a = r == null ? void 0 : r.exit) != null ? a : qw.exit(Ww.exit, i),
            transitionEnd: n == null ? void 0 : n.exit
        }
    }, enter: ({transition: t, transitionEnd: e, delay: r}) => {
        var n;
        return {
            opacity: 1,
            x: 0,
            y: 0,
            transition: (n = t == null ? void 0 : t.enter) != null ? n : qw.enter(Ww.enter, r),
            transitionEnd: e == null ? void 0 : e.enter
        }
    }, exit: ({offsetY: t, offsetX: e, transition: r, transitionEnd: n, reverse: i, delay: a}) => {
        var o;
        const s = {x: e, y: t};
        return {
            opacity: 0,
            transition: (o = r == null ? void 0 : r.exit) != null ? o : qw.exit(Ww.exit, a), ...i ? {
                ...s,
                transitionEnd: n == null ? void 0 : n.exit
            } : {transitionEnd: {...s, ...n == null ? void 0 : n.exit}}
        }
    }
}, FT = {initial: "initial", animate: "enter", exit: "exit", variants: RIt}, DIt = W.forwardRef(function (e, r) {
    const {
            unmountOnExit: n,
            in: i,
            reverse: a = !0,
            className: o,
            offsetX: s = 0,
            offsetY: l = 8,
            transition: f,
            transitionEnd: d,
            delay: p,
            ...g
        } = e, b = n ? i && n : !0, S = i || n ? "enter" : "exit",
        T = {offsetX: s, offsetY: l, reverse: a, transition: f, transitionEnd: d, delay: p};
    return ie.jsx(i3, {
        custom: T,
        children: b && ie.jsx(E1.div, {
            ref: r,
            className: mi("chakra-offset-slide", o),
            custom: T, ...FT,
            animate: S, ...g
        })
    })
});
DIt.displayName = "SlideFade";
var H3e = Jn(function (e, r) {
    const {htmlWidth: n, htmlHeight: i, alt: a, ...o} = e;
    return ie.jsx("img", {width: n, height: i, ref: r, alt: a, ...o})
});
H3e.displayName = "NativeImage";
var bC = Jn((t, e) => ie.jsx(on.img, {ref: e, as: H3e, className: "chakra-image", ...t}));

function W3e(t) {
    return W.Children.toArray(t).filter(e => W.isValidElement(e))
}

var [MIt, OIt] = rd({strict: !1, name: "ButtonGroupContext"}), PIt = {
    horizontal: {
        "> *:first-of-type:not(:last-of-type)": {borderEndRadius: 0},
        "> *:not(:first-of-type):not(:last-of-type)": {borderRadius: 0},
        "> *:not(:first-of-type):last-of-type": {borderStartRadius: 0}
    },
    vertical: {
        "> *:first-of-type:not(:last-of-type)": {borderBottomRadius: 0},
        "> *:not(:first-of-type):not(:last-of-type)": {borderRadius: 0},
        "> *:not(:first-of-type):last-of-type": {borderTopRadius: 0}
    }
}, NIt = {
    horizontal: t => ({"& > *:not(style) ~ *:not(style)": {marginStart: t}}),
    vertical: t => ({"& > *:not(style) ~ *:not(style)": {marginTop: t}})
}, q3e = Jn(function (e, r) {
    const {
            size: n,
            colorScheme: i,
            variant: a,
            className: o,
            spacing: s = "0.5rem",
            isAttached: l,
            isDisabled: f,
            orientation: d = "horizontal",
            ...p
        } = e, g = mi("chakra-button__group", o),
        b = W.useMemo(() => ({size: n, colorScheme: i, variant: a, isDisabled: f}), [n, i, a, f]);
    let S = {display: "inline-flex", ...l ? PIt[d] : NIt[d](s)};
    const T = d === "vertical";
    return ie.jsx(MIt, {
        value: b,
        children: ie.jsx(on.div, {
            ref: r,
            role: "group",
            __css: S,
            className: g,
            "data-attached": l ? "" : void 0,
            "data-orientation": d,
            flexDir: T ? "column" : void 0, ...p
        })
    })
});
q3e.displayName = "ButtonGroup";

function LIt(t) {
    const [e, r] = W.useState(!t);
    return {
        ref: W.useCallback(a => {
            a && r(a.tagName === "BUTTON")
        }, []), type: e ? "button" : void 0
    }
}

function RK(t) {
    const {children: e, className: r, ...n} = t,
        i = W.isValidElement(e) ? W.cloneElement(e, {"aria-hidden": !0, focusable: !1}) : e,
        a = mi("chakra-button__icon", r);
    return ie.jsx(on.span, {
        display: "inline-flex",
        alignSelf: "center",
        flexShrink: 0, ...n,
        className: a,
        children: i
    })
}

RK.displayName = "ButtonIcon";

function DK(t) {
    const {
        label: e,
        placement: r,
        spacing: n = "0.5rem",
        children: i = ie.jsx(aE, {color: "currentColor", width: "1em", height: "1em"}),
        className: a,
        __css: o,
        ...s
    } = t, l = mi("chakra-button__spinner", a), f = r === "start" ? "marginEnd" : "marginStart", d = W.useMemo(() => ({
        display: "flex",
        alignItems: "center",
        position: e ? "relative" : "absolute",
        [f]: e ? n : 0,
        fontSize: "1em",
        lineHeight: "normal", ...o
    }), [o, e, f, n]);
    return ie.jsx(on.div, {className: l, ...s, __css: d, children: i})
}

DK.displayName = "ButtonSpinner";
var Hc = Jn((t, e) => {
    const r = OIt(), n = _1("Button", {...r, ...t}), {
        isDisabled: i = r == null ? void 0 : r.isDisabled,
        isLoading: a,
        isActive: o,
        children: s,
        leftIcon: l,
        rightIcon: f,
        loadingText: d,
        iconSpacing: p = "0.5rem",
        type: g,
        spinner: b,
        spinnerPlacement: S = "start",
        className: T,
        as: I,
        ...N
    } = Cp(t), P = W.useMemo(() => {
        const ee = {...n == null ? void 0 : n._focus, zIndex: 1};
        return {
            display: "inline-flex",
            appearance: "none",
            alignItems: "center",
            justifyContent: "center",
            userSelect: "none",
            position: "relative",
            whiteSpace: "nowrap",
            verticalAlign: "middle",
            outline: "none", ...n, ...!!r && {_focus: ee}
        }
    }, [n, r]), {ref: F, type: V} = LIt(I), Y = {rightIcon: f, leftIcon: l, iconSpacing: p, children: s};
    return ie.jsxs(on.button, {
        ref: wIt(e, F),
        as: I,
        type: g ?? V,
        "data-active": Ry(o),
        "data-loading": Ry(a),
        __css: P,
        className: mi("chakra-button", T), ...N,
        disabled: i || a,
        children: [a && S === "start" && ie.jsx(DK, {
            className: "chakra-button__spinner--start",
            label: d,
            placement: "start",
            spacing: p,
            children: b
        }), a ? d || ie.jsx(on.span, {
            opacity: 0,
            children: ie.jsx(Yhe, {...Y})
        }) : ie.jsx(Yhe, {...Y}), a && S === "end" && ie.jsx(DK, {
            className: "chakra-button__spinner--end",
            label: d,
            placement: "end",
            spacing: p,
            children: b
        })]
    })
});
Hc.displayName = "Button";

function Yhe(t) {
    const {leftIcon: e, rightIcon: r, children: n, iconSpacing: i} = t;
    return ie.jsxs(ie.Fragment, {
        children: [e && ie.jsx(RK, {
            marginEnd: i,
            children: e
        }), n, r && ie.jsx(RK, {marginStart: i, children: r})]
    })
}

var cu = Jn((t, e) => {
    const {icon: r, children: n, isRound: i, "aria-label": a, ...o} = t, s = r || n,
        l = W.isValidElement(s) ? W.cloneElement(s, {"aria-hidden": !0, focusable: !1}) : null;
    return ie.jsx(Hc, {padding: "0", borderRadius: i ? "full" : void 0, ref: e, "aria-label": a, ...o, children: l})
});
cu.displayName = "IconButton";
var [BIt, $It] = rd({
    name: "FormControlStylesContext",
    errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
}), [FIt, G3e] = rd({strict: !1, name: "FormControlContext"});

function UIt(t) {
    const {id: e, isRequired: r, isInvalid: n, isDisabled: i, isReadOnly: a, ...o} = t, s = W.useId(),
        l = e || `field-${s}`, f = `${l}-label`, d = `${l}-feedback`,
        p = `${l}-helptext`, [g, b] = W.useState(!1), [S, T] = W.useState(!1), [I, N] = W.useState(!1),
        P = W.useCallback((oe = {}, G = null) => ({
            id: p, ...oe, ref: Kf(G, J => {
                J && T(!0)
            })
        }), [p]), F = W.useCallback((oe = {}, G = null) => ({
            ...oe,
            ref: G,
            "data-focus": Ry(I),
            "data-disabled": Ry(i),
            "data-invalid": Ry(n),
            "data-readonly": Ry(a),
            id: oe.id !== void 0 ? oe.id : f,
            htmlFor: oe.htmlFor !== void 0 ? oe.htmlFor : l
        }), [l, i, I, n, a, f]), V = W.useCallback((oe = {}, G = null) => ({
            id: d, ...oe, ref: Kf(G, J => {
                J && b(!0)
            }), "aria-live": "polite"
        }), [d]), Y = W.useCallback((oe = {}, G = null) => ({...oe, ...o, ref: G, role: "group"}), [o]),
        ee = W.useCallback((oe = {}, G = null) => ({
            ...oe,
            ref: G,
            role: "presentation",
            "aria-hidden": !0,
            children: oe.children || "*"
        }), []);
    return {
        isRequired: !!r,
        isInvalid: !!n,
        isReadOnly: !!a,
        isDisabled: !!i,
        isFocused: !!I,
        onFocus: () => N(!0),
        onBlur: () => N(!1),
        hasFeedbackText: g,
        setHasFeedbackText: b,
        hasHelpText: S,
        setHasHelpText: T,
        id: l,
        labelId: f,
        feedbackId: d,
        helpTextId: p,
        htmlProps: o,
        getHelpTextProps: P,
        getErrorMessageProps: V,
        getRootProps: Y,
        getLabelProps: F,
        getRequiredIndicatorProps: ee
    }
}

var jIt = Jn(function (e, r) {
    const n = tI("Form", e), i = Cp(e), {getRootProps: a, htmlProps: o, ...s} = UIt(i),
        l = mi("chakra-form-control", e.className);
    return ie.jsx(FIt, {
        value: s,
        children: ie.jsx(BIt, {value: n, children: ie.jsx(on.div, {...a({}, r), className: l, __css: n.container})})
    })
});
jIt.displayName = "FormControl";
var zIt = Jn(function (e, r) {
    const n = G3e(), i = $It(), a = mi("chakra-form__helper-text", e.className);
    return ie.jsx(on.div, {...n == null ? void 0 : n.getHelpTextProps(e, r), __css: i.helperText, className: a})
});
zIt.displayName = "FormHelperText";

function VIt(t) {
    const {isDisabled: e, isInvalid: r, isReadOnly: n, isRequired: i, ...a} = HIt(t);
    return {
        ...a,
        disabled: e,
        readOnly: n,
        required: i,
        "aria-invalid": DV(r),
        "aria-required": DV(i),
        "aria-readonly": DV(n)
    }
}

function HIt(t) {
    var e, r, n;
    const i = G3e(), {
        id: a,
        disabled: o,
        readOnly: s,
        required: l,
        isRequired: f,
        isInvalid: d,
        isReadOnly: p,
        isDisabled: g,
        onFocus: b,
        onBlur: S,
        ...T
    } = t, I = t["aria-describedby"] ? [t["aria-describedby"]] : [];
    return i != null && i.hasFeedbackText && (i != null && i.isInvalid) && I.push(i.feedbackId), i != null && i.hasHelpText && I.push(i.helpTextId), {
        ...T,
        "aria-describedby": I.join(" ") || void 0,
        id: a ?? (i == null ? void 0 : i.id),
        isDisabled: (e = o ?? g) != null ? e : i == null ? void 0 : i.isDisabled,
        isReadOnly: (r = s ?? p) != null ? r : i == null ? void 0 : i.isReadOnly,
        isRequired: (n = l ?? f) != null ? n : i == null ? void 0 : i.isRequired,
        isInvalid: d ?? (i == null ? void 0 : i.isInvalid),
        onFocus: iu(i == null ? void 0 : i.onFocus, b),
        onBlur: iu(i == null ? void 0 : i.onBlur, S)
    }
}

function wC(t, e, r, n) {
    const i = Uy(r);
    return W.useEffect(() => {
        const a = typeof t == "function" ? t() : t ?? document;
        if (!(!r || !a)) return a.addEventListener(e, i, n), () => {
            a.removeEventListener(e, i, n)
        }
    }, [e, t, n, i, r]), () => {
        const a = typeof t == "function" ? t() : t ?? document;
        a == null || a.removeEventListener(e, i, n)
    }
}

function WIt(t, e) {
    if (t == null) return {};
    var r = {};
    for (var n in t) if (Object.prototype.hasOwnProperty.call(t, n)) {
        if (e.indexOf(n) >= 0) continue;
        r[n] = t[n]
    }
    return r
}

var MK = {exports: {}};
var lH, Xhe;

function qIt() {
    if (Xhe) return lH;
    Xhe = 1;
    var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty,
        r = Object.prototype.propertyIsEnumerable;

    function n(a) {
        if (a == null) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(a)
    }

    function i() {
        try {
            if (!Object.assign) return !1;
            var a = new String("abc");
            if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5") return !1;
            for (var o = {}, s = 0; s < 10; s++) o["_" + String.fromCharCode(s)] = s;
            var l = Object.getOwnPropertyNames(o).map(function (d) {
                return o[d]
            });
            if (l.join("") !== "0123456789") return !1;
            var f = {};
            return "abcdefghijklmnopqrst".split("").forEach(function (d) {
                f[d] = d
            }), Object.keys(Object.assign({}, f)).join("") === "abcdefghijklmnopqrst"
        } catch {
            return !1
        }
    }

    return lH = i() ? Object.assign : function (a, o) {
        for (var s, l = n(a), f, d = 1; d < arguments.length; d++) {
            s = Object(arguments[d]);
            for (var p in s) e.call(s, p) && (l[p] = s[p]);
            if (t) {
                f = t(s);
                for (var g = 0; g < f.length; g++) r.call(s, f[g]) && (l[f[g]] = s[f[g]])
            }
        }
        return l
    }, lH
}

var uH, Qhe;

function LJ() {
    if (Qhe) return uH;
    Qhe = 1;
    var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return uH = t, uH
}

var fH, Zhe;

function K3e() {
    return Zhe || (Zhe = 1, fH = Function.call.bind(Object.prototype.hasOwnProperty)), fH
}

var dH, Jhe;

function GIt() {
    if (Jhe) return dH;
    Jhe = 1;
    var t = function () {
    };
    if (Ve.env.NODE_ENV !== "production") {
        var e = LJ(), r = {}, n = K3e();
        t = function (a) {
            var o = "Warning: " + a;
            typeof console < "u" && console.error(o);
            try {
                throw new Error(o)
            } catch {
            }
        }
    }

    function i(a, o, s, l, f) {
        if (Ve.env.NODE_ENV !== "production") {
            for (var d in a) if (n(a, d)) {
                var p;
                try {
                    if (typeof a[d] != "function") {
                        var g = Error((l || "React class") + ": " + s + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                        throw g.name = "Invariant Violation", g
                    }
                    p = a[d](o, d, l, s, null, e)
                } catch (S) {
                    p = S
                }
                if (p && !(p instanceof Error) && t((l || "React class") + ": type specification of " + s + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."), p instanceof Error && !(p.message in r)) {
                    r[p.message] = !0;
                    var b = f ? f() : "";
                    t("Failed " + s + " type: " + p.message + (b ?? ""))
                }
            }
        }
    }

    return i.resetWarningCache = function () {
        Ve.env.NODE_ENV !== "production" && (r = {})
    }, dH = i, dH
}

var hH, epe;

function KIt() {
    if (epe) return hH;
    epe = 1;
    var t = T4e, e = qIt(), r = LJ(), n = K3e(), i = GIt(), a = function () {
    };
    Ve.env.NODE_ENV !== "production" && (a = function (s) {
        var l = "Warning: " + s;
        typeof console < "u" && console.error(l);
        try {
            throw new Error(l)
        } catch {
        }
    });

    function o() {
        return null
    }

    return hH = function (s, l) {
        var f = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";

        function p(C) {
            var R = C && (f && C[f] || C[d]);
            if (typeof R == "function") return R
        }

        var g = "<<anonymous>>", b = {
            array: N("array"),
            bigint: N("bigint"),
            bool: N("boolean"),
            func: N("function"),
            number: N("number"),
            object: N("object"),
            string: N("string"),
            symbol: N("symbol"),
            any: P(),
            arrayOf: F,
            element: V(),
            elementType: Y(),
            instanceOf: ee,
            node: ce(),
            objectOf: G,
            oneOf: oe,
            oneOfType: J,
            shape: M,
            exact: D
        };

        function S(C, R) {
            return C === R ? C !== 0 || 1 / C === 1 / R : C !== C && R !== R
        }

        function T(C, R) {
            this.message = C, this.data = R && typeof R == "object" ? R : {}, this.stack = ""
        }

        T.prototype = Error.prototype;

        function I(C) {
            if (Ve.env.NODE_ENV !== "production") var R = {}, k = 0;

            function Q(ye, ue, me, Se, Ce, Me, ve) {
                if (Se = Se || g, Me = Me || me, ve !== r) {
                    if (l) {
                        var ne = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                        throw ne.name = "Invariant Violation", ne
                    } else if (Ve.env.NODE_ENV !== "production" && typeof console < "u") {
                        var be = Se + ":" + me;
                        !R[be] && k < 3 && (a("You are manually calling a React.PropTypes validation function for the `" + Me + "` prop on `" + Se + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."), R[be] = !0, k++)
                    }
                }
                return ue[me] == null ? ye ? ue[me] === null ? new T("The " + Ce + " `" + Me + "` is marked as required " + ("in `" + Se + "`, but its value is `null`.")) : new T("The " + Ce + " `" + Me + "` is marked as required in " + ("`" + Se + "`, but its value is `undefined`.")) : null : C(ue, me, Se, Ce, Me)
            }

            var fe = Q.bind(null, !1);
            return fe.isRequired = Q.bind(null, !0), fe
        }

        function N(C) {
            function R(k, Q, fe, ye, ue, me) {
                var Se = k[Q], Ce = B(Se);
                if (Ce !== C) {
                    var Me = z(Se);
                    return new T("Invalid " + ye + " `" + ue + "` of type " + ("`" + Me + "` supplied to `" + fe + "`, expected ") + ("`" + C + "`."), {expectedType: C})
                }
                return null
            }

            return I(R)
        }

        function P() {
            return I(o)
        }

        function F(C) {
            function R(k, Q, fe, ye, ue) {
                if (typeof C != "function") return new T("Property `" + ue + "` of component `" + fe + "` has invalid PropType notation inside arrayOf.");
                var me = k[Q];
                if (!Array.isArray(me)) {
                    var Se = B(me);
                    return new T("Invalid " + ye + " `" + ue + "` of type " + ("`" + Se + "` supplied to `" + fe + "`, expected an array."))
                }
                for (var Ce = 0; Ce < me.length; Ce++) {
                    var Me = C(me, Ce, fe, ye, ue + "[" + Ce + "]", r);
                    if (Me instanceof Error) return Me
                }
                return null
            }

            return I(R)
        }

        function V() {
            function C(R, k, Q, fe, ye) {
                var ue = R[k];
                if (!s(ue)) {
                    var me = B(ue);
                    return new T("Invalid " + fe + " `" + ye + "` of type " + ("`" + me + "` supplied to `" + Q + "`, expected a single ReactElement."))
                }
                return null
            }

            return I(C)
        }

        function Y() {
            function C(R, k, Q, fe, ye) {
                var ue = R[k];
                if (!t.isValidElementType(ue)) {
                    var me = B(ue);
                    return new T("Invalid " + fe + " `" + ye + "` of type " + ("`" + me + "` supplied to `" + Q + "`, expected a single ReactElement type."))
                }
                return null
            }

            return I(C)
        }

        function ee(C) {
            function R(k, Q, fe, ye, ue) {
                if (!(k[Q] instanceof C)) {
                    var me = C.name || g, Se = $(k[Q]);
                    return new T("Invalid " + ye + " `" + ue + "` of type " + ("`" + Se + "` supplied to `" + fe + "`, expected ") + ("instance of `" + me + "`."))
                }
                return null
            }

            return I(R)
        }

        function oe(C) {
            if (!Array.isArray(C)) return Ve.env.NODE_ENV !== "production" && (arguments.length > 1 ? a("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).") : a("Invalid argument supplied to oneOf, expected an array.")), o;

            function R(k, Q, fe, ye, ue) {
                for (var me = k[Q], Se = 0; Se < C.length; Se++) if (S(me, C[Se])) return null;
                var Ce = JSON.stringify(C, function (ve, ne) {
                    var be = z(ne);
                    return be === "symbol" ? String(ne) : ne
                });
                return new T("Invalid " + ye + " `" + ue + "` of value `" + String(me) + "` " + ("supplied to `" + fe + "`, expected one of " + Ce + "."))
            }

            return I(R)
        }

        function G(C) {
            function R(k, Q, fe, ye, ue) {
                if (typeof C != "function") return new T("Property `" + ue + "` of component `" + fe + "` has invalid PropType notation inside objectOf.");
                var me = k[Q], Se = B(me);
                if (Se !== "object") return new T("Invalid " + ye + " `" + ue + "` of type " + ("`" + Se + "` supplied to `" + fe + "`, expected an object."));
                for (var Ce in me) if (n(me, Ce)) {
                    var Me = C(me, Ce, fe, ye, ue + "." + Ce, r);
                    if (Me instanceof Error) return Me
                }
                return null
            }

            return I(R)
        }

        function J(C) {
            if (!Array.isArray(C)) return Ve.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
            for (var R = 0; R < C.length; R++) {
                var k = C[R];
                if (typeof k != "function") return a("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + j(k) + " at index " + R + "."), o
            }

            function Q(fe, ye, ue, me, Se) {
                for (var Ce = [], Me = 0; Me < C.length; Me++) {
                    var ve = C[Me], ne = ve(fe, ye, ue, me, Se, r);
                    if (ne == null) return null;
                    ne.data && n(ne.data, "expectedType") && Ce.push(ne.data.expectedType)
                }
                var be = Ce.length > 0 ? ", expected one of type [" + Ce.join(", ") + "]" : "";
                return new T("Invalid " + me + " `" + Se + "` supplied to " + ("`" + ue + "`" + be + "."))
            }

            return I(Q)
        }

        function ce() {
            function C(R, k, Q, fe, ye) {
                return x(R[k]) ? null : new T("Invalid " + fe + " `" + ye + "` supplied to " + ("`" + Q + "`, expected a ReactNode."))
            }

            return I(C)
        }

        function re(C, R, k, Q, fe) {
            return new T((C || "React class") + ": " + R + " type `" + k + "." + Q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + fe + "`.")
        }

        function M(C) {
            function R(k, Q, fe, ye, ue) {
                var me = k[Q], Se = B(me);
                if (Se !== "object") return new T("Invalid " + ye + " `" + ue + "` of type `" + Se + "` " + ("supplied to `" + fe + "`, expected `object`."));
                for (var Ce in C) {
                    var Me = C[Ce];
                    if (typeof Me != "function") return re(fe, ye, ue, Ce, z(Me));
                    var ve = Me(me, Ce, fe, ye, ue + "." + Ce, r);
                    if (ve) return ve
                }
                return null
            }

            return I(R)
        }

        function D(C) {
            function R(k, Q, fe, ye, ue) {
                var me = k[Q], Se = B(me);
                if (Se !== "object") return new T("Invalid " + ye + " `" + ue + "` of type `" + Se + "` " + ("supplied to `" + fe + "`, expected `object`."));
                var Ce = e({}, k[Q], C);
                for (var Me in Ce) {
                    var ve = C[Me];
                    if (n(C, Me) && typeof ve != "function") return re(fe, ye, ue, Me, z(ve));
                    if (!ve) return new T("Invalid " + ye + " `" + ue + "` key `" + Me + "` supplied to `" + fe + "`.\nBad object: " + JSON.stringify(k[Q], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(C), null, "  "));
                    var ne = ve(me, Me, fe, ye, ue + "." + Me, r);
                    if (ne) return ne
                }
                return null
            }

            return I(R)
        }

        function x(C) {
            switch (typeof C) {
                case"number":
                case"string":
                case"undefined":
                    return !0;
                case"boolean":
                    return !C;
                case"object":
                    if (Array.isArray(C)) return C.every(x);
                    if (C === null || s(C)) return !0;
                    var R = p(C);
                    if (R) {
                        var k = R.call(C), Q;
                        if (R !== C.entries) {
                            for (; !(Q = k.next()).done;) if (!x(Q.value)) return !1
                        } else for (; !(Q = k.next()).done;) {
                            var fe = Q.value;
                            if (fe && !x(fe[1])) return !1
                        }
                    } else return !1;
                    return !0;
                default:
                    return !1
            }
        }

        function A(C, R) {
            return C === "symbol" ? !0 : R ? R["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && R instanceof Symbol : !1
        }

        function B(C) {
            var R = typeof C;
            return Array.isArray(C) ? "array" : C instanceof RegExp ? "object" : A(R, C) ? "symbol" : R
        }

        function z(C) {
            if (typeof C > "u" || C === null) return "" + C;
            var R = B(C);
            if (R === "object") {
                if (C instanceof Date) return "date";
                if (C instanceof RegExp) return "regexp"
            }
            return R
        }

        function j(C) {
            var R = z(C);
            switch (R) {
                case"array":
                case"object":
                    return "an " + R;
                case"boolean":
                case"date":
                case"regexp":
                    return "a " + R;
                default:
                    return R
            }
        }

        function $(C) {
            return !C.constructor || !C.constructor.name ? g : C.constructor.name
        }

        return b.checkPropTypes = i, b.resetWarningCache = i.resetWarningCache, b.PropTypes = b, b
    }, hH
}

var pH, tpe;

function YIt() {
    if (tpe) return pH;
    tpe = 1;
    var t = LJ();

    function e() {
    }

    function r() {
    }

    return r.resetWarningCache = e, pH = function () {
        function n(o, s, l, f, d, p) {
            if (p !== t) {
                var g = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw g.name = "Invariant Violation", g
            }
        }

        n.isRequired = n;

        function i() {
            return n
        }

        var a = {
            array: n,
            bigint: n,
            bool: n,
            func: n,
            number: n,
            object: n,
            string: n,
            symbol: n,
            any: n,
            arrayOf: i,
            element: n,
            elementType: n,
            instanceOf: i,
            node: n,
            objectOf: i,
            oneOf: i,
            oneOfType: i,
            shape: i,
            exact: i,
            checkPropTypes: r,
            resetWarningCache: e
        };
        return a.PropTypes = a, a
    }, pH
}

if (Ve.env.NODE_ENV !== "production") {
    var XIt = T4e, QIt = !0;
    MK.exports = KIt()(XIt.isElement, QIt)
} else MK.exports = YIt()();
var ma = MK.exports;
const eer = za(ma);
var OK = "data-focus-lock", Y3e = "data-focus-lock-disabled", ZIt = "data-no-focus-lock", JIt = "data-autofocus-inside",
    ekt = "data-no-autofocus";

function tkt(t, e) {
    return typeof t == "function" ? t(e) : t && (t.current = e), t
}

function rkt(t, e) {
    var r = W.useState(function () {
        return {
            value: t, callback: e, facade: {
                get current() {
                    return r.value
                }, set current(n) {
                    var i = r.value;
                    i !== n && (r.value = n, r.callback(n, i))
                }
            }
        }
    })[0];
    return r.callback = e, r.facade
}

function X3e(t, e) {
    return rkt(e || null, function (r) {
        return t.forEach(function (n) {
            return tkt(n, r)
        })
    })
}

var mH = {width: "1px", height: "0px", padding: 0, overflow: "hidden", position: "fixed", top: "1px", left: "1px"},
    _0 = function () {
        return _0 = Object.assign || function (e) {
            for (var r, n = 1, i = arguments.length; n < i; n++) {
                r = arguments[n];
                for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a])
            }
            return e
        }, _0.apply(this, arguments)
    };

function cI(t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
}

function nkt(t, e, r) {
    if (r || arguments.length === 2) for (var n = 0, i = e.length, a; n < i; n++) (a || !(n in e)) && (a || (a = Array.prototype.slice.call(e, 0, n)), a[n] = e[n]);
    return t.concat(a || Array.prototype.slice.call(e))
}

function Q3e(t) {
    return t
}

function Z3e(t, e) {
    e === void 0 && (e = Q3e);
    var r = [], n = !1, i = {
        read: function () {
            if (n) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return r.length ? r[r.length - 1] : t
        }, useMedium: function (a) {
            var o = e(a, n);
            return r.push(o), function () {
                r = r.filter(function (s) {
                    return s !== o
                })
            }
        }, assignSyncMedium: function (a) {
            for (n = !0; r.length;) {
                var o = r;
                r = [], o.forEach(a)
            }
            r = {
                push: function (s) {
                    return a(s)
                }, filter: function () {
                    return r
                }
            }
        }, assignMedium: function (a) {
            n = !0;
            var o = [];
            if (r.length) {
                var s = r;
                r = [], s.forEach(a), o = r
            }
            var l = function () {
                var d = o;
                o = [], d.forEach(a)
            }, f = function () {
                return Promise.resolve().then(l)
            };
            f(), r = {
                push: function (d) {
                    o.push(d), f()
                }, filter: function (d) {
                    return o = o.filter(d), r
                }
            }
        }
    };
    return i
}

function BJ(t, e) {
    return e === void 0 && (e = Q3e), Z3e(t, e)
}

function J3e(t) {
    t === void 0 && (t = {});
    var e = Z3e(null);
    return e.options = _0({async: !0, ssr: !1}, t), e
}

var e6e = function (t) {
    var e = t.sideCar, r = cI(t, ["sideCar"]);
    if (!e) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var n = e.read();
    if (!n) throw new Error("Sidecar medium not found");
    return W.createElement(n, _0({}, r))
};
e6e.isSideCarExport = !0;

function ikt(t, e) {
    return t.useMedium(e), e6e
}

var t6e = BJ({}, function (t) {
    var e = t.target, r = t.currentTarget;
    return {target: e, currentTarget: r}
}), r6e = BJ(), akt = BJ(), okt = J3e({async: !0}), skt = [], $J = W.forwardRef(function (e, r) {
    var n, i = W.useState(), a = i[0], o = i[1], s = W.useRef(), l = W.useRef(!1), f = W.useRef(null), d = e.children,
        p = e.disabled, g = e.noFocusGuards, b = e.persistentFocus, S = e.crossFrame, T = e.autoFocus,
        I = e.allowTextSelection, N = e.group, P = e.className, F = e.whiteList, V = e.hasPositiveIndices, Y = e.shards,
        ee = Y === void 0 ? skt : Y, oe = e.as, G = oe === void 0 ? "div" : oe, J = e.lockProps,
        ce = J === void 0 ? {} : J, re = e.sideCar, M = e.returnFocus, D = e.focusOptions, x = e.onActivation,
        A = e.onDeactivation, B = W.useState({}), z = B[0], j = W.useCallback(function () {
            f.current = f.current || document && document.activeElement, s.current && x && x(s.current), l.current = !0
        }, [x]), $ = W.useCallback(function () {
            l.current = !1, A && A(s.current)
        }, [A]);
    W.useEffect(function () {
        p || (f.current = null)
    }, []);
    var C = W.useCallback(function (Se) {
        var Ce = f.current;
        if (Ce && Ce.focus) {
            var Me = typeof M == "function" ? M(Ce) : M;
            if (Me) {
                var ve = typeof Me == "object" ? Me : void 0;
                f.current = null, Se ? Promise.resolve().then(function () {
                    return Ce.focus(ve)
                }) : Ce.focus(ve)
            }
        }
    }, [M]), R = W.useCallback(function (Se) {
        l.current && t6e.useMedium(Se)
    }, []), k = r6e.useMedium, Q = W.useCallback(function (Se) {
        s.current !== Se && (s.current = Se, o(Se))
    }, []);
    Ve.env.NODE_ENV !== "production" && (typeof I < "u" && console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default"), W.useEffect(function () {
        !s.current && typeof G != "string" && console.error("FocusLock: could not obtain ref to internal node")
    }, []));
    var fe = dS((n = {}, n[Y3e] = p && "disabled", n[OK] = N, n), ce), ye = g !== !0, ue = ye && g !== "tail",
        me = X3e([r, Q]);
    return W.createElement(W.Fragment, null, ye && [W.createElement("div", {
        key: "guard-first",
        "data-focus-guard": !0,
        tabIndex: p ? -1 : 0,
        style: mH
    }), V ? W.createElement("div", {
        key: "guard-nearest",
        "data-focus-guard": !0,
        tabIndex: p ? -1 : 1,
        style: mH
    }) : null], !p && W.createElement(re, {
        id: z,
        sideCar: okt,
        observed: a,
        disabled: p,
        persistentFocus: b,
        crossFrame: S,
        autoFocus: T,
        whiteList: F,
        shards: ee,
        onActivation: j,
        onDeactivation: $,
        returnFocus: C,
        focusOptions: D
    }), W.createElement(G, dS({ref: me}, fe, {
        className: P,
        onBlur: k,
        onFocus: R
    }), d), ue && W.createElement("div", {"data-focus-guard": !0, tabIndex: p ? -1 : 0, style: mH}))
});
$J.propTypes = Ve.env.NODE_ENV !== "production" ? {
    children: ma.node,
    disabled: ma.bool,
    returnFocus: ma.oneOfType([ma.bool, ma.object, ma.func]),
    focusOptions: ma.object,
    noFocusGuards: ma.bool,
    hasPositiveIndices: ma.bool,
    allowTextSelection: ma.bool,
    autoFocus: ma.bool,
    persistentFocus: ma.bool,
    crossFrame: ma.bool,
    group: ma.string,
    className: ma.string,
    whiteList: ma.func,
    shards: ma.arrayOf(ma.any),
    as: ma.oneOfType([ma.string, ma.func, ma.object]),
    lockProps: ma.object,
    onActivation: ma.func,
    onDeactivation: ma.func,
    sideCar: ma.any.isRequired
} : {};
$J.defaultProps = {
    children: void 0,
    disabled: !1,
    returnFocus: !1,
    focusOptions: void 0,
    noFocusGuards: !1,
    autoFocus: !0,
    persistentFocus: !1,
    crossFrame: !0,
    hasPositiveIndices: void 0,
    allowTextSelection: void 0,
    group: void 0,
    className: void 0,
    whiteList: void 0,
    shards: void 0,
    as: "div",
    lockProps: {},
    onActivation: void 0,
    onDeactivation: void 0
};
const n6e = $J;

function OA(t) {
    "@babel/helpers - typeof";
    return OA = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
        return typeof e
    } : function (e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, OA(t)
}

function ckt(t, e) {
    if (OA(t) != "object" || !t) return t;
    var r = t[Symbol.toPrimitive];
    if (r !== void 0) {
        var n = r.call(t, e || "default");
        if (OA(n) != "object") return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}

function lkt(t) {
    var e = ckt(t, "string");
    return OA(e) == "symbol" ? e : e + ""
}

function ukt(t, e, r) {
    return e = lkt(e), e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}

function fkt(t, e) {
    if (Ve.env.NODE_ENV !== "production") {
        if (typeof t != "function") throw new Error("Expected reducePropsToState to be a function.");
        if (typeof e != "function") throw new Error("Expected handleStateChangeOnClient to be a function.")
    }

    function r(n) {
        return n.displayName || n.name || "Component"
    }

    return function (i) {
        if (Ve.env.NODE_ENV !== "production" && typeof i != "function") throw new Error("Expected WrappedComponent to be a React component.");
        var a = [], o;

        function s() {
            o = t(a.map(function (f) {
                return f.props
            })), e(o)
        }

        var l = function (f) {
            k_e(d, f);

            function d() {
                return f.apply(this, arguments) || this
            }

            d.peek = function () {
                return o
            };
            var p = d.prototype;
            return p.componentDidMount = function () {
                a.push(this), s()
            }, p.componentDidUpdate = function () {
                s()
            }, p.componentWillUnmount = function () {
                var b = a.indexOf(this);
                a.splice(b, 1), s()
            }, p.render = function () {
                return ar.createElement(i, this.props)
            }, d
        }(W.PureComponent);
        return ukt(l, "displayName", "SideEffect(" + r(i) + ")"), l
    }
}

var nm = function (t) {
        for (var e = Array(t.length), r = 0; r < t.length; ++r) e[r] = t[r];
        return e
    }, HO = function (t) {
        return Array.isArray(t) ? t : [t]
    }, i6e = function (t) {
        return Array.isArray(t) ? t[0] : t
    }, dkt = function (t) {
        if (t.nodeType !== Node.ELEMENT_NODE) return !1;
        var e = window.getComputedStyle(t, null);
        return !e || !e.getPropertyValue ? !1 : e.getPropertyValue("display") === "none" || e.getPropertyValue("visibility") === "hidden"
    }, a6e = function (t) {
        return t.parentNode && t.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? t.parentNode.host : t.parentNode
    }, o6e = function (t) {
        return t === document || t && t.nodeType === Node.DOCUMENT_NODE
    }, hkt = function (t, e) {
        return !t || o6e(t) || !dkt(t) && e(a6e(t))
    }, s6e = function (t, e) {
        var r = t.get(e);
        if (r !== void 0) return r;
        var n = hkt(e, s6e.bind(void 0, t));
        return t.set(e, n), n
    }, pkt = function (t, e) {
        return t && !o6e(t) ? gkt(t) ? e(a6e(t)) : !1 : !0
    }, c6e = function (t, e) {
        var r = t.get(e);
        if (r !== void 0) return r;
        var n = pkt(e, c6e.bind(void 0, t));
        return t.set(e, n), n
    }, l6e = function (t) {
        return t.dataset
    }, mkt = function (t) {
        return t.tagName === "BUTTON"
    }, u6e = function (t) {
        return t.tagName === "INPUT"
    }, f6e = function (t) {
        return u6e(t) && t.type === "radio"
    }, vkt = function (t) {
        return !((u6e(t) || mkt(t)) && (t.type === "hidden" || t.disabled))
    }, gkt = function (t) {
        var e = t.getAttribute(ekt);
        return ![!0, "true", ""].includes(e)
    }, FJ = function (t) {
        var e;
        return !!(t && (!((e = l6e(t)) === null || e === void 0) && e.focusGuard))
    }, WO = function (t) {
        return !FJ(t)
    }, ykt = function (t) {
        return !!t
    }, bkt = function (t, e) {
        var r = t.tabIndex - e.tabIndex, n = t.index - e.index;
        if (r) {
            if (!t.tabIndex) return 1;
            if (!e.tabIndex) return -1
        }
        return r || n
    }, d6e = function (t, e, r) {
        return nm(t).map(function (n, i) {
            return {
                node: n,
                index: i,
                tabIndex: r && n.tabIndex === -1 ? (n.dataset || {}).focusGuard ? 0 : -1 : n.tabIndex
            }
        }).filter(function (n) {
            return !e || n.tabIndex >= 0
        }).sort(bkt)
    },
    wkt = ["button:enabled", "select:enabled", "textarea:enabled", "input:enabled", "a[href]", "area[href]", "summary", "iframe", "object", "embed", "audio[controls]", "video[controls]", "[tabindex]", "[contenteditable]", "[autofocus]"],
    UJ = wkt.join(","), Skt = "".concat(UJ, ", [data-focus-guard]"), h6e = function (t, e) {
        return nm((t.shadowRoot || t).children).reduce(function (r, n) {
            return r.concat(n.matches(e ? Skt : UJ) ? [n] : [], h6e(n))
        }, [])
    }, _kt = function (t, e) {
        var r;
        return t instanceof HTMLIFrameElement && (!((r = t.contentDocument) === null || r === void 0) && r.body) ? uL([t.contentDocument.body], e) : [t]
    }, uL = function (t, e) {
        return t.reduce(function (r, n) {
            var i, a = h6e(n, e), o = (i = []).concat.apply(i, a.map(function (s) {
                return _kt(s, e)
            }));
            return r.concat(o, n.parentNode ? nm(n.parentNode.querySelectorAll(UJ)).filter(function (s) {
                return s === n
            }) : [])
        }, [])
    }, xkt = function (t) {
        var e = t.querySelectorAll("[".concat(JIt, "]"));
        return nm(e).map(function (r) {
            return uL([r])
        }).reduce(function (r, n) {
            return r.concat(n)
        }, [])
    }, jJ = function (t, e) {
        return nm(t).filter(function (r) {
            return s6e(e, r)
        }).filter(function (r) {
            return vkt(r)
        })
    }, rpe = function (t, e) {
        return e === void 0 && (e = new Map), nm(t).filter(function (r) {
            return c6e(e, r)
        })
    }, PK = function (t, e, r) {
        return d6e(jJ(uL(t, r), e), !0, r)
    }, npe = function (t, e) {
        return d6e(jJ(uL(t), e), !1)
    }, Ekt = function (t, e) {
        return jJ(xkt(t), e)
    }, d4 = function (t, e) {
        return t.shadowRoot ? d4(t.shadowRoot, e) : Object.getPrototypeOf(t).contains !== void 0 && Object.getPrototypeOf(t).contains.call(t, e) ? !0 : nm(t.children).some(function (r) {
            var n;
            if (r instanceof HTMLIFrameElement) {
                var i = (n = r.contentDocument) === null || n === void 0 ? void 0 : n.body;
                return i ? d4(i, e) : !1
            }
            return d4(r, e)
        })
    }, Tkt = function (t) {
        for (var e = new Set, r = t.length, n = 0; n < r; n += 1) for (var i = n + 1; i < r; i += 1) {
            var a = t[n].compareDocumentPosition(t[i]);
            (a & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && e.add(i), (a & Node.DOCUMENT_POSITION_CONTAINS) > 0 && e.add(n)
        }
        return t.filter(function (o, s) {
            return !e.has(s)
        })
    }, p6e = function (t) {
        return t.parentNode ? p6e(t.parentNode) : t
    }, zJ = function (t) {
        var e = HO(t);
        return e.filter(Boolean).reduce(function (r, n) {
            var i = n.getAttribute(OK);
            return r.push.apply(r, i ? Tkt(nm(p6e(n).querySelectorAll("[".concat(OK, '="').concat(i, '"]:not([').concat(Y3e, '="disabled"])')))) : [n]), r
        }, [])
    }, Ckt = function (t) {
        try {
            return t()
        } catch {
            return
        }
    }, PA = function (t) {
        if (t === void 0 && (t = document), !(!t || !t.activeElement)) {
            var e = t.activeElement;
            return e.shadowRoot ? PA(e.shadowRoot) : e instanceof HTMLIFrameElement && Ckt(function () {
                return e.contentWindow.document
            }) ? PA(e.contentWindow.document) : e
        }
    }, Akt = function (t, e) {
        return t === e
    }, Ikt = function (t, e) {
        return !!nm(t.querySelectorAll("iframe")).some(function (r) {
            return Akt(r, e)
        })
    }, m6e = function (t, e) {
        return e === void 0 && (e = PA(i6e(t).ownerDocument)), !e || e.dataset && e.dataset.focusGuard ? !1 : zJ(t).some(function (r) {
            return d4(r, e) || Ikt(r, e)
        })
    }, kkt = function (t) {
        t === void 0 && (t = document);
        var e = PA(t);
        return e ? nm(t.querySelectorAll("[".concat(ZIt, "]"))).some(function (r) {
            return d4(r, e)
        }) : !1
    }, Rkt = function (t, e) {
        return e.filter(f6e).filter(function (r) {
            return r.name === t.name
        }).filter(function (r) {
            return r.checked
        })[0] || t
    }, VJ = function (t, e) {
        return f6e(t) && t.name ? Rkt(t, e) : t
    }, Dkt = function (t) {
        var e = new Set;
        return t.forEach(function (r) {
            return e.add(VJ(r, t))
        }), t.filter(function (r) {
            return e.has(r)
        })
    }, ipe = function (t) {
        return t[0] && t.length > 1 ? VJ(t[0], t) : t[0]
    }, ape = function (t, e) {
        return t.length > 1 ? t.indexOf(VJ(t[e], t)) : e
    }, v6e = "NEW_FOCUS", Mkt = function (t, e, r, n) {
        var i = t.length, a = t[0], o = t[i - 1], s = FJ(r);
        if (!(r && t.indexOf(r) >= 0)) {
            var l = r !== void 0 ? e.indexOf(r) : -1, f = n ? e.indexOf(n) : l, d = n ? t.indexOf(n) : -1, p = l - f,
                g = e.indexOf(a), b = e.indexOf(o), S = Dkt(e), T = r !== void 0 ? S.indexOf(r) : -1,
                I = T - (n ? S.indexOf(n) : l), N = ape(t, 0), P = ape(t, i - 1);
            if (l === -1 || d === -1) return v6e;
            if (!p && d >= 0) return d;
            if (l <= g && s && Math.abs(p) > 1) return P;
            if (l >= b && s && Math.abs(p) > 1) return N;
            if (p && Math.abs(I) > 1) return d;
            if (l <= g) return P;
            if (l > b) return N;
            if (p) return Math.abs(p) > 1 ? d : (i + d + p) % i
        }
    }, Okt = function (t) {
        return function (e) {
            var r, n = (r = l6e(e)) === null || r === void 0 ? void 0 : r.autofocus;
            return e.autofocus || n !== void 0 && n !== "false" || t.indexOf(e) >= 0
        }
    }, Pkt = function (t, e, r) {
        var n = t.map(function (a) {
            var o = a.node;
            return o
        }), i = rpe(n.filter(Okt(r)));
        return i && i.length ? ipe(i) : ipe(rpe(e))
    }, NK = function (t, e) {
        return e === void 0 && (e = []), e.push(t), t.parentNode && NK(t.parentNode.host || t.parentNode, e), e
    }, vH = function (t, e) {
        for (var r = NK(t), n = NK(e), i = 0; i < r.length; i += 1) {
            var a = r[i];
            if (n.indexOf(a) >= 0) return a
        }
        return !1
    }, g6e = function (t, e, r) {
        var n = HO(t), i = HO(e), a = n[0], o = !1;
        return i.filter(Boolean).forEach(function (s) {
            o = vH(o || s, s) || o, r.filter(Boolean).forEach(function (l) {
                var f = vH(a, l);
                f && (!o || d4(f, o) ? o = f : o = vH(f, o))
            })
        }), o
    }, Nkt = function (t, e) {
        return t.reduce(function (r, n) {
            return r.concat(Ekt(n, e))
        }, [])
    }, Lkt = function (t, e) {
        var r = new Map;
        return e.forEach(function (n) {
            return r.set(n.node, n)
        }), t.map(function (n) {
            return r.get(n)
        }).filter(ykt)
    }, Bkt = function (t, e) {
        var r = PA(HO(t).length > 0 ? document : i6e(t).ownerDocument), n = zJ(t).filter(WO), i = g6e(r || t, t, n),
            a = new Map, o = npe(n, a), s = PK(n, a).filter(function (b) {
                var S = b.node;
                return WO(S)
            });
        if (!(!s[0] && (s = o, !s[0]))) {
            var l = npe([i], a).map(function (b) {
                var S = b.node;
                return S
            }), f = Lkt(l, s), d = f.map(function (b) {
                var S = b.node;
                return S
            }), p = Mkt(d, l, r, e);
            if (p === v6e) {
                var g = Pkt(o, d, Nkt(n, a));
                if (g) return {node: g};
                console.warn("focus-lock: cannot find any node to move focus into");
                return
            }
            return p === void 0 ? p : f[p]
        }
    }, $kt = function (t) {
        var e = zJ(t).filter(WO), r = g6e(t, t, e), n = new Map, i = PK([r], n, !0), a = PK(e, n).filter(function (o) {
            var s = o.node;
            return WO(s)
        }).map(function (o) {
            var s = o.node;
            return s
        });
        return i.map(function (o) {
            var s = o.node, l = o.index;
            return {node: s, index: l, lockItem: a.indexOf(s) >= 0, guard: FJ(s)}
        })
    }, Fkt = function (t, e) {
        "focus" in t && t.focus(e), "contentWindow" in t && t.contentWindow && t.contentWindow.focus()
    }, gH = 0, yH = !1, y6e = function (t, e, r) {
        r === void 0 && (r = {});
        var n = Bkt(t, e);
        if (!yH && n) {
            if (gH > 2) {
                console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"), yH = !0, setTimeout(function () {
                    yH = !1
                }, 1);
                return
            }
            gH++, Fkt(n.node, r.focusOptions), gH--
        }
    };

function HJ(t) {
    setTimeout(t, 1)
}

var Ukt = function () {
    return document && document.activeElement === document.body
}, jkt = function () {
    return Ukt() || kkt()
}, h4 = null, jx = null, p4 = null, NA = !1, zkt = function () {
    return !0
}, Vkt = function (e) {
    return (h4.whiteList || zkt)(e)
}, Hkt = function (e, r) {
    p4 = {observerNode: e, portaledElement: r}
}, Wkt = function (e) {
    return p4 && p4.portaledElement === e
};

function ope(t, e, r, n) {
    var i = null, a = t;
    do {
        var o = n[a];
        if (o.guard) o.node.dataset.focusAutoGuard && (i = o); else if (o.lockItem) {
            if (a !== t) return;
            i = null
        } else break
    } while ((a += r) !== e);
    i && (i.node.tabIndex = 0)
}

var qkt = function (e) {
    return e && "current" in e ? e.current : e
}, Gkt = function (e) {
    return e ? !!NA : NA === "meanwhile"
}, Kkt = function t(e, r, n) {
    return r && (r.host === e && (!r.activeElement || n.contains(r.activeElement)) || r.parentNode && t(e, r.parentNode, n))
}, Ykt = function (e, r) {
    return r.some(function (n) {
        return Kkt(e, n, n)
    })
}, qO = function () {
    var e = !1;
    if (h4) {
        var r = h4, n = r.observed, i = r.persistentFocus, a = r.autoFocus, o = r.shards, s = r.crossFrame,
            l = r.focusOptions, f = n || p4 && p4.portaledElement, d = document && document.activeElement;
        if (f) {
            var p = [f].concat(o.map(qkt).filter(Boolean));
            if ((!d || Vkt(d)) && (i || Gkt(s) || !jkt() || !jx && a) && (f && !(m6e(p) || d && Ykt(d, p) || Wkt(d)) && (document && !jx && d && !a ? (d.blur && d.blur(), document.body.focus()) : (e = y6e(p, jx, {focusOptions: l}), p4 = {})), NA = !1, jx = document && document.activeElement), document) {
                var g = document && document.activeElement, b = $kt(p), S = b.map(function (T) {
                    var I = T.node;
                    return I
                }).indexOf(g);
                S > -1 && (b.filter(function (T) {
                    var I = T.guard, N = T.node;
                    return I && N.dataset.focusAutoGuard
                }).forEach(function (T) {
                    var I = T.node;
                    return I.removeAttribute("tabIndex")
                }), ope(S, b.length, 1, b), ope(S, -1, -1, b))
            }
        }
    }
    return e
}, b6e = function (e) {
    qO() && e && (e.stopPropagation(), e.preventDefault())
}, WJ = function () {
    return HJ(qO)
}, Xkt = function (e) {
    var r = e.target, n = e.currentTarget;
    n.contains(r) || Hkt(n, r)
}, Qkt = function () {
    return null
}, w6e = function () {
    NA = "just", HJ(function () {
        NA = "meanwhile"
    })
}, Zkt = function () {
    document.addEventListener("focusin", b6e), document.addEventListener("focusout", WJ), window.addEventListener("blur", w6e)
}, Jkt = function () {
    document.removeEventListener("focusin", b6e), document.removeEventListener("focusout", WJ), window.removeEventListener("blur", w6e)
};

function eRt(t) {
    return t.filter(function (e) {
        var r = e.disabled;
        return !r
    })
}

function tRt(t) {
    var e = t.slice(-1)[0];
    e && !h4 && Zkt();
    var r = h4, n = r && e && e.id === r.id;
    h4 = e, r && !n && (r.onDeactivation(), t.filter(function (i) {
        var a = i.id;
        return a === r.id
    }).length || r.returnFocus(!e)), e ? (jx = null, (!n || r.observed !== e.observed) && e.onActivation(), qO(), HJ(qO)) : (Jkt(), jx = null)
}

t6e.assignSyncMedium(Xkt);
r6e.assignMedium(WJ);
akt.assignMedium(function (t) {
    return t({moveFocusInside: y6e, focusInside: m6e})
});
const rRt = fkt(eRt, tRt)(Qkt);
var S6e = W.forwardRef(function (e, r) {
    return W.createElement(n6e, dS({sideCar: rRt, ref: r}, e))
}), nRt = n6e.propTypes || {}, iRt = WIt(nRt, ["sideCar"]);
S6e.propTypes = Ve.env.NODE_ENV !== "production" ? iRt : {};
const spe = S6e;

function _6e(t) {
    return t != null && typeof t == "object" && "nodeType" in t && t.nodeType === Node.ELEMENT_NODE
}

function qJ(t) {
    var e;
    if (!_6e(t)) return !1;
    const r = (e = t.ownerDocument.defaultView) != null ? e : window;
    return t instanceof r.HTMLElement
}

function aRt(t) {
    var e, r;
    return (r = (e = x6e(t)) == null ? void 0 : e.defaultView) != null ? r : window
}

function x6e(t) {
    return _6e(t) ? t.ownerDocument : document
}

function oRt(t) {
    return x6e(t).activeElement
}

function sRt(t) {
    const e = t.ownerDocument.defaultView || window, {overflow: r, overflowX: n, overflowY: i} = e.getComputedStyle(t);
    return /auto|scroll|overlay|hidden/.test(r + i + n)
}

function cRt(t) {
    return t.localName === "html" ? t : t.assignedSlot || t.parentElement || t.ownerDocument.documentElement
}

function E6e(t) {
    return ["html", "body", "#document"].includes(t.localName) ? t.ownerDocument.body : qJ(t) && sRt(t) ? t : E6e(cRt(t))
}

var T6e = t => t.hasAttribute("tabindex"), lRt = t => T6e(t) && t.tabIndex === -1;

function uRt(t) {
    return !!t.getAttribute("disabled") || !!t.getAttribute("aria-disabled")
}

function C6e(t) {
    return t.parentElement && C6e(t.parentElement) ? !0 : t.hidden
}

function fRt(t) {
    const e = t.getAttribute("contenteditable");
    return e !== "false" && e != null
}

function A6e(t) {
    if (!qJ(t) || C6e(t) || uRt(t)) return !1;
    const {localName: e} = t;
    if (["input", "select", "textarea", "button"].indexOf(e) >= 0) return !0;
    const n = {
        a: () => t.hasAttribute("href"),
        audio: () => t.hasAttribute("controls"),
        video: () => t.hasAttribute("controls")
    };
    return e in n ? n[e]() : fRt(t) ? !0 : T6e(t)
}

function dRt(t) {
    return t ? qJ(t) && A6e(t) && !lRt(t) : !1
}

var hRt = ["input:not(:disabled):not([disabled])", "select:not(:disabled):not([disabled])", "textarea:not(:disabled):not([disabled])", "embed", "iframe", "object", "a[href]", "area[href]", "button:not(:disabled):not([disabled])", "[tabindex]", "audio[controls]", "video[controls]", "*[tabindex]:not([aria-disabled])", "*[contenteditable]"],
    pRt = hRt.join(), mRt = t => t.offsetWidth > 0 && t.offsetHeight > 0;

function I6e(t) {
    const e = Array.from(t.querySelectorAll(pRt));
    return e.unshift(t), e.filter(r => A6e(r) && mRt(r))
}

var cpe, vRt = (cpe = spe.default) != null ? cpe : spe, k6e = t => {
    const {
        initialFocusRef: e,
        finalFocusRef: r,
        contentRef: n,
        restoreFocus: i,
        children: a,
        isDisabled: o,
        autoFocus: s,
        persistentFocus: l,
        lockFocusAcrossFrames: f
    } = t, d = W.useCallback(() => {
        e != null && e.current ? e.current.focus() : n != null && n.current && I6e(n.current).length === 0 && requestAnimationFrame(() => {
            var S;
            (S = n.current) == null || S.focus()
        })
    }, [e, n]), p = W.useCallback(() => {
        var b;
        (b = r == null ? void 0 : r.current) == null || b.focus()
    }, [r]), g = i && !r;
    return ie.jsx(vRt, {
        crossFrame: f,
        persistentFocus: l,
        autoFocus: s,
        disabled: o,
        onActivation: d,
        onDeactivation: p,
        returnFocus: g,
        children: a
    })
};
k6e.displayName = "FocusLock";
var gRt = e5t ? W.useLayoutEffect : W.useEffect;

function lpe(t, e = []) {
    const r = W.useRef(t);
    return gRt(() => {
        r.current = t
    }), W.useCallback((...n) => {
        var i;
        return (i = r.current) == null ? void 0 : i.call(r, ...n)
    }, e)
}

function yRt(t, e) {
    const r = W.useId();
    return W.useMemo(() => t || [e, r].filter(Boolean).join("-"), [t, e, r])
}

function bRt(t, e) {
    const r = t !== void 0;
    return [r, r && typeof t < "u" ? t : e]
}

function GJ(t = {}) {
    const {onClose: e, onOpen: r, isOpen: n, id: i} = t, a = lpe(r),
        o = lpe(e), [s, l] = W.useState(t.defaultIsOpen || !1), [f, d] = bRt(n, s), p = yRt(i, "disclosure"),
        g = W.useCallback(() => {
            f || l(!1), o == null || o()
        }, [f, o]), b = W.useCallback(() => {
            f || l(!0), a == null || a()
        }, [f, a]), S = W.useCallback(() => {
            (d ? g : b)()
        }, [d, b, g]);
    return {
        isOpen: !!d,
        onOpen: b,
        onClose: g,
        onToggle: S,
        isControlled: f,
        getButtonProps: (T = {}) => ({...T, "aria-expanded": d, "aria-controls": p, onClick: a5t(T.onClick, S)}),
        getDisclosureProps: (T = {}) => ({...T, hidden: !d, id: p})
    }
}

var wRt = function () {
        var t = document.getSelection();
        if (!t.rangeCount) return function () {
        };
        for (var e = document.activeElement, r = [], n = 0; n < t.rangeCount; n++) r.push(t.getRangeAt(n));
        switch (e.tagName.toUpperCase()) {
            case"INPUT":
            case"TEXTAREA":
                e.blur();
                break;
            default:
                e = null;
                break
        }
        return t.removeAllRanges(), function () {
            t.type === "Caret" && t.removeAllRanges(), t.rangeCount || r.forEach(function (i) {
                t.addRange(i)
            }), e && e.focus()
        }
    }, SRt = wRt, upe = {"text/plain": "Text", "text/html": "Url", default: "Text"},
    _Rt = "Copy to clipboard: #{key}, Enter";

function xRt(t) {
    var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
    return t.replace(/#{\s*key\s*}/g, e)
}

function ERt(t, e) {
    var r, n, i, a, o, s, l = !1;
    e || (e = {}), r = e.debug || !1;
    try {
        i = SRt(), a = document.createRange(), o = document.getSelection(), s = document.createElement("span"), s.textContent = t, s.ariaHidden = "true", s.style.all = "unset", s.style.position = "fixed", s.style.top = 0, s.style.clip = "rect(0, 0, 0, 0)", s.style.whiteSpace = "pre", s.style.webkitUserSelect = "text", s.style.MozUserSelect = "text", s.style.msUserSelect = "text", s.style.userSelect = "text", s.addEventListener("copy", function (d) {
            if (d.stopPropagation(), e.format) if (d.preventDefault(), typeof d.clipboardData > "u") {
                r && console.warn("unable to use e.clipboardData"), r && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
                var p = upe[e.format] || upe.default;
                window.clipboardData.setData(p, t)
            } else d.clipboardData.clearData(), d.clipboardData.setData(e.format, t);
            e.onCopy && (d.preventDefault(), e.onCopy(d.clipboardData))
        }), document.body.appendChild(s), a.selectNodeContents(s), o.addRange(a);
        var f = document.execCommand("copy");
        if (!f) throw new Error("copy command was unsuccessful");
        l = !0
    } catch (d) {
        r && console.error("unable to copy using execCommand: ", d), r && console.warn("trying IE specific stuff");
        try {
            window.clipboardData.setData(e.format || "text", t), e.onCopy && e.onCopy(window.clipboardData), l = !0
        } catch (p) {
            r && console.error("unable to copy using clipboardData: ", p), r && console.error("falling back to prompt"), n = xRt("message" in e ? e.message : _Rt), window.prompt(n, t)
        }
    } finally {
        o && (typeof o.removeRange == "function" ? o.removeRange(a) : o.removeAllRanges()), s && document.body.removeChild(s), i()
    }
    return l
}

var TRt = ERt;
const CRt = za(TRt);
var LA = Jn(function (e, r) {
    const {htmlSize: n, ...i} = e, a = tI("Input", i), o = Cp(i), s = VIt(o), l = mi("chakra-input", e.className);
    return ie.jsx(on.input, {size: n, ...s, __css: a.field, ref: r, className: l})
});
LA.displayName = "Input";
LA.id = "Input";
var Bf = Jn(function (e, r) {
    const n = _1("Link", e), {className: i, isExternal: a, ...o} = Cp(e);
    return ie.jsx(on.a, {
        target: a ? "_blank" : void 0,
        rel: a ? "noopener" : void 0,
        ref: r,
        className: mi("chakra-link", i), ...o,
        __css: n
    })
});
Bf.displayName = "Link";
var R6e = Object.freeze(["base", "sm", "md", "lg", "xl", "2xl"]);

function ARt(t, e) {
    return Array.isArray(t) ? t.map(r => r === null ? null : e(r)) : rf(t) ? Object.keys(t).reduce((r, n) => (r[n] = e(t[n]), r), {}) : t != null ? e(t) : null
}

function IRt(t, e = R6e) {
    const r = {};
    return t.forEach((n, i) => {
        const a = e[i];
        n != null && (r[a] = n)
    }), r
}

var ln = Jn(function (e, r) {
    const n = _1("Text", e), {className: i, align: a, decoration: o, casing: s, ...l} = Cp(e),
        f = m5t({textAlign: e.align, textDecoration: e.decoration, textTransform: e.casing});
    return ie.jsx(on.p, {ref: r, className: mi("chakra-text", e.className), ...f, ...l, __css: n})
});
ln.displayName = "Text";
var D6e = t => ie.jsx(on.div, {
    className: "chakra-stack__item", ...t,
    __css: {display: "inline-block", flex: "0 0 auto", minWidth: 0, ...t.__css}
});
D6e.displayName = "StackItem";

function kRt(t) {
    const {spacing: e, direction: r} = t, n = {
        column: {my: e, mx: 0, borderLeftWidth: 0, borderBottomWidth: "1px"},
        "column-reverse": {my: e, mx: 0, borderLeftWidth: 0, borderBottomWidth: "1px"},
        row: {mx: e, my: 0, borderLeftWidth: "1px", borderBottomWidth: 0},
        "row-reverse": {mx: e, my: 0, borderLeftWidth: "1px", borderBottomWidth: 0}
    };
    return {"&": ARt(r, i => n[i])}
}

var fL = Jn((t, e) => {
    const {
            isInline: r,
            direction: n,
            align: i,
            justify: a,
            spacing: o = "0.5rem",
            wrap: s,
            children: l,
            divider: f,
            className: d,
            shouldWrapChildren: p,
            ...g
        } = t, b = r ? "row" : n ?? "column", S = W.useMemo(() => kRt({spacing: o, direction: b}), [o, b]), T = !!f,
        I = !p && !T, N = W.useMemo(() => {
            const F = W3e(l);
            return I ? F : F.map((V, Y) => {
                const ee = typeof V.key < "u" ? V.key : Y, oe = Y + 1 === F.length,
                    J = p ? ie.jsx(D6e, {children: V}, ee) : V;
                if (!T) return J;
                const ce = W.cloneElement(f, {__css: S}), re = oe ? null : ce;
                return ie.jsxs(W.Fragment, {children: [J, re]}, ee)
            })
        }, [f, S, T, I, p, l]), P = mi("chakra-stack", d);
    return ie.jsx(on.div, {
        ref: e,
        display: "flex",
        alignItems: i,
        justifyContent: a,
        flexDirection: b,
        flexWrap: s,
        gap: T ? void 0 : o,
        className: P, ...g,
        children: N
    })
});
fL.displayName = "Stack";
var Dy = Jn((t, e) => ie.jsx(fL, {align: "center", ...t, direction: "column", ref: e}));
Dy.displayName = "VStack";
var dL = Jn((t, e) => ie.jsx(fL, {align: "center", ...t, direction: "row", ref: e}));
dL.displayName = "HStack";
var i1 = Jn(function (e, r) {
    const n = _1("Heading", e), {className: i, ...a} = Cp(e);
    return ie.jsx(on.h2, {ref: r, className: mi("chakra-heading", e.className), ...a, __css: n})
});
i1.displayName = "Heading";
var Gn = on("div");
Gn.displayName = "Box";
var M6e = Jn(function (e, r) {
    const {size: n, centerContent: i = !0, ...a} = e,
        o = i ? {display: "flex", alignItems: "center", justifyContent: "center"} : {};
    return ie.jsx(Gn, {ref: r, boxSize: n, __css: {...o, flexShrink: 0, flexGrow: 0}, ...a})
});
M6e.displayName = "Square";
var RRt = Jn(function (e, r) {
    const {size: n, ...i} = e;
    return ie.jsx(M6e, {size: n, ref: r, borderRadius: "9999px", ...i})
});
RRt.displayName = "Circle";
var KJ = on("div", {baseStyle: {display: "flex", alignItems: "center", justifyContent: "center"}});
KJ.displayName = "Center";
var DRt = {
    horizontal: {insetStart: "50%", transform: "translateX(-50%)"},
    vertical: {top: "50%", transform: "translateY(-50%)"},
    both: {insetStart: "50%", top: "50%", transform: "translate(-50%, -50%)"}
};
Jn(function (e, r) {
    const {axis: n = "both", ...i} = e;
    return ie.jsx(on.div, {ref: r, __css: DRt[n], ...i, position: "absolute"})
});

function MRt(t, e = {}) {
    const {ssr: r = !0, fallback: n} = e, {getWindow: i} = k5t(), a = Array.isArray(t) ? t : [t];
    let o = Array.isArray(n) ? n : [n];
    o = o.filter(f => f != null);
    const [s, l] = W.useState(() => a.map((f, d) => ({media: f, matches: r ? !!o[d] : i().matchMedia(f).matches})));
    return W.useEffect(() => {
        const f = i();
        l(a.map(g => ({media: g, matches: f.matchMedia(g).matches})));
        const d = a.map(g => f.matchMedia(g)), p = g => {
            l(b => b.slice().map(S => S.media === g.media ? {...S, matches: g.matches} : S))
        };
        return d.forEach(g => {
            typeof g.addListener == "function" ? g.addListener(p) : g.addEventListener("change", p)
        }), () => {
            d.forEach(g => {
                typeof g.removeListener == "function" ? g.removeListener(p) : g.removeEventListener("change", p)
            })
        }
    }, [i]), s.map(f => f.matches)
}

function ORt(t, e, r = R6e) {
    let n = Object.keys(t).indexOf(e);
    if (n !== -1) return t[e];
    let i = r.indexOf(e);
    for (; i >= 0;) {
        const a = r[i];
        if (t.hasOwnProperty(a)) {
            n = i;
            break
        }
        i -= 1
    }
    if (n !== -1) {
        const a = r[n];
        return t[a]
    }
}

function PRt(t) {
    var e, r;
    const n = rf(t) ? t : {fallback: t ?? "base"},
        a = n3().__breakpoints.details.map(({minMaxQuery: f, breakpoint: d}) => ({
            breakpoint: d,
            query: f.replace("@media screen and ", "")
        })), o = a.map(f => f.breakpoint === n.fallback),
        l = MRt(a.map(f => f.query), {fallback: o, ssr: n.ssr}).findIndex(f => f == !0);
    return (r = (e = a[l]) == null ? void 0 : e.breakpoint) != null ? r : n.fallback
}

function BA(t, e) {
    var r;
    const n = rf(e) ? e : {fallback: e ?? "base"}, i = PRt(n), a = n3();
    if (!i) return;
    const o = Array.from(((r = a.__breakpoints) == null ? void 0 : r.keys) || []),
        s = Array.isArray(t) ? Object.fromEntries(Object.entries(IRt(t, o)).map(([l, f]) => [l, f])) : t;
    return ORt(s, i, o)
}

function NRt(t) {
    const {key: e} = t;
    return e.length === 1 || e.length > 1 && /[^a-zA-Z0-9]/.test(e)
}

function LRt(t = {}) {
    const {timeout: e = 300, preventDefault: r = () => !0} = t, [n, i] = W.useState([]), a = W.useRef(), o = () => {
        a.current && (clearTimeout(a.current), a.current = null)
    }, s = () => {
        o(), a.current = setTimeout(() => {
            i([]), a.current = null
        }, e)
    };
    W.useEffect(() => o, []);

    function l(f) {
        return d => {
            if (d.key === "Backspace") {
                const p = [...n];
                p.pop(), i(p);
                return
            }
            if (NRt(d)) {
                const p = n.concat(d.key);
                r(d) && (d.preventDefault(), d.stopPropagation()), i(p), f(p.join("")), s()
            }
        }
    }

    return l
}

function BRt(t, e, r, n) {
    if (e == null) return n;
    if (!n) return t.find(o => r(o).toLowerCase().startsWith(e.toLowerCase()));
    const i = t.filter(a => r(a).toLowerCase().startsWith(e.toLowerCase()));
    if (i.length > 0) {
        let a;
        return i.includes(n) ? (a = i.indexOf(n) + 1, a === i.length && (a = 0), i[a]) : (a = t.indexOf(i[0]), t[a])
    }
    return n
}

function $Rt() {
    const t = W.useRef(new Map), e = t.current, r = W.useCallback((i, a, o, s) => {
        t.current.set(o, {type: a, el: i, options: s}), i.addEventListener(a, o, s)
    }, []), n = W.useCallback((i, a, o, s) => {
        i.removeEventListener(a, o, s), t.current.delete(o)
    }, []);
    return W.useEffect(() => () => {
        e.forEach((i, a) => {
            n(i.el, i.type, a, i.options)
        })
    }, [n, e]), {add: r, remove: n}
}

function bH(t) {
    const e = t.target, {tagName: r, isContentEditable: n} = e;
    return r !== "INPUT" && r !== "TEXTAREA" && n !== !0
}

function FRt(t = {}) {
    const {
        ref: e,
        isDisabled: r,
        isFocusable: n,
        clickOnEnter: i = !0,
        clickOnSpace: a = !0,
        onMouseDown: o,
        onMouseUp: s,
        onClick: l,
        onKeyDown: f,
        onKeyUp: d,
        tabIndex: p,
        onMouseOver: g,
        onMouseLeave: b,
        ...S
    } = t, [T, I] = W.useState(!0), [N, P] = W.useState(!1), F = $Rt(), V = z => {
        z && z.tagName !== "BUTTON" && I(!1)
    }, Y = T ? p : p || 0, ee = r && !n, oe = W.useCallback(z => {
        if (r) {
            z.stopPropagation(), z.preventDefault();
            return
        }
        z.currentTarget.focus(), l == null || l(z)
    }, [r, l]), G = W.useCallback(z => {
        N && bH(z) && (z.preventDefault(), z.stopPropagation(), P(!1), F.remove(document, "keyup", G, !1))
    }, [N, F]), J = W.useCallback(z => {
        if (f == null || f(z), r || z.defaultPrevented || z.metaKey || !bH(z.nativeEvent) || T) return;
        const j = i && z.key === "Enter";
        a && z.key === " " && (z.preventDefault(), P(!0)), j && (z.preventDefault(), z.currentTarget.click()), F.add(document, "keyup", G, !1)
    }, [r, T, f, i, a, F, G]), ce = W.useCallback(z => {
        if (d == null || d(z), r || z.defaultPrevented || z.metaKey || !bH(z.nativeEvent) || T) return;
        a && z.key === " " && (z.preventDefault(), P(!1), z.currentTarget.click())
    }, [a, T, r, d]), re = W.useCallback(z => {
        z.button === 0 && (P(!1), F.remove(document, "mouseup", re, !1))
    }, [F]), M = W.useCallback(z => {
        if (z.button !== 0) return;
        if (r) {
            z.stopPropagation(), z.preventDefault();
            return
        }
        T || P(!0), z.currentTarget.focus({preventScroll: !0}), F.add(document, "mouseup", re, !1), o == null || o(z)
    }, [r, T, o, F, re]), D = W.useCallback(z => {
        z.button === 0 && (T || P(!1), s == null || s(z))
    }, [s, T]), x = W.useCallback(z => {
        if (r) {
            z.preventDefault();
            return
        }
        g == null || g(z)
    }, [r, g]), A = W.useCallback(z => {
        N && (z.preventDefault(), P(!1)), b == null || b(z)
    }, [N, b]), B = Kf(e, V);
    return T ? {
        ...S,
        ref: B,
        type: "button",
        "aria-disabled": ee ? void 0 : r,
        disabled: ee,
        onClick: oe,
        onMouseDown: o,
        onMouseUp: s,
        onKeyUp: d,
        onKeyDown: f,
        onMouseOver: g,
        onMouseLeave: b
    } : {
        ...S,
        ref: B,
        role: "button",
        "data-active": Ry(N),
        "aria-disabled": r ? "true" : void 0,
        tabIndex: ee ? void 0 : Y,
        onClick: oe,
        onMouseDown: M,
        onMouseUp: D,
        onKeyUp: ce,
        onKeyDown: J,
        onMouseOver: x,
        onMouseLeave: A
    }
}

function URt(t) {
    const e = t.current;
    if (!e) return !1;
    const r = oRt(e);
    return !r || e.contains(r) ? !1 : !!dRt(r)
}

function jRt(t, e) {
    const {shouldFocus: r, visible: n, focusRef: i} = e, a = r && !n;
    rE(() => {
        if (!a || URt(t)) return;
        const o = (i == null ? void 0 : i.current) || t.current;
        let s;
        if (o) return s = requestAnimationFrame(() => {
            o.focus({preventScroll: !0})
        }), () => {
            cancelAnimationFrame(s)
        }
    }, [a, t, i])
}

var zRt = {preventScroll: !0, shouldFocus: !1};

function ter(t, e = zRt) {
    const {focusRef: r, preventScroll: n, shouldFocus: i, visible: a} = e, o = VRt(t) ? t.current : t, s = i && a,
        l = W.useRef(s), f = W.useRef(a);
    Z4(() => {
        !f.current && a && (l.current = s), f.current = a
    }, [a, s]);
    const d = W.useCallback(() => {
        if (!(!a || !o || !l.current) && (l.current = !1, !o.contains(document.activeElement))) if (r != null && r.current) requestAnimationFrame(() => {
            var p;
            (p = r.current) == null || p.focus({preventScroll: n})
        }); else {
            const p = I6e(o);
            p.length > 0 && requestAnimationFrame(() => {
                p[0].focus({preventScroll: n})
            })
        }
    }, [a, n, o, r]);
    rE(() => {
        d()
    }, [d]), wC(o, "transitionend", d)
}

function VRt(t) {
    return "current" in t
}

var nx = (t, e) => ({var: t, varRef: e ? `var(${t}, ${e})` : `var(${t})`}), zc = {
    arrowShadowColor: nx("--popper-arrow-shadow-color"),
    arrowSize: nx("--popper-arrow-size", "8px"),
    arrowSizeHalf: nx("--popper-arrow-size-half"),
    arrowBg: nx("--popper-arrow-bg"),
    transformOrigin: nx("--popper-transform-origin"),
    arrowOffset: nx("--popper-arrow-offset")
};

function HRt(t) {
    if (t.includes("top")) return "1px 1px 0px 0 var(--popper-arrow-shadow-color)";
    if (t.includes("bottom")) return "-1px -1px 0px 0 var(--popper-arrow-shadow-color)";
    if (t.includes("right")) return "-1px 1px 0px 0 var(--popper-arrow-shadow-color)";
    if (t.includes("left")) return "1px -1px 0px 0 var(--popper-arrow-shadow-color)"
}

var WRt = {
    top: "bottom center",
    "top-start": "bottom left",
    "top-end": "bottom right",
    bottom: "top center",
    "bottom-start": "top left",
    "bottom-end": "top right",
    left: "right center",
    "left-start": "right top",
    "left-end": "right bottom",
    right: "left center",
    "right-start": "left top",
    "right-end": "left bottom"
}, qRt = t => WRt[t], fpe = {scroll: !0, resize: !0};

function GRt(t) {
    let e;
    return typeof t == "object" ? e = {enabled: !0, options: {...fpe, ...t}} : e = {enabled: t, options: fpe}, e
}

var KRt = {
    name: "matchWidth", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: ({state: t}) => {
        t.styles.popper.width = `${t.rects.reference.width}px`
    }, effect: ({state: t}) => () => {
        const e = t.elements.reference;
        t.elements.popper.style.width = `${e.offsetWidth}px`
    }
}, YRt = {
    name: "transformOrigin", enabled: !0, phase: "write", fn: ({state: t}) => {
        dpe(t)
    }, effect: ({state: t}) => () => {
        dpe(t)
    }
}, dpe = t => {
    t.elements.popper.style.setProperty(zc.transformOrigin.var, qRt(t.placement))
}, XRt = {
    name: "positionArrow", enabled: !0, phase: "afterWrite", fn: ({state: t}) => {
        QRt(t)
    }
}, QRt = t => {
    var e;
    if (!t.placement) return;
    const r = ZRt(t.placement);
    if ((e = t.elements) != null && e.arrow && r) {
        Object.assign(t.elements.arrow.style, {
            [r.property]: r.value,
            width: zc.arrowSize.varRef,
            height: zc.arrowSize.varRef,
            zIndex: -1
        });
        const n = {
            [zc.arrowSizeHalf.var]: `calc(${zc.arrowSize.varRef} / 2 - 1px)`,
            [zc.arrowOffset.var]: `calc(${zc.arrowSizeHalf.varRef} * -1)`
        };
        for (const i in n) t.elements.arrow.style.setProperty(i, n[i])
    }
}, ZRt = t => {
    if (t.startsWith("top")) return {property: "bottom", value: zc.arrowOffset.varRef};
    if (t.startsWith("bottom")) return {property: "top", value: zc.arrowOffset.varRef};
    if (t.startsWith("left")) return {property: "right", value: zc.arrowOffset.varRef};
    if (t.startsWith("right")) return {property: "left", value: zc.arrowOffset.varRef}
}, JRt = {
    name: "innerArrow", enabled: !0, phase: "main", requires: ["arrow"], fn: ({state: t}) => {
        hpe(t)
    }, effect: ({state: t}) => () => {
        hpe(t)
    }
}, hpe = t => {
    if (!t.elements.arrow) return;
    const e = t.elements.arrow.querySelector("[data-popper-arrow-inner]");
    if (!e) return;
    const r = HRt(t.placement);
    r && e.style.setProperty("--popper-arrow-default-shadow", r), Object.assign(e.style, {
        transform: "rotate(45deg)",
        background: zc.arrowBg.varRef,
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        position: "absolute",
        zIndex: "inherit",
        boxShadow: "var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))"
    })
}, e9t = {
    "start-start": {ltr: "left-start", rtl: "right-start"},
    "start-end": {ltr: "left-end", rtl: "right-end"},
    "end-start": {ltr: "right-start", rtl: "left-start"},
    "end-end": {ltr: "right-end", rtl: "left-end"},
    start: {ltr: "left", rtl: "right"},
    end: {ltr: "right", rtl: "left"}
}, t9t = {
    "auto-start": "auto-end",
    "auto-end": "auto-start",
    "top-start": "top-end",
    "top-end": "top-start",
    "bottom-start": "bottom-end",
    "bottom-end": "bottom-start"
};

function r9t(t, e = "ltr") {
    var r, n;
    const i = ((r = e9t[t]) == null ? void 0 : r[e]) || t;
    return e === "ltr" ? i : (n = t9t[t]) != null ? n : i
}

var nf = "top", Zd = "bottom", Jd = "right", af = "left", YJ = "auto", lI = [nf, Zd, Jd, af], oE = "start", $A = "end",
    n9t = "clippingParents", O6e = "viewport", lT = "popper", i9t = "reference", ppe = lI.reduce(function (t, e) {
        return t.concat([e + "-" + oE, e + "-" + $A])
    }, []), P6e = [].concat(lI, [YJ]).reduce(function (t, e) {
        return t.concat([e, e + "-" + oE, e + "-" + $A])
    }, []), a9t = "beforeRead", o9t = "read", s9t = "afterRead", c9t = "beforeMain", l9t = "main", u9t = "afterMain",
    f9t = "beforeWrite", d9t = "write", h9t = "afterWrite", p9t = [a9t, o9t, s9t, c9t, l9t, u9t, f9t, d9t, h9t];

function G0(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function Yf(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function pS(t) {
    var e = Yf(t).Element;
    return t instanceof e || t instanceof Element
}

function Kd(t) {
    var e = Yf(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}

function XJ(t) {
    if (typeof ShadowRoot > "u") return !1;
    var e = Yf(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}

function m9t(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function (r) {
        var n = e.styles[r] || {}, i = e.attributes[r] || {}, a = e.elements[r];
        !Kd(a) || !G0(a) || (Object.assign(a.style, n), Object.keys(i).forEach(function (o) {
            var s = i[o];
            s === !1 ? a.removeAttribute(o) : a.setAttribute(o, s === !0 ? "" : s)
        }))
    })
}

function v9t(t) {
    var e = t.state, r = {
        popper: {position: e.options.strategy, left: "0", top: "0", margin: "0"},
        arrow: {position: "absolute"},
        reference: {}
    };
    return Object.assign(e.elements.popper.style, r.popper), e.styles = r, e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow), function () {
        Object.keys(e.elements).forEach(function (n) {
            var i = e.elements[n], a = e.attributes[n] || {},
                o = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]), s = o.reduce(function (l, f) {
                    return l[f] = "", l
                }, {});
            !Kd(i) || !G0(i) || (Object.assign(i.style, s), Object.keys(a).forEach(function (l) {
                i.removeAttribute(l)
            }))
        })
    }
}

const g9t = {name: "applyStyles", enabled: !0, phase: "write", fn: m9t, effect: v9t, requires: ["computeStyles"]};

function B0(t) {
    return t.split("-")[0]
}

var Gw = Math.max, GO = Math.min, sE = Math.round;

function LK() {
    var t = navigator.userAgentData;
    return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function (e) {
        return e.brand + "/" + e.version
    }).join(" ") : navigator.userAgent
}

function N6e() {
    return !/^((?!chrome|android).)*safari/i.test(LK())
}

function cE(t, e, r) {
    e === void 0 && (e = !1), r === void 0 && (r = !1);
    var n = t.getBoundingClientRect(), i = 1, a = 1;
    e && Kd(t) && (i = t.offsetWidth > 0 && sE(n.width) / t.offsetWidth || 1, a = t.offsetHeight > 0 && sE(n.height) / t.offsetHeight || 1);
    var o = pS(t) ? Yf(t) : window, s = o.visualViewport, l = !N6e() && r,
        f = (n.left + (l && s ? s.offsetLeft : 0)) / i, d = (n.top + (l && s ? s.offsetTop : 0)) / a, p = n.width / i,
        g = n.height / a;
    return {width: p, height: g, top: d, right: f + p, bottom: d + g, left: f, x: f, y: d}
}

function QJ(t) {
    var e = cE(t), r = t.offsetWidth, n = t.offsetHeight;
    return Math.abs(e.width - r) <= 1 && (r = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: r,
        height: n
    }
}

function L6e(t, e) {
    var r = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (r && XJ(r)) {
        var n = e;
        do {
            if (n && t.isSameNode(n)) return !0;
            n = n.parentNode || n.host
        } while (n)
    }
    return !1
}

function zv(t) {
    return Yf(t).getComputedStyle(t)
}

function y9t(t) {
    return ["table", "td", "th"].indexOf(G0(t)) >= 0
}

function T1(t) {
    return ((pS(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function hL(t) {
    return G0(t) === "html" ? t : t.assignedSlot || t.parentNode || (XJ(t) ? t.host : null) || T1(t)
}

function mpe(t) {
    return !Kd(t) || zv(t).position === "fixed" ? null : t.offsetParent
}

function b9t(t) {
    var e = /firefox/i.test(LK()), r = /Trident/i.test(LK());
    if (r && Kd(t)) {
        var n = zv(t);
        if (n.position === "fixed") return null
    }
    var i = hL(t);
    for (XJ(i) && (i = i.host); Kd(i) && ["html", "body"].indexOf(G0(i)) < 0;) {
        var a = zv(i);
        if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || e && a.willChange === "filter" || e && a.filter && a.filter !== "none") return i;
        i = i.parentNode
    }
    return null
}

function uI(t) {
    for (var e = Yf(t), r = mpe(t); r && y9t(r) && zv(r).position === "static";) r = mpe(r);
    return r && (G0(r) === "html" || G0(r) === "body" && zv(r).position === "static") ? e : r || b9t(t) || e
}

function ZJ(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function SC(t, e, r) {
    return Gw(t, GO(e, r))
}

function w9t(t, e, r) {
    var n = SC(t, e, r);
    return n > r ? r : n
}

function B6e() {
    return {top: 0, right: 0, bottom: 0, left: 0}
}

function $6e(t) {
    return Object.assign({}, B6e(), t)
}

function F6e(t, e) {
    return e.reduce(function (r, n) {
        return r[n] = t, r
    }, {})
}

var S9t = function (e, r) {
    return e = typeof e == "function" ? e(Object.assign({}, r.rects, {placement: r.placement})) : e, $6e(typeof e != "number" ? e : F6e(e, lI))
};

function _9t(t) {
    var e, r = t.state, n = t.name, i = t.options, a = r.elements.arrow, o = r.modifiersData.popperOffsets,
        s = B0(r.placement), l = ZJ(s), f = [af, Jd].indexOf(s) >= 0, d = f ? "height" : "width";
    if (!(!a || !o)) {
        var p = S9t(i.padding, r), g = QJ(a), b = l === "y" ? nf : af, S = l === "y" ? Zd : Jd,
            T = r.rects.reference[d] + r.rects.reference[l] - o[l] - r.rects.popper[d], I = o[l] - r.rects.reference[l],
            N = uI(a), P = N ? l === "y" ? N.clientHeight || 0 : N.clientWidth || 0 : 0, F = T / 2 - I / 2, V = p[b],
            Y = P - g[d] - p[S], ee = P / 2 - g[d] / 2 + F, oe = SC(V, ee, Y), G = l;
        r.modifiersData[n] = (e = {}, e[G] = oe, e.centerOffset = oe - ee, e)
    }
}

function x9t(t) {
    var e = t.state, r = t.options, n = r.element, i = n === void 0 ? "[data-popper-arrow]" : n;
    i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || L6e(e.elements.popper, i) && (e.elements.arrow = i))
}

const E9t = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: _9t,
    effect: x9t,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};

function lE(t) {
    return t.split("-")[1]
}

var T9t = {top: "auto", right: "auto", bottom: "auto", left: "auto"};

function C9t(t, e) {
    var r = t.x, n = t.y, i = e.devicePixelRatio || 1;
    return {x: sE(r * i) / i || 0, y: sE(n * i) / i || 0}
}

function vpe(t) {
    var e, r = t.popper, n = t.popperRect, i = t.placement, a = t.variation, o = t.offsets, s = t.position,
        l = t.gpuAcceleration, f = t.adaptive, d = t.roundOffsets, p = t.isFixed, g = o.x, b = g === void 0 ? 0 : g,
        S = o.y, T = S === void 0 ? 0 : S, I = typeof d == "function" ? d({x: b, y: T}) : {x: b, y: T};
    b = I.x, T = I.y;
    var N = o.hasOwnProperty("x"), P = o.hasOwnProperty("y"), F = af, V = nf, Y = window;
    if (f) {
        var ee = uI(r), oe = "clientHeight", G = "clientWidth";
        if (ee === Yf(r) && (ee = T1(r), zv(ee).position !== "static" && s === "absolute" && (oe = "scrollHeight", G = "scrollWidth")), ee = ee, i === nf || (i === af || i === Jd) && a === $A) {
            V = Zd;
            var J = p && ee === Y && Y.visualViewport ? Y.visualViewport.height : ee[oe];
            T -= J - n.height, T *= l ? 1 : -1
        }
        if (i === af || (i === nf || i === Zd) && a === $A) {
            F = Jd;
            var ce = p && ee === Y && Y.visualViewport ? Y.visualViewport.width : ee[G];
            b -= ce - n.width, b *= l ? 1 : -1
        }
    }
    var re = Object.assign({position: s}, f && T9t), M = d === !0 ? C9t({x: b, y: T}, Yf(r)) : {x: b, y: T};
    if (b = M.x, T = M.y, l) {
        var D;
        return Object.assign({}, re, (D = {}, D[V] = P ? "0" : "", D[F] = N ? "0" : "", D.transform = (Y.devicePixelRatio || 1) <= 1 ? "translate(" + b + "px, " + T + "px)" : "translate3d(" + b + "px, " + T + "px, 0)", D))
    }
    return Object.assign({}, re, (e = {}, e[V] = P ? T + "px" : "", e[F] = N ? b + "px" : "", e.transform = "", e))
}

function A9t(t) {
    var e = t.state, r = t.options, n = r.gpuAcceleration, i = n === void 0 ? !0 : n, a = r.adaptive,
        o = a === void 0 ? !0 : a, s = r.roundOffsets, l = s === void 0 ? !0 : s, f = {
            placement: B0(e.placement),
            variation: lE(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: i,
            isFixed: e.options.strategy === "fixed"
        };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, vpe(Object.assign({}, f, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, vpe(Object.assign({}, f, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {"data-popper-placement": e.placement})
}

const I9t = {name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: A9t, data: {}};
var L7 = {passive: !0};

function k9t(t) {
    var e = t.state, r = t.instance, n = t.options, i = n.scroll, a = i === void 0 ? !0 : i, o = n.resize,
        s = o === void 0 ? !0 : o, l = Yf(e.elements.popper),
        f = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return a && f.forEach(function (d) {
        d.addEventListener("scroll", r.update, L7)
    }), s && l.addEventListener("resize", r.update, L7), function () {
        a && f.forEach(function (d) {
            d.removeEventListener("scroll", r.update, L7)
        }), s && l.removeEventListener("resize", r.update, L7)
    }
}

const R9t = {
    name: "eventListeners", enabled: !0, phase: "write", fn: function () {
    }, effect: k9t, data: {}
};
var D9t = {left: "right", right: "left", bottom: "top", top: "bottom"};

function tM(t) {
    return t.replace(/left|right|bottom|top/g, function (e) {
        return D9t[e]
    })
}

var M9t = {start: "end", end: "start"};

function gpe(t) {
    return t.replace(/start|end/g, function (e) {
        return M9t[e]
    })
}

function JJ(t) {
    var e = Yf(t), r = e.pageXOffset, n = e.pageYOffset;
    return {scrollLeft: r, scrollTop: n}
}

function eee(t) {
    return cE(T1(t)).left + JJ(t).scrollLeft
}

function O9t(t, e) {
    var r = Yf(t), n = T1(t), i = r.visualViewport, a = n.clientWidth, o = n.clientHeight, s = 0, l = 0;
    if (i) {
        a = i.width, o = i.height;
        var f = N6e();
        (f || !f && e === "fixed") && (s = i.offsetLeft, l = i.offsetTop)
    }
    return {width: a, height: o, x: s + eee(t), y: l}
}

function P9t(t) {
    var e, r = T1(t), n = JJ(t), i = (e = t.ownerDocument) == null ? void 0 : e.body,
        a = Gw(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = Gw(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        s = -n.scrollLeft + eee(t), l = -n.scrollTop;
    return zv(i || r).direction === "rtl" && (s += Gw(r.clientWidth, i ? i.clientWidth : 0) - a), {
        width: a,
        height: o,
        x: s,
        y: l
    }
}

function tee(t) {
    var e = zv(t), r = e.overflow, n = e.overflowX, i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(r + i + n)
}

function U6e(t) {
    return ["html", "body", "#document"].indexOf(G0(t)) >= 0 ? t.ownerDocument.body : Kd(t) && tee(t) ? t : U6e(hL(t))
}

function _C(t, e) {
    var r;
    e === void 0 && (e = []);
    var n = U6e(t), i = n === ((r = t.ownerDocument) == null ? void 0 : r.body), a = Yf(n),
        o = i ? [a].concat(a.visualViewport || [], tee(n) ? n : []) : n, s = e.concat(o);
    return i ? s : s.concat(_C(hL(o)))
}

function BK(t) {
    return Object.assign({}, t, {left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height})
}

function N9t(t, e) {
    var r = cE(t, !1, e === "fixed");
    return r.top = r.top + t.clientTop, r.left = r.left + t.clientLeft, r.bottom = r.top + t.clientHeight, r.right = r.left + t.clientWidth, r.width = t.clientWidth, r.height = t.clientHeight, r.x = r.left, r.y = r.top, r
}

function ype(t, e, r) {
    return e === O6e ? BK(O9t(t, r)) : pS(e) ? N9t(e, r) : BK(P9t(T1(t)))
}

function L9t(t) {
    var e = _C(hL(t)), r = ["absolute", "fixed"].indexOf(zv(t).position) >= 0, n = r && Kd(t) ? uI(t) : t;
    return pS(n) ? e.filter(function (i) {
        return pS(i) && L6e(i, n) && G0(i) !== "body"
    }) : []
}

function B9t(t, e, r, n) {
    var i = e === "clippingParents" ? L9t(t) : [].concat(e), a = [].concat(i, [r]), o = a[0],
        s = a.reduce(function (l, f) {
            var d = ype(t, f, n);
            return l.top = Gw(d.top, l.top), l.right = GO(d.right, l.right), l.bottom = GO(d.bottom, l.bottom), l.left = Gw(d.left, l.left), l
        }, ype(t, o, n));
    return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s
}

function j6e(t) {
    var e = t.reference, r = t.element, n = t.placement, i = n ? B0(n) : null, a = n ? lE(n) : null,
        o = e.x + e.width / 2 - r.width / 2, s = e.y + e.height / 2 - r.height / 2, l;
    switch (i) {
        case nf:
            l = {x: o, y: e.y - r.height};
            break;
        case Zd:
            l = {x: o, y: e.y + e.height};
            break;
        case Jd:
            l = {x: e.x + e.width, y: s};
            break;
        case af:
            l = {x: e.x - r.width, y: s};
            break;
        default:
            l = {x: e.x, y: e.y}
    }
    var f = i ? ZJ(i) : null;
    if (f != null) {
        var d = f === "y" ? "height" : "width";
        switch (a) {
            case oE:
                l[f] = l[f] - (e[d] / 2 - r[d] / 2);
                break;
            case $A:
                l[f] = l[f] + (e[d] / 2 - r[d] / 2);
                break
        }
    }
    return l
}

function FA(t, e) {
    e === void 0 && (e = {});
    var r = e, n = r.placement, i = n === void 0 ? t.placement : n, a = r.strategy, o = a === void 0 ? t.strategy : a,
        s = r.boundary, l = s === void 0 ? n9t : s, f = r.rootBoundary, d = f === void 0 ? O6e : f,
        p = r.elementContext, g = p === void 0 ? lT : p, b = r.altBoundary, S = b === void 0 ? !1 : b, T = r.padding,
        I = T === void 0 ? 0 : T, N = $6e(typeof I != "number" ? I : F6e(I, lI)), P = g === lT ? i9t : lT,
        F = t.rects.popper, V = t.elements[S ? P : g],
        Y = B9t(pS(V) ? V : V.contextElement || T1(t.elements.popper), l, d, o), ee = cE(t.elements.reference),
        oe = j6e({reference: ee, element: F, strategy: "absolute", placement: i}), G = BK(Object.assign({}, F, oe)),
        J = g === lT ? G : ee, ce = {
            top: Y.top - J.top + N.top,
            bottom: J.bottom - Y.bottom + N.bottom,
            left: Y.left - J.left + N.left,
            right: J.right - Y.right + N.right
        }, re = t.modifiersData.offset;
    if (g === lT && re) {
        var M = re[i];
        Object.keys(ce).forEach(function (D) {
            var x = [Jd, Zd].indexOf(D) >= 0 ? 1 : -1, A = [nf, Zd].indexOf(D) >= 0 ? "y" : "x";
            ce[D] += M[A] * x
        })
    }
    return ce
}

function $9t(t, e) {
    e === void 0 && (e = {});
    var r = e, n = r.placement, i = r.boundary, a = r.rootBoundary, o = r.padding, s = r.flipVariations,
        l = r.allowedAutoPlacements, f = l === void 0 ? P6e : l, d = lE(n), p = d ? s ? ppe : ppe.filter(function (S) {
            return lE(S) === d
        }) : lI, g = p.filter(function (S) {
            return f.indexOf(S) >= 0
        });
    g.length === 0 && (g = p);
    var b = g.reduce(function (S, T) {
        return S[T] = FA(t, {placement: T, boundary: i, rootBoundary: a, padding: o})[B0(T)], S
    }, {});
    return Object.keys(b).sort(function (S, T) {
        return b[S] - b[T]
    })
}

function F9t(t) {
    if (B0(t) === YJ) return [];
    var e = tM(t);
    return [gpe(t), e, gpe(e)]
}

function U9t(t) {
    var e = t.state, r = t.options, n = t.name;
    if (!e.modifiersData[n]._skip) {
        for (var i = r.mainAxis, a = i === void 0 ? !0 : i, o = r.altAxis, s = o === void 0 ? !0 : o, l = r.fallbackPlacements, f = r.padding, d = r.boundary, p = r.rootBoundary, g = r.altBoundary, b = r.flipVariations, S = b === void 0 ? !0 : b, T = r.allowedAutoPlacements, I = e.options.placement, N = B0(I), P = N === I, F = l || (P || !S ? [tM(I)] : F9t(I)), V = [I].concat(F).reduce(function (fe, ye) {
            return fe.concat(B0(ye) === YJ ? $9t(e, {
                placement: ye,
                boundary: d,
                rootBoundary: p,
                padding: f,
                flipVariations: S,
                allowedAutoPlacements: T
            }) : ye)
        }, []), Y = e.rects.reference, ee = e.rects.popper, oe = new Map, G = !0, J = V[0], ce = 0; ce < V.length; ce++) {
            var re = V[ce], M = B0(re), D = lE(re) === oE, x = [nf, Zd].indexOf(M) >= 0, A = x ? "width" : "height",
                B = FA(e, {placement: re, boundary: d, rootBoundary: p, altBoundary: g, padding: f}),
                z = x ? D ? Jd : af : D ? Zd : nf;
            Y[A] > ee[A] && (z = tM(z));
            var j = tM(z), $ = [];
            if (a && $.push(B[M] <= 0), s && $.push(B[z] <= 0, B[j] <= 0), $.every(function (fe) {
                return fe
            })) {
                J = re, G = !1;
                break
            }
            oe.set(re, $)
        }
        if (G) for (var C = S ? 3 : 1, R = function (ye) {
            var ue = V.find(function (me) {
                var Se = oe.get(me);
                if (Se) return Se.slice(0, ye).every(function (Ce) {
                    return Ce
                })
            });
            if (ue) return J = ue, "break"
        }, k = C; k > 0; k--) {
            var Q = R(k);
            if (Q === "break") break
        }
        e.placement !== J && (e.modifiersData[n]._skip = !0, e.placement = J, e.reset = !0)
    }
}

const j9t = {name: "flip", enabled: !0, phase: "main", fn: U9t, requiresIfExists: ["offset"], data: {_skip: !1}};

function bpe(t, e, r) {
    return r === void 0 && (r = {x: 0, y: 0}), {
        top: t.top - e.height - r.y,
        right: t.right - e.width + r.x,
        bottom: t.bottom - e.height + r.y,
        left: t.left - e.width - r.x
    }
}

function wpe(t) {
    return [nf, Jd, Zd, af].some(function (e) {
        return t[e] >= 0
    })
}

function z9t(t) {
    var e = t.state, r = t.name, n = e.rects.reference, i = e.rects.popper, a = e.modifiersData.preventOverflow,
        o = FA(e, {elementContext: "reference"}), s = FA(e, {altBoundary: !0}), l = bpe(o, n), f = bpe(s, i, a),
        d = wpe(l), p = wpe(f);
    e.modifiersData[r] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: f,
        isReferenceHidden: d,
        hasPopperEscaped: p
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": d,
        "data-popper-escaped": p
    })
}

const V9t = {name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: z9t};

function H9t(t, e, r) {
    var n = B0(t), i = [af, nf].indexOf(n) >= 0 ? -1 : 1,
        a = typeof r == "function" ? r(Object.assign({}, e, {placement: t})) : r, o = a[0], s = a[1];
    return o = o || 0, s = (s || 0) * i, [af, Jd].indexOf(n) >= 0 ? {x: s, y: o} : {x: o, y: s}
}

function W9t(t) {
    var e = t.state, r = t.options, n = t.name, i = r.offset, a = i === void 0 ? [0, 0] : i,
        o = P6e.reduce(function (d, p) {
            return d[p] = H9t(p, e.rects, a), d
        }, {}), s = o[e.placement], l = s.x, f = s.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += f), e.modifiersData[n] = o
}

const q9t = {name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: W9t};

function G9t(t) {
    var e = t.state, r = t.name;
    e.modifiersData[r] = j6e({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}

const K9t = {name: "popperOffsets", enabled: !0, phase: "read", fn: G9t, data: {}};

function Y9t(t) {
    return t === "x" ? "y" : "x"
}

function X9t(t) {
    var e = t.state, r = t.options, n = t.name, i = r.mainAxis, a = i === void 0 ? !0 : i, o = r.altAxis,
        s = o === void 0 ? !1 : o, l = r.boundary, f = r.rootBoundary, d = r.altBoundary, p = r.padding, g = r.tether,
        b = g === void 0 ? !0 : g, S = r.tetherOffset, T = S === void 0 ? 0 : S,
        I = FA(e, {boundary: l, rootBoundary: f, padding: p, altBoundary: d}), N = B0(e.placement), P = lE(e.placement),
        F = !P, V = ZJ(N), Y = Y9t(V), ee = e.modifiersData.popperOffsets, oe = e.rects.reference, G = e.rects.popper,
        J = typeof T == "function" ? T(Object.assign({}, e.rects, {placement: e.placement})) : T,
        ce = typeof J == "number" ? {mainAxis: J, altAxis: J} : Object.assign({mainAxis: 0, altAxis: 0}, J),
        re = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, M = {x: 0, y: 0};
    if (ee) {
        if (a) {
            var D, x = V === "y" ? nf : af, A = V === "y" ? Zd : Jd, B = V === "y" ? "height" : "width", z = ee[V],
                j = z + I[x], $ = z - I[A], C = b ? -G[B] / 2 : 0, R = P === oE ? oe[B] : G[B],
                k = P === oE ? -G[B] : -oe[B], Q = e.elements.arrow, fe = b && Q ? QJ(Q) : {width: 0, height: 0},
                ye = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : B6e(),
                ue = ye[x], me = ye[A], Se = SC(0, oe[B], fe[B]),
                Ce = F ? oe[B] / 2 - C - Se - ue - ce.mainAxis : R - Se - ue - ce.mainAxis,
                Me = F ? -oe[B] / 2 + C + Se + me + ce.mainAxis : k + Se + me + ce.mainAxis,
                ve = e.elements.arrow && uI(e.elements.arrow),
                ne = ve ? V === "y" ? ve.clientTop || 0 : ve.clientLeft || 0 : 0,
                be = (D = re == null ? void 0 : re[V]) != null ? D : 0, Ee = z + Ce - be - ne, Oe = z + Me - be,
                ze = SC(b ? GO(j, Ee) : j, z, b ? Gw($, Oe) : $);
            ee[V] = ze, M[V] = ze - z
        }
        if (s) {
            var Be, it = V === "x" ? nf : af, Ue = V === "x" ? Zd : Jd, bt = ee[Y], gt = Y === "y" ? "height" : "width",
                Ot = bt + I[it], zt = bt - I[Ue], _t = [nf, af].indexOf(N) !== -1,
                Dt = (Be = re == null ? void 0 : re[Y]) != null ? Be : 0,
                rr = _t ? Ot : bt - oe[gt] - G[gt] - Dt + ce.altAxis,
                pe = _t ? bt + oe[gt] + G[gt] - Dt - ce.altAxis : zt,
                te = b && _t ? w9t(rr, bt, pe) : SC(b ? rr : Ot, bt, b ? pe : zt);
            ee[Y] = te, M[Y] = te - bt
        }
        e.modifiersData[n] = M
    }
}

const Q9t = {name: "preventOverflow", enabled: !0, phase: "main", fn: X9t, requiresIfExists: ["offset"]};

function Z9t(t) {
    return {scrollLeft: t.scrollLeft, scrollTop: t.scrollTop}
}

function J9t(t) {
    return t === Yf(t) || !Kd(t) ? JJ(t) : Z9t(t)
}

function e7t(t) {
    var e = t.getBoundingClientRect(), r = sE(e.width) / t.offsetWidth || 1, n = sE(e.height) / t.offsetHeight || 1;
    return r !== 1 || n !== 1
}

function t7t(t, e, r) {
    r === void 0 && (r = !1);
    var n = Kd(e), i = Kd(e) && e7t(e), a = T1(e), o = cE(t, i, r), s = {scrollLeft: 0, scrollTop: 0}, l = {x: 0, y: 0};
    return (n || !n && !r) && ((G0(e) !== "body" || tee(a)) && (s = J9t(e)), Kd(e) ? (l = cE(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : a && (l.x = eee(a))), {
        x: o.left + s.scrollLeft - l.x,
        y: o.top + s.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}

function r7t(t) {
    var e = new Map, r = new Set, n = [];
    t.forEach(function (a) {
        e.set(a.name, a)
    });

    function i(a) {
        r.add(a.name);
        var o = [].concat(a.requires || [], a.requiresIfExists || []);
        o.forEach(function (s) {
            if (!r.has(s)) {
                var l = e.get(s);
                l && i(l)
            }
        }), n.push(a)
    }

    return t.forEach(function (a) {
        r.has(a.name) || i(a)
    }), n
}

function n7t(t) {
    var e = r7t(t);
    return p9t.reduce(function (r, n) {
        return r.concat(e.filter(function (i) {
            return i.phase === n
        }))
    }, [])
}

function i7t(t) {
    var e;
    return function () {
        return e || (e = new Promise(function (r) {
            Promise.resolve().then(function () {
                e = void 0, r(t())
            })
        })), e
    }
}

function a7t(t) {
    var e = t.reduce(function (r, n) {
        var i = r[n.name];
        return r[n.name] = i ? Object.assign({}, i, n, {
            options: Object.assign({}, i.options, n.options),
            data: Object.assign({}, i.data, n.data)
        }) : n, r
    }, {});
    return Object.keys(e).map(function (r) {
        return e[r]
    })
}

var Spe = {placement: "bottom", modifiers: [], strategy: "absolute"};

function _pe() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
    return !e.some(function (n) {
        return !(n && typeof n.getBoundingClientRect == "function")
    })
}

function o7t(t) {
    t === void 0 && (t = {});
    var e = t, r = e.defaultModifiers, n = r === void 0 ? [] : r, i = e.defaultOptions, a = i === void 0 ? Spe : i;
    return function (s, l, f) {
        f === void 0 && (f = a);
        var d = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, Spe, a),
            modifiersData: {},
            elements: {reference: s, popper: l},
            attributes: {},
            styles: {}
        }, p = [], g = !1, b = {
            state: d, setOptions: function (N) {
                var P = typeof N == "function" ? N(d.options) : N;
                T(), d.options = Object.assign({}, a, d.options, P), d.scrollParents = {
                    reference: pS(s) ? _C(s) : s.contextElement ? _C(s.contextElement) : [],
                    popper: _C(l)
                };
                var F = n7t(a7t([].concat(n, d.options.modifiers)));
                return d.orderedModifiers = F.filter(function (V) {
                    return V.enabled
                }), S(), b.update()
            }, forceUpdate: function () {
                if (!g) {
                    var N = d.elements, P = N.reference, F = N.popper;
                    if (_pe(P, F)) {
                        d.rects = {
                            reference: t7t(P, uI(F), d.options.strategy === "fixed"),
                            popper: QJ(F)
                        }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function (ce) {
                            return d.modifiersData[ce.name] = Object.assign({}, ce.data)
                        });
                        for (var V = 0; V < d.orderedModifiers.length; V++) {
                            if (d.reset === !0) {
                                d.reset = !1, V = -1;
                                continue
                            }
                            var Y = d.orderedModifiers[V], ee = Y.fn, oe = Y.options, G = oe === void 0 ? {} : oe,
                                J = Y.name;
                            typeof ee == "function" && (d = ee({state: d, options: G, name: J, instance: b}) || d)
                        }
                    }
                }
            }, update: i7t(function () {
                return new Promise(function (I) {
                    b.forceUpdate(), I(d)
                })
            }), destroy: function () {
                T(), g = !0
            }
        };
        if (!_pe(s, l)) return b;
        b.setOptions(f).then(function (I) {
            !g && f.onFirstUpdate && f.onFirstUpdate(I)
        });

        function S() {
            d.orderedModifiers.forEach(function (I) {
                var N = I.name, P = I.options, F = P === void 0 ? {} : P, V = I.effect;
                if (typeof V == "function") {
                    var Y = V({state: d, name: N, instance: b, options: F}), ee = function () {
                    };
                    p.push(Y || ee)
                }
            })
        }

        function T() {
            p.forEach(function (I) {
                return I()
            }), p = []
        }

        return b
    }
}

var s7t = [R9t, K9t, I9t, g9t, q9t, j9t, Q9t, E9t, V9t], c7t = o7t({defaultModifiers: s7t});

function z6e(t = {}) {
    const {
        enabled: e = !0,
        modifiers: r,
        placement: n = "bottom",
        strategy: i = "absolute",
        arrowPadding: a = 8,
        eventListeners: o = !0,
        offset: s,
        gutter: l = 8,
        flip: f = !0,
        boundary: d = "clippingParents",
        preventOverflow: p = !0,
        matchWidth: g,
        direction: b = "ltr"
    } = t, S = W.useRef(null), T = W.useRef(null), I = W.useRef(null), N = r9t(n, b), P = W.useRef(() => {
    }), F = W.useCallback(() => {
        var ce;
        !e || !S.current || !T.current || ((ce = P.current) == null || ce.call(P), I.current = c7t(S.current, T.current, {
            placement: N,
            modifiers: [JRt, XRt, YRt, {...KRt, enabled: !!g}, {name: "eventListeners", ...GRt(o)}, {
                name: "arrow",
                options: {padding: a}
            }, {name: "offset", options: {offset: s ?? [0, l]}}, {
                name: "flip",
                enabled: !!f,
                options: {padding: 8}
            }, {name: "preventOverflow", enabled: !!p, options: {boundary: d}}, ...r ?? []],
            strategy: i
        }), I.current.forceUpdate(), P.current = I.current.destroy)
    }, [N, e, r, g, o, a, s, l, f, p, d, i]);
    W.useEffect(() => () => {
        var ce;
        !S.current && !T.current && ((ce = I.current) == null || ce.destroy(), I.current = null)
    }, []);
    const V = W.useCallback(ce => {
        S.current = ce, F()
    }, [F]), Y = W.useCallback((ce = {}, re = null) => ({...ce, ref: Kf(V, re)}), [V]), ee = W.useCallback(ce => {
        T.current = ce, F()
    }, [F]), oe = W.useCallback((ce = {}, re = null) => ({
        ...ce,
        ref: Kf(ee, re),
        style: {...ce.style, position: i, minWidth: g ? void 0 : "max-content", inset: "0 auto auto 0"}
    }), [i, ee, g]), G = W.useCallback((ce = {}, re = null) => {
        const {size: M, shadowColor: D, bg: x, style: A, ...B} = ce;
        return {...B, ref: re, "data-popper-arrow": "", style: l7t(ce)}
    }, []), J = W.useCallback((ce = {}, re = null) => ({...ce, ref: re, "data-popper-arrow-inner": ""}), []);
    return {
        update() {
            var ce;
            (ce = I.current) == null || ce.update()
        },
        forceUpdate() {
            var ce;
            (ce = I.current) == null || ce.forceUpdate()
        },
        transformOrigin: zc.transformOrigin.varRef,
        referenceRef: V,
        popperRef: ee,
        getPopperProps: oe,
        getArrowProps: G,
        getArrowInnerProps: J,
        getReferenceProps: Y
    }
}

function l7t(t) {
    const {size: e, shadowColor: r, bg: n, style: i} = t, a = {...i, position: "absolute"};
    return e && (a["--popper-arrow-size"] = e), r && (a["--popper-arrow-shadow-color"] = r), n && (a["--popper-arrow-bg"] = n), a
}

function V6e(t = {}) {
    const {onClose: e, onOpen: r, isOpen: n, id: i} = t, a = Uy(r),
        o = Uy(e), [s, l] = W.useState(t.defaultIsOpen || !1), f = n !== void 0 ? n : s, d = n !== void 0,
        p = W.useId(), g = i ?? `disclosure-${p}`, b = W.useCallback(() => {
            d || l(!1), o == null || o()
        }, [d, o]), S = W.useCallback(() => {
            d || l(!0), a == null || a()
        }, [d, a]), T = W.useCallback(() => {
            f ? b() : S()
        }, [f, S, b]);

    function I(P = {}) {
        return {
            ...P, "aria-expanded": f, "aria-controls": g, onClick(F) {
                var V;
                (V = P.onClick) == null || V.call(P, F), T()
            }
        }
    }

    function N(P = {}) {
        return {...P, hidden: !f, id: g}
    }

    return {isOpen: f, onOpen: S, onClose: b, onToggle: T, isControlled: d, getButtonProps: I, getDisclosureProps: N}
}

function u7t(t) {
    const {ref: e, handler: r, enabled: n = !0} = t, i = Uy(r),
        o = W.useRef({isPointerDown: !1, ignoreEmulatedMouseEvents: !1}).current;
    W.useEffect(() => {
        if (!n) return;
        const s = p => {
            wH(p, e) && (o.isPointerDown = !0)
        }, l = p => {
            if (o.ignoreEmulatedMouseEvents) {
                o.ignoreEmulatedMouseEvents = !1;
                return
            }
            o.isPointerDown && r && wH(p, e) && (o.isPointerDown = !1, i(p))
        }, f = p => {
            o.ignoreEmulatedMouseEvents = !0, r && o.isPointerDown && wH(p, e) && (o.isPointerDown = !1, i(p))
        }, d = H6e(e.current);
        return d.addEventListener("mousedown", s, !0), d.addEventListener("mouseup", l, !0), d.addEventListener("touchstart", s, !0), d.addEventListener("touchend", f, !0), () => {
            d.removeEventListener("mousedown", s, !0), d.removeEventListener("mouseup", l, !0), d.removeEventListener("touchstart", s, !0), d.removeEventListener("touchend", f, !0)
        }
    }, [r, e, i, o, n])
}

function wH(t, e) {
    var r;
    const n = t.target;
    return n && !H6e(n).contains(n) ? !1 : !((r = e.current) != null && r.contains(n))
}

function H6e(t) {
    var e;
    return (e = t == null ? void 0 : t.ownerDocument) != null ? e : document
}

function f7t(t) {
    const {isOpen: e, ref: r} = t, [n, i] = W.useState(e), [a, o] = W.useState(!1);
    return W.useEffect(() => {
        a || (i(e), o(!0))
    }, [e, a, n]), wC(() => r.current, "animationend", () => {
        i(e)
    }), {
        present: !(e ? !1 : !n), onComplete() {
            var l;
            const f = aRt(r.current), d = new f.CustomEvent("animationend", {bubbles: !0});
            (l = r.current) == null || l.dispatchEvent(d)
        }
    }
}

function d7t(t) {
    const {wasSelected: e, enabled: r, isSelected: n, mode: i = "unmount"} = t;
    return !!(!r || n || i === "keepMounted" && e)
}

var [h7t, p7t, m7t, v7t] = EIt(), [g7t, fI] = rd({strict: !1, name: "MenuContext"});

function y7t(t, ...e) {
    const r = W.useId(), n = t || r;
    return W.useMemo(() => e.map(i => `${i}-${n}`), [n, e])
}

function W6e(t) {
    var e;
    return (e = t == null ? void 0 : t.ownerDocument) != null ? e : document
}

function xpe(t) {
    return W6e(t).activeElement === t
}

function b7t(t = {}) {
    const {
        id: e,
        closeOnSelect: r = !0,
        closeOnBlur: n = !0,
        initialFocusRef: i,
        autoSelect: a = !0,
        isLazy: o,
        isOpen: s,
        defaultIsOpen: l,
        onClose: f,
        onOpen: d,
        placement: p = "bottom-start",
        lazyBehavior: g = "unmount",
        direction: b,
        computePositionOnMount: S = !1,
        ...T
    } = t, I = W.useRef(null), N = W.useRef(null), P = m7t(), F = W.useCallback(() => {
        requestAnimationFrame(() => {
            var Q;
            (Q = I.current) == null || Q.focus({preventScroll: !1})
        })
    }, []), V = W.useCallback(() => {
        const Q = setTimeout(() => {
            var fe;
            if (i) (fe = i.current) == null || fe.focus(); else {
                const ye = P.firstEnabled();
                ye && D(ye.index)
            }
        });
        j.current.add(Q)
    }, [P, i]), Y = W.useCallback(() => {
        const Q = setTimeout(() => {
            const fe = P.lastEnabled();
            fe && D(fe.index)
        });
        j.current.add(Q)
    }, [P]), ee = W.useCallback(() => {
        d == null || d(), a ? V() : F()
    }, [a, V, F, d]), {isOpen: oe, onOpen: G, onClose: J, onToggle: ce} = V6e({
        isOpen: s,
        defaultIsOpen: l,
        onClose: f,
        onOpen: ee
    });
    u7t({
        enabled: oe && n, ref: I, handler: Q => {
            var fe;
            (fe = N.current) != null && fe.contains(Q.target) || J()
        }
    });
    const re = z6e({...T, enabled: oe || S, placement: p, direction: b}), [M, D] = W.useState(-1);
    rE(() => {
        oe || D(-1)
    }, [oe]), jRt(I, {focusRef: N, visible: oe, shouldFocus: !0});
    const x = f7t({isOpen: oe, ref: I}), [A, B] = y7t(e, "menu-button", "menu-list"), z = W.useCallback(() => {
        G(), F()
    }, [G, F]), j = W.useRef(new Set([]));
    W.useEffect(() => {
        const Q = j.current;
        return () => {
            Q.forEach(fe => clearTimeout(fe)), Q.clear()
        }
    }, []);
    const $ = W.useCallback(() => {
        G(), V()
    }, [V, G]), C = W.useCallback(() => {
        G(), Y()
    }, [G, Y]), R = W.useCallback(() => {
        var Q, fe;
        const ye = W6e(I.current), ue = (Q = I.current) == null ? void 0 : Q.contains(ye.activeElement);
        if (!(oe && !ue)) return;
        const Se = (fe = P.item(M)) == null ? void 0 : fe.node;
        Se == null || Se.focus({preventScroll: !0})
    }, [oe, M, P]), k = W.useRef(null);
    return {
        openAndFocusMenu: z,
        openAndFocusFirstItem: $,
        openAndFocusLastItem: C,
        onTransitionEnd: R,
        unstable__animationState: x,
        descendants: P,
        popper: re,
        buttonId: A,
        menuId: B,
        forceUpdate: re.forceUpdate,
        orientation: "vertical",
        isOpen: oe,
        onToggle: ce,
        onOpen: G,
        onClose: J,
        menuRef: I,
        buttonRef: N,
        focusedIndex: M,
        closeOnSelect: r,
        closeOnBlur: n,
        autoSelect: a,
        setFocusedIndex: D,
        isLazy: o,
        lazyBehavior: g,
        initialFocusRef: i,
        rafId: k
    }
}

function w7t(t = {}, e = null) {
    const r = fI(), {onToggle: n, popper: i, openAndFocusFirstItem: a, openAndFocusLastItem: o} = r,
        s = W.useCallback(l => {
            const f = l.key, p = {Enter: a, ArrowDown: a, ArrowUp: o}[f];
            p && (l.preventDefault(), l.stopPropagation(), p(l))
        }, [a, o]);
    return {
        ...t,
        ref: Kf(r.buttonRef, e, i.referenceRef),
        id: r.buttonId,
        "data-active": Ry(r.isOpen),
        "aria-expanded": r.isOpen,
        "aria-haspopup": "menu",
        "aria-controls": r.menuId,
        onClick: iu(t.onClick, n),
        onKeyDown: iu(t.onKeyDown, s)
    }
}

function $K(t) {
    var e;
    return T7t(t) && !!((e = t == null ? void 0 : t.getAttribute("role")) != null && e.startsWith("menuitem"))
}

function S7t(t = {}, e = null) {
    const r = fI();
    if (!r) throw new Error("useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>");
    const {
        focusedIndex: n,
        setFocusedIndex: i,
        menuRef: a,
        isOpen: o,
        onClose: s,
        menuId: l,
        isLazy: f,
        lazyBehavior: d,
        unstable__animationState: p
    } = r, g = p7t(), b = LRt({preventDefault: N => N.key !== " " && $K(N.target)}), S = W.useCallback(N => {
        if (!N.currentTarget.contains(N.target)) return;
        const P = N.key, V = {
            Tab: ee => ee.preventDefault(), Escape: s, ArrowDown: () => {
                const ee = g.nextEnabled(n);
                ee && i(ee.index)
            }, ArrowUp: () => {
                const ee = g.prevEnabled(n);
                ee && i(ee.index)
            }
        }[P];
        if (V) {
            N.preventDefault(), V(N);
            return
        }
        const Y = b(ee => {
            const oe = BRt(g.values(), ee, G => {
                var J, ce;
                return (ce = (J = G == null ? void 0 : G.node) == null ? void 0 : J.textContent) != null ? ce : ""
            }, g.item(n));
            if (oe) {
                const G = g.indexOf(oe.node);
                i(G)
            }
        });
        $K(N.target) && Y(N)
    }, [g, n, b, s, i]), T = W.useRef(!1);
    o && (T.current = !0);
    const I = d7t({wasSelected: T.current, enabled: f, mode: d, isSelected: p.present});
    return {
        ...t,
        ref: Kf(a, e),
        children: I ? t.children : null,
        tabIndex: -1,
        role: "menu",
        id: l,
        style: {...t.style, transformOrigin: "var(--popper-transform-origin)"},
        "aria-orientation": "vertical",
        onKeyDown: iu(t.onKeyDown, S)
    }
}

function _7t(t = {}) {
    const {popper: e, isOpen: r} = fI();
    return e.getPopperProps({...t, style: {visibility: r ? "visible" : "hidden", ...t.style}})
}

function q6e(t = {}, e = null) {
    const {
            onMouseEnter: r,
            onMouseMove: n,
            onMouseLeave: i,
            onClick: a,
            onFocus: o,
            isDisabled: s,
            isFocusable: l,
            closeOnSelect: f,
            type: d,
            ...p
        } = t, g = fI(), {
            setFocusedIndex: b,
            focusedIndex: S,
            closeOnSelect: T,
            onClose: I,
            menuRef: N,
            isOpen: P,
            menuId: F,
            rafId: V
        } = g, Y = W.useRef(null), ee = `${F}-menuitem-${W.useId()}`, {index: oe, register: G} = v7t({disabled: s && !l}),
        J = W.useCallback(z => {
            r == null || r(z), !s && b(oe)
        }, [b, oe, s, r]), ce = W.useCallback(z => {
            n == null || n(z), Y.current && !xpe(Y.current) && J(z)
        }, [J, n]), re = W.useCallback(z => {
            i == null || i(z), !s && b(-1)
        }, [b, s, i]), M = W.useCallback(z => {
            a == null || a(z), $K(z.currentTarget) && (f ?? T) && I()
        }, [I, a, T, f]), D = W.useCallback(z => {
            o == null || o(z), b(oe)
        }, [b, o, oe]), x = oe === S, A = s && !l;
    rE(() => {
        if (P) return x && !A && Y.current ? (V.current && cancelAnimationFrame(V.current), V.current = requestAnimationFrame(() => {
            var z;
            (z = Y.current) == null || z.focus({preventScroll: !0}), V.current = null
        })) : N.current && !xpe(N.current) && N.current.focus({preventScroll: !0}), () => {
            V.current && cancelAnimationFrame(V.current)
        }
    }, [x, A, N, P]);
    const B = FRt({
        onClick: M,
        onFocus: D,
        onMouseEnter: J,
        onMouseMove: ce,
        onMouseLeave: re,
        ref: Kf(G, Y, e),
        isDisabled: s,
        isFocusable: l
    });
    return {...p, ...B, type: d ?? B.type, id: ee, role: "menuitem", tabIndex: x ? 0 : -1}
}

function x7t(t = {}, e = null) {
    const {type: r = "radio", isChecked: n, ...i} = t;
    return {...q6e(i, e), role: `menuitem${r}`, "aria-checked": n}
}

function E7t(t = {}) {
    const {children: e, type: r = "radio", value: n, defaultValue: i, onChange: a, ...o} = t,
        l = r === "radio" ? "" : [], [f, d] = TIt({defaultValue: i ?? l, value: n, onChange: a}),
        p = W.useCallback(S => {
            if (r === "radio" && typeof f == "string" && d(S), r === "checkbox" && Array.isArray(f)) {
                const T = f.includes(S) ? f.filter(I => I !== S) : f.concat(S);
                d(T)
            }
        }, [f, d, r]), b = W3e(e).map(S => {
            if (S.type.id !== "MenuItemOption") return S;
            const T = N => {
                var P, F;
                p(S.props.value), (F = (P = S.props).onClick) == null || F.call(P, N)
            }, I = r === "radio" ? S.props.value === f : f.includes(S.props.value);
            return W.cloneElement(S, {type: r, onClick: T, isChecked: I})
        });
    return {...o, children: b}
}

function T7t(t) {
    var e;
    if (!C7t(t)) return !1;
    const r = (e = t.ownerDocument.defaultView) != null ? e : window;
    return t instanceof r.HTMLElement
}

function C7t(t) {
    return t != null && typeof t == "object" && "nodeType" in t && t.nodeType === Node.ELEMENT_NODE
}

var [A7t, XS] = rd({
    name: "MenuStylesContext",
    errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
}), G6e = t => {
    const {children: e} = t, r = tI("Menu", t), n = Cp(t), {direction: i} = n3(), {descendants: a, ...o} = b7t({
        ...n,
        direction: i
    }), s = W.useMemo(() => o, [o]), {isOpen: l, onClose: f, forceUpdate: d} = s;
    return ie.jsx(h7t, {
        value: a,
        children: ie.jsx(g7t, {
            value: s,
            children: ie.jsx(A7t, {value: r, children: tp(e, {isOpen: l, onClose: f, forceUpdate: d})})
        })
    })
};
G6e.displayName = "Menu";
var K6e = Jn((t, e) => {
    const r = XS();
    return ie.jsx(on.span, {ref: e, ...t, __css: r.command, className: "chakra-menu__command"})
});
K6e.displayName = "MenuCommand";
var Y6e = Jn((t, e) => {
    const {type: r, ...n} = t, i = XS(), a = n.as || r ? r ?? void 0 : "button", o = W.useMemo(() => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0, ...i.item
    }), [i.item]);
    return ie.jsx(on.button, {ref: e, type: a, ...n, __css: o})
}), ree = t => {
    const {className: e, children: r, ...n} = t, i = XS(), a = W.Children.only(r),
        o = W.isValidElement(a) ? W.cloneElement(a, {
            focusable: "false",
            "aria-hidden": !0,
            className: mi("chakra-menu__icon", a.props.className)
        }) : null, s = mi("chakra-menu__icon-wrapper", e);
    return ie.jsx(on.span, {className: s, ...n, __css: i.icon, children: o})
};
ree.displayName = "MenuIcon";
var X6e = Jn((t, e) => {
    const {icon: r, iconSpacing: n = "0.75rem", command: i, commandSpacing: a = "0.75rem", children: o, ...s} = t,
        l = q6e(s, e), d = r || i ? ie.jsx("span", {style: {pointerEvents: "none", flex: 1}, children: o}) : o;
    return ie.jsxs(Y6e, {
        ...l,
        className: mi("chakra-menu__menuitem", l.className),
        children: [r && ie.jsx(ree, {
            fontSize: "0.8em",
            marginEnd: n,
            children: r
        }), d, i && ie.jsx(K6e, {marginStart: a, children: i})]
    })
});
X6e.displayName = "MenuItem";
var I7t = {
    enter: {visibility: "visible", opacity: 1, scale: 1, transition: {duration: .2, ease: [.4, 0, .2, 1]}},
    exit: {transitionEnd: {visibility: "hidden"}, opacity: 0, scale: .8, transition: {duration: .1, easings: "easeOut"}}
}, k7t = on(E1.div), Q6e = Jn(function (e, r) {
    var n, i;
    const {rootProps: a, motionProps: o, ...s} = e, {isOpen: l, onTransitionEnd: f, unstable__animationState: d} = fI(),
        p = S7t(s, r), g = _7t(a), b = XS();
    return ie.jsx(on.div, {
        ...g,
        __css: {zIndex: (i = e.zIndex) != null ? i : (n = b.list) == null ? void 0 : n.zIndex},
        children: ie.jsx(k7t, {
            variants: I7t,
            initial: !1,
            animate: l ? "enter" : "exit",
            __css: {outline: 0, ...b.list}, ...o,
            className: mi("chakra-menu__menu-list", p.className), ...p,
            onUpdate: f,
            onAnimationComplete: lSt(d.onComplete, p.onAnimationComplete)
        })
    })
});
Q6e.displayName = "MenuList";
var nee = Jn((t, e) => {
    const {title: r, children: n, className: i, ...a} = t, o = mi("chakra-menu__group__title", i), s = XS();
    return ie.jsxs("div", {
        ref: e,
        className: "chakra-menu__group",
        role: "group",
        children: [r && ie.jsx(on.p, {className: o, ...a, __css: s.groupTitle, children: r}), n]
    })
});
nee.displayName = "MenuGroup";
var Z6e = t => {
    const {className: e, title: r, ...n} = t, i = E7t(n);
    return ie.jsx(nee, {title: r, className: mi("chakra-menu__option-group", e), ...i})
};
Z6e.displayName = "MenuOptionGroup";
var R7t = Jn((t, e) => {
    const r = XS();
    return ie.jsx(on.button, {
        ref: e, ...t,
        __css: {display: "inline-flex", appearance: "none", alignItems: "center", outline: 0, ...r.button}
    })
}), J6e = Jn((t, e) => {
    const {children: r, as: n, ...i} = t, a = w7t(i, e), o = n || R7t;
    return ie.jsx(o, {
        ...a,
        className: mi("chakra-menu__menu-button", t.className),
        children: ie.jsx(on.span, {__css: {pointerEvents: "none", flex: "1 1 auto", minW: 0}, children: t.children})
    })
});
J6e.displayName = "MenuButton";
var e5e = t => {
    const {className: e, ...r} = t, n = XS();
    return ie.jsx(on.hr, {
        "aria-orientation": "horizontal",
        className: mi("chakra-menu__divider", e), ...r,
        __css: n.divider
    })
};
e5e.displayName = "MenuDivider";
var D7t = t => ie.jsx("svg", {
    viewBox: "0 0 14 14",
    width: "1em",
    height: "1em", ...t,
    children: ie.jsx("polygon", {
        fill: "currentColor",
        points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
    })
}), iee = Jn((t, e) => {
    const {icon: r, iconSpacing: n = "0.75rem", ...i} = t, a = x7t(i, e);
    return ie.jsxs(Y6e, {
        ...a,
        className: mi("chakra-menu__menuitem-option", i.className),
        children: [r !== null && ie.jsx(ree, {
            fontSize: "0.8em",
            marginEnd: n,
            opacity: t.isChecked ? 1 : 0,
            children: r || ie.jsx(D7t, {})
        }), ie.jsx("span", {style: {flex: 1}, children: a.children})]
    })
});
iee.id = "MenuItemOption";
iee.displayName = "MenuItemOption";
var M7t = {
    slideInBottom: {...FT, custom: {offsetY: 16, reverse: !0}},
    slideInRight: {...FT, custom: {offsetX: 16, reverse: !0}},
    slideInTop: {...FT, custom: {offsetY: -16, reverse: !0}},
    slideInLeft: {...FT, custom: {offsetX: -16, reverse: !0}},
    scale: {...V3e, custom: {initialScale: .95, reverse: !0}},
    none: {}
}, O7t = on(E1.section), P7t = t => M7t[t || "none"], t5e = W.forwardRef((t, e) => {
    const {preset: r, motionProps: n = P7t(r), ...i} = t;
    return ie.jsx(O7t, {ref: e, ...n, ...i})
});
t5e.displayName = "ModalTransition";
var N7t = Object.defineProperty,
    L7t = (t, e, r) => e in t ? N7t(t, e, {enumerable: !0, configurable: !0, writable: !0, value: r}) : t[e] = r,
    B7t = (t, e, r) => (L7t(t, typeof e != "symbol" ? e + "" : e, r), r), $7t = class {
        constructor() {
            B7t(this, "modals"), this.modals = new Map
        }

        add(t) {
            return this.modals.set(t, this.modals.size + 1), this.modals.size
        }

        remove(t) {
            this.modals.delete(t)
        }

        isTopModal(t) {
            return t ? this.modals.get(t) === this.modals.size : !1
        }
    }, FK = new $7t;

function r5e(t, e) {
    const [r, n] = W.useState(0);
    return W.useEffect(() => {
        const i = t.current;
        if (i) {
            if (e) {
                const a = FK.add(i);
                n(a)
            }
            return () => {
                FK.remove(i), n(0)
            }
        }
    }, [e, t]), r
}

var F7t = function (t) {
    if (typeof document > "u") return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body
}, ix = new WeakMap, B7 = new WeakMap, $7 = {}, SH = 0, n5e = function (t) {
    return t && (t.host || n5e(t.parentNode))
}, U7t = function (t, e) {
    return e.map(function (r) {
        if (t.contains(r)) return r;
        var n = n5e(r);
        return n && t.contains(n) ? n : (console.error("aria-hidden", r, "in not contained inside", t, ". Doing nothing"), null)
    }).filter(function (r) {
        return !!r
    })
}, j7t = function (t, e, r, n) {
    var i = U7t(e, Array.isArray(t) ? t : [t]);
    $7[r] || ($7[r] = new WeakMap);
    var a = $7[r], o = [], s = new Set, l = new Set(i), f = function (p) {
        !p || s.has(p) || (s.add(p), f(p.parentNode))
    };
    i.forEach(f);
    var d = function (p) {
        !p || l.has(p) || Array.prototype.forEach.call(p.children, function (g) {
            if (s.has(g)) d(g); else {
                var b = g.getAttribute(n), S = b !== null && b !== "false", T = (ix.get(g) || 0) + 1,
                    I = (a.get(g) || 0) + 1;
                ix.set(g, T), a.set(g, I), o.push(g), T === 1 && S && B7.set(g, !0), I === 1 && g.setAttribute(r, "true"), S || g.setAttribute(n, "true")
            }
        })
    };
    return d(e), s.clear(), SH++, function () {
        o.forEach(function (p) {
            var g = ix.get(p) - 1, b = a.get(p) - 1;
            ix.set(p, g), a.set(p, b), g || (B7.has(p) || p.removeAttribute(n), B7.delete(p)), b || p.removeAttribute(r)
        }), SH--, SH || (ix = new WeakMap, ix = new WeakMap, B7 = new WeakMap, $7 = {})
    }
}, z7t = function (t, e, r) {
    r === void 0 && (r = "data-aria-hidden");
    var n = Array.from(Array.isArray(t) ? t : [t]), i = e || F7t(t);
    return i ? (n.push.apply(n, Array.from(i.querySelectorAll("[aria-live]"))), j7t(n, i, r, "aria-hidden")) : function () {
        return null
    }
};

function V7t(t) {
    const {
            isOpen: e,
            onClose: r,
            id: n,
            closeOnOverlayClick: i = !0,
            closeOnEsc: a = !0,
            useInert: o = !0,
            onOverlayClick: s,
            onEsc: l
        } = t, f = W.useRef(null),
        d = W.useRef(null), [p, g, b] = W7t(n, "chakra-modal", "chakra-modal--header", "chakra-modal--body");
    H7t(f, e && o);
    const S = r5e(f, e), T = W.useRef(null), I = W.useCallback(J => {
        T.current = J.target
    }, []), N = W.useCallback(J => {
        J.key === "Escape" && (J.stopPropagation(), a && (r == null || r()), l == null || l())
    }, [a, r, l]), [P, F] = W.useState(!1), [V, Y] = W.useState(!1), ee = W.useCallback((J = {}, ce = null) => ({
        role: "dialog", ...J,
        ref: Kf(ce, f),
        id: p,
        tabIndex: -1,
        "aria-modal": !0,
        "aria-labelledby": P ? g : void 0,
        "aria-describedby": V ? b : void 0,
        onClick: iu(J.onClick, re => re.stopPropagation())
    }), [b, V, p, g, P]), oe = W.useCallback(J => {
        J.stopPropagation(), T.current === J.target && FK.isTopModal(f.current) && (i && (r == null || r()), s == null || s())
    }, [r, i, s]), G = W.useCallback((J = {}, ce = null) => ({
        ...J,
        ref: Kf(ce, d),
        onClick: iu(J.onClick, oe),
        onKeyDown: iu(J.onKeyDown, N),
        onMouseDown: iu(J.onMouseDown, I)
    }), [N, I, oe]);
    return {
        isOpen: e,
        onClose: r,
        headerId: g,
        bodyId: b,
        setBodyMounted: Y,
        setHeaderMounted: F,
        dialogRef: f,
        overlayRef: d,
        getDialogProps: ee,
        getDialogContainerProps: G,
        index: S
    }
}

function H7t(t, e) {
    const r = t.current;
    W.useEffect(() => {
        if (!(!t.current || !e)) return z7t(t.current)
    }, [e, t, r])
}

function W7t(t, ...e) {
    const r = W.useId(), n = t || r;
    return W.useMemo(() => e.map(i => `${i}-${n}`), [n, e])
}

var [q7t, a3] = rd({
    name: "ModalStylesContext",
    errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
}), [G7t, mS] = rd({
    strict: !0,
    name: "ModalContext",
    errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
}), dI = t => {
    const e = {
        scrollBehavior: "outside",
        autoFocus: !0,
        trapFocus: !0,
        returnFocusOnClose: !0,
        blockScrollOnMount: !0,
        allowPinchZoom: !1,
        motionPreset: "scale",
        lockFocusAcrossFrames: !0, ...t
    }, {
        portalProps: r,
        children: n,
        autoFocus: i,
        trapFocus: a,
        initialFocusRef: o,
        finalFocusRef: s,
        returnFocusOnClose: l,
        blockScrollOnMount: f,
        allowPinchZoom: d,
        preserveScrollBarGap: p,
        motionPreset: g,
        lockFocusAcrossFrames: b,
        onCloseComplete: S
    } = e, T = tI("Modal", e), N = {
        ...V7t(e),
        autoFocus: i,
        trapFocus: a,
        initialFocusRef: o,
        finalFocusRef: s,
        returnFocusOnClose: l,
        blockScrollOnMount: f,
        allowPinchZoom: d,
        preserveScrollBarGap: p,
        motionPreset: g,
        lockFocusAcrossFrames: b
    };
    return ie.jsx(G7t, {
        value: N,
        children: ie.jsx(q7t, {
            value: T,
            children: ie.jsx(i3, {onExitComplete: S, children: N.isOpen && ie.jsx(GS, {...r, children: n})})
        })
    })
};
dI.displayName = "Modal";
var rM = "right-scroll-bar-position", nM = "width-before-scroll-bar", K7t = "with-scroll-bars-hidden",
    Y7t = "--removed-body-scroll-bar-size", i5e = J3e(), _H = function () {
    }, pL = W.forwardRef(function (t, e) {
        var r = W.useRef(null), n = W.useState({onScrollCapture: _H, onWheelCapture: _H, onTouchMoveCapture: _H}), i = n[0],
            a = n[1], o = t.forwardProps, s = t.children, l = t.className, f = t.removeScrollBar, d = t.enabled,
            p = t.shards, g = t.sideCar, b = t.noIsolation, S = t.inert, T = t.allowPinchZoom, I = t.as,
            N = I === void 0 ? "div" : I, P = t.gapMode,
            F = cI(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]),
            V = g, Y = X3e([r, e]), ee = _0(_0({}, F), i);
        return W.createElement(W.Fragment, null, d && W.createElement(V, {
            sideCar: i5e,
            removeScrollBar: f,
            shards: p,
            noIsolation: b,
            inert: S,
            setCallbacks: a,
            allowPinchZoom: !!T,
            lockRef: r,
            gapMode: P
        }), o ? W.cloneElement(W.Children.only(s), _0(_0({}, ee), {ref: Y})) : W.createElement(N, _0({}, ee, {
            className: l,
            ref: Y
        }), s))
    });
pL.defaultProps = {enabled: !0, removeScrollBar: !0, inert: !1};
pL.classNames = {fullWidth: nM, zeroRight: rM};
var X7t = function () {
    if (typeof __webpack_nonce__ < "u") return __webpack_nonce__
};

function Q7t() {
    if (!document) return null;
    var t = document.createElement("style");
    t.type = "text/css";
    var e = X7t();
    return e && t.setAttribute("nonce", e), t
}

function Z7t(t, e) {
    t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e))
}

function J7t(t) {
    var e = document.head || document.getElementsByTagName("head")[0];
    e.appendChild(t)
}

var eDt = function () {
    var t = 0, e = null;
    return {
        add: function (r) {
            t == 0 && (e = Q7t()) && (Z7t(e, r), J7t(e)), t++
        }, remove: function () {
            t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null)
        }
    }
}, tDt = function () {
    var t = eDt();
    return function (e, r) {
        W.useEffect(function () {
            return t.add(e), function () {
                t.remove()
            }
        }, [e && r])
    }
}, a5e = function () {
    var t = tDt(), e = function (r) {
        var n = r.styles, i = r.dynamic;
        return t(n, i), null
    };
    return e
}, rDt = {left: 0, top: 0, right: 0, gap: 0}, xH = function (t) {
    return parseInt(t || "", 10) || 0
}, nDt = function (t) {
    var e = window.getComputedStyle(document.body), r = e[t === "padding" ? "paddingLeft" : "marginLeft"],
        n = e[t === "padding" ? "paddingTop" : "marginTop"], i = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [xH(r), xH(n), xH(i)]
}, iDt = function (t) {
    if (t === void 0 && (t = "margin"), typeof window > "u") return rDt;
    var e = nDt(t), r = document.documentElement.clientWidth, n = window.innerWidth;
    return {left: e[0], top: e[1], right: e[2], gap: Math.max(0, n - r + e[2] - e[0])}
}, aDt = a5e(), oDt = function (t, e, r, n) {
    var i = t.left, a = t.top, o = t.right, s = t.gap;
    return r === void 0 && (r = "margin"), `
  .`.concat(K7t, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(s, "px ").concat(n, `;
  }
  body {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(n, ";"), r === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(n, `;
    `), r === "padding" && "padding-right: ".concat(s, "px ").concat(n, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(rM, ` {
    right: `).concat(s, "px ").concat(n, `;
  }
  
  .`).concat(nM, ` {
    margin-right: `).concat(s, "px ").concat(n, `;
  }
  
  .`).concat(rM, " .").concat(rM, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(nM, " .").concat(nM, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body {
    `).concat(Y7t, ": ").concat(s, `px;
  }
`)
}, sDt = function (t) {
    var e = t.noRelative, r = t.noImportant, n = t.gapMode, i = n === void 0 ? "margin" : n, a = W.useMemo(function () {
        return iDt(i)
    }, [i]);
    return W.createElement(aDt, {styles: oDt(a, !e, i, r ? "" : "!important")})
}, UK = !1;
if (typeof window < "u") try {
    var F7 = Object.defineProperty({}, "passive", {
        get: function () {
            return UK = !0, !0
        }
    });
    window.addEventListener("test", F7, F7), window.removeEventListener("test", F7, F7)
} catch {
    UK = !1
}
var ax = UK ? {passive: !1} : !1, cDt = function (t) {
    return t.tagName === "TEXTAREA"
}, o5e = function (t, e) {
    var r = window.getComputedStyle(t);
    return r[e] !== "hidden" && !(r.overflowY === r.overflowX && !cDt(t) && r[e] === "visible")
}, lDt = function (t) {
    return o5e(t, "overflowY")
}, uDt = function (t) {
    return o5e(t, "overflowX")
}, Epe = function (t, e) {
    var r = e.ownerDocument, n = e;
    do {
        typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
        var i = s5e(t, n);
        if (i) {
            var a = c5e(t, n), o = a[1], s = a[2];
            if (o > s) return !0
        }
        n = n.parentNode
    } while (n && n !== r.body);
    return !1
}, fDt = function (t) {
    var e = t.scrollTop, r = t.scrollHeight, n = t.clientHeight;
    return [e, r, n]
}, dDt = function (t) {
    var e = t.scrollLeft, r = t.scrollWidth, n = t.clientWidth;
    return [e, r, n]
}, s5e = function (t, e) {
    return t === "v" ? lDt(e) : uDt(e)
}, c5e = function (t, e) {
    return t === "v" ? fDt(e) : dDt(e)
}, hDt = function (t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
}, pDt = function (t, e, r, n, i) {
    var a = hDt(t, window.getComputedStyle(e).direction), o = a * n, s = r.target, l = e.contains(s), f = !1, d = o > 0,
        p = 0, g = 0;
    do {
        var b = c5e(t, s), S = b[0], T = b[1], I = b[2], N = T - I - a * S;
        (S || N) && s5e(t, s) && (p += N, g += S), s instanceof ShadowRoot ? s = s.host : s = s.parentNode
    } while (!l && s !== document.body || l && (e.contains(s) || e === s));
    return (d && (i && Math.abs(p) < 1 || !i && o > p) || !d && (i && Math.abs(g) < 1 || !i && -o > g)) && (f = !0), f
}, U7 = function (t) {
    return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
}, Tpe = function (t) {
    return [t.deltaX, t.deltaY]
}, Cpe = function (t) {
    return t && "current" in t ? t.current : t
}, mDt = function (t, e) {
    return t[0] === e[0] && t[1] === e[1]
}, vDt = function (t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}, gDt = 0, ox = [];

function yDt(t) {
    var e = W.useRef([]), r = W.useRef([0, 0]), n = W.useRef(), i = W.useState(gDt++)[0], a = W.useState(a5e)[0],
        o = W.useRef(t);
    W.useEffect(function () {
        o.current = t
    }, [t]), W.useEffect(function () {
        if (t.inert) {
            document.body.classList.add("block-interactivity-".concat(i));
            var T = nkt([t.lockRef.current], (t.shards || []).map(Cpe), !0).filter(Boolean);
            return T.forEach(function (I) {
                return I.classList.add("allow-interactivity-".concat(i))
            }), function () {
                document.body.classList.remove("block-interactivity-".concat(i)), T.forEach(function (I) {
                    return I.classList.remove("allow-interactivity-".concat(i))
                })
            }
        }
    }, [t.inert, t.lockRef.current, t.shards]);
    var s = W.useCallback(function (T, I) {
        if ("touches" in T && T.touches.length === 2) return !o.current.allowPinchZoom;
        var N = U7(T), P = r.current, F = "deltaX" in T ? T.deltaX : P[0] - N[0],
            V = "deltaY" in T ? T.deltaY : P[1] - N[1], Y, ee = T.target, oe = Math.abs(F) > Math.abs(V) ? "h" : "v";
        if ("touches" in T && oe === "h" && ee.type === "range") return !1;
        var G = Epe(oe, ee);
        if (!G) return !0;
        if (G ? Y = oe : (Y = oe === "v" ? "h" : "v", G = Epe(oe, ee)), !G) return !1;
        if (!n.current && "changedTouches" in T && (F || V) && (n.current = Y), !Y) return !0;
        var J = n.current || Y;
        return pDt(J, I, T, J === "h" ? F : V, !0)
    }, []), l = W.useCallback(function (T) {
        var I = T;
        if (!(!ox.length || ox[ox.length - 1] !== a)) {
            var N = "deltaY" in I ? Tpe(I) : U7(I), P = e.current.filter(function (Y) {
                return Y.name === I.type && (Y.target === I.target || I.target === Y.shadowParent) && mDt(Y.delta, N)
            })[0];
            if (P && P.should) {
                I.cancelable && I.preventDefault();
                return
            }
            if (!P) {
                var F = (o.current.shards || []).map(Cpe).filter(Boolean).filter(function (Y) {
                    return Y.contains(I.target)
                }), V = F.length > 0 ? s(I, F[0]) : !o.current.noIsolation;
                V && I.cancelable && I.preventDefault()
            }
        }
    }, []), f = W.useCallback(function (T, I, N, P) {
        var F = {name: T, delta: I, target: N, should: P, shadowParent: bDt(N)};
        e.current.push(F), setTimeout(function () {
            e.current = e.current.filter(function (V) {
                return V !== F
            })
        }, 1)
    }, []), d = W.useCallback(function (T) {
        r.current = U7(T), n.current = void 0
    }, []), p = W.useCallback(function (T) {
        f(T.type, Tpe(T), T.target, s(T, t.lockRef.current))
    }, []), g = W.useCallback(function (T) {
        f(T.type, U7(T), T.target, s(T, t.lockRef.current))
    }, []);
    W.useEffect(function () {
        return ox.push(a), t.setCallbacks({
            onScrollCapture: p,
            onWheelCapture: p,
            onTouchMoveCapture: g
        }), document.addEventListener("wheel", l, ax), document.addEventListener("touchmove", l, ax), document.addEventListener("touchstart", d, ax), function () {
            ox = ox.filter(function (T) {
                return T !== a
            }), document.removeEventListener("wheel", l, ax), document.removeEventListener("touchmove", l, ax), document.removeEventListener("touchstart", d, ax)
        }
    }, []);
    var b = t.removeScrollBar, S = t.inert;
    return W.createElement(W.Fragment, null, S ? W.createElement(a, {styles: vDt(i)}) : null, b ? W.createElement(sDt, {gapMode: t.gapMode}) : null)
}

function bDt(t) {
    for (var e = null; t !== null;) t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
    return e
}

const wDt = ikt(i5e, yDt);
var l5e = W.forwardRef(function (t, e) {
    return W.createElement(pL, _0({}, t, {ref: e, sideCar: wDt}))
});
l5e.classNames = pL.classNames;
const SDt = l5e;

function _Dt(t) {
    const {
        autoFocus: e,
        trapFocus: r,
        dialogRef: n,
        initialFocusRef: i,
        blockScrollOnMount: a,
        allowPinchZoom: o,
        finalFocusRef: s,
        returnFocusOnClose: l,
        preserveScrollBarGap: f,
        lockFocusAcrossFrames: d,
        isOpen: p
    } = mS(), [g, b] = w3e();
    W.useEffect(() => {
        !g && b && setTimeout(b)
    }, [g, b]);
    const S = r5e(n, p);
    return ie.jsx(k6e, {
        autoFocus: e,
        isDisabled: !r,
        initialFocusRef: i,
        finalFocusRef: s,
        restoreFocus: l,
        contentRef: n,
        lockFocusAcrossFrames: d,
        children: ie.jsx(SDt, {
            removeScrollBar: !f,
            allowPinchZoom: o,
            enabled: S === 1 && a,
            forwardProps: !0,
            children: t.children
        })
    })
}

var hI = Jn((t, e) => {
    const {className: r, children: n, containerProps: i, motionProps: a, ...o} = t, {
            getDialogProps: s,
            getDialogContainerProps: l
        } = mS(), f = s(o, e), d = l(i), p = mi("chakra-modal__content", r), g = a3(),
        b = {display: "flex", flexDirection: "column", position: "relative", width: "100%", outline: 0, ...g.dialog},
        S = {
            display: "flex",
            width: "100vw",
            height: "$100vh",
            position: "fixed",
            left: 0,
            top: 0, ...g.dialogContainer
        }, {motionPreset: T} = mS();
    return ie.jsx(_Dt, {
        children: ie.jsx(on.div, {
            ...d,
            className: "chakra-modal__content-container",
            tabIndex: -1,
            __css: S,
            children: ie.jsx(t5e, {preset: T, motionProps: a, className: p, ...f, __css: b, children: n})
        })
    })
});
hI.displayName = "ModalContent";
var u5e = Jn((t, e) => {
    const {className: r, ...n} = t, i = mi("chakra-modal__footer", r),
        o = {display: "flex", alignItems: "center", justifyContent: "flex-end", ...a3().footer};
    return ie.jsx(on.footer, {ref: e, ...n, __css: o, className: i})
});
u5e.displayName = "ModalFooter";
var f5e = Jn((t, e) => {
    const {className: r, ...n} = t, {headerId: i, setHeaderMounted: a} = mS();
    W.useEffect(() => (a(!0), () => a(!1)), [a]);
    const o = mi("chakra-modal__header", r), l = {flex: 0, ...a3().header};
    return ie.jsx(on.header, {ref: e, className: o, id: i, ...n, __css: l})
});
f5e.displayName = "ModalHeader";
var xDt = on(E1.div), pI = Jn((t, e) => {
    const {className: r, transition: n, motionProps: i, ...a} = t, o = mi("chakra-modal__overlay", r),
        l = {pos: "fixed", left: "0", top: "0", w: "100vw", h: "100vh", ...a3().overlay}, {motionPreset: f} = mS(),
        p = i || (f === "none" ? {} : z3e);
    return ie.jsx(xDt, {...p, __css: l, ref: e, className: o, ...a})
});
pI.displayName = "ModalOverlay";
var mI = Jn((t, e) => {
    const {className: r, ...n} = t, {bodyId: i, setBodyMounted: a} = mS();
    W.useEffect(() => (a(!0), () => a(!1)), [a]);
    const o = mi("chakra-modal__body", r), s = a3();
    return ie.jsx(on.div, {ref: e, className: o, id: i, ...n, __css: s.body})
});
mI.displayName = "ModalBody";
var vI = Jn((t, e) => {
    const {onClick: r, className: n, ...i} = t, {onClose: a} = mS(), o = mi("chakra-modal__close-btn", n), s = a3();
    return ie.jsx(PJ, {
        ref: e, __css: s.closeButton, className: o, onClick: iu(r, l => {
            l.stopPropagation(), a()
        }), ...i
    })
});
vI.displayName = "ModalCloseButton";
var EDt = {
    exit: {
        scale: .85,
        opacity: 0,
        transition: {opacity: {duration: .15, easings: "easeInOut"}, scale: {duration: .2, easings: "easeInOut"}}
    },
    enter: {
        scale: 1,
        opacity: 1,
        transition: {opacity: {easings: "easeOut", duration: .2}, scale: {duration: .2, ease: [.175, .885, .4, 1.1]}}
    }
}, jK = t => {
    var e;
    return ((e = t.current) == null ? void 0 : e.ownerDocument) || document
}, iM = t => {
    var e, r;
    return ((r = (e = t.current) == null ? void 0 : e.ownerDocument) == null ? void 0 : r.defaultView) || window
};

function TDt(t = {}) {
    const {
        openDelay: e = 0,
        closeDelay: r = 0,
        closeOnClick: n = !0,
        closeOnMouseDown: i,
        closeOnScroll: a,
        closeOnPointerDown: o = i,
        closeOnEsc: s = !0,
        onOpen: l,
        onClose: f,
        placement: d,
        id: p,
        isOpen: g,
        defaultIsOpen: b,
        arrowSize: S = 10,
        arrowShadowColor: T,
        arrowPadding: I,
        modifiers: N,
        isDisabled: P,
        gutter: F,
        offset: V,
        direction: Y,
        ...ee
    } = t, {isOpen: oe, onOpen: G, onClose: J} = V6e({
        isOpen: g,
        defaultIsOpen: b,
        onOpen: l,
        onClose: f
    }), {referenceRef: ce, getPopperProps: re, getArrowInnerProps: M, getArrowProps: D} = z6e({
        enabled: oe,
        placement: d,
        arrowPadding: I,
        modifiers: N,
        gutter: F,
        offset: V,
        direction: Y
    }), x = W.useId(), B = `tooltip-${p ?? x}`, z = W.useRef(null), j = W.useRef(), $ = W.useCallback(() => {
        j.current && (clearTimeout(j.current), j.current = void 0)
    }, []), C = W.useRef(), R = W.useCallback(() => {
        C.current && (clearTimeout(C.current), C.current = void 0)
    }, []), k = W.useCallback(() => {
        R(), J()
    }, [J, R]), Q = CDt(z, k), fe = W.useCallback(() => {
        if (!P && !j.current) {
            oe && Q();
            const ne = iM(z);
            j.current = ne.setTimeout(G, e)
        }
    }, [Q, P, oe, G, e]), ye = W.useCallback(() => {
        $();
        const ne = iM(z);
        C.current = ne.setTimeout(k, r)
    }, [r, k, $]), ue = W.useCallback(() => {
        oe && n && ye()
    }, [n, ye, oe]), me = W.useCallback(() => {
        oe && o && ye()
    }, [o, ye, oe]), Se = W.useCallback(ne => {
        oe && ne.key === "Escape" && ye()
    }, [oe, ye]);
    wC(() => jK(z), "keydown", s ? Se : void 0), wC(() => {
        const ne = z.current;
        if (!ne) return null;
        const be = E6e(ne);
        return be.localName === "body" ? iM(z) : be
    }, "scroll", () => {
        oe && a && k()
    }, {passive: !0, capture: !0}), W.useEffect(() => {
        P && ($(), oe && J())
    }, [P, oe, J, $]), W.useEffect(() => () => {
        $(), R()
    }, [$, R]), wC(() => z.current, "pointerleave", ye);
    const Ce = W.useCallback((ne = {}, be = null) => ({
        ...ne,
        ref: Kf(z, be, ce),
        onPointerEnter: iu(ne.onPointerEnter, Oe => {
            Oe.pointerType !== "touch" && fe()
        }),
        onClick: iu(ne.onClick, ue),
        onPointerDown: iu(ne.onPointerDown, me),
        onFocus: iu(ne.onFocus, fe),
        onBlur: iu(ne.onBlur, ye),
        "aria-describedby": oe ? B : void 0
    }), [fe, ye, me, oe, B, ue, ce]), Me = W.useCallback((ne = {}, be = null) => re({
        ...ne,
        style: {...ne.style, [zc.arrowSize.var]: S ? `${S}px` : void 0, [zc.arrowShadowColor.var]: T}
    }, be), [re, S, T]), ve = W.useCallback((ne = {}, be = null) => {
        const Ee = {...ne.style, position: "relative", transformOrigin: zc.transformOrigin.varRef};
        return {ref: be, ...ee, ...ne, id: B, role: "tooltip", style: Ee}
    }, [ee, B]);
    return {
        isOpen: oe,
        show: fe,
        hide: ye,
        getTriggerProps: Ce,
        getTooltipProps: ve,
        getTooltipPositionerProps: Me,
        getArrowProps: D,
        getArrowInnerProps: M
    }
}

var EH = "chakra-ui:close-tooltip";

function CDt(t, e) {
    return W.useEffect(() => {
        const r = jK(t);
        return r.addEventListener(EH, e), () => r.removeEventListener(EH, e)
    }, [e, t]), () => {
        const r = jK(t), n = iM(t);
        r.dispatchEvent(new n.CustomEvent(EH))
    }
}

function ADt(t, e = []) {
    const r = Object.assign({}, t);
    for (const n of e) n in r && delete r[n];
    return r
}

function IDt(t, e) {
    const r = {};
    for (const n of e) n in t && (r[n] = t[n]);
    return r
}

var kDt = on(E1.div), aee = Jn((t, e) => {
    var r, n;
    const i = _1("Tooltip", t), a = Cp(t), o = n3(), {
        children: s,
        label: l,
        shouldWrapChildren: f,
        "aria-label": d,
        hasArrow: p,
        bg: g,
        portalProps: b,
        background: S,
        backgroundColor: T,
        bgColor: I,
        motionProps: N,
        ...P
    } = a, F = (n = (r = S ?? T) != null ? r : g) != null ? n : I;
    if (F) {
        i.bg = F;
        const re = C2t(o, "colors", F);
        i[zc.arrowBg.var] = re
    }
    const V = TDt({...P, direction: o.direction}), Y = typeof s == "string" || f;
    let ee;
    if (Y) ee = ie.jsx(on.span, {display: "inline-block", tabIndex: 0, ...V.getTriggerProps(), children: s}); else {
        const re = W.Children.only(s);
        ee = W.cloneElement(re, V.getTriggerProps(re.props, re.ref))
    }
    const oe = !!d, G = V.getTooltipProps({}, e), J = oe ? ADt(G, ["role", "id"]) : G, ce = IDt(G, ["role", "id"]);
    return l ? ie.jsxs(ie.Fragment, {
        children: [ee, ie.jsx(i3, {
            children: V.isOpen && ie.jsx(GS, {
                ...b,
                children: ie.jsx(on.div, {
                    ...V.getTooltipPositionerProps(),
                    __css: {zIndex: i.zIndex, pointerEvents: "none"},
                    children: ie.jsxs(kDt, {
                        variants: EDt,
                        initial: "exit",
                        animate: "enter",
                        exit: "exit", ...N, ...J,
                        __css: i,
                        children: [l, oe && ie.jsx(on.span, {
                            srOnly: !0, ...ce,
                            children: d
                        }), p && ie.jsx(on.div, {
                            "data-popper-arrow": !0,
                            className: "chakra-tooltip__arrow-wrapper",
                            children: ie.jsx(on.div, {
                                "data-popper-arrow-inner": !0,
                                className: "chakra-tooltip__arrow",
                                __css: {bg: i.bg}
                            })
                        })]
                    })
                })
            })
        })]
    }) : ie.jsx(ie.Fragment, {children: s})
});
aee.displayName = "Tooltip";
var d5e = {color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0},
    Ape = ar.createContext && ar.createContext(d5e), Vy = function () {
        return Vy = Object.assign || function (t) {
            for (var e, r = 1, n = arguments.length; r < n; r++) {
                e = arguments[r];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
        }, Vy.apply(this, arguments)
    }, RDt = function (t, e) {
        var r = {};
        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
        if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
        return r
    };

function h5e(t) {
    return t && t.map(function (e, r) {
        return ar.createElement(e.tag, Vy({key: r}, e.attr), h5e(e.child))
    })
}

function ct(t) {
    return function (e) {
        return ar.createElement(DDt, Vy({attr: Vy({}, t.attr)}, e), h5e(t.child))
    }
}

function DDt(t) {
    var e = function (r) {
        var n = t.attr, i = t.size, a = t.title, o = RDt(t, ["attr", "size", "title"]), s = i || r.size || "1em", l;
        return r.className && (l = r.className), t.className && (l = (l ? l + " " : "") + t.className), ar.createElement("svg", Vy({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, r.attr, n, o, {
            className: l,
            style: Vy(Vy({color: t.color || r.color}, r.style), t.style),
            height: s,
            width: s,
            xmlns: "http://www.w3.org/2000/svg"
        }), a && ar.createElement("title", null, a), t.children)
    };
    return Ape !== void 0 ? ar.createElement(Ape.Consumer, null, function (r) {
        return e(r)
    }) : e(d5e)
}

function rer(t) {
    return ct({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{tag: "path", attr: {stroke: "none", d: "M0 0h24v24H0z", fill: "none"}}, {
            tag: "path",
            attr: {d: "M17 3l0 18"}
        }, {tag: "path", attr: {d: "M10 18l-3 3l-3 -3"}}, {tag: "path", attr: {d: "M7 21l0 -18"}}, {
            tag: "path",
            attr: {d: "M20 6l-3 -3l-3 3"}
        }]
    })(t)
}

function p5e(t) {
    return ct({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{tag: "path", attr: {stroke: "none", d: "M0 0h24v24H0z", fill: "none"}}, {
            tag: "path",
            attr: {d: "M3 9l4 -4l4 4m-4 -4v14"}
        }, {tag: "path", attr: {d: "M21 15l-4 4l-4 -4m4 4v-14"}}]
    })(t)
}

function ner(t) {
    return ct({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{tag: "path", attr: {stroke: "none", d: "M0 0h24v24H0z", fill: "none"}}, {
            tag: "path",
            attr: {
                d: "M15.22 9.375a1 1 0 0 1 1.393 -.165l.094 .083l4 4a1 1 0 0 1 .284 .576l.009 .131v5a1 1 0 0 1 -.883 .993l-.117 .007h-16.022l-.11 -.009l-.11 -.02l-.107 -.034l-.105 -.046l-.1 -.059l-.094 -.07l-.06 -.055l-.072 -.082l-.064 -.089l-.054 -.096l-.016 -.035l-.04 -.103l-.027 -.106l-.015 -.108l-.004 -.11l.009 -.11l.019 -.105c.01 -.04 .022 -.077 .035 -.112l.046 -.105l.059 -.1l4 -6a1 1 0 0 1 1.165 -.39l.114 .05l3.277 1.638l3.495 -4.369z",
                strokeWidth: "0",
                fill: "currentColor"
            }
        }, {
            tag: "path",
            attr: {
                d: "M15.232 3.36a1 1 0 0 1 1.382 -.15l.093 .083l4 4a1 1 0 0 1 -1.32 1.497l-.094 -.083l-3.226 -3.225l-4.299 5.158a1 1 0 0 1 -1.1 .303l-.115 -.049l-3.254 -1.626l-2.499 3.332a1 1 0 0 1 -1.295 .269l-.105 -.069a1 1 0 0 1 -.269 -1.295l.069 -.105l3 -4a1 1 0 0 1 1.137 -.341l.11 .047l3.291 1.645l4.494 -5.391z",
                strokeWidth: "0",
                fill: "currentColor"
            }
        }]
    })(t)
}

function MDt(t) {
    return ct({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{tag: "path", attr: {stroke: "none", d: "M0 0h24v24H0z", fill: "none"}}, {
            tag: "path",
            attr: {
                d: "M12 1.999l.041 .002l.208 .003a8 8 0 0 1 7.747 7.747l.003 .248l.177 .006a3 3 0 0 1 2.819 2.819l.005 .176a3 3 0 0 1 -3 3l-.001 1.696l1.833 2.75a1 1 0 0 1 -.72 1.548l-.112 .006h-10c-3.445 .002 -6.327 -2.49 -6.901 -5.824l-.028 -.178l-.071 .001a3 3 0 0 1 -2.995 -2.824l-.005 -.175a3 3 0 0 1 3 -3l.004 -.25a8 8 0 0 1 7.996 -7.75zm0 10.001a2 2 0 0 0 -2 2a1 1 0 0 0 1 1h2a1 1 0 0 0 1 -1a2 2 0 0 0 -2 -2zm-1.99 -4l-.127 .007a1 1 0 0 0 .117 1.993l.127 -.007a1 1 0 0 0 -.117 -1.993zm4 0l-.127 .007a1 1 0 0 0 .117 1.993l.127 -.007a1 1 0 0 0 -.117 -1.993z",
                strokeWidth: "0",
                fill: "currentColor"
            }
        }]
    })(t)
}

function ier(t) {
    return ct({
        tag: "svg",
        attr: {
            viewBox: "0 0 24 24",
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{tag: "path", attr: {stroke: "none", d: "M0 0h24v24H0z", fill: "none"}}, {
            tag: "path",
            attr: {d: "M8 8h-2a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h2v-4h-1"}
        }, {tag: "path", attr: {d: "M12 8v8"}}, {tag: "path", attr: {d: "M16 12h3"}}, {
            tag: "path",
            attr: {d: "M20 8h-4v8"}
        }]
    })(t)
}

const ODt = t => {
        switch (t) {
            case"installed":
                return "Installed";
            case"notdetected":
                return "Not detected";
            case"unsupported":
                return "Unsupported";
            case"loadable":
                return "Loadable"
        }
    }, PDt = () => {
        const {isModalOpened: t, closeModal: e, wallets: r, selectWallet: n} = m5e(({
                                                                                        isModalOpened: o,
                                                                                        closeModal: s,
                                                                                        wallets: l,
                                                                                        selectWallet: f
                                                                                    }) => ({
            isModalOpened: o,
            closeModal: s,
            wallets: l,
            selectWallet: f
        })), i = hS("gray.500", "blue.400"), a = hS("gray.500", "white");
        return ie.jsxs(dI, {
            isOpen: t, onClose: e, isCentered: !0, children: [ie.jsx(pI, {}), ie.jsxs(hI, {
                children: [ie.jsx(vI, {}), ie.jsxs(mI, {
                    py: 5,
                    px: 0,
                    textAlign: "center",
                    children: [ie.jsx(i1, {children: "Connect Wallet"}), ie.jsx(Dy, {
                        mt: "6",
                        px: "5",
                        spacing: "4",
                        alignItems: "stretch",
                        children: r.length > 0 ? ie.jsx(Dy, {
                            spacing: "2",
                            paddingX: "4",
                            alignItems: "stretch",
                            children: r.map(o => {
                                const s = o.state === "notdetected" || o.state === "unsupported";
                                return ie.jsxs(dL, {
                                    as: Hc,
                                    onClick: () => n(o.id),
                                    variant: "ghost",
                                    isDisabled: s,
                                    disabled: s,
                                    size: "lg",
                                    children: [ie.jsx(bC, {
                                        src: o.icon,
                                        alt: o.name,
                                        w: "8",
                                        h: "8"
                                    }), ie.jsx(ln, {
                                        as: "span",
                                        flex: "1",
                                        textAlign: "left",
                                        children: o.name
                                    }), s && ie.jsx(ln, {
                                        as: "span",
                                        color: i,
                                        fontWeight: "normal",
                                        fontSize: "xs",
                                        children: ODt(o.state)
                                    })]
                                }, o.id)
                            })
                        }) : ie.jsxs(Dy, {
                            maxW: "90vw",
                            p: "8",
                            children: [ie.jsx(Wi, {as: MDt, color: a, boxSize: "50px"}), ie.jsxs(Dy, {
                                spacing: 2,
                                mt: 3,
                                children: [ie.jsx(i1, {
                                    size: "lg",
                                    children: "No supported wallets detected!"
                                }), ie.jsxs(ln, {
                                    children: ["Checkout", " ", ie.jsx(Bf, {
                                        href: "https://phantom.app/",
                                        textDecor: "underline",
                                        rel: "noopener noreferrer",
                                        children: "Phantom"
                                    }), " ", "or", " ", ie.jsx(Bf, {
                                        href: "https://solflare.com/",
                                        textDecor: "underline",
                                        rel: "noopener noreferrer",
                                        children: "Solflare"
                                    }), "!"]
                                })]
                            })]
                        })
                    })]
                })]
            })]
        })
    }, [m5e, NDt] = LN("WalletAdapterContext"), Ipe = ["installed", "loadable", "notdetected", "unsupported"],
    v5e = W.memo(({
                      children: t,
                      disconnect: e,
                      state: r,
                      wallets: n,
                      wallet: i,
                      onWalletSelect: a,
                      signTransaction: o,
                      getBalance: s,
                      getTokenBalance: l,
                      signMessage: f
                  }) => {
        const {value: d, enable: p, disable: g} = V_e(!1),
            b = W.useMemo(() => [...n].sort((ee, oe) => Ipe.indexOf(ee.state) - Ipe.indexOf(oe.state)), [n]),
            S = W.useCallback(ee => {
                a(ee), g()
            }, [a, g]), T = W.useCallback(() => p(), [p]), I = W.useMemo(() => new Mv, []),
            N = W.useMemo(() => new Map, []),
            P = ZE(() => ZW(QW(0, 6e4), I.pipe(j0(ee => ee === void 0))).pipe(vWe(1e3), uo(() => Ju(s()))), [I, s]),
            F = W.useCallback(() => (I.next(void 0), s()), [I, s]), V = W.useCallback(ee => {
                const oe = N.get(`${ee.chainId}/${ee.tokenAddress}`);
                if (!oe) {
                    const G = ZW(QW(0, 6e4), I.pipe(j0(J => (J == null ? void 0 : J.chainId) === ee.chainId && (J == null ? void 0 : J.tokenAddress) === ee.tokenAddress))).pipe(uo(() => Ju(l(ee))), Xa, SWe(() => N.delete(`${ee.chainId}/${ee.tokenAddress}`)));
                    return N.set(`${ee.chainId}/${ee.tokenAddress}`, G), G
                }
                return I.next(ee), oe
            }, [I, l, N]), Y = {
                isModalOpened: d,
                openModal: p,
                closeModal: g,
                state: r,
                wallets: b,
                selectWallet: S,
                connect: T,
                disconnect: e,
                wallet: i,
                signTransaction: o,
                signMessage: f,
                balance: P,
                getBalance: F,
                getTokenBalance: V
            };
        return ie.jsxs(NDt, {value: Y, children: [t, ie.jsx(PDt, {})]})
    }), kpe = t => {
        var e;
        return {
            type: "solana",
            id: t.adapter.name,
            name: t.adapter.name,
            state: m0t(t.readyState),
            icon: t.adapter.icon,
            adapter: t.adapter,
            publicKey: ((e = t.adapter.publicKey) == null ? void 0 : e.toBase58()) ?? void 0
        }
    }, LDt = t => K4.deserialize(kr.from(t, "base64")), BDt = t => kr.from(t.serialize()).toString("base64"),
    $Dt = W.memo(({children: t}) => {
        var ee, oe;
        const {connection: e} = c4e(), {
                wallets: r,
                select: n,
                connected: i,
                connecting: a,
                disconnecting: o,
                disconnect: s,
                wallet: l,
                signTransaction: f,
                signMessage: d
            } = p1t(), p = ss(e), g = p0t({connected: i, connecting: a, disconnecting: o}),
            b = W.useMemo(() => r.map(kpe), [r]),
            S = W.useMemo(() => l ? kpe(l) : void 0, [l, (oe = (ee = l == null ? void 0 : l.adapter) == null ? void 0 : ee.publicKey) == null ? void 0 : oe.toBase58()]),
            T = ss(b), I = W.useCallback(() => void s(), [s]), N = W.useCallback(G => {
                const J = T.current.find(ce => ce.id === G);
                J && n(J.adapter.name)
            }, [T, n]), P = W.useCallback(async G => {
                if (!f) return;
                const J = LDt(G);
                if (J) try {
                    const ce = await f(J);
                    return BDt(ce)
                } catch (ce) {
                    const re = $f(ce);
                    throw ce instanceof Ay ? new pZ({message: re.message, baseError: re}) : re
                }
            }, [f]), F = W.useCallback(async G => {
                if (d) try {
                    const J = await d(kr.from(G));
                    return qZ.encode(J)
                } catch (J) {
                    const ce = $f(J);
                    throw J instanceof gZ ? new mZ({message: ce.message, baseError: ce}) : ce
                }
            }, [d]), V = W.useCallback(async () => {
                if (!(S != null && S.publicKey)) return;
                const G = await p.current.getBalance(new Sr(S == null ? void 0 : S.publicKey));
                return qW(G, 9).toString()
            }, [p, S == null ? void 0 : S.publicKey]), Y = W.useCallback(async G => {
                if (!(S != null && S.publicKey)) return;
                const J = f1t(new Sr(G.tokenAddress), new Sr(S == null ? void 0 : S.publicKey), !0);
                try {
                    const ce = await l1t(p.current, new Sr(J));
                    return qW(ce.amount.toString(), 9).toString()
                } catch (ce) {
                    return ce instanceof a4e ? "0" : void 0
                }
            }, [p, S == null ? void 0 : S.publicKey]);
        return ie.jsx(v5e, {
            disconnect: I,
            state: g,
            wallet: S,
            wallets: b,
            onWalletSelect: N,
            signTransaction: P,
            signMessage: F,
            getBalance: V,
            getTokenBalance: Y,
            children: t
        })
    }), aer = W.memo(({children: t, config: e}) => {
        const {network: r} = e, n = W.useMemo(() => e.rpcUrl ?? e1t(r), [e.rpcUrl, r]),
            i = W.useMemo(() => e.adapters.map(a => a({network: h0t(r), rpcUrl: n})), [e.adapters, r, n]);
        return ie.jsx(d1t, {
            endpoint: n,
            children: ie.jsx(Obt, {wallets: i, autoConnect: !0, children: ie.jsx($Dt, {children: t})})
        })
    }), FDt = W.memo(({children: t}) => ie.jsx(v5e, {
        disconnect: ZC,
        state: "disconnected",
        wallet: void 0,
        wallets: Wd,
        onWalletSelect: ZC,
        signTransaction: X9,
        signMessage: X9,
        getBalance: X9,
        getTokenBalance: X9,
        children: t
    }));

function oer(t) {
    return ct({
        tag: "svg", attr: {viewBox: "0 0 640 512"}, child: [{
            tag: "path",
            attr: {d: "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"}
        }]
    })(t)
}

function ser(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"}
        }]
    })(t)
}

function cer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M438.6 150.6c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.7 96 32 96C14.3 96 0 110.3 0 128s14.3 32 32 32l306.7 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l96-96zm-333.3 352c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 416 416 416c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96z"}
        }]
    })(t)
}

function UDt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M502.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224 192 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l210.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128zM160 96c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 32C43 32 0 75 0 128L0 384c0 53 43 96 96 96l64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l64 0z"}
        }]
    })(t)
}

function ler(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 576 512"},
        child: [{
            tag: "path",
            attr: {d: "M384 160c-17.7 0-32-14.3-32-32s14.3-32 32-32H544c17.7 0 32 14.3 32 32V288c0 17.7-14.3 32-32 32s-32-14.3-32-32V205.3L342.6 374.6c-12.5 12.5-32.8 12.5-45.3 0L192 269.3 54.6 406.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160c12.5-12.5 32.8-12.5 45.3 0L320 306.7 466.7 160H384z"}
        }]
    })(t)
}

function uer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 384 512"},
        child: [{
            tag: "path",
            attr: {d: "M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2V448c0 17.7 14.3 32 32 32s32-14.3 32-32V141.2L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z"}
        }]
    })(t)
}

function fer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M105.1 202.6c7.7-21.8 20.2-42.3 37.8-59.8c62.5-62.5 163.8-62.5 226.3 0L386.3 160H336c-17.7 0-32 14.3-32 32s14.3 32 32 32H463.5c0 0 0 0 0 0h.4c17.7 0 32-14.3 32-32V64c0-17.7-14.3-32-32-32s-32 14.3-32 32v51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0C73.2 122 55.6 150.7 44.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5zM39 289.3c-5 1.5-9.8 4.2-13.7 8.2c-4 4-6.7 8.8-8.1 14c-.3 1.2-.6 2.5-.8 3.8c-.3 1.7-.4 3.4-.4 5.1V448c0 17.7 14.3 32 32 32s32-14.3 32-32V396.9l17.6 17.5 0 0c87.5 87.4 229.3 87.4 316.7 0c24.4-24.4 42.1-53.1 52.9-83.7c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.5 62.5-163.8 62.5-226.3 0l-.1-.1L125.6 352H176c17.7 0 32-14.3 32-32s-14.3-32-32-32H48.4c-1.6 0-3.2 .1-4.8 .3s-3.1 .5-4.6 1z"}
        }]
    })(t)
}

function der(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"}
        }]
    })(t)
}

function her(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M160 80c0-26.5 21.5-48 48-48h32c26.5 0 48 21.5 48 48V432c0 26.5-21.5 48-48 48H208c-26.5 0-48-21.5-48-48V80zM0 272c0-26.5 21.5-48 48-48H80c26.5 0 48 21.5 48 48V432c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V272zM368 96h32c26.5 0 48 21.5 48 48V432c0 26.5-21.5 48-48 48H368c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48z"}
        }]
    })(t)
}

function per(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"}
        }]
    })(t)
}

function mer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"}
        }]
    })(t)
}

function ver(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"}
        }]
    })(t)
}

function ger(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"}
        }]
    })(t)
}

function yer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"}
        }]
    })(t)
}

function jDt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M208 0H332.1c12.7 0 24.9 5.1 33.9 14.1l67.9 67.9c9 9 14.1 21.2 14.1 33.9V336c0 26.5-21.5 48-48 48H208c-26.5 0-48-21.5-48-48V48c0-26.5 21.5-48 48-48zM48 128h80v64H64V448H256V416h64v48c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V176c0-26.5 21.5-48 48-48z"}
        }]
    })(t)
}

function ber(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M159.3 5.4c7.8-7.3 19.9-7.2 27.7 .1c27.6 25.9 53.5 53.8 77.7 84c11-14.4 23.5-30.1 37-42.9c7.9-7.4 20.1-7.4 28 .1c34.6 33 63.9 76.6 84.5 118c20.3 40.8 33.8 82.5 33.8 111.9C448 404.2 348.2 512 224 512C98.4 512 0 404.1 0 276.5c0-38.4 17.8-85.3 45.4-131.7C73.3 97.7 112.7 48.6 159.3 5.4zM225.7 416c25.3 0 47.7-7 68.8-21c42.1-29.4 53.4-88.2 28.1-134.4c-4.5-9-16-9.6-22.5-2l-25.2 29.3c-6.6 7.6-18.5 7.4-24.7-.5c-16.5-21-46-58.5-62.8-79.8c-6.3-8-18.3-8.1-24.7-.1c-33.8 42.5-50.8 69.3-50.8 99.4C112 375.4 162.6 416 225.7 416z"}
        }]
    })(t)
}

function wer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M32 0C49.7 0 64 14.3 64 32V48l69-17.2c38.1-9.5 78.3-5.1 113.5 12.5c46.3 23.2 100.8 23.2 147.1 0l9.6-4.8C423.8 28.1 448 43.1 448 66.1V345.8c0 13.3-8.3 25.3-20.8 30l-34.7 13c-46.2 17.3-97.6 14.6-141.7-7.4c-37.9-19-81.3-23.7-122.5-13.4L64 384v96c0 17.7-14.3 32-32 32s-32-14.3-32-32V400 334 64 32C0 14.3 14.3 0 32 0zM64 187.1l64-13.9v65.5L64 252.6V318l48.8-12.2c5.1-1.3 10.1-2.4 15.2-3.3V238.7l38.9-8.4c8.3-1.8 16.7-2.5 25.1-2.1l0-64c13.6 .4 27.2 2.6 40.4 6.4l23.6 6.9v66.7l-41.7-12.3c-7.3-2.1-14.8-3.4-22.3-3.8v71.4c21.8 1.9 43.3 6.7 64 14.4V244.2l22.7 6.7c13.5 4 27.3 6.4 41.3 7.4V194c-7.8-.8-15.6-2.3-23.2-4.5l-40.8-12v-62c-13-3.8-25.8-8.8-38.2-15c-8.2-4.1-16.9-7-25.8-8.8v72.4c-13-.4-26 .8-38.7 3.6L128 173.2V98L64 114v73.1zM320 335.7c16.8 1.5 33.9-.7 50-6.8l14-5.2V251.9l-7.9 1.8c-18.4 4.3-37.3 5.7-56.1 4.5v77.4zm64-149.4V115.4c-20.9 6.1-42.4 9.1-64 9.1V194c13.9 1.4 28 .5 41.7-2.6l22.3-5.2z"}
        }]
    })(t)
}

function Ser(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M352 256c0 22.2-1.2 43.6-3.3 64H163.3c-2.2-20.4-3.3-41.8-3.3-64s1.2-43.6 3.3-64H348.7c2.2 20.4 3.3 41.8 3.3 64zm28.8-64H503.9c5.3 20.5 8.1 41.9 8.1 64s-2.8 43.5-8.1 64H380.8c2.1-20.6 3.2-42 3.2-64s-1.1-43.4-3.2-64zm112.6-32H376.7c-10-63.9-29.8-117.4-55.3-151.6c78.3 20.7 142 77.5 171.9 151.6zm-149.1 0H167.7c6.1-36.4 15.5-68.6 27-94.7c10.5-23.6 22.2-40.7 33.5-51.5C239.4 3.2 248.7 0 256 0s16.6 3.2 27.8 13.8c11.3 10.8 23 27.9 33.5 51.5c11.6 26 20.9 58.2 27 94.7zm-209 0H18.6C48.6 85.9 112.2 29.1 190.6 8.4C165.1 42.6 145.3 96.1 135.3 160zM8.1 192H131.2c-2.1 20.6-3.2 42-3.2 64s1.1 43.4 3.2 64H8.1C2.8 299.5 0 278.1 0 256s2.8-43.5 8.1-64zM194.7 446.6c-11.6-26-20.9-58.2-27-94.6H344.3c-6.1 36.4-15.5 68.6-27 94.6c-10.5 23.6-22.2 40.7-33.5 51.5C272.6 508.8 263.3 512 256 512s-16.6-3.2-27.8-13.8c-11.3-10.8-23-27.9-33.5-51.5zM135.3 352c10 63.9 29.8 117.4 55.3 151.6C112.2 482.9 48.6 426.1 18.6 352H135.3zm358.1 0c-30 74.1-93.6 130.9-171.9 151.6c25.5-34.2 45.2-87.7 55.3-151.6H493.4z"}
        }]
    })(t)
}

function _er(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M362.7 19.3L314.3 67.7 444.3 197.7l48.4-48.4c25-25 25-65.5 0-90.5L453.3 19.3c-25-25-65.5-25-90.5 0zm-71 71L58.6 323.5c-10.4 10.4-18 23.3-22.2 37.4L1 481.2C-1.5 489.7 .8 498.8 7 505s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L421.7 220.3 291.7 90.3z"}
        }]
    })(t)
}

function xer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M410.3 231l11.3-11.3-33.9-33.9-62.1-62.1L291.7 89.8l-11.3 11.3-22.6 22.6L58.6 322.9c-10.4 10.4-18 23.3-22.2 37.4L1 480.7c-2.5 8.4-.2 17.5 6.1 23.7s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L387.7 253.7 410.3 231zM160 399.4l-9.1 22.7c-4 3.1-8.5 5.4-13.3 6.9L59.4 452l23-78.1c1.4-4.9 3.8-9.4 6.9-13.3l22.7-9.1v32c0 8.8 7.2 16 16 16h32zM362.7 18.7L348.3 33.2 325.7 55.8 314.3 67.1l33.9 33.9 62.1 62.1 33.9 33.9 11.3-11.3 22.6-22.6 14.5-14.5c25-25 25-65.5 0-90.5L453.3 18.7c-25-25-65.5-25-90.5 0zm-47.4 168l-144 144c-6.2 6.2-16.4 6.2-22.6 0s-6.2-16.4 0-22.6l144-144c6.2-6.2 16.4-6.2 22.6 0s6.2 16.4 0 22.6z"}
        }]
    })(t)
}

function Eer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M156.6 384.9L125.7 354c-8.5-8.5-11.5-20.8-7.7-32.2c3-8.9 7-20.5 11.8-33.8L24 288c-8.6 0-16.6-4.6-20.9-12.1s-4.2-16.7 .2-24.1l52.5-88.5c13-21.9 36.5-35.3 61.9-35.3l82.3 0c2.4-4 4.8-7.7 7.2-11.3C289.1-4.1 411.1-8.1 483.9 5.3c11.6 2.1 20.6 11.2 22.8 22.8c13.4 72.9 9.3 194.8-111.4 276.7c-3.5 2.4-7.3 4.8-11.3 7.2v82.3c0 25.4-13.4 49-35.3 61.9l-88.5 52.5c-7.4 4.4-16.6 4.5-24.1 .2s-12.1-12.2-12.1-20.9V380.8c-14.1 4.9-26.4 8.9-35.7 11.9c-11.2 3.6-23.4 .5-31.8-7.8zM384 168a40 40 0 1 0 0-80 40 40 0 1 0 0 80z"}
        }]
    })(t)
}

function Ter(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M512 32c0 113.6-84.6 207.5-194.2 222c-7.1-53.4-30.6-101.6-65.3-139.3C290.8 46.3 364 0 448 0h32c17.7 0 32 14.3 32 32zM0 96C0 78.3 14.3 64 32 64H64c123.7 0 224 100.3 224 224v32V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V320C100.3 320 0 219.7 0 96z"}
        }]
    })(t)
}

function Cer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"}
        }]
    })(t)
}

function Aer(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512H418.3c16.4 0 29.7-13.3 29.7-29.7C448 383.8 368.2 304 269.7 304H178.3z"}
        }]
    })(t)
}

function Ier(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V192c0-35.3-28.7-64-64-64H80c-8.8 0-16-7.2-16-16s7.2-16 16-16H448c17.7 0 32-14.3 32-32s-14.3-32-32-32H64zM416 272a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"}
        }]
    })(t)
}

function ker(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 384 512"},
        child: [{
            tag: "path",
            attr: {d: "M376.6 84.5c11.3-13.6 9.5-33.8-4.1-45.1s-33.8-9.5-45.1 4.1L192 206 56.6 43.5C45.3 29.9 25.1 28.1 11.5 39.4S-3.9 70.9 7.4 84.5L150.3 256 7.4 427.5c-11.3 13.6-9.5 33.8 4.1 45.1s33.8 9.5 45.1-4.1L192 306 327.4 468.5c11.3 13.6 31.5 15.4 45.1 4.1s15.4-31.5 4.1-45.1L233.7 256 376.6 84.5z"}
        }]
    })(t)
}

function zDt() {
    var t = W.useRef(!1), e = W.useCallback(function () {
        return t.current
    }, []);
    return W.useEffect(function () {
        return t.current = !0, function () {
            t.current = !1
        }
    }, []), e
}

var VDt = function (t) {
    t === void 0 && (t = {});
    var e = W.useState(t), r = e[0], n = e[1], i = W.useCallback(function (a) {
        n(function (o) {
            return Object.assign({}, o, a instanceof Function ? a(o) : a)
        })
    }, []);
    return [r, i]
}, HDt = function () {
    var t = zDt(), e = VDt({value: void 0, error: void 0, noUserInteraction: !0}), r = e[0], n = e[1],
        i = W.useCallback(function (a) {
            if (t()) {
                var o, s;
                try {
                    if (typeof a != "string" && typeof a != "number") {
                        var l = new Error("Cannot copy typeof " + typeof a + " to clipboard, must be a string");
                        Ve.env.NODE_ENV === "development" && console.error(l), n({
                            value: a,
                            error: l,
                            noUserInteraction: !0
                        });
                        return
                    } else if (a === "") {
                        var l = new Error("Cannot copy empty string to clipboard.");
                        Ve.env.NODE_ENV === "development" && console.error(l), n({
                            value: a,
                            error: l,
                            noUserInteraction: !0
                        });
                        return
                    }
                    s = a.toString(), o = CRt(s), n({value: s, error: void 0, noUserInteraction: o})
                } catch (f) {
                    n({value: s, error: f, noUserInteraction: o})
                }
            }
        }, []);
    return [r, i]
};
const WDt = () => {
        var o;
        const {state: t, disconnect: e, connect: r, wallet: n} = m5e(({
                                                                          state: s,
                                                                          disconnect: l,
                                                                          connect: f,
                                                                          wallet: d
                                                                      }) => ({
            state: s,
            disconnect: l,
            connect: f,
            wallet: d
        })), [, i] = HDt(), a = NJ();
        switch (t) {
            case"connected": {
                if (!n) return {state: "disconnected", connect: r};
                const s = n.publicKey && ((o = n.publicKey) == null ? void 0 : o.length) > 8 ? VZe(n.publicKey, 4, 4) : n.publicKey;
                return {
                    state: t, wallet: n, label: s, disconnect: e, copyLabelToClipboard: () => {
                        n.publicKey && (i(n.publicKey), a({description: "Address copied to clipboard", status: "success"}))
                    }
                }
            }
            case"connecting":
                return {state: t};
            case"disconnected":
                return {state: t, connect: r};
            case"disconnecting":
                return {state: t}
        }
    }, Rer = W.memo(({size: t, variant: e, colorScheme: r}) => {
        const n = WDt();
        switch (n.state) {
            case"connected":
                return ie.jsxs(q3e, {
                    isAttached: !0,
                    size: t,
                    variant: e,
                    colorScheme: r,
                    children: [ie.jsx(Hc, {
                        onClick: n.label ? n.copyLabelToClipboard : void 0,
                        children: n.label ? ie.jsxs(dL, {children: [ie.jsx(ln, {children: n.label}), ie.jsx(Wi, {as: jDt})]}) : "Disconnect"
                    }), ie.jsx(cu, {icon: ie.jsx(Wi, {as: UDt}), "aria-label": "Disconnect", onClick: n.disconnect})]
                });
            case"connecting":
                return ie.jsx(Hc, {
                    size: t,
                    leftIcon: ie.jsx(aE, {size: "sm"}),
                    isDisabled: !0,
                    variant: e,
                    colorScheme: r,
                    children: "Connecting..."
                });
            case"disconnected":
                return ie.jsx(Hc, {size: t, onClick: n.connect, variant: e, colorScheme: r, children: "Connect"});
            case"disconnecting":
                return ie.jsx(Hc, {
                    size: t,
                    leftIcon: ie.jsx(aE, {size: "sm"}),
                    isDisabled: !0,
                    variant: e,
                    colorScheme: r,
                    children: "Disconnecting..."
                })
        }
    }), mL = _.enum(["browser", "pushNative", "stdout"]), qDt = _.object({type: _.literal(mL.Values.browser)}),
    GDt = _.object({type: _.literal(mL.Values.pushNative)}), KDt = _.object({type: _.literal(mL.Values.stdout)}),
    YDt = _.union([qDt, GDt, KDt]), XDt = t => typeof t == "object" && t !== null && "toMillis" in t,
    fo = _.preprocess(t => XDt(t) ? t.toMillis() : t, _.number()), ch = _.object({
        type: _.literal("dexPair"),
        chainId: _.string(),
        pairId: _.string(),
        dexId: _.string().optional(),
        baseTokenName: _.string().optional(),
        baseTokenSymbol: _.string().optional(),
        quoteTokenSymbol: _.string().optional()
    }), QDt = _.object({
        type: _.literal("dexToken"),
        chainId: _.string(),
        tokenId: _.string(),
        dexId: _.string().optional(),
        baseTokenName: _.string().optional(),
        baseTokenSymbol: _.string().optional(),
        quoteTokenSymbol: _.string().optional()
    }),
    Ap = _.enum(["priceUsd", "priceUsdInverted", "priceUsdPercentage", "priceNative", "priceNativeInverted", "priceUsdCross", "priceUsdInvertedCross", "newScreenerPair", "watchlistPriceUsdPercentage", "moonshotProgress", "marketCap"]),
    eg = _.literal("over").or(_.literal("under")).or(_.literal("equal")),
    ZDt = _.object({type: _.literal(Ap.Values.priceUsd), subject: ch, direction: eg, priceUsd: _.string()}),
    JDt = _.object({type: _.literal(Ap.Values.priceUsdInverted), subject: ch, direction: eg, priceUsd: _.string()}),
    eMt = _.object({type: _.literal(Ap.Values.priceNative), subject: ch, direction: eg, price: _.string()}),
    tMt = _.object({type: _.literal(Ap.Values.priceNativeInverted), subject: ch, direction: eg, price: _.string()}),
    rMt = _.object({
        type: _.literal(Ap.Values.priceUsdCross),
        subject: ch,
        lastDirection: eg.optional(),
        priceUsd: _.string(),
        cooldown: _.number()
    }), nMt = _.object({
        type: _.literal(Ap.Values.priceUsdInvertedCross),
        subject: ch,
        lastDirection: eg.optional(),
        priceUsd: _.string(),
        cooldown: _.number()
    }), iMt = _.object({
        type: _.literal(Ap.Values.priceUsdPercentage),
        subject: ch,
        direction: eg,
        percentage: _.number(),
        timeframeKey: NN
    }), aMt = _.object({
        type: _.literal(Ap.Values.newScreenerPair),
        subject: _.object({type: _.literal("screenerQuery"), query: xht}),
        timeframeKey: NN,
        lastPairs: _.array(K2e)
    }), oMt = _.object({
        chainId: _.string().toLowerCase(),
        pairId: _.string().toLowerCase(),
        percentageNotifications: _.object({over: _.number().nullable(), under: _.number().nullable()}).optional()
    }), sMt = _.object({
        type: _.literal(Ap.Values.watchlistPriceUsdPercentage),
        subject: _.object({type: _.literal("watchlist"), id: _.string(), name: _.string()}),
        cooldown: _.number(),
        timeframeKey: NN,
        percentage: _.object({
            under: _.number().negative().nullable(),
            over: _.number().nullable()
        }).refine(t => t.under !== null || t.over !== null, {message: "Either percentage.under or percentage.over must be provided"}),
        pairs: _.array(oMt).optional()
    }), cMt = _.object({type: _.literal(Ap.Values.moonshotProgress), subject: QDt, direction: eg, percentage: _.number()}),
    lMt = _.object({type: _.literal(Ap.Values.marketCap), subject: ch, direction: eg, marketCap: _.number()}),
    uMt = _.union([ZDt, JDt, eMt, tMt, rMt, nMt, iMt, aMt, sMt, cMt, lMt]), Rpe = {min: 0, max: 100}, fMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        trigger: uMt,
        channels: Cn(YDt),
        enabled: _.boolean(),
        partitionId: _.preprocess(fO.undefinedToNull, _.number().nullable()),
        createdAt: fo,
        updatedAt: fo,
        triggeredAt: fo.nullable(),
        note: _.preprocess(fO.undefinedToNull, _.string().nullable())
    }), dMt = fMt, hMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        name: _.string(),
        content: _.string(),
        createdAt: fo,
        updatedAt: fo
    }), pMt = hMt, mMt = _.record(_.string(), _.string()), vMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        settings: mMt,
        createdAt: fo,
        updatedAt: fo
    }), gMt = vMt, yMt = _.record(_.string(), _.number()), bMt = _.record(_.string(), yMt), wMt = _.object({
        showHeader: _.boolean(),
        showFooter: _.boolean(),
        interval: _.string().nullable(),
        columns: _.number(),
        spacing: _.number(),
        cardHeightRatio: bMt.optional()
    }), SMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        order: _.number(),
        default: _.boolean(),
        name: _.string(),
        pairs: _.array(ch),
        settings: wMt,
        createdAt: fo,
        updatedAt: fo
    }), _Mt = SMt, xMt = _.record(_.literal("usd").or(_.literal("quote")), _.string()), EMt = _.record(_.string(), xMt),
    TMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        pair: ch,
        settings: EMt,
        createdAt: fo,
        updatedAt: fo
    }), Dpe = TMt, CMt = _.record(_.number()), AMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        pair: ch,
        tokenValues: CMt.optional(),
        createdAt: fo,
        updatedAt: fo
    }), IMt = AMt, kMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        address: _.string(),
        order: _.number(),
        name: _.string(),
        hiddenPairs: _.array(_.object({chainId: _.string(), pairIds: _.array(_.string())})).optional(),
        createdAt: fo,
        updatedAt: fo
    }), Mpe = kMt, g5e = _.object({id: _.string(), isEnabled: O0(_.boolean(), !0)}),
    RMt = _.object({id: _.string(), weight: _.number()}), DMt = _.object({
        watchlistsSize: _.union([_.literal("default"), _.literal("minimized")]).optional(),
        watchlistsActiveId: _.string().nullable().optional(),
        pairDetailsTokenHeaderImageVisibility: _.boolean().optional()
    }), y5e = _.object({key: _.string(), createdAt: _.number()}), MMt = _.object({chainId: _.string(), pairId: _.string()}),
    OMt = _.object({
        chainIds: _.array(_.string()),
        dexIds: _.array(_.string()),
        txns: As.optional(),
        buys: As.optional(),
        sells: As.optional(),
        volume: As.optional(),
        priceChange: As.optional(),
        liquidity: As.optional(),
        marketCap: As.optional(),
        pairAge: As.optional(),
        timeframe: NN.optional(),
        rankBy: _.object({key: _.union([t_e, _.string()]), order: r_e}).optional(),
        moonshot: _.boolean().optional(),
        moonshotProgress: As.optional()
    }), PMt = _.object({columnId: _.string(), order: _.union([_.literal("asc"), _.literal("desc")])}),
    NMt = _.object({chainId: _.string(), dexId: _.string(), mode: _.literal("dex").or(_.string())}), LMt = _.object({
        colorScheme: _.union([_.literal("light"), _.literal("dark"), _.literal("system")]).optional(),
        ignoredWarnings: _.array(y5e).optional(),
        screenerColumns: O0(_.array(g5e).optional(), void 0),
        screenerViewMode: _.union([_.literal("compact"), _.literal("expanded")]).optional(),
        screenerFilter: OMt.optional(),
        screenerSort: PMt.optional(),
        transactionsViewMode: _.union([_.literal("compact"), _.literal("expanded")]).optional(),
        watchlistsLastViewedWatchlistId: _.string().optional(),
        defaultHomeScreen: _.union([_.literal("screener"), _.literal("search"), _.literal("watchlists"), _.literal("alerts")]).optional(),
        defaultPairDetailsTab: _.union([_.literal("info"), _.literal("chart"), _.literal("txns"), _.literal("chart-txns")]).optional(),
        pairDetailsTokenHeaderImageVisibility: _.boolean().optional(),
        tradingWallets: _.array(RMt).optional(),
        screenerCompactVersion: _.union([_.literal("v1"), _.literal("v2")]).optional(),
        screenerCompactV2Options: _.array(_.object({
            id: _.union([_.literal("quoteToken"), _.literal("secondaryPriceChange")]),
            label: _.string(),
            isEnabled: _.boolean()
        })).optional()
    }), BMt = _.object({
        mobile: LMt.optional(),
        desktop: DMt.optional(),
        lastSearchQueries: O0(_.array(_.string()).optional(), void 0),
        lastViewedPairs: O0(_.array(MMt).optional(), void 0),
        watchlistsSize: _.literal("default").or(_.literal("minimized")).optional(),
        watchlistsActiveId: _.string().nullable().optional(),
        ignoredWarnings: _.array(y5e).optional(),
        screenerViewMode: _.literal("compact").or(_.literal("expanded")).optional(),
        screenerColumns: O0(_.array(g5e).optional(), void 0),
        transactionsViewMode: _.literal("compact").or(_.literal("expanded")).optional(),
        "mobile/colorScheme": _.union([_.literal("light"), _.literal("dark"), _.literal("system")]).optional(),
        tradingModes: _.array(NMt).optional(),
        searchEmptyStateTab: _.union([_.literal("latestTokens"), _.literal("history")]).optional()
    }), $Mt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        value: BMt,
        createdAt: fo,
        updatedAt: fo
    }), FMt = $Mt, UMt = _.object({
        visibility: _.literal("private").or(_.literal("public")),
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        default: _.boolean(),
        name: _.string(),
        pairs: _.array(ch),
        createdAt: fo,
        updatedAt: fo
    }), TH = UMt, jMt = _.object({
        type: _.literal("fcm"),
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        active: _.boolean(),
        channelType: _.literal(mL.Values.pushNative),
        token: _.string(),
        platform: _.enum(["ios", "android"]),
        createdAt: fo,
        updatedAt: fo
    }), zMt = jMt, VMt = _.literal("web3wallet").or(_.literal("google")).or(_.literal("apple")),
    Ope = ["web3wallet", "google", "apple"], HMt = _.object({
        schemaVersion: _.literal("1.0.0"),
        id: _.string(),
        userId: _.string(),
        provider: VMt,
        token: _.string(),
        createdAt: fo,
        updatedAt: fo
    }), WMt = HMt, Ppe = Ff({
        id: as(),
        content: t4([Ff({kind: pA("text"), text: as()}), Ff({kind: pA("tenor"), url: Ect(), width: Gh(), height: Gh()})]),
        timestamp: _ct(),
        userId: as(),
        reportCount: Gh().catch(() => 0),
        votes: Gh().catch(() => 0),
        upvotedUserIds: Kq(as()).catch(() => []),
        downvotedUserIds: Kq(as()).catch(() => []),
        chainId: as(),
        tokenAddress: as()
    }), qMt = HQ({name: IN()}), oee = mn("@dexscreener/users-client/alert-repository")();

class GMt extends Error {
}

const KMt = pt(oee, t => ({
        create: async e => {
            var r;
            return (r = e.existingAlerts) == null || r.forEach(n => {
                if (X1e(n.trigger, e.input.trigger)) throw new GMt("Alert already exists")
            }), t.create(e.userId, e.input)
        },
        update: async (e, r) => t.update(e, r),
        delete: async e => t.delete(e),
        reset: async e => t.update(e, {enabled: !0, createdAt: Date.now(), triggeredAt: null}),
        setTriggered: async e => t.update(e, {enabled: !1, triggeredAt: Date.now()})
    })), b5e = mn("@dexscreener/users-client/auth-provider-repository")(),
    w5e = mn("@dexscreener/users-client/auth-repository")(),
    YMt = {isAuthenticated: !1, isAnonymous: !0, username: "anon", allProvidersConnected: !1},
    gI = pt(b5e, w5e, (t, e) => {
        const r = e.currentUser, n = r.pipe(uo(s => s ? Hd(s) : e.signInAnonymously()), op(), Xa),
            i = r.pipe(uo(s => s ? t.findByUserId(s.id) : Hd(Wd)), Xa), a = i.pipe(uo(s => {
                const l = Ope.map(f => s.find(d => d.provider === f)).filter(f => f !== void 0);
                return Hd(l.length === Ope.length)
            }), Xa);
        return {
            authData: Qy([r, i, a]).pipe(uo(([s, l, f]) => {
                if (!s) return Hd(YMt);
                const d = l.find(I => I.provider === "web3wallet"), p = l.find(I => I.provider === "google"),
                    g = l.find(I => I.provider === "apple"), b = l.length === 0, S = l.length > 0;
                let T = "";
                return b ? T = "anon" : d ? T = zut(d.token) : s.email && (T = s.email), Hd({
                    isAuthenticated: S,
                    isAnonymous: b,
                    username: T,
                    allProvidersConnected: f,
                    web3walletProvider: d,
                    googleProvider: p,
                    appleProvider: g
                })
            })),
            authProviders: i,
            currentUser: r,
            ensuredCurrentUser: n,
            signWithCustomToken: e.signWithCustomToken,
            signOut: e.signOut,
            deleteUser: e.deleteUser
        }
    }), S5e = mn("@dexscreener/users-client/notification-settings-repository")(), XMt = pt(gI, S5e, sr, (t, e, r) => ({
        actions: {
            findBy: async n => {
                const i = await _l(t.currentUser);
                return i ? await e.findBy(i.id, n) : null
            }, registerDevice: async n => {
                const i = await _l(t.ensuredCurrentUser);
                r.info({event: {id: "registeringDeviceForNotifications", data: {userId: i.id, platform: n.platform}}});
                const a = await e.findBy(i.id, {token: n.token});
                if (!a || a.length === 0) {
                    await e.create(i.id, {
                        type: n.type,
                        schemaVersion: "1.0.0",
                        active: !0,
                        channelType: n.channelType,
                        token: n.token,
                        platform: n.platform
                    });
                    return
                }
                for (const o of a) {
                    if (o.active) return;
                    await e.update(o.id, {active: !0})
                }
            }
        }
    })), vL = pt(oee, gI, sr, KMt, XMt, (t, e, r, n, i) => {
        const a = new l1e(Wd), o = a.pipe(zn(p => p == null ? void 0 : p.filter(g => g.enabled === !0)), op(), Xa),
            s = o.pipe(zn(p => p.length), PE(), Xa),
            l = a.pipe(zn(p => p.filter(g => g.trigger.subject.type === "dexPair")), op(), Xa),
            f = a.pipe(zn(p => p.filter(g => g.trigger.subject.type === "dexToken")), op(), Xa), d = p => {
                if (!p) {
                    a.next(Wd);
                    return
                }
                t.findByUserIdSnapshot({
                    userId: p.id, onResult: g => a.next(bD(g, "createdAt", "desc")), onError: g => {
                        r.error({
                            event: {
                                id: "failedOnReadingAlertsStore",
                                data: {error: g, userId: p.id}
                            }
                        }), a.next(Wd), a.error(g)
                    }
                })
            };
        return e.currentUser.subscribe(d), {
            all: a,
            active: o,
            activeCount: s,
            listPairAlerts: l,
            listTokenAlerts: f,
            orderedByCreatedDate: p => Qy([l, f]).pipe(zn(([g, b]) => bD(g.concat(b), "createdAt", p))),
            orderedByTriggeredDate: p => Qy([l, f]).pipe(zn(([g, b]) => bD(g.concat(b), S => S.triggeredAt || "", p))),
            getPairAlertById: (p, g, b, S) => l.pipe(zn(T => T.filter(I => {
                if (I.id === S && I.trigger.subject.type === "dexPair" && I.trigger.subject.pairId === b && I.trigger.subject.chainId === p && I.trigger.subject.dexId === g) return I
            }))),
            getTokenAlertById: (p, g, b, S) => f.pipe(zn(T => T.filter(I => {
                if (I.id === S && I.trigger.subject.type === "dexToken" && I.trigger.subject.tokenId === b && I.trigger.subject.chainId === p && I.trigger.subject.dexId === g) return I
            }))),
            listAlertsByPair: (p, g, b) => l.pipe(zn(S => S.filter(T => {
                if (T.trigger.subject.type === "dexPair" && T.trigger.subject.pairId === b && T.trigger.subject.chainId === p && T.trigger.subject.dexId === g) return T
            }))),
            listAlertsByToken: (p, g, b) => f.pipe(zn(S => S.filter(T => {
                if (T.trigger.subject.type === "dexToken" && T.trigger.subject.tokenId === b && T.trigger.subject.chainId === p && T.trigger.subject.dexId === g) return T
            }))),
            actions: {
                createAlert: async p => {
                    const g = await _l(e.ensuredCurrentUser), b = p.channels;
                    if (!b.find(({type: S}) => S === "pushNative")) {
                        const S = await i.actions.findBy({channelType: "pushNative"});
                        S && S.length > 0 && b.push({type: "pushNative"})
                    }
                    await n.create({input: {...p, channels: b}, userId: g.id, existingAlerts: a.getValue()})
                },
                updateAlert: async (p, g) => n.update(p, g),
                deleteAlert: async p => n.delete(p),
                resetAlert: async p => n.reset(p),
                setAlertTriggered: async p => n.setTriggered(p)
            }
        }
    }), QMt = mn("@dexscreener/users-client/chart-study-template-repository")(),
    ZMt = mn("@dexscreener/users-client/global-chart-settings-repository")(),
    JMt = mn("@dexscreener/users-client/multichart-repository")(),
    eOt = mn("@dexscreener/users-client/pair-chart-settings-repository")(),
    _5e = mn("@dexscreener/users-client/ui-settings-repository")(), tOt = pt(gI, _5e, sr, (t, e, r) => {
        const n = t.currentUser.pipe(uo(l => l ? new ia(f => e.findByUserIdSnapshot({
                userId: l.id, onResult: d => {
                    f.next(d)
                }, onError: d => {
                    r.error({event: {id: "failedOnReadingUISettingsStore", data: {error: d, userId: l.id}}}), f.error(d)
                }
            })) : Hd(void 0)), Xa), i = new Mv, a = ZW(n, i).pipe(Xa),
            o = a.pipe(zn(l => l == null ? void 0 : l.value.desktop), Xa),
            s = a.pipe(zn(l => l == null ? void 0 : l.value.mobile), Xa);
        return {
            all: a, desktop: o, mobile: s, actions: {
                async createUISettings(l) {
                    const f = await _l(t.ensuredCurrentUser);
                    await e.create(f.id, l)
                }, async updateUISettings(l, f) {
                    await e.update(l, f)
                }, async persistUISettingsValue(l) {
                    const f = await _l(a);
                    if (f) {
                        const d = {...f, value: {...f.value, ...l}};
                        l.mobile && (d.value.mobile = {...f.value.mobile, ...l.mobile}), l.desktop && (d.value.desktop = {...f.value.desktop, ...l.desktop}), i.next(d), await this.updateUISettings(f.id, d)
                    } else await this.createUISettings({schemaVersion: "1.0.0", value: l})
                }, async ignoreWarning(l) {
                    var g;
                    const f = await _l(a),
                        d = ((g = f == null ? void 0 : f.value.mobile) == null ? void 0 : g.ignoredWarnings) ?? (f == null ? void 0 : f.value.ignoredWarnings) ?? [],
                        p = {key: l, createdAt: Date.now()};
                    await this.persistUISettingsValue({mobile: {ignoredWarnings: [...d, p]}})
                }, async setTradingMode({chainId: l, dexId: f, mode: d}) {
                    const p = await _l(a),
                        b = ((p == null ? void 0 : p.value.tradingModes) ?? []).filter(S => !(S.chainId === l && S.dexId === f));
                    b.push({chainId: l, dexId: f, mode: d}), await this.persistUISettingsValue({tradingModes: b})
                }
            }
        }
    }), x5e = mn("@dexscreener/users-client/watchlist-repository")(), E5e = t => {
        if (t.pairs.length >= 100) throw new Error("Too many pairs in watchlist");
        return t
    }, CH = (t, e) => {
        const r = e;
        return {visibility: r.visibility ?? "private", ...r, id: t}
    }, T5e = pt(gI, x5e, sr, (t, e, r) => {
        const n = new I4(1), i = a => a ? new ia(o => e.findByUserIdSnapshot({
            userId: a.id, onResult: s => {
                const l = bD(s, ["default", "name"], ["desc", "asc"]);
                o.next(l)
            }, onError: s => {
                r.error({
                    event: {
                        id: "failedOnReadingWatchlistsStore",
                        data: {error: s, userId: a.id}
                    }
                }), o.next(Wd), o.error(s)
            }
        })).pipe(Xa) : Hd(Wd);
        return t.currentUser.pipe(uo(i), Zy(a => n.next(a))).subscribe(), {
            all: n,
            actions: {
                findById: async (a, o) => e.findById(a, o), createWatchlist: async a => {
                    const o = await _l(t.ensuredCurrentUser);
                    return e.create(o.id, a)
                }, updatedWatchlist: async (a, o) => {
                    const s = await _l(n), l = s == null ? void 0 : s.map(f => f.id === a ? {...f, ...o} : f);
                    n.next(l), await e.update(a, o)
                }, deleteWatchlist: async a => {
                    const o = await _l(n), s = o == null ? void 0 : o.filter(l => l.id !== a);
                    n.next(s), await e.delete(a)
                }, renameWatchlist: async (a, o) => {
                    const s = await _l(n), l = s.find(d => d.id === a),
                        f = s == null ? void 0 : s.map(d => d.id !== a ? d : {...d, name: o});
                    n.next(f), await e.update(a, {...l, name: o})
                }, addPairToWatchlist: async (a, o) => {
                    const s = await _l(n),
                        l = s == null ? void 0 : s.map(f => f.id !== a ? f : (E5e(f), {...f, pairs: [...f.pairs, o]}));
                    n.next(l), await e.addPair(a, o)
                }, removePairFromWatchlist: async (a, o) => {
                    const s = await _l(n),
                        l = s == null ? void 0 : s.map(f => f.id !== a ? f : {...f, pairs: f.pairs.filter(d => d !== o)});
                    n.next(l), await e.removePair(a, o)
                }
            }
        }
    }), rOt = mn("@dexscreener/users-client/portfolio-repository")(), nOt = "alerts", iOt = "authProviders",
    aOt = "chartStudyTemplates", oOt = "globalChartsSettings", sOt = "multicharts", cOt = "notificationSettings",
    lOt = "pairChartsSettings", uOt = "pairSettings", fOt = "portfolio", dOt = "uiSettings", hOt = "watchlists",
    pOt = mn("@dexscreener/users-client/pair-settings-repository")(),
    mOt = mn("@dexscreener/users-client/chatsRepository")(),
    C5e = mn("@dexscreener/users-client/publicUserDataRepository")(),
    vOt = mn("@dexscreener/web/pair-chart-settings-service")(),
    gOt = _.object({interval: O0(O_e.optional(), void 0)}).passthrough(), yOt = _.object({state: gOt}).passthrough(),
    bOt = _.object({sources: qQ(yOt)}).passthrough(), wOt = _.object({panes: qQ(bOt)}).passthrough(),
    SOt = _.object({charts: qQ(wOt)}).passthrough(), zK = t => {
        let e = t.isInverted ? encodeURIComponent(t.pair.quoteTokenAddress) : encodeURIComponent(t.pair.baseTokenAddress);
        return t.chartType === "marketCap" && (e = `${t.chartType}:${e}`), e.replace(/\./g, "%")
    }, Npe = (t, e, r) => {
        const n = e.settings[t];
        if (!n) return;
        const i = n[r];
        return i ? SOt.parse(JSON.parse(i)) : void 0
    }, _Ot = pt(() => ({
        getChartContent: t => {
            const e = zK({pair: t.pair, isInverted: t.isInverted, chartType: t.chartType}),
                r = Npe(e, t.pairChartSettings, t.quotePricingMode);
            return r || Npe("imported", t.pairChartSettings, t.quotePricingMode)
        }
    })), A5e = mn("@dexscreener/users-client/publicUserDataServiceCacheTimeToStaleInMs")(), Der = pt(C5e, A5e, (t, e) => {
        const r = Ddt().expireAfterWrite(e).loading().build();
        return {
            setUserName: async ({userId: i, userName: a, captchaValue: o}) => {
                await t.setPublicUserName({userName: a, captchaValue: o});
                const s = await t.getPublicUserData({userId: i});
                r.set(i, s)
            },
            getUserName: async ({userId: i}) => {
                const a = await r.get(i, async o => t.getPublicUserData({userId: o}));
                return a == null ? void 0 : a.name
            },
            listenToUserName: ({userId: i}) => t.listenToPublicUserData({userId: i}).pipe(Zy(a => r.set(i, a)), zn(a => a == null ? void 0 : a.name), Xa),
            getUserNameSync: i => {
                var a;
                return (a = r.getIfPresent(i.userId)) == null ? void 0 : a.name
            }
        }
    }), xOt = Ff({name: as().minLength(1).maxLength(20), captchaValue: as()}), EOt = Ff({
        content: t4([Ff({kind: pA("text"), text: as().minLength(1).maxLength(1521)}), Ff({
            kind: pA("tenor"),
            id: as().minLength(1).maxLength(200)
        })]), chainId: as(), tokenAddress: as()
    }), TOt = Ff({messageId: as()});
Ff({ip: as(), userReports: Kq(as()).catchDecode(() => [])});
const COt = XSe(["up", "down", "reset"]), AOt = Ff({messageId: as(), value: COt});
Ff({
    time: xct(),
    totalMessages: Ff({allTime: Gh(), last7Days: Gh(), last24Hours: Gh(), last1Hour: Gh(), last5Minutes: Gh()})
});
const IOt = () => PZe(Rpe.min, Rpe.max, !1), I5e = mn("@dexscreener/util-localstorage-web//windowLike")(),
    kOt = pt(I5e, t => new ia(e => {
        const r = n => {
            e.next(n)
        };
        return t.addEventListener("storage", r), () => t.removeEventListener("storage", r)
    }).pipe(IX())), k5e = mn("@dexscreener/util-localstorage-web//storageLike")(), ROt = pt(k5e, kOt, (t, e) => r => {
        const n = l => {
            var f;
            try {
                return r.schema.parse(JSON.parse(l ?? ""))
            } catch (d) {
                return (f = r.onError) == null || f.call(r, $f(d)), r.defaultState
            }
        }, i = e.pipe(j0(l => l.key === r.key), zn(l => n(l.newValue ?? "")), zn(l => {
            var d;
            return (d = r.localKeys) != null && d.length ? XP(l, r.localKeys) : l
        }), op()), a = new SX(r.defaultState);
        return {
            state: new ia(l => {
                const f = xX.schedule(function () {
                    this.closed || l.next(n(t.getItem(r.key)))
                });
                return f.add(i.subscribe(l)), f.add(a.subscribe(l)), f
            }).pipe(xWe((l, f) => ({...l, ...f}), r.defaultState), op(), Xa), setState: l => {
                var f;
                try {
                    const d = r.schema.parse(l);
                    a.next(d), t.setItem(r.key, JSON.stringify(d))
                } catch (d) {
                    (f = r.onError) == null || f.call(r, $f(d))
                }
            }
        }
    }), DOt = t => {
        const e = async (s, l) => {
            let f;
            try {
                const p = () => l != null && l.body ? l.body instanceof FormData || l.body instanceof qr.Buffer ? l.body : JSON.stringify(l.body) : null;
                f = await ((t == null ? void 0 : t.fetch) ?? fetch)(s, {...l, body: p()})
            } catch (p) {
                throw p instanceof Error && p.name !== "AbortError" ? new JQ({url: s, message: p.message}) : p
            }
            let d = !1;
            try {
                d = "type" in f && f.type === "opaque"
            } catch {
            }
            if (!d && (f.status < 200 || f.status >= 400)) {
                const p = await f.json().catch(() => f.text()).catch(() => {
                });
                throw new Kh({url: s, status: f.status, message: p, response: p})
            }
            return f
        }, r = async (s, l, f) => {
            let d;
            try {
                d = await f.json()
            } catch (g) {
                throw g instanceof Error ? new Kh({url: s, status: f.status, message: g.toString()}) : g
            }
            const p = l.safeParse(d);
            if (p.success) return p.data;
            throw new eZ({url: s, status: f.status, error: p.error})
        }, n = async (s, l, f) => {
            let d;
            try {
                d = await f.json()
            } catch (g) {
                throw g instanceof Error ? new Kh({url: s, status: f.status, message: g.toString()}) : g
            }
            const p = l.safeDecode(d);
            if (p.ok) return p.value;
            throw new mO({url: s, status: f.status, cause: p.error})
        }, i = async (s, l) => {
            try {
                return await l.text()
            } catch (f) {
                throw f instanceof Error ? new Kh({url: s, status: l.status, message: f.toString()}) : f
            }
        }, a = async (s, l) => {
            try {
                return await l.arrayBuffer()
            } catch (f) {
                throw f instanceof Error ? new Kh({url: s, status: l.status, message: f.toString()}) : f
            }
        };
        return {
            get: async (s, l, f) => {
                const d = await e(s, f);
                return r(s, l, d)
            }, text: async (s, l) => {
                const f = await e(s, l);
                return i(s, f)
            }, arrayBuffer: async (s, l) => {
                const f = await e(s, l);
                return a(s, f)
            }, head: async (s, l) => {
                await e(s, {...l, method: "HEAD"})
            }, post: async (s, l, f) => {
                const d = await e(s, {...f, method: "POST"});
                return r(s, l, d)
            }, delete: async (s, l, f) => {
                const d = await e(s, {...f, method: "DELETE"});
                return r(s, l, d)
            }, patch: async (s, l, f) => {
                const d = await e(s, {...f, method: "PATCH"});
                return r(s, l, d)
            }, avro: async (s, l, f) => {
                const d = await e(s, f), p = await a(s, d), g = l.safeFromBuffer(qr.Buffer.from(p));
                if (g.ok) return g.value;
                throw new mO({url: s, status: d.status, message: g.error.message, cause: g.error})
            }, json: async (s, l, f) => {
                const d = await e(s, f);
                return n(s, l, d)
            }
        }
    };
var MOt = function (t, e, r, n, i, a, o, s) {
    if (Ve.env.NODE_ENV !== "production" && e === void 0) throw new Error("invariant requires an error message argument");
    if (!t) {
        var l;
        if (e === void 0) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
            var f = [r, n, i, a, o, s], d = 0;
            l = new Error(e.replace(/%s/g, function () {
                return f[d++]
            })), l.name = "Invariant Violation"
        }
        throw l.framesToPop = 1, l
    }
}, OOt = MOt;
const Lpe = za(OOt);
var POt = function (e, r, n, i) {
    var a = n ? n.call(i, e, r) : void 0;
    if (a !== void 0) return !!a;
    if (e === r) return !0;
    if (typeof e != "object" || !e || typeof r != "object" || !r) return !1;
    var o = Object.keys(e), s = Object.keys(r);
    if (o.length !== s.length) return !1;
    for (var l = Object.prototype.hasOwnProperty.bind(r), f = 0; f < o.length; f++) {
        var d = o[f];
        if (!l(d)) return !1;
        var p = e[d], g = r[d];
        if (a = n ? n.call(i, p, g, d) : void 0, a === !1 || a === void 0 && p !== g) return !1
    }
    return !0
};
const NOt = za(POt);
var R5e = (t => (t.BASE = "base", t.BODY = "body", t.HEAD = "head", t.HTML = "html", t.LINK = "link", t.META = "meta", t.NOSCRIPT = "noscript", t.SCRIPT = "script", t.STYLE = "style", t.TITLE = "title", t.FRAGMENT = "Symbol(react.fragment)", t))(R5e || {}),
    AH = {
        link: {rel: ["amphtml", "canonical", "alternate"]},
        script: {type: ["application/ld+json"]},
        meta: {
            charset: "",
            name: ["generator", "robots", "description"],
            property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
        }
    }, Bpe = Object.values(R5e), see = {
        accesskey: "accessKey",
        charset: "charSet",
        class: "className",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        "http-equiv": "httpEquiv",
        itemprop: "itemProp",
        tabindex: "tabIndex"
    }, LOt = Object.entries(see).reduce((t, [e, r]) => (t[r] = e, t), {}), rp = "data-rh", m4 = {
        DEFAULT_TITLE: "defaultTitle",
        DEFER: "defer",
        ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
        ON_CHANGE_CLIENT_STATE: "onChangeClientState",
        TITLE_TEMPLATE: "titleTemplate",
        PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
    }, v4 = (t, e) => {
        for (let r = t.length - 1; r >= 0; r -= 1) {
            const n = t[r];
            if (Object.prototype.hasOwnProperty.call(n, e)) return n[e]
        }
        return null
    }, BOt = t => {
        let e = v4(t, "title");
        const r = v4(t, m4.TITLE_TEMPLATE);
        if (Array.isArray(e) && (e = e.join("")), r && e) return r.replace(/%s/g, () => e);
        const n = v4(t, m4.DEFAULT_TITLE);
        return e || n || void 0
    }, $Ot = t => v4(t, m4.ON_CHANGE_CLIENT_STATE) || (() => {
    }), IH = (t, e) => e.filter(r => typeof r[t] < "u").map(r => r[t]).reduce((r, n) => ({...r, ...n}), {}),
    FOt = (t, e) => e.filter(r => typeof r.base < "u").map(r => r.base).reverse().reduce((r, n) => {
        if (!r.length) {
            const i = Object.keys(n);
            for (let a = 0; a < i.length; a += 1) {
                const s = i[a].toLowerCase();
                if (t.indexOf(s) !== -1 && n[s]) return r.concat(n)
            }
        }
        return r
    }, []), UOt = t => console && typeof console.warn == "function" && console.warn(t), uT = (t, e, r) => {
        const n = {};
        return r.filter(i => Array.isArray(i[t]) ? !0 : (typeof i[t] < "u" && UOt(`Helmet: ${t} should be of type "Array". Instead found type "${typeof i[t]}"`), !1)).map(i => i[t]).reverse().reduce((i, a) => {
            const o = {};
            a.filter(l => {
                let f;
                const d = Object.keys(l);
                for (let g = 0; g < d.length; g += 1) {
                    const b = d[g], S = b.toLowerCase();
                    e.indexOf(S) !== -1 && !(f === "rel" && l[f].toLowerCase() === "canonical") && !(S === "rel" && l[S].toLowerCase() === "stylesheet") && (f = S), e.indexOf(b) !== -1 && (b === "innerHTML" || b === "cssText" || b === "itemprop") && (f = b)
                }
                if (!f || !l[f]) return !1;
                const p = l[f].toLowerCase();
                return n[f] || (n[f] = {}), o[f] || (o[f] = {}), n[f][p] ? !1 : (o[f][p] = !0, !0)
            }).reverse().forEach(l => i.push(l));
            const s = Object.keys(o);
            for (let l = 0; l < s.length; l += 1) {
                const f = s[l], d = {...n[f], ...o[f]};
                n[f] = d
            }
            return i
        }, []).reverse()
    }, jOt = (t, e) => {
        if (Array.isArray(t) && t.length) {
            for (let r = 0; r < t.length; r += 1) if (t[r][e]) return !0
        }
        return !1
    }, zOt = t => ({
        baseTag: FOt(["href"], t),
        bodyAttributes: IH("bodyAttributes", t),
        defer: v4(t, m4.DEFER),
        encode: v4(t, m4.ENCODE_SPECIAL_CHARACTERS),
        htmlAttributes: IH("htmlAttributes", t),
        linkTags: uT("link", ["rel", "href"], t),
        metaTags: uT("meta", ["name", "charset", "http-equiv", "property", "itemprop"], t),
        noscriptTags: uT("noscript", ["innerHTML"], t),
        onChangeClientState: $Ot(t),
        scriptTags: uT("script", ["src", "innerHTML"], t),
        styleTags: uT("style", ["cssText"], t),
        title: BOt(t),
        titleAttributes: IH("titleAttributes", t),
        prioritizeSeoTags: jOt(t, m4.PRIORITIZE_SEO_TAGS)
    }), D5e = t => Array.isArray(t) ? t.join("") : t, VOt = (t, e) => {
        const r = Object.keys(t);
        for (let n = 0; n < r.length; n += 1) if (e[r[n]] && e[r[n]].includes(t[r[n]])) return !0;
        return !1
    }, kH = (t, e) => Array.isArray(t) ? t.reduce((r, n) => (VOt(n, e) ? r.priority.push(n) : r.default.push(n), r), {
        priority: [],
        default: []
    }) : {default: t, priority: []}, $pe = (t, e) => ({...t, [e]: void 0}), HOt = ["noscript", "script", "style"],
    VK = (t, e = !0) => e === !1 ? String(t) : String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"),
    M5e = t => Object.keys(t).reduce((e, r) => {
        const n = typeof t[r] < "u" ? `${r}="${t[r]}"` : `${r}`;
        return e ? `${e} ${n}` : n
    }, ""), WOt = (t, e, r, n) => {
        const i = M5e(r), a = D5e(e);
        return i ? `<${t} ${rp}="true" ${i}>${VK(a, n)}</${t}>` : `<${t} ${rp}="true">${VK(a, n)}</${t}>`
    }, qOt = (t, e, r = !0) => e.reduce((n, i) => {
        const a = i, o = Object.keys(a).filter(f => !(f === "innerHTML" || f === "cssText")).reduce((f, d) => {
            const p = typeof a[d] > "u" ? d : `${d}="${VK(a[d], r)}"`;
            return f ? `${f} ${p}` : p
        }, ""), s = a.innerHTML || a.cssText || "", l = HOt.indexOf(t) === -1;
        return `${n}<${t} ${rp}="true" ${o}${l ? "/>" : `>${s}</${t}>`}`
    }, ""), O5e = (t, e = {}) => Object.keys(t).reduce((r, n) => {
        const i = see[n];
        return r[i || n] = t[n], r
    }, e), GOt = (t, e, r) => {
        const n = {key: e, [rp]: !0}, i = O5e(r, n);
        return [ar.createElement("title", i, e)]
    }, aM = (t, e) => e.map((r, n) => {
        const i = {key: n, [rp]: !0};
        return Object.keys(r).forEach(a => {
            const s = see[a] || a;
            if (s === "innerHTML" || s === "cssText") {
                const l = r.innerHTML || r.cssText;
                i.dangerouslySetInnerHTML = {__html: l}
            } else i[s] = r[a]
        }), ar.createElement(t, i)
    }), $d = (t, e, r = !0) => {
        switch (t) {
            case"title":
                return {
                    toComponent: () => GOt(t, e.title, e.titleAttributes),
                    toString: () => WOt(t, e.title, e.titleAttributes, r)
                };
            case"bodyAttributes":
            case"htmlAttributes":
                return {toComponent: () => O5e(e), toString: () => M5e(e)};
            default:
                return {toComponent: () => aM(t, e), toString: () => qOt(t, e, r)}
        }
    }, KOt = ({metaTags: t, linkTags: e, scriptTags: r, encode: n}) => {
        const i = kH(t, AH.meta), a = kH(e, AH.link), o = kH(r, AH.script);
        return {
            priorityMethods: {
                toComponent: () => [...aM("meta", i.priority), ...aM("link", a.priority), ...aM("script", o.priority)],
                toString: () => `${$d("meta", i.priority, n)} ${$d("link", a.priority, n)} ${$d("script", o.priority, n)}`
            }, metaTags: i.default, linkTags: a.default, scriptTags: o.default
        }
    }, YOt = t => {
        const {
            baseTag: e,
            bodyAttributes: r,
            encode: n = !0,
            htmlAttributes: i,
            noscriptTags: a,
            styleTags: o,
            title: s = "",
            titleAttributes: l,
            prioritizeSeoTags: f
        } = t;
        let {linkTags: d, metaTags: p, scriptTags: g} = t, b = {
            toComponent: () => {
            }, toString: () => ""
        };
        return f && ({priorityMethods: b, linkTags: d, metaTags: p, scriptTags: g} = KOt(t)), {
            priority: b,
            base: $d("base", e, n),
            bodyAttributes: $d("bodyAttributes", r, n),
            htmlAttributes: $d("htmlAttributes", i, n),
            link: $d("link", d, n),
            meta: $d("meta", p, n),
            noscript: $d("noscript", a, n),
            script: $d("script", g, n),
            style: $d("style", o, n),
            title: $d("title", {title: s, titleAttributes: l}, n)
        }
    }, HK = YOt, j7 = [], P5e = !!(typeof window < "u" && window.document && window.document.createElement), WK = class {
        constructor(t, e) {
            Ft(this, "instances", []);
            Ft(this, "canUseDOM", P5e);
            Ft(this, "context");
            Ft(this, "value", {
                setHelmet: t => {
                    this.context.helmet = t
                }, helmetInstances: {
                    get: () => this.canUseDOM ? j7 : this.instances, add: t => {
                        (this.canUseDOM ? j7 : this.instances).push(t)
                    }, remove: t => {
                        const e = (this.canUseDOM ? j7 : this.instances).indexOf(t);
                        (this.canUseDOM ? j7 : this.instances).splice(e, 1)
                    }
                }
            });
            this.context = t, this.canUseDOM = e || !1, e || (t.helmet = HK({
                baseTag: [],
                bodyAttributes: {},
                encodeSpecialCharacters: !0,
                htmlAttributes: {},
                linkTags: [],
                metaTags: [],
                noscriptTags: [],
                scriptTags: [],
                styleTags: [],
                title: "",
                titleAttributes: {}
            }))
        }
    }, XOt = {}, N5e = ar.createContext(XOt), S4, L5e = (S4 = class extends W.Component {
        constructor(r) {
            super(r);
            Ft(this, "helmetData");
            this.helmetData = new WK(this.props.context || {}, S4.canUseDOM)
        }

        render() {
            return ar.createElement(N5e.Provider, {value: this.helmetData.value}, this.props.children)
        }
    }, Ft(S4, "canUseDOM", P5e), S4), sx = (t, e) => {
        const r = document.head || document.querySelector("head"), n = r.querySelectorAll(`${t}[${rp}]`),
            i = [].slice.call(n), a = [];
        let o;
        return e && e.length && e.forEach(s => {
            const l = document.createElement(t);
            for (const f in s) if (Object.prototype.hasOwnProperty.call(s, f)) if (f === "innerHTML") l.innerHTML = s.innerHTML; else if (f === "cssText") l.styleSheet ? l.styleSheet.cssText = s.cssText : l.appendChild(document.createTextNode(s.cssText)); else {
                const d = f, p = typeof s[d] > "u" ? "" : s[d];
                l.setAttribute(f, p)
            }
            l.setAttribute(rp, "true"), i.some((f, d) => (o = d, l.isEqualNode(f))) ? i.splice(o, 1) : a.push(l)
        }), i.forEach(s => {
            var l;
            return (l = s.parentNode) == null ? void 0 : l.removeChild(s)
        }), a.forEach(s => r.appendChild(s)), {oldTags: i, newTags: a}
    }, qK = (t, e) => {
        const r = document.getElementsByTagName(t)[0];
        if (!r) return;
        const n = r.getAttribute(rp), i = n ? n.split(",") : [], a = [...i], o = Object.keys(e);
        for (const s of o) {
            const l = e[s] || "";
            r.getAttribute(s) !== l && r.setAttribute(s, l), i.indexOf(s) === -1 && i.push(s);
            const f = a.indexOf(s);
            f !== -1 && a.splice(f, 1)
        }
        for (let s = a.length - 1; s >= 0; s -= 1) r.removeAttribute(a[s]);
        i.length === a.length ? r.removeAttribute(rp) : r.getAttribute(rp) !== o.join(",") && r.setAttribute(rp, o.join(","))
    }, QOt = (t, e) => {
        typeof t < "u" && document.title !== t && (document.title = D5e(t)), qK("title", e)
    }, Fpe = (t, e) => {
        const {
            baseTag: r,
            bodyAttributes: n,
            htmlAttributes: i,
            linkTags: a,
            metaTags: o,
            noscriptTags: s,
            onChangeClientState: l,
            scriptTags: f,
            styleTags: d,
            title: p,
            titleAttributes: g
        } = t;
        qK("body", n), qK("html", i), QOt(p, g);
        const b = {
            baseTag: sx("base", r),
            linkTags: sx("link", a),
            metaTags: sx("meta", o),
            noscriptTags: sx("noscript", s),
            scriptTags: sx("script", f),
            styleTags: sx("style", d)
        }, S = {}, T = {};
        Object.keys(b).forEach(I => {
            const {newTags: N, oldTags: P} = b[I];
            N.length && (S[I] = N), P.length && (T[I] = b[I].oldTags)
        }), e && e(), l(t, S, T)
    }, fT = null, ZOt = t => {
        fT && cancelAnimationFrame(fT), t.defer ? fT = requestAnimationFrame(() => {
            Fpe(t, () => {
                fT = null
            })
        }) : (Fpe(t), fT = null)
    }, JOt = ZOt, Upe = class extends W.Component {
        constructor() {
            super(...arguments);
            Ft(this, "rendered", !1)
        }

        shouldComponentUpdate(e) {
            return !NOt(e, this.props)
        }

        componentDidUpdate() {
            this.emitChange()
        }

        componentWillUnmount() {
            const {helmetInstances: e} = this.props.context;
            e.remove(this), this.emitChange()
        }

        emitChange() {
            const {helmetInstances: e, setHelmet: r} = this.props.context;
            let n = null;
            const i = zOt(e.get().map(a => {
                const o = {...a.props};
                return delete o.context, o
            }));
            L5e.canUseDOM ? JOt(i) : HK && (n = HK(i)), r(n)
        }

        init() {
            if (this.rendered) return;
            this.rendered = !0;
            const {helmetInstances: e} = this.props.context;
            e.add(this), this.emitChange()
        }

        render() {
            return this.init(), null
        }
    }, yW, B5e = (yW = class extends W.Component {
        shouldComponentUpdate(t) {
            return !sEe($pe(this.props, "helmetData"), $pe(t, "helmetData"))
        }

        mapNestedChildrenToProps(t, e) {
            if (!e) return null;
            switch (t.type) {
                case"script":
                case"noscript":
                    return {innerHTML: e};
                case"style":
                    return {cssText: e};
                default:
                    throw new Error(`<${t.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`)
            }
        }

        flattenArrayTypeChildren(t, e, r, n) {
            return {...e, [t.type]: [...e[t.type] || [], {...r, ...this.mapNestedChildrenToProps(t, n)}]}
        }

        mapObjectTypeChildren(t, e, r, n) {
            switch (t.type) {
                case"title":
                    return {...e, [t.type]: n, titleAttributes: {...r}};
                case"body":
                    return {...e, bodyAttributes: {...r}};
                case"html":
                    return {...e, htmlAttributes: {...r}};
                default:
                    return {...e, [t.type]: {...r}}
            }
        }

        mapArrayTypeChildrenToProps(t, e) {
            let r = {...e};
            return Object.keys(t).forEach(n => {
                r = {...r, [n]: t[n]}
            }), r
        }

        warnOnInvalidChildren(t, e) {
            return Lpe(Bpe.some(r => t.type === r), typeof t.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${Bpe.join(", ")} are allowed. Helmet does not support rendering <${t.type}> elements. Refer to our API for more information.`), Lpe(!e || typeof e == "string" || Array.isArray(e) && !e.some(r => typeof r != "string"), `Helmet expects a string as a child of <${t.type}>. Did you forget to wrap your children in braces? ( <${t.type}>{\`\`}</${t.type}> ) Refer to our API for more information.`), !0
        }

        mapChildrenToProps(t, e) {
            let r = {};
            return ar.Children.forEach(t, n => {
                if (!n || !n.props) return;
                const {children: i, ...a} = n.props, o = Object.keys(a).reduce((l, f) => (l[LOt[f] || f] = a[f], l), {});
                let {type: s} = n;
                switch (typeof s == "symbol" ? s = s.toString() : this.warnOnInvalidChildren(n, i), s) {
                    case"Symbol(react.fragment)":
                        e = this.mapChildrenToProps(i, e);
                        break;
                    case"link":
                    case"meta":
                    case"noscript":
                    case"script":
                    case"style":
                        r = this.flattenArrayTypeChildren(n, r, o, i);
                        break;
                    default:
                        e = this.mapObjectTypeChildren(n, e, o, i);
                        break
                }
            }), this.mapArrayTypeChildrenToProps(r, e)
        }

        render() {
            const {children: t, ...e} = this.props;
            let r = {...e}, {helmetData: n} = e;
            if (t && (r = this.mapChildrenToProps(t, r)), n && !(n instanceof WK)) {
                const i = n;
                n = new WK(i.context, !0), delete r.helmetData
            }
            return n ? ar.createElement(Upe, {
                ...r,
                context: n.value
            }) : ar.createElement(N5e.Consumer, null, i => ar.createElement(Upe, {...r, context: i}))
        }
    }, Ft(yW, "defaultProps", {defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1}), yW);

function KO() {
    return KO = Object.assign ? Object.assign.bind() : function (t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }, KO.apply(this, arguments)
}

var Dw;
(function (t) {
    t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE"
})(Dw || (Dw = {}));
const jpe = "popstate";

function ePt(t) {
    t === void 0 && (t = {});

    function e(n, i) {
        let {pathname: a, search: o, hash: s} = n.location;
        return GK("", {
            pathname: a,
            search: o,
            hash: s
        }, i.state && i.state.usr || null, i.state && i.state.key || "default")
    }

    function r(n, i) {
        return typeof i == "string" ? i : YO(i)
    }

    return rPt(e, r, null, t)
}

function tPt() {
    return Math.random().toString(36).substr(2, 8)
}

function zpe(t) {
    return {usr: t.state, key: t.key}
}

function GK(t, e, r, n) {
    return r === void 0 && (r = null), KO({
        pathname: typeof t == "string" ? t : t.pathname,
        search: "",
        hash: ""
    }, typeof e == "string" ? gL(e) : e, {state: r, key: e && e.key || n || tPt()})
}

function YO(t) {
    let {pathname: e = "/", search: r = "", hash: n = ""} = t;
    return r && r !== "?" && (e += r.charAt(0) === "?" ? r : "?" + r), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e
}

function gL(t) {
    let e = {};
    if (t) {
        let r = t.indexOf("#");
        r >= 0 && (e.hash = t.substr(r), t = t.substr(0, r));
        let n = t.indexOf("?");
        n >= 0 && (e.search = t.substr(n), t = t.substr(0, n)), t && (e.pathname = t)
    }
    return e
}

function rPt(t, e, r, n) {
    n === void 0 && (n = {});
    let {window: i = document.defaultView, v5Compat: a = !1} = n, o = i.history, s = Dw.Pop, l = null;

    function f() {
        s = Dw.Pop, l && l({action: s, location: g.location})
    }

    function d(b, S) {
        s = Dw.Push;
        let T = GK(g.location, b, S);
        r && r(T, b);
        let I = zpe(T), N = g.createHref(T);
        try {
            o.pushState(I, "", N)
        } catch {
            i.location.assign(N)
        }
        a && l && l({action: s, location: T})
    }

    function p(b, S) {
        s = Dw.Replace;
        let T = GK(g.location, b, S);
        r && r(T, b);
        let I = zpe(T), N = g.createHref(T);
        o.replaceState(I, "", N), a && l && l({action: s, location: T})
    }

    let g = {
        get action() {
            return s
        }, get location() {
            return t(i, o)
        }, listen(b) {
            if (l) throw new Error("A history only accepts one active listener");
            return i.addEventListener(jpe, f), l = b, () => {
                i.removeEventListener(jpe, f), l = null
            }
        }, createHref(b) {
            return e(i, b)
        }, push: d, replace: p, go(b) {
            return o.go(b)
        }
    };
    return g
}

var Vpe;
(function (t) {
    t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error"
})(Vpe || (Vpe = {}));

function $5e(t, e) {
    typeof t == "string" && (t = {path: t, caseSensitive: !1, end: !0});
    let [r, n] = nPt(t.path, t.caseSensitive, t.end), i = e.match(r);
    if (!i) return null;
    let a = i[0], o = a.replace(/(.)\/+$/, "$1"), s = i.slice(1);
    return {
        params: n.reduce((f, d, p) => {
            if (d === "*") {
                let g = s[p] || "";
                o = a.slice(0, a.length - g.length).replace(/(.)\/+$/, "$1")
            }
            return f[d] = iPt(s[p] || "", d), f
        }, {}), pathname: a, pathnameBase: o, pattern: t
    }
}

function nPt(t, e, r) {
    e === void 0 && (e = !1), r === void 0 && (r = !0), yL(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".'));
    let n = [],
        i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (o, s) => (n.push(s), "([^\\/]+)"));
    return t.endsWith("*") ? (n.push("*"), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : i += r ? "\\/*$" : "(?:(?=[@.~-]|%[0-9A-F]{2})|\\b|\\/|$)", [new RegExp(i, e ? void 0 : "i"), n]
}

function iPt(t, e) {
    try {
        return decodeURIComponent(t)
    } catch (r) {
        return yL(!1, 'The value for the URL param "' + e + '" will not be decoded because' + (' the string "' + t + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + r + ").")), t
    }
}

function aPt(t, e) {
    if (e === "/") return t;
    if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
    let r = e.endsWith("/") ? e.length - 1 : e.length, n = t.charAt(r);
    return n && n !== "/" ? null : t.slice(r) || "/"
}

function El(t, e) {
    if (t === !1 || t === null || typeof t > "u") throw new Error(e)
}

function yL(t, e) {
    if (!t) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {
        }
    }
}

function oPt(t, e) {
    e === void 0 && (e = "/");
    let {pathname: r, search: n = "", hash: i = ""} = typeof t == "string" ? gL(t) : t;
    return {pathname: r ? r.startsWith("/") ? r : sPt(r, e) : e, search: cPt(n), hash: lPt(i)}
}

function sPt(t, e) {
    let r = e.replace(/\/+$/, "").split("/");
    return t.split("/").forEach(i => {
        i === ".." ? r.length > 1 && r.pop() : i !== "." && r.push(i)
    }), r.length > 1 ? r.join("/") : "/"
}

function F5e(t, e, r, n) {
    n === void 0 && (n = !1);
    let i = typeof t == "string" ? gL(t) : KO({}, t), a = t === "" || i.pathname === "", o = a ? "/" : i.pathname, s;
    if (n || o == null) s = r; else {
        let p = e.length - 1;
        if (o.startsWith("..")) {
            let g = o.split("/");
            for (; g[0] === "..";) g.shift(), p -= 1;
            i.pathname = g.join("/")
        }
        s = p >= 0 ? e[p] : "/"
    }
    let l = oPt(i, s), f = o && o !== "/" && o.endsWith("/"), d = (a || o === ".") && r.endsWith("/");
    return !l.pathname.endsWith("/") && (f || d) && (l.pathname += "/"), l
}

const U5e = t => t.join("/").replace(/\/\/+/g, "/"), cPt = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t,
    lPt = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t, uPt = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (uPt.displayName = "DataStaticRouterContext");
const j5e = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (j5e.displayName = "DataRouter");
const z5e = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (z5e.displayName = "DataRouterState");
const fPt = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (fPt.displayName = "Await");
const bL = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (bL.displayName = "Navigation");
const wL = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (wL.displayName = "Location");
const SL = W.createContext({outlet: null, matches: []});
Ve.env.NODE_ENV !== "production" && (SL.displayName = "Route");
const dPt = W.createContext(null);
Ve.env.NODE_ENV !== "production" && (dPt.displayName = "RouteError");

function hPt(t, e) {
    let {relative: r} = e === void 0 ? {} : e;
    yI() || (Ve.env.NODE_ENV !== "production" ? El(!1, "useHref() may be used only in the context of a <Router> component.") : El(!1));
    let {basename: n, navigator: i} = W.useContext(bL), {hash: a, pathname: o, search: s} = UA(t, {relative: r}), l = o;
    return n !== "/" && (l = o === "/" ? n : U5e([n, o])), i.createHref({pathname: l, search: s, hash: a})
}

function yI() {
    return W.useContext(wL) != null
}

function Oo() {
    return yI() || (Ve.env.NODE_ENV !== "production" ? El(!1, "useLocation() may be used only in the context of a <Router> component.") : El(!1)), W.useContext(wL).location
}

function pPt(t) {
    yI() || (Ve.env.NODE_ENV !== "production" ? El(!1, "useMatch() may be used only in the context of a <Router> component.") : El(!1));
    let {pathname: e} = Oo();
    return W.useMemo(() => $5e(t, e), [e, t])
}

function V5e(t) {
    return t.filter((e, r) => r === 0 || !e.route.index && e.pathnameBase !== t[r - 1].pathnameBase)
}

function C1() {
    yI() || (Ve.env.NODE_ENV !== "production" ? El(!1, "useNavigate() may be used only in the context of a <Router> component.") : El(!1));
    let {basename: t, navigator: e} = W.useContext(bL), {matches: r} = W.useContext(SL), {pathname: n} = Oo(),
        i = JSON.stringify(V5e(r).map(s => s.pathnameBase)), a = W.useRef(!1);
    return W.useEffect(() => {
        a.current = !0
    }), W.useCallback(function (s, l) {
        if (l === void 0 && (l = {}), Ve.env.NODE_ENV !== "production" && yL(a.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered."), !a.current) return;
        if (typeof s == "number") {
            e.go(s);
            return
        }
        let f = F5e(s, JSON.parse(i), n, l.relative === "path");
        t !== "/" && (f.pathname = f.pathname === "/" ? t : U5e([t, f.pathname])), (l.replace ? e.replace : e.push)(f, l.state, l)
    }, [t, e, i, n])
}

function UA(t, e) {
    let {relative: r} = e === void 0 ? {} : e, {matches: n} = W.useContext(SL), {pathname: i} = Oo(),
        a = JSON.stringify(V5e(n).map(o => o.pathnameBase));
    return W.useMemo(() => F5e(t, JSON.parse(a), i, r === "path"), [t, a, i, r])
}

var Hpe;
(function (t) {
    t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator"
})(Hpe || (Hpe = {}));

function mPt(t) {
    let {
        basename: e = "/",
        children: r = null,
        location: n,
        navigationType: i = Dw.Pop,
        navigator: a,
        static: o = !1
    } = t;
    yI() && (Ve.env.NODE_ENV !== "production" ? El(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : El(!1));
    let s = e.replace(/^\/*/, "/"), l = W.useMemo(() => ({basename: s, navigator: a, static: o}), [s, a, o]);
    typeof n == "string" && (n = gL(n));
    let {pathname: f = "/", search: d = "", hash: p = "", state: g = null, key: b = "default"} = n,
        S = W.useMemo(() => {
            let T = aPt(f, s);
            return T == null ? null : {pathname: T, search: d, hash: p, state: g, key: b}
        }, [s, f, d, p, g, b]);
    return Ve.env.NODE_ENV !== "production" && yL(S != null, '<Router basename="' + s + '"> is not able to match the URL ' + ('"' + f + d + p + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), S == null ? null : W.createElement(bL.Provider, {value: l}, W.createElement(wL.Provider, {
        children: r,
        value: {location: S, navigationType: i}
    }))
}

var Wpe;
(function (t) {
    t[t.pending = 0] = "pending", t[t.success = 1] = "success", t[t.error = 2] = "error"
})(Wpe || (Wpe = {}));
new Promise(() => {
});

function uE() {
    return uE = Object.assign ? Object.assign.bind() : function (t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }, uE.apply(this, arguments)
}

function cee(t, e) {
    if (t == null) return {};
    var r = {}, n = Object.keys(t), i, a;
    for (a = 0; a < n.length; a++) i = n[a], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
    return r
}

const oM = "get", RH = "application/x-www-form-urlencoded";

function _L(t) {
    return t != null && typeof t.tagName == "string"
}

function vPt(t) {
    return _L(t) && t.tagName.toLowerCase() === "button"
}

function gPt(t) {
    return _L(t) && t.tagName.toLowerCase() === "form"
}

function yPt(t) {
    return _L(t) && t.tagName.toLowerCase() === "input"
}

function bPt(t) {
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}

function wPt(t, e) {
    return t.button === 0 && (!e || e === "_self") && !bPt(t)
}

function KK(t) {
    return t === void 0 && (t = ""), new URLSearchParams(typeof t == "string" || Array.isArray(t) || t instanceof URLSearchParams ? t : Object.keys(t).reduce((e, r) => {
        let n = t[r];
        return e.concat(Array.isArray(n) ? n.map(i => [r, i]) : [[r, n]])
    }, []))
}

function SPt(t, e) {
    let r = KK(t);
    for (let n of e.keys()) r.has(n) || e.getAll(n).forEach(i => {
        r.append(n, i)
    });
    return r
}

function _Pt(t, e, r) {
    let n, i, a, o;
    if (gPt(t)) {
        let d = r.submissionTrigger;
        n = r.method || t.getAttribute("method") || oM, i = r.action || t.getAttribute("action") || e, a = r.encType || t.getAttribute("enctype") || RH, o = new FormData(t), d && d.name && o.append(d.name, d.value)
    } else if (vPt(t) || yPt(t) && (t.type === "submit" || t.type === "image")) {
        let d = t.form;
        if (d == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        n = r.method || t.getAttribute("formmethod") || d.getAttribute("method") || oM, i = r.action || t.getAttribute("formaction") || d.getAttribute("action") || e, a = r.encType || t.getAttribute("formenctype") || d.getAttribute("enctype") || RH, o = new FormData(d), t.name && o.append(t.name, t.value)
    } else {
        if (_L(t)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        if (n = r.method || oM, i = r.action || e, a = r.encType || RH, t instanceof FormData) o = t; else if (o = new FormData, t instanceof URLSearchParams) for (let [d, p] of t) o.append(d, p); else if (t != null) for (let d of Object.keys(t)) o.append(d, t[d])
    }
    let {protocol: s, host: l} = window.location;
    return {url: new URL(i, s + "//" + l), method: n, encType: a, formData: o}
}

const xPt = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
    EPt = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"],
    TPt = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative"];

function CPt(t) {
    let {basename: e, children: r, window: n} = t, i = W.useRef();
    i.current == null && (i.current = ePt({window: n, v5Compat: !0}));
    let a = i.current, [o, s] = W.useState({action: a.action, location: a.location});
    return W.useLayoutEffect(() => a.listen(s), [a]), W.createElement(mPt, {
        basename: e,
        children: r,
        location: o.location,
        navigationType: o.action,
        navigator: a
    })
}

const bI = W.forwardRef(function (e, r) {
    let {onClick: n, relative: i, reloadDocument: a, replace: o, state: s, target: l, to: f, preventScrollReset: d} = e,
        p = cee(e, xPt), g = hPt(f, {relative: i}),
        b = kPt(f, {replace: o, state: s, target: l, preventScrollReset: d, relative: i});

    function S(T) {
        n && n(T), T.defaultPrevented || b(T)
    }

    return W.createElement("a", uE({}, p, {href: g, onClick: a ? n : S, ref: r, target: l}))
});
Ve.env.NODE_ENV !== "production" && (bI.displayName = "Link");
const APt = W.forwardRef(function (e, r) {
    let {
            "aria-current": n = "page",
            caseSensitive: i = !1,
            className: a = "",
            end: o = !1,
            style: s,
            to: l,
            children: f
        } = e, d = cee(e, EPt), p = UA(l), g = pPt({path: p.pathname, end: o, caseSensitive: i}), b = W.useContext(z5e),
        S = b == null ? void 0 : b.navigation.location, T = UA(S || ""), N = W.useMemo(() => S ? $5e({
            path: p.pathname,
            end: o,
            caseSensitive: i
        }, T.pathname) : null, [S, p.pathname, i, o, T.pathname]) != null, P = g != null, F = P ? n : void 0, V;
    typeof a == "function" ? V = a({
        isActive: P,
        isPending: N
    }) : V = [a, P ? "active" : null, N ? "pending" : null].filter(Boolean).join(" ");
    let Y = typeof s == "function" ? s({isActive: P, isPending: N}) : s;
    return W.createElement(bI, uE({}, d, {
        "aria-current": F,
        className: V,
        ref: r,
        style: Y,
        to: l
    }), typeof f == "function" ? f({isActive: P, isPending: N}) : f)
});
Ve.env.NODE_ENV !== "production" && (APt.displayName = "NavLink");
const H5e = W.forwardRef((t, e) => W.createElement(IPt, uE({}, t, {ref: e})));
Ve.env.NODE_ENV !== "production" && (H5e.displayName = "Form");
const IPt = W.forwardRef((t, e) => {
    let {
            reloadDocument: r,
            replace: n,
            method: i = oM,
            action: a,
            onSubmit: o,
            fetcherKey: s,
            routeId: l,
            relative: f
        } = t, d = cee(t, TPt), p = RPt(s, l), g = i.toLowerCase() === "get" ? "get" : "post", b = q5e(a, {relative: f}),
        S = T => {
            if (o && o(T), T.defaultPrevented) return;
            T.preventDefault();
            let I = T.nativeEvent.submitter;
            p(I || T.currentTarget, {method: i, replace: n, relative: f})
        };
    return W.createElement("form", uE({ref: e, method: g, action: b, onSubmit: r ? o : S}, d))
});
Ve.env.NODE_ENV !== "production" && (H5e.displayName = "Form");

function kPt(t, e) {
    let {target: r, replace: n, state: i, preventScrollReset: a, relative: o} = e === void 0 ? {} : e, s = C1(),
        l = Oo(), f = UA(t, {relative: o});
    return W.useCallback(d => {
        if (wPt(d, r)) {
            d.preventDefault();
            let p = n !== void 0 ? n : YO(l) === YO(f);
            s(t, {replace: p, state: i, preventScrollReset: a, relative: o})
        }
    }, [l, s, f, n, i, r, t, a, o])
}

function W5e(t) {
    Ve.env.NODE_ENV !== "production" && DPt(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
    let e = W.useRef(KK(t)), r = Oo(), n = W.useMemo(() => SPt(r.search, e.current), [r.search]), i = C1(),
        a = W.useCallback((o, s) => {
            const l = KK(typeof o == "function" ? o(n) : o);
            i("?" + l, s)
        }, [i, n]);
    return [n, a]
}

function RPt(t, e) {
    let r = W.useContext(j5e);
    r || (Ve.env.NODE_ENV !== "production" ? El(!1, "useSubmitImpl must be used within a Data Router") : El(!1));
    let {router: n} = r, i = q5e();
    return W.useCallback(function (a, o) {
        if (o === void 0 && (o = {}), typeof document > "u") throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
        let {method: s, encType: l, formData: f, url: d} = _Pt(a, i, o), p = d.pathname + d.search,
            g = {replace: o.replace, formData: f, formMethod: s, formEncType: l};
        t ? (e == null && (Ve.env.NODE_ENV !== "production" ? El(!1, "No routeId available for useFetcher()") : El(!1)), n.fetch(t, e, p, g)) : n.navigate(p, g)
    }, [i, n, t, e])
}

function q5e(t, e) {
    let {relative: r} = e === void 0 ? {} : e, n = W.useContext(SL);
    n || (Ve.env.NODE_ENV !== "production" ? El(!1, "useFormAction must be used inside a RouteContext") : El(!1));
    let [i] = n.matches.slice(-1), o = UA(t ?? ".", {relative: r}), s = Oo();
    if (t == null && (o.search = s.search, o.hash = s.hash, i.route.index)) {
        let l = new URLSearchParams(o.search);
        l.delete("index"), o.search = l.toString() ? "?" + l.toString() : ""
    }
    return (!t || t === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), YO(o)
}

function DPt(t, e) {
    if (!t) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {
        }
    }
}

const MPt = {pingIntervalInMs: 25e3, pingTimeoutInMs: 3e4}, OPt = '"ping"', DH = '"pong"', lee = t => {
        var ee;
        const e = new Mv, r = new l1e("idle"), n = new Mv, i = t.serializer, a = t.connectionConfig ?? MPt;
        let o, s, l;
        (ee = t.beforeUnloadTarget) == null || ee.addEventListener("beforeunload", p);

        function f() {
            d(), s = setInterval(() => {
                P()
            }, a.pingIntervalInMs + a.pingTimeoutInMs)
        }

        function d() {
            s && (clearInterval(s), s = void 0)
        }

        function p() {
            V(1e3, "beforeunload")
        }

        function g(oe) {
            r.next("connected");
            try {
                if (oe.data === OPt) {
                    S();
                    return
                }
                const G = i.decode(oe.data);
                e.next(G)
            } catch (G) {
                t.logger.error({
                    event: {
                        id: "failedDecodingWSMessage",
                        data: {url: t.url, binaryType: t.binaryType, data: oe.data, error: G}
                    }
                })
            }
        }

        function b() {
            r.next("closed"), t.reconnectionStrategy && (r.next("reconnecting"), t.reconnectionStrategy.reconnect(N))
        }

        function S() {
            Y(DH), f()
        }

        function T(oe) {
            if (r.getValue() === "connecting") {
                const G = oe.target instanceof WebSocket;
                t.logger.error({
                    event: {
                        id: "webSocketClientError",
                        data: {
                            readyState: G ? oe.target.readyState : void 0,
                            url: G ? oe.target.url : void 0,
                            message: G ? oe.message : void 0
                        }
                    }
                })
            }
            r.next("closed"), t.onError && t.onError(oe), t.reconnectionStrategy && (r.next("reconnecting"), t.reconnectionStrategy.reconnect(N))
        }

        function I() {
            r.next("connected")
        }

        function N() {
            return F(), f(), r.getValue() !== "reconnecting" && r.next("connecting"), o = t.transport(t.url), o.addEventListener("open", I), o.addEventListener("message", g), o.addEventListener("close", b), o.addEventListener("error", T), l = n.pipe(CWe(r.pipe(zn(oe => oe === "connected"))), Zy(oe => o == null ? void 0 : o.send(oe === DH ? DH : i.encode(oe)))).subscribe(), V
        }

        function P() {
            r.next("reconnecting"), N()
        }

        function F(oe, G) {
            l == null || l.unsubscribe(), l = void 0, o && (o.removeEventListener("open", I), o.removeEventListener("message", g), o.removeEventListener("close", b), o.removeEventListener("error", T), o.close(oe, G))
        }

        function V(oe, G) {
            var J;
            r.next("closed"), (J = t.beforeUnloadTarget) == null || J.removeEventListener("beforeunload", p), F(oe, G), d()
        }

        function Y(oe) {
            n.next(oe)
        }

        return {message: e, send: Y, status: r, connect: N}
    }, PPt = t => new WebSocket(t.toString()), G5e = pt(() => PPt), NPt = pt(() => ({
        create: Hd(t => lee({
            ...t, transport: e => {
                const r = new WebSocket(e.toString());
                return t.binaryType && (r.binaryType = t.binaryType), r
            }, beforeUnloadTarget: typeof document < "u" ? window : void 0
        }))
    })), o3 = pt(sr, $i(), (t, e) => ls(async () => {
        const [{initializeApp: r, onLog: n}, {
            initializeAppCheck: i,
            ReCaptchaEnterpriseProvider: a
        }] = await Promise.all([na(() => import("../chunks/index.esm-bcL8Zxqs.js"), __vite__mapDeps([0, 1])), na(() => import("../chunks/index.esm-iIE-CZzH.js"), __vite__mapDeps([2, 1]))]);
        n(s => {
            t.error({event: {id: "firebaseError", data: s}})
        }, {level: "error"});
        const o = r({
            apiKey: e.DS_WEB_FIREBASE_API_KEY,
            appId: e.DS_WEB_FIREBASE_APP_ID,
            authDomain: e.DS_WEB_FIREBASE_AUTH_DOMAIN,
            messagingSenderId: e.DS_WEB_FIREBASE_MESSAGING_SENDER_ID,
            projectId: e.DS_WEB_FIREBASE_PROJECT_ID,
            storageBucket: e.DS_WEB_FIREBASE_STORAGE_BUCKET,
            measurementId: e.DS_WEB_FIREBASE_MEASUREMENT_ID
        });
        return i(o, {provider: new a(e.DS_WEB_RECAPTCHA_ENTERPRISE_SCORE_SITE_KEY), isTokenAutoRefreshEnabled: !0}), o
    })), LPt = pt(o3, t => ls(async () => {
        const [{getAuth: e}, r] = await Promise.all([na(() => Promise.resolve().then(() => KHt), void 0), t()]);
        return e(r)
    })), BPt = pt(o3, t => ls(async () => {
        const [{getAnalytics: e}, r] = await Promise.all([na(() => import("../chunks/index.esm-JifkhCEc.js"), __vite__mapDeps([3, 1])), t()]);
        return e(r)
    })), nd = pt(o3, t => ls(async () => {
        const [e, {
            CACHE_SIZE_UNLIMITED: r,
            initializeFirestore: n
        }] = await Promise.all([t(), na(() => Promise.resolve().then(() => Djt), void 0)]);
        return n(e, {cacheSizeBytes: r, experimentalAutoDetectLongPolling: !0})
    })), $Pt = pt(o3, t => ls(async () => {
        const {getFunctions: e} = await na(() => import("../chunks/index.esm-P1WENdMj.js"), __vite__mapDeps([4, 1]));
        return e(await t())
    })), Mer = pt($Pt, t => ls(async () => ({
        async httpsCallable(e) {
            const {httpsCallable: r} = await na(() => import("../chunks/index.esm-P1WENdMj.js"), __vite__mapDeps([4, 1])),
                n = await t();
            return r(n, e)
        }
    }))), FPt = pt(BPt, t => ({
        id: "firebase", track: async e => {
            const {logEvent: r} = await na(() => import("../chunks/index.esm-JifkhCEc.js"), __vite__mapDeps([3, 1]));
            switch (e.event) {
                case"screen":
                    return r(await t(), "page_view", kf({
                        ...e.data,
                        page_path: e.data.path,
                        screen_name: e.data.screenName
                    }));
                case"search":
                    return r(await t(), "search", {search_term: e.data.query})
            }
            return r(await t(), e.event, e.data ? kf(e.data) : void 0)
        }
    })), uee = mn("@dexscreener/web/notifications/notifications-manager-transport")(),
    UPt = ["search", "search:open", "websocket:error"], jPt = pt(() => ({
        id: "plausible", track: async t => {
            if (!UPt.includes(t.event)) {
                switch (t.event) {
                    case"screen":
                        return qpe("pageview", {...Gpe(t.data), screen_name: t.data.screenName})
                }
                return qpe(t.event, Gpe(t.data))
            }
        }
    }));

function qpe(t, e) {
    const r = window.plausible;
    if (typeof r == "function") {
        r(t, {props: e});
        return
    }
    console.warn("window.plausible not found. Make sure to render PlausibleTag.")
}

function Gpe(t) {
    if (!t) return;
    const e = {};
    for (const [r, n] of Object.entries(t)) iHe(n) && (e[r] = n);
    return e
}

const zPt = pt(() => {
        function t() {
        }

        function e() {
            return typeof document < "u" && "Notification" in window
        }

        async function r() {
            return e() ? new Promise(a => {
                window.Notification.requestPermission(o => {
                    a(o === "granted")
                })
            }) : !1
        }

        function n() {
            return e() ? window.Notification.permission === "granted" : !1
        }

        async function i(a) {
            return new Promise((o, s) => {
                const l = new window.Notification(a.message, {icon: a.icon, requireInteraction: a.interactable});

                function f() {
                    l.removeEventListener("show", d), l.removeEventListener("error", p), l.removeEventListener("close", g), l.removeEventListener("click", b)
                }

                function d() {
                    o(), l.removeEventListener("show", d)
                }

                function p() {
                    s(), f()
                }

                function g() {
                    f()
                }

                function b(S) {
                    if (S.preventDefault(), l.removeEventListener("click", b), !a.url) return;
                    const T = new URL(window.location.toString());
                    T.pathname = a.url, window.location.href = T.toString()
                }

                l.addEventListener("show", d), l.addEventListener("error", p), l.addEventListener("close", g), a.url && l.addEventListener("click", b)
            })
        }

        return {dispose: t, isSupported: e, hasPermission: n, requestPermission: r, send: i}
    }), VPt = mn("@dexscreener/web/pairs/pairs-repository")(),
    HPt = _.object({schemaVersion: _.literal("1.3.0"), type: _.literal("pair"), pair: e_e.nullable()});
aZ.nullable();
const Oer = HPt, WPt = _.object({
    schemaVersion: _.literal("1.3.0"),
    type: _.literal("pairs"),
    stats: Eht,
    pairs: Cn(e_e),
    pairsCount: _.number().optional()
});
Xt().optional();
const K5e = WPt,
    qPt = _.object({schemaVersion: _.literal("1.3.0"), type: _.literal("latestBlock"), latestBlock: Zdt.nullable()});
Y2e.nullable();
Xt().optional(), Y2e.nullable();
const Per = qPt, Ner = pt($i(), t => ({
    uniswapScreenerServer: {
        schemaVersion: "1.3.0",
        endpoints: {root: t.DS_WEB_UNISWAP_SCREENER_HOST}
    }
})), XO = mn("@dexscreener/web/dexScreenerWSSHost")(), GPt = pt(sr, G5e, XO, (t, e, r) => ({
    getAll: i => {
        const a = KPt(r), o = ZQ(5e3, 1 / 0), s = lee({
            url: a,
            reconnectionStrategy: o,
            logger: t,
            transport: e,
            serializer: v2e(K5e),
            beforeUnloadTarget: typeof document < "u" ? window : void 0
        });
        return new ia(f => {
            const d = s.message.subscribe(f),
                p = s.status.pipe(zn(b => b === "connected"), PE(), j0(b => b)).subscribe(() => {
                    s.send({type: "subscribe", payload: {timeframe: "h24", page: 1, query: i ?? {}}})
                }), g = s.connect();
            return () => {
                d.unsubscribe(), p.unsubscribe(), g == null || g()
            }
        }).pipe(j0(f => f.type === "pairs"), zn(f => f.pairs))
    }
}));

function KPt(t) {
    const e = new URL(t);
    return e.pathname = "/dex/screener/pairs-search", e
}

const YPt = pt(sr, XE, (t, e) => ({
        log: r => {
            var o;
            const {id: n, info: i, error: a} = r;
            t.error({
                event: {
                    id: "errorBoundary",
                    data: {
                        id: n,
                        error: a.message,
                        stack: i.componentStack,
                        userAgent: navigator == null ? void 0 : navigator.userAgent,
                        url: (o = window == null ? void 0 : window.location) == null ? void 0 : o.href
                    }
                }
            }), e.track({event: "errorBoundary", data: {id: n}})
        }
    })), Y5e = mn("@dexscreener/users-client-web//firebaseAuthWebDataSource")(),
    Ra = mn("@dexscreener/users-client-web//firebaseFirestoreWebDataSource")(),
    xL = mn("@dexscreener/users-client-web/firebaseFunctionsWeb")(),
    EL = mn("@dexscreener/users-client-web/firebaseHTTPSCallableWeb")();
const X5e = function (t) {
    const e = [];
    let r = 0;
    for (let n = 0; n < t.length; n++) {
        let i = t.charCodeAt(n);
        i < 128 ? e[r++] = i : i < 2048 ? (e[r++] = i >> 6 | 192, e[r++] = i & 63 | 128) : (i & 64512) === 55296 && n + 1 < t.length && (t.charCodeAt(n + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++n) & 1023), e[r++] = i >> 18 | 240, e[r++] = i >> 12 & 63 | 128, e[r++] = i >> 6 & 63 | 128, e[r++] = i & 63 | 128) : (e[r++] = i >> 12 | 224, e[r++] = i >> 6 & 63 | 128, e[r++] = i & 63 | 128)
    }
    return e
}, XPt = function (t) {
    const e = [];
    let r = 0, n = 0;
    for (; r < t.length;) {
        const i = t[r++];
        if (i < 128) e[n++] = String.fromCharCode(i); else if (i > 191 && i < 224) {
            const a = t[r++];
            e[n++] = String.fromCharCode((i & 31) << 6 | a & 63)
        } else if (i > 239 && i < 365) {
            const a = t[r++], o = t[r++], s = t[r++],
                l = ((i & 7) << 18 | (a & 63) << 12 | (o & 63) << 6 | s & 63) - 65536;
            e[n++] = String.fromCharCode(55296 + (l >> 10)), e[n++] = String.fromCharCode(56320 + (l & 1023))
        } else {
            const a = t[r++], o = t[r++];
            e[n++] = String.fromCharCode((i & 15) << 12 | (a & 63) << 6 | o & 63)
        }
    }
    return e.join("")
}, Q5e = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/="
    },
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_."
    },
    HAS_NATIVE_SUPPORT: typeof atob == "function",
    encodeByteArray(t, e) {
        if (!Array.isArray(t)) throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        const r = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, n = [];
        for (let i = 0; i < t.length; i += 3) {
            const a = t[i], o = i + 1 < t.length, s = o ? t[i + 1] : 0, l = i + 2 < t.length, f = l ? t[i + 2] : 0,
                d = a >> 2, p = (a & 3) << 4 | s >> 4;
            let g = (s & 15) << 2 | f >> 6, b = f & 63;
            l || (b = 64, o || (g = 64)), n.push(r[d], r[p], r[g], r[b])
        }
        return n.join("")
    },
    encodeString(t, e) {
        return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(X5e(t), e)
    },
    decodeString(t, e) {
        return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : XPt(this.decodeStringToByteArray(t, e))
    },
    decodeStringToByteArray(t, e) {
        this.init_();
        const r = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, n = [];
        for (let i = 0; i < t.length;) {
            const a = r[t.charAt(i++)], s = i < t.length ? r[t.charAt(i)] : 0;
            ++i;
            const f = i < t.length ? r[t.charAt(i)] : 64;
            ++i;
            const p = i < t.length ? r[t.charAt(i)] : 64;
            if (++i, a == null || s == null || f == null || p == null) throw Error();
            const g = a << 2 | s >> 4;
            if (n.push(g), f !== 64) {
                const b = s << 4 & 240 | f >> 2;
                if (n.push(b), p !== 64) {
                    const S = f << 6 & 192 | p;
                    n.push(S)
                }
            }
        }
        return n
    },
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
            for (let t = 0; t < this.ENCODED_VALS.length; t++) this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t)
        }
    }
}, QPt = function (t) {
    const e = X5e(t);
    return Q5e.encodeByteArray(e, !0)
}, QO = function (t) {
    return QPt(t).replace(/\./g, "")
}, ZO = function (t) {
    try {
        return Q5e.decodeString(t, !0)
    } catch (e) {
        console.error("base64Decode failed: ", e)
    }
    return null
};

function ZPt() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof Os < "u") return Os;
    throw new Error("Unable to locate global object.")
}

const JPt = () => ZPt().__FIREBASE_DEFAULTS__, eNt = () => {
    if (typeof Ve > "u" || typeof Ve.env > "u") return;
    const t = Ve.env.__FIREBASE_DEFAULTS__;
    if (t) return JSON.parse(t)
}, tNt = () => {
    if (typeof document > "u") return;
    let t;
    try {
        t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
    } catch {
        return
    }
    const e = t && ZO(t[1]);
    return e && JSON.parse(e)
}, TL = () => {
    try {
        return JPt() || eNt() || tNt()
    } catch (t) {
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
        return
    }
}, Z5e = t => {
    var e, r;
    return (r = (e = TL()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || r === void 0 ? void 0 : r[t]
}, rNt = t => {
    const e = Z5e(t);
    if (!e) return;
    const r = e.lastIndexOf(":");
    if (r <= 0 || r + 1 === e.length) throw new Error(`Invalid host ${e} with no separate hostname and port!`);
    const n = parseInt(e.substring(r + 1), 10);
    return e[0] === "[" ? [e.substring(1, r - 1), n] : [e.substring(0, r), n]
}, nNt = () => {
    var t;
    return (t = TL()) === null || t === void 0 ? void 0 : t.config
}, J5e = t => {
    var e;
    return (e = TL()) === null || e === void 0 ? void 0 : e[`_${t}`]
};

class iNt {
    constructor() {
        this.reject = () => {
        }, this.resolve = () => {
        }, this.promise = new Promise((e, r) => {
            this.resolve = e, this.reject = r
        })
    }

    wrapCallback(e) {
        return (r, n) => {
            r ? this.reject(r) : this.resolve(n), typeof e == "function" && (this.promise.catch(() => {
            }), e.length === 1 ? e(r) : e(r, n))
        }
    }
}

function aNt(t, e) {
    if (t.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    const r = {alg: "none", type: "JWT"}, n = e || "demo-project", i = t.iat || 0, a = t.sub || t.user_id;
    if (!a) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    const o = Object.assign({
        iss: `https://securetoken.google.com/${n}`,
        aud: n,
        iat: i,
        exp: i + 3600,
        auth_time: i,
        sub: a,
        user_id: a,
        firebase: {sign_in_provider: "custom", identities: {}}
    }, t);
    return [QO(JSON.stringify(r)), QO(JSON.stringify(o)), ""].join(".")
}

function $s() {
    return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : ""
}

function oNt() {
    return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test($s())
}

function sNt() {
    var t;
    const e = (t = TL()) === null || t === void 0 ? void 0 : t.forceEnvironment;
    if (e === "node") return !0;
    if (e === "browser") return !1;
    try {
        return Object.prototype.toString.call(Os.process) === "[object process]"
    } catch {
        return !1
    }
}

function cNt() {
    const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
    return typeof t == "object" && t.id !== void 0
}

function lNt() {
    return typeof navigator == "object" && navigator.product === "ReactNative"
}

function uNt() {
    const t = $s();
    return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0
}

function fNt() {
    return !sNt() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
}

function eTe() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}

function dNt() {
    return new Promise((t, e) => {
        try {
            let r = !0;
            const n = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(n);
            i.onsuccess = () => {
                i.result.close(), r || self.indexedDB.deleteDatabase(n), t(!0)
            }, i.onupgradeneeded = () => {
                r = !1
            }, i.onerror = () => {
                var a;
                e(((a = i.error) === null || a === void 0 ? void 0 : a.message) || "")
            }
        } catch (r) {
            e(r)
        }
    })
}

function Ler() {
    return !(typeof navigator > "u" || !navigator.cookieEnabled)
}

const hNt = "FirebaseError";

class tg extends Error {
    constructor(e, r, n) {
        super(r), this.code = e, this.customData = n, this.name = hNt, Object.setPrototypeOf(this, tg.prototype), Error.captureStackTrace && Error.captureStackTrace(this, wI.prototype.create)
    }
}

class wI {
    constructor(e, r, n) {
        this.service = e, this.serviceName = r, this.errors = n
    }

    create(e, ...r) {
        const n = r[0] || {}, i = `${this.service}/${e}`, a = this.errors[e], o = a ? pNt(a, n) : "Error",
            s = `${this.serviceName}: ${o} (${i}).`;
        return new tg(i, s, n)
    }
}

function pNt(t, e) {
    return t.replace(mNt, (r, n) => {
        const i = e[n];
        return i != null ? String(i) : `<${n}?>`
    })
}

const mNt = /\{\$([^}]+)}/g;

function Kpe(t) {
    return JSON.parse(t)
}

const vNt = function (t) {
    let e = {}, r = {}, n = {}, i = "";
    try {
        const a = t.split(".");
        e = Kpe(ZO(a[0]) || ""), r = Kpe(ZO(a[1]) || ""), i = a[2], n = r.d || {}, delete r.d
    } catch {
    }
    return {header: e, claims: r, data: n, signature: i}
}, Ber = function (t) {
    const e = vNt(t).claims;
    return typeof e == "object" && e.hasOwnProperty("iat") ? e.iat : null
};

function gNt(t) {
    for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
    return !0
}

function fE(t, e) {
    if (t === e) return !0;
    const r = Object.keys(t), n = Object.keys(e);
    for (const i of r) {
        if (!n.includes(i)) return !1;
        const a = t[i], o = e[i];
        if (Ype(a) && Ype(o)) {
            if (!fE(a, o)) return !1
        } else if (a !== o) return !1
    }
    for (const i of n) if (!r.includes(i)) return !1;
    return !0
}

function Ype(t) {
    return t !== null && typeof t == "object"
}

function s3(t) {
    const e = [];
    for (const [r, n] of Object.entries(t)) Array.isArray(n) ? n.forEach(i => {
        e.push(encodeURIComponent(r) + "=" + encodeURIComponent(i))
    }) : e.push(encodeURIComponent(r) + "=" + encodeURIComponent(n));
    return e.length ? "&" + e.join("&") : ""
}

function UT(t) {
    const e = {};
    return t.replace(/^\?/, "").split("&").forEach(n => {
        if (n) {
            const [i, a] = n.split("=");
            e[decodeURIComponent(i)] = decodeURIComponent(a)
        }
    }), e
}

function jT(t) {
    const e = t.indexOf("?");
    if (!e) return "";
    const r = t.indexOf("#", e);
    return t.substring(e, r > 0 ? r : void 0)
}

function yNt(t, e) {
    const r = new bNt(t, e);
    return r.subscribe.bind(r)
}

class bNt {
    constructor(e, r) {
        this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = r, this.task.then(() => {
            e(this)
        }).catch(n => {
            this.error(n)
        })
    }

    next(e) {
        this.forEachObserver(r => {
            r.next(e)
        })
    }

    error(e) {
        this.forEachObserver(r => {
            r.error(e)
        }), this.close(e)
    }

    complete() {
        this.forEachObserver(e => {
            e.complete()
        }), this.close()
    }

    subscribe(e, r, n) {
        let i;
        if (e === void 0 && r === void 0 && n === void 0) throw new Error("Missing Observer.");
        wNt(e, ["next", "error", "complete"]) ? i = e : i = {
            next: e,
            error: r,
            complete: n
        }, i.next === void 0 && (i.next = MH), i.error === void 0 && (i.error = MH), i.complete === void 0 && (i.complete = MH);
        const a = this.unsubscribeOne.bind(this, this.observers.length);
        return this.finalized && this.task.then(() => {
            try {
                this.finalError ? i.error(this.finalError) : i.complete()
            } catch {
            }
        }), this.observers.push(i), a
    }

    unsubscribeOne(e) {
        this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
    }

    forEachObserver(e) {
        if (!this.finalized) for (let r = 0; r < this.observers.length; r++) this.sendOne(r, e)
    }

    sendOne(e, r) {
        this.task.then(() => {
            if (this.observers !== void 0 && this.observers[e] !== void 0) try {
                r(this.observers[e])
            } catch (n) {
                typeof console < "u" && console.error && console.error(n)
            }
        })
    }

    close(e) {
        this.finalized || (this.finalized = !0, e !== void 0 && (this.finalError = e), this.task.then(() => {
            this.observers = void 0, this.onNoObservers = void 0
        }))
    }
}

function wNt(t, e) {
    if (typeof t != "object" || t === null) return !1;
    for (const r of e) if (r in t && typeof t[r] == "function") return !0;
    return !1
}

function MH() {
}

const $er = function () {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
        const e = Math.random() * 16 | 0;
        return (t === "x" ? e : e & 3 | 8).toString(16)
    })
};
const SNt = 1e3, _Nt = 2, xNt = 4 * 60 * 60 * 1e3, ENt = .5;

function Fer(t, e = SNt, r = _Nt) {
    const n = e * Math.pow(r, t), i = Math.round(ENt * n * (Math.random() - .5) * 2);
    return Math.min(xNt, n + i)
}

function Tr(t) {
    return t && t._delegate ? t._delegate : t
}

class vS {
    constructor(e, r, n) {
        this.name = e, this.instanceFactory = r, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
    }

    setInstantiationMode(e) {
        return this.instantiationMode = e, this
    }

    setMultipleInstances(e) {
        return this.multipleInstances = e, this
    }

    setServiceProps(e) {
        return this.serviceProps = e, this
    }

    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e, this
    }
}

const ow = "[DEFAULT]";
let TNt = class {
    constructor(e, r) {
        this.name = e, this.container = r, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
    }

    get(e) {
        const r = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(r)) {
            const n = new iNt;
            if (this.instancesDeferred.set(r, n), this.isInitialized(r) || this.shouldAutoInitialize()) try {
                const i = this.getOrInitializeService({instanceIdentifier: r});
                i && n.resolve(i)
            } catch {
            }
        }
        return this.instancesDeferred.get(r).promise
    }

    getImmediate(e) {
        var r;
        const n = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier),
            i = (r = e == null ? void 0 : e.optional) !== null && r !== void 0 ? r : !1;
        if (this.isInitialized(n) || this.shouldAutoInitialize()) try {
            return this.getOrInitializeService({instanceIdentifier: n})
        } catch (a) {
            if (i) return null;
            throw a
        } else {
            if (i) return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }

    getComponent() {
        return this.component
    }

    setComponent(e) {
        if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
        if (this.component) throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = e, !!this.shouldAutoInitialize()) {
            if (ANt(e)) try {
                this.getOrInitializeService({instanceIdentifier: ow})
            } catch {
            }
            for (const [r, n] of this.instancesDeferred.entries()) {
                const i = this.normalizeInstanceIdentifier(r);
                try {
                    const a = this.getOrInitializeService({instanceIdentifier: i});
                    n.resolve(a)
                } catch {
                }
            }
        }
    }

    clearInstance(e = ow) {
        this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
    }

    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([...e.filter(r => "INTERNAL" in r).map(r => r.INTERNAL.delete()), ...e.filter(r => "_delete" in r).map(r => r._delete())])
    }

    isComponentSet() {
        return this.component != null
    }

    isInitialized(e = ow) {
        return this.instances.has(e)
    }

    getOptions(e = ow) {
        return this.instancesOptions.get(e) || {}
    }

    initialize(e = {}) {
        const {options: r = {}} = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`);
        if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
        const i = this.getOrInitializeService({instanceIdentifier: n, options: r});
        for (const [a, o] of this.instancesDeferred.entries()) {
            const s = this.normalizeInstanceIdentifier(a);
            n === s && o.resolve(i)
        }
        return i
    }

    onInit(e, r) {
        var n;
        const i = this.normalizeInstanceIdentifier(r),
            a = (n = this.onInitCallbacks.get(i)) !== null && n !== void 0 ? n : new Set;
        a.add(e), this.onInitCallbacks.set(i, a);
        const o = this.instances.get(i);
        return o && e(o, i), () => {
            a.delete(e)
        }
    }

    invokeOnInitCallbacks(e, r) {
        const n = this.onInitCallbacks.get(r);
        if (n) for (const i of n) try {
            i(e, r)
        } catch {
        }
    }

    getOrInitializeService({instanceIdentifier: e, options: r = {}}) {
        let n = this.instances.get(e);
        if (!n && this.component && (n = this.component.instanceFactory(this.container, {
            instanceIdentifier: CNt(e),
            options: r
        }), this.instances.set(e, n), this.instancesOptions.set(e, r), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated)) try {
            this.component.onInstanceCreated(this.container, e, n)
        } catch {
        }
        return n || null
    }

    normalizeInstanceIdentifier(e = ow) {
        return this.component ? this.component.multipleInstances ? e : ow : e
    }

    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
};

function CNt(t) {
    return t === ow ? void 0 : t
}

function ANt(t) {
    return t.instantiationMode === "EAGER"
}

class INt {
    constructor(e) {
        this.name = e, this.providers = new Map
    }

    addComponent(e) {
        const r = this.getProvider(e.name);
        if (r.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
        r.setComponent(e)
    }

    addOrOverwriteComponent(e) {
        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
    }

    getProvider(e) {
        if (this.providers.has(e)) return this.providers.get(e);
        const r = new TNt(e, this);
        return this.providers.set(e, r), r
    }

    getProviders() {
        return Array.from(this.providers.values())
    }
}

const fee = [];
var Ri;
(function (t) {
    t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT"
})(Ri || (Ri = {}));
const tTe = {debug: Ri.DEBUG, verbose: Ri.VERBOSE, info: Ri.INFO, warn: Ri.WARN, error: Ri.ERROR, silent: Ri.SILENT},
    kNt = Ri.INFO,
    RNt = {[Ri.DEBUG]: "log", [Ri.VERBOSE]: "log", [Ri.INFO]: "info", [Ri.WARN]: "warn", [Ri.ERROR]: "error"},
    DNt = (t, e, ...r) => {
        if (e < t.logLevel) return;
        const n = new Date().toISOString(), i = RNt[e];
        if (i) console[i](`[${n}]  ${t.name}:`, ...r); else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
    };

class dee {
    constructor(e) {
        this.name = e, this._logLevel = kNt, this._logHandler = DNt, this._userLogHandler = null, fee.push(this)
    }

    get logLevel() {
        return this._logLevel
    }

    set logLevel(e) {
        if (!(e in Ri)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e
    }

    setLogLevel(e) {
        this._logLevel = typeof e == "string" ? tTe[e] : e
    }

    get logHandler() {
        return this._logHandler
    }

    set logHandler(e) {
        if (typeof e != "function") throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e
    }

    get userLogHandler() {
        return this._userLogHandler
    }

    set userLogHandler(e) {
        this._userLogHandler = e
    }

    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, Ri.DEBUG, ...e), this._logHandler(this, Ri.DEBUG, ...e)
    }

    log(...e) {
        this._userLogHandler && this._userLogHandler(this, Ri.VERBOSE, ...e), this._logHandler(this, Ri.VERBOSE, ...e)
    }

    info(...e) {
        this._userLogHandler && this._userLogHandler(this, Ri.INFO, ...e), this._logHandler(this, Ri.INFO, ...e)
    }

    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, Ri.WARN, ...e), this._logHandler(this, Ri.WARN, ...e)
    }

    error(...e) {
        this._userLogHandler && this._userLogHandler(this, Ri.ERROR, ...e), this._logHandler(this, Ri.ERROR, ...e)
    }
}

function MNt(t) {
    fee.forEach(e => {
        e.setLogLevel(t)
    })
}

function ONt(t, e) {
    for (const r of fee) {
        let n = null;
        e && e.level && (n = tTe[e.level]), t === null ? r.userLogHandler = null : r.userLogHandler = (i, a, ...o) => {
            const s = o.map(l => {
                if (l == null) return null;
                if (typeof l == "string") return l;
                if (typeof l == "number" || typeof l == "boolean") return l.toString();
                if (l instanceof Error) return l.message;
                try {
                    return JSON.stringify(l)
                } catch {
                    return null
                }
            }).filter(l => l).join(" ");
            a >= (n ?? i.logLevel) && t({level: Ri[a].toLowerCase(), message: s, args: o, type: i.name})
        }
    }
}

const PNt = (t, e) => e.some(r => t instanceof r);
let Xpe, Qpe;

function NNt() {
    return Xpe || (Xpe = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}

function LNt() {
    return Qpe || (Qpe = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}

const rTe = new WeakMap, YK = new WeakMap, nTe = new WeakMap, OH = new WeakMap, hee = new WeakMap;

function BNt(t) {
    const e = new Promise((r, n) => {
        const i = () => {
            t.removeEventListener("success", a), t.removeEventListener("error", o)
        }, a = () => {
            r(Hy(t.result)), i()
        }, o = () => {
            n(t.error), i()
        };
        t.addEventListener("success", a), t.addEventListener("error", o)
    });
    return e.then(r => {
        r instanceof IDBCursor && rTe.set(r, t)
    }).catch(() => {
    }), hee.set(e, t), e
}

function $Nt(t) {
    if (YK.has(t)) return;
    const e = new Promise((r, n) => {
        const i = () => {
            t.removeEventListener("complete", a), t.removeEventListener("error", o), t.removeEventListener("abort", o)
        }, a = () => {
            r(), i()
        }, o = () => {
            n(t.error || new DOMException("AbortError", "AbortError")), i()
        };
        t.addEventListener("complete", a), t.addEventListener("error", o), t.addEventListener("abort", o)
    });
    YK.set(t, e)
}

let XK = {
    get(t, e, r) {
        if (t instanceof IDBTransaction) {
            if (e === "done") return YK.get(t);
            if (e === "objectStoreNames") return t.objectStoreNames || nTe.get(t);
            if (e === "store") return r.objectStoreNames[1] ? void 0 : r.objectStore(r.objectStoreNames[0])
        }
        return Hy(t[e])
    }, set(t, e, r) {
        return t[e] = r, !0
    }, has(t, e) {
        return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t
    }
};

function FNt(t) {
    XK = t(XK)
}

function UNt(t) {
    return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function (e, ...r) {
        const n = t.call(PH(this), e, ...r);
        return nTe.set(n, e.sort ? e.sort() : [e]), Hy(n)
    } : LNt().includes(t) ? function (...e) {
        return t.apply(PH(this), e), Hy(rTe.get(this))
    } : function (...e) {
        return Hy(t.apply(PH(this), e))
    }
}

function jNt(t) {
    return typeof t == "function" ? UNt(t) : (t instanceof IDBTransaction && $Nt(t), PNt(t, NNt()) ? new Proxy(t, XK) : t)
}

function Hy(t) {
    if (t instanceof IDBRequest) return BNt(t);
    if (OH.has(t)) return OH.get(t);
    const e = jNt(t);
    return e !== t && (OH.set(t, e), hee.set(e, t)), e
}

const PH = t => hee.get(t);

function zNt(t, e, {blocked: r, upgrade: n, blocking: i, terminated: a} = {}) {
    const o = indexedDB.open(t, e), s = Hy(o);
    return n && o.addEventListener("upgradeneeded", l => {
        n(Hy(o.result), l.oldVersion, l.newVersion, Hy(o.transaction))
    }), r && o.addEventListener("blocked", () => r()), s.then(l => {
        a && l.addEventListener("close", () => a()), i && l.addEventListener("versionchange", () => i())
    }).catch(() => {
    }), s
}

const VNt = ["get", "getKey", "getAll", "getAllKeys", "count"], HNt = ["put", "add", "delete", "clear"], NH = new Map;

function Zpe(t, e) {
    if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return;
    if (NH.get(e)) return NH.get(e);
    const r = e.replace(/FromIndex$/, ""), n = e !== r, i = HNt.includes(r);
    if (!(r in (n ? IDBIndex : IDBObjectStore).prototype) || !(i || VNt.includes(r))) return;
    const a = async function (o, ...s) {
        const l = this.transaction(o, i ? "readwrite" : "readonly");
        let f = l.store;
        return n && (f = f.index(s.shift())), (await Promise.all([f[r](...s), i && l.done]))[0]
    };
    return NH.set(e, a), a
}

FNt(t => ({...t, get: (e, r, n) => Zpe(e, r) || t.get(e, r, n), has: (e, r) => !!Zpe(e, r) || t.has(e, r)}));

class WNt {
    constructor(e) {
        this.container = e
    }

    getPlatformInfoString() {
        return this.container.getProviders().map(r => {
            if (qNt(r)) {
                const n = r.getImmediate();
                return `${n.library}/${n.version}`
            } else return null
        }).filter(r => r).join(" ")
    }
}

function qNt(t) {
    const e = t.getComponent();
    return (e == null ? void 0 : e.type) === "VERSION"
}

const QK = "@firebase/app", Jpe = "0.9.3";
const gS = new dee("@firebase/app"), GNt = "@firebase/app-compat", KNt = "@firebase/analytics-compat",
    YNt = "@firebase/analytics", XNt = "@firebase/app-check-compat", QNt = "@firebase/app-check",
    ZNt = "@firebase/auth", JNt = "@firebase/auth-compat", eLt = "@firebase/database",
    tLt = "@firebase/database-compat", rLt = "@firebase/functions", nLt = "@firebase/functions-compat",
    iLt = "@firebase/installations", aLt = "@firebase/installations-compat", oLt = "@firebase/messaging",
    sLt = "@firebase/messaging-compat", cLt = "@firebase/performance", lLt = "@firebase/performance-compat",
    uLt = "@firebase/remote-config", fLt = "@firebase/remote-config-compat", dLt = "@firebase/storage",
    hLt = "@firebase/storage-compat", pLt = "@firebase/firestore", mLt = "@firebase/firestore-compat", vLt = "firebase",
    gLt = "9.17.1";
const JO = "[DEFAULT]", yLt = {
    [QK]: "fire-core",
    [GNt]: "fire-core-compat",
    [YNt]: "fire-analytics",
    [KNt]: "fire-analytics-compat",
    [QNt]: "fire-app-check",
    [XNt]: "fire-app-check-compat",
    [ZNt]: "fire-auth",
    [JNt]: "fire-auth-compat",
    [eLt]: "fire-rtdb",
    [tLt]: "fire-rtdb-compat",
    [rLt]: "fire-fn",
    [nLt]: "fire-fn-compat",
    [iLt]: "fire-iid",
    [aLt]: "fire-iid-compat",
    [oLt]: "fire-fcm",
    [sLt]: "fire-fcm-compat",
    [cLt]: "fire-perf",
    [lLt]: "fire-perf-compat",
    [uLt]: "fire-rc",
    [fLt]: "fire-rc-compat",
    [dLt]: "fire-gcs",
    [hLt]: "fire-gcs-compat",
    [pLt]: "fire-fst",
    [mLt]: "fire-fst-compat",
    "fire-js": "fire-js",
    [vLt]: "fire-js-all"
};
const yS = new Map, eP = new Map;

function bLt(t, e) {
    try {
        t.container.addComponent(e)
    } catch (r) {
        gS.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, r)
    }
}

function jer(t, e) {
    t.container.addOrOverwriteComponent(e)
}

function dE(t) {
    const e = t.name;
    if (eP.has(e)) return gS.debug(`There were multiple attempts to register component ${e}.`), !1;
    eP.set(e, t);
    for (const r of yS.values()) bLt(r, t);
    return !0
}

function SI(t, e) {
    const r = t.container.getProvider("heartbeat").getImmediate({optional: !0});
    return r && r.triggerHeartbeat(), t.container.getProvider(e)
}

function wLt(t, e, r = JO) {
    SI(t, e).clearInstance(r)
}

function zer() {
    eP.clear()
}

const SLt = {
    "no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
    "bad-app-name": "Illegal App name: '{$appName}",
    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
    "app-deleted": "Firebase App named '{$appName}' already deleted",
    "no-options": "Need to provide options, when not being deployed to hosting via source.",
    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}, Cv = new wI("app", "Firebase", SLt);

class _Lt {
    constructor(e, r, n) {
        this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, r), this._name = r.name, this._automaticDataCollectionEnabled = r.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new vS("app", () => this, "PUBLIC"))
    }

    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(), this._automaticDataCollectionEnabled
    }

    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(), this._automaticDataCollectionEnabled = e
    }

    get name() {
        return this.checkDestroyed(), this._name
    }

    get options() {
        return this.checkDestroyed(), this._options
    }

    get config() {
        return this.checkDestroyed(), this._config
    }

    get container() {
        return this._container
    }

    get isDeleted() {
        return this._isDeleted
    }

    set isDeleted(e) {
        this._isDeleted = e
    }

    checkDestroyed() {
        if (this.isDeleted) throw Cv.create("app-deleted", {appName: this._name})
    }
}

const _I = gLt;

function xLt(t, e = {}) {
    let r = t;
    typeof e != "object" && (e = {name: e});
    const n = Object.assign({name: JO, automaticDataCollectionEnabled: !1}, e), i = n.name;
    if (typeof i != "string" || !i) throw Cv.create("bad-app-name", {appName: String(i)});
    if (r || (r = nNt()), !r) throw Cv.create("no-options");
    const a = yS.get(i);
    if (a) {
        if (fE(r, a.options) && fE(n, a.config)) return a;
        throw Cv.create("duplicate-app", {appName: i})
    }
    const o = new INt(i);
    for (const l of eP.values()) o.addComponent(l);
    const s = new _Lt(r, n, o);
    return yS.set(i, s), s
}

function iTe(t = JO) {
    const e = yS.get(t);
    if (!e && t === JO) return xLt();
    if (!e) throw Cv.create("no-app", {appName: t});
    return e
}

function Ver() {
    return Array.from(yS.values())
}

async function Her(t) {
    const e = t.name;
    yS.has(e) && (yS.delete(e), await Promise.all(t.container.getProviders().map(r => r.delete())), t.isDeleted = !0)
}

function Kw(t, e, r) {
    var n;
    let i = (n = yLt[t]) !== null && n !== void 0 ? n : t;
    r && (i += `-${r}`);
    const a = i.match(/\s|\//), o = e.match(/\s|\//);
    if (a || o) {
        const s = [`Unable to register library "${i}" with version "${e}":`];
        a && s.push(`library name "${i}" contains illegal characters (whitespace or "/")`), a && o && s.push("and"), o && s.push(`version name "${e}" contains illegal characters (whitespace or "/")`), gS.warn(s.join(" "));
        return
    }
    dE(new vS(`${i}-version`, () => ({library: i, version: e}), "VERSION"))
}

function Wer(t, e) {
    if (t !== null && typeof t != "function") throw Cv.create("invalid-log-argument");
    ONt(t, e)
}

function qer(t) {
    MNt(t)
}

const ELt = "firebase-heartbeat-database", TLt = 1, jA = "firebase-heartbeat-store";
let LH = null;

function aTe() {
    return LH || (LH = zNt(ELt, TLt, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(jA)
            }
        }
    }).catch(t => {
        throw Cv.create("idb-open", {originalErrorMessage: t.message})
    })), LH
}

async function CLt(t) {
    try {
        return (await aTe()).transaction(jA).objectStore(jA).get(oTe(t))
    } catch (e) {
        if (e instanceof tg) gS.warn(e.message); else {
            const r = Cv.create("idb-get", {originalErrorMessage: e == null ? void 0 : e.message});
            gS.warn(r.message)
        }
    }
}

async function e0e(t, e) {
    try {
        const n = (await aTe()).transaction(jA, "readwrite");
        return await n.objectStore(jA).put(e, oTe(t)), n.done
    } catch (r) {
        if (r instanceof tg) gS.warn(r.message); else {
            const n = Cv.create("idb-set", {originalErrorMessage: r == null ? void 0 : r.message});
            gS.warn(n.message)
        }
    }
}

function oTe(t) {
    return `${t.name}!${t.options.appId}`
}

const ALt = 1024, ILt = 30 * 24 * 60 * 60 * 1e3;

class kLt {
    constructor(e) {
        this.container = e, this._heartbeatsCache = null;
        const r = this.container.getProvider("app").getImmediate();
        this._storage = new DLt(r), this._heartbeatsCachePromise = this._storage.read().then(n => (this._heartbeatsCache = n, n))
    }

    async triggerHeartbeat() {
        const r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), n = t0e();
        if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === n || this._heartbeatsCache.heartbeats.some(i => i.date === n))) return this._heartbeatsCache.heartbeats.push({
            date: n,
            agent: r
        }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(i => {
            const a = new Date(i.date).valueOf();
            return Date.now() - a <= ILt
        }), this._storage.overwrite(this._heartbeatsCache)
    }

    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) return "";
        const e = t0e(), {heartbeatsToSend: r, unsentEntries: n} = RLt(this._heartbeatsCache.heartbeats),
            i = QO(JSON.stringify({version: 2, heartbeats: r}));
        return this._heartbeatsCache.lastSentHeartbeatDate = e, n.length > 0 ? (this._heartbeatsCache.heartbeats = n, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), i
    }
}

function t0e() {
    return new Date().toISOString().substring(0, 10)
}

function RLt(t, e = ALt) {
    const r = [];
    let n = t.slice();
    for (const i of t) {
        const a = r.find(o => o.agent === i.agent);
        if (a) {
            if (a.dates.push(i.date), r0e(r) > e) {
                a.dates.pop();
                break
            }
        } else if (r.push({agent: i.agent, dates: [i.date]}), r0e(r) > e) {
            r.pop();
            break
        }
        n = n.slice(1)
    }
    return {heartbeatsToSend: r, unsentEntries: n}
}

class DLt {
    constructor(e) {
        this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }

    async runIndexedDBEnvironmentCheck() {
        return eTe() ? dNt().then(() => !0).catch(() => !1) : !1
    }

    async read() {
        return await this._canUseIndexedDBPromise ? await CLt(this.app) || {heartbeats: []} : {heartbeats: []}
    }

    async overwrite(e) {
        var r;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return e0e(this.app, {
                lastSentHeartbeatDate: (r = e.lastSentHeartbeatDate) !== null && r !== void 0 ? r : i.lastSentHeartbeatDate,
                heartbeats: e.heartbeats
            })
        } else return
    }

    async add(e) {
        var r;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return e0e(this.app, {
                lastSentHeartbeatDate: (r = e.lastSentHeartbeatDate) !== null && r !== void 0 ? r : i.lastSentHeartbeatDate,
                heartbeats: [...i.heartbeats, ...e.heartbeats]
            })
        } else return
    }
}

function r0e(t) {
    return QO(JSON.stringify({version: 2, heartbeats: t})).length
}

function MLt(t) {
    dE(new vS("platform-logger", e => new WNt(e), "PRIVATE")), dE(new vS("heartbeat", e => new kLt(e), "PRIVATE")), Kw(QK, Jpe, t), Kw(QK, Jpe, "esm2017"), Kw("fire-js", "")
}

MLt("");
var OLt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Os < "u" ? Os : typeof self < "u" ? self : {},
    Rr, pee = pee || {}, yn = OLt || self;

function tP() {
}

function CL(t) {
    var e = typeof t;
    return e = e != "object" ? e : t ? Array.isArray(t) ? "array" : e : "null", e == "array" || e == "object" && typeof t.length == "number"
}

function xI(t) {
    var e = typeof t;
    return e == "object" && t != null || e == "function"
}

function PLt(t) {
    return Object.prototype.hasOwnProperty.call(t, BH) && t[BH] || (t[BH] = ++NLt)
}

var BH = "closure_uid_" + (1e9 * Math.random() >>> 0), NLt = 0;

function LLt(t, e, r) {
    return t.call.apply(t.bind, arguments)
}

function BLt(t, e, r) {
    if (!t) throw Error();
    if (2 < arguments.length) {
        var n = Array.prototype.slice.call(arguments, 2);
        return function () {
            var i = Array.prototype.slice.call(arguments);
            return Array.prototype.unshift.apply(i, n), t.apply(e, i)
        }
    }
    return function () {
        return t.apply(e, arguments)
    }
}

function Cl(t, e, r) {
    return Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? Cl = LLt : Cl = BLt, Cl.apply(null, arguments)
}

function z7(t, e) {
    var r = Array.prototype.slice.call(arguments, 1);
    return function () {
        var n = r.slice();
        return n.push.apply(n, arguments), t.apply(this, n)
    }
}

function Kc(t, e) {
    function r() {
    }

    r.prototype = e.prototype, t.X = e.prototype, t.prototype = new r, t.prototype.constructor = t, t.Wb = function (n, i, a) {
        for (var o = Array(arguments.length - 2), s = 2; s < arguments.length; s++) o[s - 2] = arguments[s];
        return e.prototype[i].apply(n, o)
    }
}

function A1() {
    this.s = this.s, this.o = this.o
}

var $Lt = 0;
A1.prototype.s = !1;
A1.prototype.na = function () {
    !this.s && (this.s = !0, this.M(), $Lt != 0) && PLt(this)
};
A1.prototype.M = function () {
    if (this.o) for (; this.o.length;) this.o.shift()()
};
const sTe = Array.prototype.indexOf ? function (t, e) {
    return Array.prototype.indexOf.call(t, e, void 0)
} : function (t, e) {
    if (typeof t == "string") return typeof e != "string" || e.length != 1 ? -1 : t.indexOf(e, 0);
    for (let r = 0; r < t.length; r++) if (r in t && t[r] === e) return r;
    return -1
};

function mee(t) {
    const e = t.length;
    if (0 < e) {
        const r = Array(e);
        for (let n = 0; n < e; n++) r[n] = t[n];
        return r
    }
    return []
}

function n0e(t, e) {
    for (let r = 1; r < arguments.length; r++) {
        const n = arguments[r];
        if (CL(n)) {
            const i = t.length || 0, a = n.length || 0;
            t.length = i + a;
            for (let o = 0; o < a; o++) t[i + o] = n[o]
        } else t.push(n)
    }
}

function Al(t, e) {
    this.type = t, this.g = this.target = e, this.defaultPrevented = !1
}

Al.prototype.h = function () {
    this.defaultPrevented = !0
};
var FLt = function () {
    if (!yn.addEventListener || !Object.defineProperty) return !1;
    var t = !1, e = Object.defineProperty({}, "passive", {
        get: function () {
            t = !0
        }
    });
    try {
        yn.addEventListener("test", tP, e), yn.removeEventListener("test", tP, e)
    } catch {
    }
    return t
}();

function rP(t) {
    return /^[\s\xa0]*$/.test(t)
}

var i0e = String.prototype.trim ? function (t) {
    return t.trim()
} : function (t) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(t)[1]
};

function $H(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
}

function AL() {
    var t = yn.navigator;
    return t && (t = t.userAgent) ? t : ""
}

function x0(t) {
    return AL().indexOf(t) != -1
}

function vee(t) {
    return vee[" "](t), t
}

vee[" "] = tP;

function ULt(t) {
    var e = VLt;
    return Object.prototype.hasOwnProperty.call(e, 9) ? e[9] : e[9] = t(9)
}

var jLt = x0("Opera"), hE = x0("Trident") || x0("MSIE"), cTe = x0("Edge"), ZK = cTe || hE,
    lTe = x0("Gecko") && !(AL().toLowerCase().indexOf("webkit") != -1 && !x0("Edge")) && !(x0("Trident") || x0("MSIE")) && !x0("Edge"),
    zLt = AL().toLowerCase().indexOf("webkit") != -1 && !x0("Edge");

function uTe() {
    var t = yn.document;
    return t ? t.documentMode : void 0
}

var nP;
e:{
    var FH = "", UH = function () {
        var t = AL();
        if (lTe) return /rv:([^\);]+)(\)|;)/.exec(t);
        if (cTe) return /Edge\/([\d\.]+)/.exec(t);
        if (hE) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(t);
        if (zLt) return /WebKit\/(\S+)/.exec(t);
        if (jLt) return /(?:Version)[ \/]?(\S+)/.exec(t)
    }();
    if (UH && (FH = UH ? UH[1] : ""), hE) {
        var jH = uTe();
        if (jH != null && jH > parseFloat(FH)) {
            nP = String(jH);
            break e
        }
    }
    nP = FH
}
var VLt = {};

function HLt() {
    return ULt(function () {
        let t = 0;
        const e = i0e(String(nP)).split("."), r = i0e("9").split("."), n = Math.max(e.length, r.length);
        for (let o = 0; t == 0 && o < n; o++) {
            var i = e[o] || "", a = r[o] || "";
            do {
                if (i = /(\d*)(\D*)(.*)/.exec(i) || ["", "", "", ""], a = /(\d*)(\D*)(.*)/.exec(a) || ["", "", "", ""], i[0].length == 0 && a[0].length == 0) break;
                t = $H(i[1].length == 0 ? 0 : parseInt(i[1], 10), a[1].length == 0 ? 0 : parseInt(a[1], 10)) || $H(i[2].length == 0, a[2].length == 0) || $H(i[2], a[2]), i = i[3], a = a[3]
            } while (t == 0)
        }
        return 0 <= t
    })
}

var JK;
if (yn.document && hE) {
    var a0e = uTe();
    JK = a0e || parseInt(nP, 10) || void 0
} else JK = void 0;
var WLt = JK;

function gee(t, e) {
    if (Al.call(this, t ? t.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, t) {
        var r = this.type = t.type, n = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : null;
        if (this.target = t.target || t.srcElement, this.g = e, e = t.relatedTarget) {
            if (lTe) {
                e:{
                    try {
                        vee(e.nodeName);
                        var i = !0;
                        break e
                    } catch {
                    }
                    i = !1
                }
                i || (e = null)
            }
        } else r == "mouseover" ? e = t.fromElement : r == "mouseout" && (e = t.toElement);
        this.relatedTarget = e, n ? (this.clientX = n.clientX !== void 0 ? n.clientX : n.pageX, this.clientY = n.clientY !== void 0 ? n.clientY : n.pageY, this.screenX = n.screenX || 0, this.screenY = n.screenY || 0) : (this.clientX = t.clientX !== void 0 ? t.clientX : t.pageX, this.clientY = t.clientY !== void 0 ? t.clientY : t.pageY, this.screenX = t.screenX || 0, this.screenY = t.screenY || 0), this.button = t.button, this.key = t.key || "", this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.pointerId = t.pointerId || 0, this.pointerType = typeof t.pointerType == "string" ? t.pointerType : qLt[t.pointerType] || "", this.state = t.state, this.i = t
    }
}

Kc(gee, Al);
var qLt = {2: "touch", 3: "pen", 4: "mouse"};
gee.prototype.h = function () {
    var t = this.i;
    t.preventDefault ? t.preventDefault() : t.returnValue = !1
};
var EI = "closure_listenable_" + (1e6 * Math.random() | 0), GLt = 0;

function KLt(t, e, r, n, i) {
    this.listener = t, this.proxy = null, this.src = e, this.type = r, this.capture = !!n, this.ha = i, this.key = ++GLt, this.ba = this.ea = !1
}

function IL(t) {
    t.ba = !0, t.listener = null, t.proxy = null, t.src = null, t.ha = null
}

function yee(t, e, r) {
    for (const n in t) e.call(r, t[n], n, t)
}

function fTe(t) {
    const e = {};
    for (const r in t) e[r] = t[r];
    return e
}

const o0e = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");

function dTe(t, e) {
    let r, n;
    for (let i = 1; i < arguments.length; i++) {
        n = arguments[i];
        for (r in n) t[r] = n[r];
        for (let a = 0; a < o0e.length; a++) r = o0e[a], Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
    }
}

function kL(t) {
    this.src = t, this.g = {}, this.h = 0
}

kL.prototype.add = function (t, e, r, n, i) {
    var a = t.toString();
    t = this.g[a], t || (t = this.g[a] = [], this.h++);
    var o = tY(t, e, n, i);
    return -1 < o ? (e = t[o], r || (e.ea = !1)) : (e = new KLt(e, this.src, a, !!n, i), e.ea = r, t.push(e)), e
};

function eY(t, e) {
    var r = e.type;
    if (r in t.g) {
        var n = t.g[r], i = sTe(n, e), a;
        (a = 0 <= i) && Array.prototype.splice.call(n, i, 1), a && (IL(e), t.g[r].length == 0 && (delete t.g[r], t.h--))
    }
}

function tY(t, e, r, n) {
    for (var i = 0; i < t.length; ++i) {
        var a = t[i];
        if (!a.ba && a.listener == e && a.capture == !!r && a.ha == n) return i
    }
    return -1
}

var bee = "closure_lm_" + (1e6 * Math.random() | 0), zH = {};

function hTe(t, e, r, n, i) {
    if (n && n.once) return mTe(t, e, r, n, i);
    if (Array.isArray(e)) {
        for (var a = 0; a < e.length; a++) hTe(t, e[a], r, n, i);
        return null
    }
    return r = _ee(r), t && t[EI] ? t.N(e, r, xI(n) ? !!n.capture : !!n, i) : pTe(t, e, r, !1, n, i)
}

function pTe(t, e, r, n, i, a) {
    if (!e) throw Error("Invalid event type");
    var o = xI(i) ? !!i.capture : !!i, s = See(t);
    if (s || (t[bee] = s = new kL(t)), r = s.add(e, r, n, o, a), r.proxy) return r;
    if (n = YLt(), r.proxy = n, n.src = t, n.listener = r, t.addEventListener) FLt || (i = o), i === void 0 && (i = !1), t.addEventListener(e.toString(), n, i); else if (t.attachEvent) t.attachEvent(gTe(e.toString()), n); else if (t.addListener && t.removeListener) t.addListener(n); else throw Error("addEventListener and attachEvent are unavailable.");
    return r
}

function YLt() {
    function t(r) {
        return e.call(t.src, t.listener, r)
    }

    const e = XLt;
    return t
}

function mTe(t, e, r, n, i) {
    if (Array.isArray(e)) {
        for (var a = 0; a < e.length; a++) mTe(t, e[a], r, n, i);
        return null
    }
    return r = _ee(r), t && t[EI] ? t.O(e, r, xI(n) ? !!n.capture : !!n, i) : pTe(t, e, r, !0, n, i)
}

function vTe(t, e, r, n, i) {
    if (Array.isArray(e)) for (var a = 0; a < e.length; a++) vTe(t, e[a], r, n, i); else n = xI(n) ? !!n.capture : !!n, r = _ee(r), t && t[EI] ? (t = t.i, e = String(e).toString(), e in t.g && (a = t.g[e], r = tY(a, r, n, i), -1 < r && (IL(a[r]), Array.prototype.splice.call(a, r, 1), a.length == 0 && (delete t.g[e], t.h--)))) : t && (t = See(t)) && (e = t.g[e.toString()], t = -1, e && (t = tY(e, r, n, i)), (r = -1 < t ? e[t] : null) && wee(r))
}

function wee(t) {
    if (typeof t != "number" && t && !t.ba) {
        var e = t.src;
        if (e && e[EI]) eY(e.i, t); else {
            var r = t.type, n = t.proxy;
            e.removeEventListener ? e.removeEventListener(r, n, t.capture) : e.detachEvent ? e.detachEvent(gTe(r), n) : e.addListener && e.removeListener && e.removeListener(n), (r = See(e)) ? (eY(r, t), r.h == 0 && (r.src = null, e[bee] = null)) : IL(t)
        }
    }
}

function gTe(t) {
    return t in zH ? zH[t] : zH[t] = "on" + t
}

function XLt(t, e) {
    if (t.ba) t = !0; else {
        e = new gee(e, this);
        var r = t.listener, n = t.ha || t.src;
        t.ea && wee(t), t = r.call(n, e)
    }
    return t
}

function See(t) {
    return t = t[bee], t instanceof kL ? t : null
}

var VH = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);

function _ee(t) {
    return typeof t == "function" ? t : (t[VH] || (t[VH] = function (e) {
        return t.handleEvent(e)
    }), t[VH])
}

function rc() {
    A1.call(this), this.i = new kL(this), this.P = this, this.I = null
}

Kc(rc, A1);
rc.prototype[EI] = !0;
rc.prototype.removeEventListener = function (t, e, r, n) {
    vTe(this, t, e, r, n)
};

function Wc(t, e) {
    var r, n = t.I;
    if (n) for (r = []; n; n = n.I) r.push(n);
    if (t = t.P, n = e.type || e, typeof e == "string") e = new Al(e, t); else if (e instanceof Al) e.target = e.target || t; else {
        var i = e;
        e = new Al(n, t), dTe(e, i)
    }
    if (i = !0, r) for (var a = r.length - 1; 0 <= a; a--) {
        var o = e.g = r[a];
        i = V7(o, n, !0, e) && i
    }
    if (o = e.g = t, i = V7(o, n, !0, e) && i, i = V7(o, n, !1, e) && i, r) for (a = 0; a < r.length; a++) o = e.g = r[a], i = V7(o, n, !1, e) && i
}

rc.prototype.M = function () {
    if (rc.X.M.call(this), this.i) {
        var t = this.i, e;
        for (e in t.g) {
            for (var r = t.g[e], n = 0; n < r.length; n++) IL(r[n]);
            delete t.g[e], t.h--
        }
    }
    this.I = null
};
rc.prototype.N = function (t, e, r, n) {
    return this.i.add(String(t), e, !1, r, n)
};
rc.prototype.O = function (t, e, r, n) {
    return this.i.add(String(t), e, !0, r, n)
};

function V7(t, e, r, n) {
    if (e = t.i.g[String(e)], !e) return !0;
    e = e.concat();
    for (var i = !0, a = 0; a < e.length; ++a) {
        var o = e[a];
        if (o && !o.ba && o.capture == r) {
            var s = o.listener, l = o.ha || o.src;
            o.ea && eY(t.i, o), i = s.call(l, n) !== !1 && i
        }
    }
    return i && !n.defaultPrevented
}

var xee = yn.JSON.stringify;

function QLt() {
    var t = wTe;
    let e = null;
    return t.g && (e = t.g, t.g = t.g.next, t.g || (t.h = null), e.next = null), e
}

class ZLt {
    constructor() {
        this.h = this.g = null
    }

    add(e, r) {
        const n = yTe.get();
        n.set(e, r), this.h ? this.h.next = n : this.g = n, this.h = n
    }
}

var yTe = new class {
    constructor(t, e) {
        this.i = t, this.j = e, this.h = 0, this.g = null
    }

    get() {
        let t;
        return 0 < this.h ? (this.h--, t = this.g, this.g = t.next, t.next = null) : t = this.i(), t
    }
}(() => new JLt, t => t.reset());

class JLt {
    constructor() {
        this.next = this.g = this.h = null
    }

    set(e, r) {
        this.h = e, this.g = r, this.next = null
    }

    reset() {
        this.next = this.g = this.h = null
    }
}

function eBt(t) {
    yn.setTimeout(() => {
        throw t
    }, 0)
}

function bTe(t, e) {
    rY || tBt(), nY || (rY(), nY = !0), wTe.add(t, e)
}

var rY;

function tBt() {
    var t = yn.Promise.resolve(void 0);
    rY = function () {
        t.then(rBt)
    }
}

var nY = !1, wTe = new ZLt;

function rBt() {
    for (var t; t = QLt();) {
        try {
            t.h.call(t.g)
        } catch (r) {
            eBt(r)
        }
        var e = yTe;
        e.j(t), 100 > e.h && (e.h++, t.next = e.g, e.g = t)
    }
    nY = !1
}

function RL(t, e) {
    rc.call(this), this.h = t || 1, this.g = e || yn, this.j = Cl(this.lb, this), this.l = Date.now()
}

Kc(RL, rc);
Rr = RL.prototype;
Rr.ca = !1;
Rr.R = null;
Rr.lb = function () {
    if (this.ca) {
        var t = Date.now() - this.l;
        0 < t && t < .8 * this.h ? this.R = this.g.setTimeout(this.j, this.h - t) : (this.R && (this.g.clearTimeout(this.R), this.R = null), Wc(this, "tick"), this.ca && (Eee(this), this.start()))
    }
};
Rr.start = function () {
    this.ca = !0, this.R || (this.R = this.g.setTimeout(this.j, this.h), this.l = Date.now())
};

function Eee(t) {
    t.ca = !1, t.R && (t.g.clearTimeout(t.R), t.R = null)
}

Rr.M = function () {
    RL.X.M.call(this), Eee(this), delete this.g
};

function Tee(t, e, r) {
    if (typeof t == "function") r && (t = Cl(t, r)); else if (t && typeof t.handleEvent == "function") t = Cl(t.handleEvent, t); else throw Error("Invalid listener argument");
    return 2147483647 < Number(e) ? -1 : yn.setTimeout(t, e || 0)
}

function STe(t) {
    t.g = Tee(() => {
        t.g = null, t.i && (t.i = !1, STe(t))
    }, t.j);
    const e = t.h;
    t.h = null, t.m.apply(null, e)
}

class nBt extends A1 {
    constructor(e, r) {
        super(), this.m = e, this.j = r, this.h = null, this.i = !1, this.g = null
    }

    l(e) {
        this.h = arguments, this.g ? this.i = !0 : STe(this)
    }

    M() {
        super.M(), this.g && (yn.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null)
    }
}

function zA(t) {
    A1.call(this), this.h = t, this.g = {}
}

Kc(zA, A1);
var s0e = [];

function _Te(t, e, r, n) {
    Array.isArray(r) || (r && (s0e[0] = r.toString()), r = s0e);
    for (var i = 0; i < r.length; i++) {
        var a = hTe(e, r[i], n || t.handleEvent, !1, t.h || t);
        if (!a) break;
        t.g[a.key] = a
    }
}

function xTe(t) {
    yee(t.g, function (e, r) {
        this.g.hasOwnProperty(r) && wee(e)
    }, t), t.g = {}
}

zA.prototype.M = function () {
    zA.X.M.call(this), xTe(this)
};
zA.prototype.handleEvent = function () {
    throw Error("EventHandler.handleEvent not implemented")
};

function DL() {
    this.g = !0
}

DL.prototype.Aa = function () {
    this.g = !1
};

function iBt(t, e, r, n, i, a) {
    t.info(function () {
        if (t.g) if (a) for (var o = "", s = a.split("&"), l = 0; l < s.length; l++) {
            var f = s[l].split("=");
            if (1 < f.length) {
                var d = f[0];
                f = f[1];
                var p = d.split("_");
                o = 2 <= p.length && p[1] == "type" ? o + (d + "=" + f + "&") : o + (d + "=redacted&")
            }
        } else o = null; else o = a;
        return "XMLHTTP REQ (" + n + ") [attempt " + i + "]: " + e + `
` + r + `
` + o
    })
}

function aBt(t, e, r, n, i, a, o) {
    t.info(function () {
        return "XMLHTTP RESP (" + n + ") [ attempt " + i + "]: " + e + `
` + r + `
` + a + " " + o
    })
}

function zx(t, e, r, n) {
    t.info(function () {
        return "XMLHTTP TEXT (" + e + "): " + sBt(t, r) + (n ? " " + n : "")
    })
}

function oBt(t, e) {
    t.info(function () {
        return "TIMEOUT: " + e
    })
}

DL.prototype.info = function () {
};

function sBt(t, e) {
    if (!t.g) return e;
    if (!e) return null;
    try {
        var r = JSON.parse(e);
        if (r) {
            for (t = 0; t < r.length; t++) if (Array.isArray(r[t])) {
                var n = r[t];
                if (!(2 > n.length)) {
                    var i = n[1];
                    if (Array.isArray(i) && !(1 > i.length)) {
                        var a = i[0];
                        if (a != "noop" && a != "stop" && a != "close") for (var o = 1; o < i.length; o++) i[o] = ""
                    }
                }
            }
        }
        return xee(r)
    } catch {
        return e
    }
}

var QS = {}, c0e = null;

function ML() {
    return c0e = c0e || new rc
}

QS.Pa = "serverreachability";

function ETe(t) {
    Al.call(this, QS.Pa, t)
}

Kc(ETe, Al);

function VA(t) {
    const e = ML();
    Wc(e, new ETe(e))
}

QS.STAT_EVENT = "statevent";

function TTe(t, e) {
    Al.call(this, QS.STAT_EVENT, t), this.stat = e
}

Kc(TTe, Al);

function lu(t) {
    const e = ML();
    Wc(e, new TTe(e, t))
}

QS.Qa = "timingevent";

function CTe(t, e) {
    Al.call(this, QS.Qa, t), this.size = e
}

Kc(CTe, Al);

function TI(t, e) {
    if (typeof t != "function") throw Error("Fn must not be null and must be a function");
    return yn.setTimeout(function () {
        t()
    }, e)
}

var OL = {NO_ERROR: 0, mb: 1, zb: 2, yb: 3, tb: 4, xb: 5, Ab: 6, Ma: 7, TIMEOUT: 8, Db: 9}, ATe = {
    rb: "complete",
    Nb: "success",
    Na: "error",
    Ma: "abort",
    Fb: "ready",
    Gb: "readystatechange",
    TIMEOUT: "timeout",
    Bb: "incrementaldata",
    Eb: "progress",
    ub: "downloadprogress",
    Vb: "uploadprogress"
};

function Cee() {
}

Cee.prototype.h = null;

function l0e(t) {
    return t.h || (t.h = t.i())
}

function ITe() {
}

var CI = {OPEN: "a", qb: "b", Na: "c", Cb: "d"};

function Aee() {
    Al.call(this, "d")
}

Kc(Aee, Al);

function Iee() {
    Al.call(this, "c")
}

Kc(Iee, Al);
var iY;

function PL() {
}

Kc(PL, Cee);
PL.prototype.g = function () {
    return new XMLHttpRequest
};
PL.prototype.i = function () {
    return {}
};
iY = new PL;

function AI(t, e, r, n) {
    this.l = t, this.j = e, this.m = r, this.U = n || 1, this.S = new zA(this), this.O = cBt, t = ZK ? 125 : void 0, this.T = new RL(t), this.H = null, this.i = !1, this.s = this.A = this.v = this.K = this.F = this.V = this.B = null, this.D = [], this.g = null, this.C = 0, this.o = this.u = null, this.Y = -1, this.I = !1, this.N = 0, this.L = null, this.$ = this.J = this.Z = this.P = !1, this.h = new kTe
}

function kTe() {
    this.i = null, this.g = "", this.h = !1
}

var cBt = 45e3, aY = {}, iP = {};
Rr = AI.prototype;
Rr.setTimeout = function (t) {
    this.O = t
};

function oY(t, e, r) {
    t.K = 1, t.v = LL(Vv(e)), t.s = r, t.P = !0, RTe(t, null)
}

function RTe(t, e) {
    t.F = Date.now(), II(t), t.A = Vv(t.v);
    var r = t.A, n = t.U;
    Array.isArray(n) || (n = [String(n)]), $Te(r.i, "t", n), t.C = 0, r = t.l.H, t.h = new kTe, t.g = aCe(t.l, r ? e : null, !t.s), 0 < t.N && (t.L = new nBt(Cl(t.La, t, t.g), t.N)), _Te(t.S, t.g, "readystatechange", t.ib), e = t.H ? fTe(t.H) : {}, t.s ? (t.u || (t.u = "POST"), e["Content-Type"] = "application/x-www-form-urlencoded", t.g.da(t.A, t.u, t.s, e)) : (t.u = "GET", t.g.da(t.A, t.u, null, e)), VA(), iBt(t.j, t.u, t.A, t.m, t.U, t.s)
}

Rr.ib = function (t) {
    t = t.target;
    const e = this.L;
    e && mv(t) == 3 ? e.l() : this.La(t)
};
Rr.La = function (t) {
    try {
        if (t == this.g) e:{
            const d = mv(this.g);
            var e = this.g.Ea();
            const p = this.g.aa();
            if (!(3 > d) && (d != 3 || ZK || this.g && (this.h.h || this.g.fa() || h0e(this.g)))) {
                this.I || d != 4 || e == 7 || (e == 8 || 0 >= p, VA()), NL(this);
                var r = this.g.aa();
                this.Y = r;
                t:if (DTe(this)) {
                    var n = h0e(this.g);
                    t = "";
                    var i = n.length, a = mv(this.g) == 4;
                    if (!this.h.i) {
                        if (typeof TextDecoder > "u") {
                            Mw(this), xC(this);
                            var o = "";
                            break t
                        }
                        this.h.i = new yn.TextDecoder
                    }
                    for (e = 0; e < i; e++) this.h.h = !0, t += this.h.i.decode(n[e], {stream: a && e == i - 1});
                    n.splice(0, i), this.h.g += t, this.C = 0, o = this.h.g
                } else o = this.g.fa();
                if (this.i = r == 200, aBt(this.j, this.u, this.A, this.m, this.U, d, r), this.i) {
                    if (this.Z && !this.J) {
                        t:{
                            if (this.g) {
                                var s, l = this.g;
                                if ((s = l.g ? l.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !rP(s)) {
                                    var f = s;
                                    break t
                                }
                            }
                            f = null
                        }
                        if (r = f) zx(this.j, this.m, r, "Initial handshake response via X-HTTP-Initial-Response"), this.J = !0, sY(this, r); else {
                            this.i = !1, this.o = 3, lu(12), Mw(this), xC(this);
                            break e
                        }
                    }
                    this.P ? (MTe(this, d, o), ZK && this.i && d == 3 && (_Te(this.S, this.T, "tick", this.hb), this.T.start())) : (zx(this.j, this.m, o, null), sY(this, o)), d == 4 && Mw(this), this.i && !this.I && (d == 4 ? tCe(this.l, this) : (this.i = !1, II(this)))
                } else r == 400 && 0 < o.indexOf("Unknown SID") ? (this.o = 3, lu(12)) : (this.o = 0, lu(13)), Mw(this), xC(this)
            }
        }
    } catch {
    } finally {
    }
};

function DTe(t) {
    return t.g ? t.u == "GET" && t.K != 2 && t.l.Da : !1
}

function MTe(t, e, r) {
    let n = !0, i;
    for (; !t.I && t.C < r.length;) if (i = lBt(t, r), i == iP) {
        e == 4 && (t.o = 4, lu(14), n = !1), zx(t.j, t.m, null, "[Incomplete Response]");
        break
    } else if (i == aY) {
        t.o = 4, lu(15), zx(t.j, t.m, r, "[Invalid Chunk]"), n = !1;
        break
    } else zx(t.j, t.m, i, null), sY(t, i);
    DTe(t) && i != iP && i != aY && (t.h.g = "", t.C = 0), e != 4 || r.length != 0 || t.h.h || (t.o = 1, lu(16), n = !1), t.i = t.i && n, n ? 0 < r.length && !t.$ && (t.$ = !0, e = t.l, e.g == t && e.$ && !e.K && (e.j.info("Great, no buffering proxy detected. Bytes received: " + r.length), Nee(e), e.K = !0, lu(11))) : (zx(t.j, t.m, r, "[Invalid Chunked Response]"), Mw(t), xC(t))
}

Rr.hb = function () {
    if (this.g) {
        var t = mv(this.g), e = this.g.fa();
        this.C < e.length && (NL(this), MTe(this, t, e), this.i && t != 4 && II(this))
    }
};

function lBt(t, e) {
    var r = t.C, n = e.indexOf(`
`, r);
    return n == -1 ? iP : (r = Number(e.substring(r, n)), isNaN(r) ? aY : (n += 1, n + r > e.length ? iP : (e = e.substr(n, r), t.C = n + r, e)))
}

Rr.cancel = function () {
    this.I = !0, Mw(this)
};

function II(t) {
    t.V = Date.now() + t.O, OTe(t, t.O)
}

function OTe(t, e) {
    if (t.B != null) throw Error("WatchDog timer not null");
    t.B = TI(Cl(t.gb, t), e)
}

function NL(t) {
    t.B && (yn.clearTimeout(t.B), t.B = null)
}

Rr.gb = function () {
    this.B = null;
    const t = Date.now();
    0 <= t - this.V ? (oBt(this.j, this.A), this.K != 2 && (VA(), lu(17)), Mw(this), this.o = 2, xC(this)) : OTe(this, this.V - t)
};

function xC(t) {
    t.l.G == 0 || t.I || tCe(t.l, t)
}

function Mw(t) {
    NL(t);
    var e = t.L;
    e && typeof e.na == "function" && e.na(), t.L = null, Eee(t.T), xTe(t.S), t.g && (e = t.g, t.g = null, e.abort(), e.na())
}

function sY(t, e) {
    try {
        var r = t.l;
        if (r.G != 0 && (r.g == t || cY(r.h, t))) {
            if (!t.J && cY(r.h, t) && r.G == 3) {
                try {
                    var n = r.Fa.g.parse(e)
                } catch {
                    n = null
                }
                if (Array.isArray(n) && n.length == 3) {
                    var i = n;
                    if (i[0] == 0) {
                        e:if (!r.u) {
                            if (r.g) if (r.g.F + 3e3 < t.F) sP(r), FL(r); else break e;
                            Pee(r), lu(18)
                        }
                    } else r.Ba = i[1], 0 < r.Ba - r.T && 37500 > i[2] && r.L && r.A == 0 && !r.v && (r.v = TI(Cl(r.cb, r), 6e3));
                    if (1 >= jTe(r.h) && r.ja) {
                        try {
                            r.ja()
                        } catch {
                        }
                        r.ja = void 0
                    }
                } else Ow(r, 11)
            } else if ((t.J || r.g == t) && sP(r), !rP(e)) for (i = r.Fa.g.parse(e), e = 0; e < i.length; e++) {
                let f = i[e];
                if (r.T = f[0], f = f[1], r.G == 2) if (f[0] == "c") {
                    r.I = f[1], r.ka = f[2];
                    const d = f[3];
                    d != null && (r.ma = d, r.j.info("VER=" + r.ma));
                    const p = f[4];
                    p != null && (r.Ca = p, r.j.info("SVER=" + r.Ca));
                    const g = f[5];
                    g != null && typeof g == "number" && 0 < g && (n = 1.5 * g, r.J = n, r.j.info("backChannelRequestTimeoutMs_=" + n)), n = r;
                    const b = t.g;
                    if (b) {
                        const S = b.g ? b.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                        if (S) {
                            var a = n.h;
                            a.g || S.indexOf("spdy") == -1 && S.indexOf("quic") == -1 && S.indexOf("h2") == -1 || (a.j = a.l, a.g = new Set, a.h && (kee(a, a.h), a.h = null))
                        }
                        if (n.D) {
                            const T = b.g ? b.g.getResponseHeader("X-HTTP-Session-Id") : null;
                            T && (n.za = T, Ka(n.F, n.D, T))
                        }
                    }
                    r.G = 3, r.l && r.l.xa(), r.$ && (r.P = Date.now() - t.F, r.j.info("Handshake RTT: " + r.P + "ms")), n = r;
                    var o = t;
                    if (n.sa = iCe(n, n.H ? n.ka : null, n.V), o.J) {
                        zTe(n.h, o);
                        var s = o, l = n.J;
                        l && s.setTimeout(l), s.B && (NL(s), II(s)), n.g = o
                    } else JTe(n);
                    0 < r.i.length && UL(r)
                } else f[0] != "stop" && f[0] != "close" || Ow(r, 7); else r.G == 3 && (f[0] == "stop" || f[0] == "close" ? f[0] == "stop" ? Ow(r, 7) : Oee(r) : f[0] != "noop" && r.l && r.l.wa(f), r.A = 0)
            }
        }
        VA()
    } catch {
    }
}

function uBt(t) {
    if (t.W && typeof t.W == "function") return t.W();
    if (typeof Map < "u" && t instanceof Map || typeof Set < "u" && t instanceof Set) return Array.from(t.values());
    if (typeof t == "string") return t.split("");
    if (CL(t)) {
        for (var e = [], r = t.length, n = 0; n < r; n++) e.push(t[n]);
        return e
    }
    e = [], r = 0;
    for (n in t) e[r++] = t[n];
    return e
}

function fBt(t) {
    if (t.oa && typeof t.oa == "function") return t.oa();
    if (!t.W || typeof t.W != "function") {
        if (typeof Map < "u" && t instanceof Map) return Array.from(t.keys());
        if (!(typeof Set < "u" && t instanceof Set)) {
            if (CL(t) || typeof t == "string") {
                var e = [];
                t = t.length;
                for (var r = 0; r < t; r++) e.push(r);
                return e
            }
            e = [], r = 0;
            for (const n in t) e[r++] = n;
            return e
        }
    }
}

function PTe(t, e) {
    if (t.forEach && typeof t.forEach == "function") t.forEach(e, void 0); else if (CL(t) || typeof t == "string") Array.prototype.forEach.call(t, e, void 0); else for (var r = fBt(t), n = uBt(t), i = n.length, a = 0; a < i; a++) e.call(void 0, n[a], r && r[a], t)
}

var NTe = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");

function dBt(t, e) {
    if (t) {
        t = t.split("&");
        for (var r = 0; r < t.length; r++) {
            var n = t[r].indexOf("="), i = null;
            if (0 <= n) {
                var a = t[r].substring(0, n);
                i = t[r].substring(n + 1)
            } else a = t[r];
            e(a, i ? decodeURIComponent(i.replace(/\+/g, " ")) : "")
        }
    }
}

function Yw(t, e) {
    if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = !1, t instanceof Yw) {
        this.h = e !== void 0 ? e : t.h, aP(this, t.j), this.s = t.s, this.g = t.g, oP(this, t.m), this.l = t.l, e = t.i;
        var r = new HA;
        r.i = e.i, e.g && (r.g = new Map(e.g), r.h = e.h), u0e(this, r), this.o = t.o
    } else t && (r = String(t).match(NTe)) ? (this.h = !!e, aP(this, r[1] || "", !0), this.s = zT(r[2] || ""), this.g = zT(r[3] || "", !0), oP(this, r[4]), this.l = zT(r[5] || "", !0), u0e(this, r[6] || "", !0), this.o = zT(r[7] || "")) : (this.h = !!e, this.i = new HA(null, this.h))
}

Yw.prototype.toString = function () {
    var t = [], e = this.j;
    e && t.push(VT(e, f0e, !0), ":");
    var r = this.g;
    return (r || e == "file") && (t.push("//"), (e = this.s) && t.push(VT(e, f0e, !0), "@"), t.push(encodeURIComponent(String(r)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), r = this.m, r != null && t.push(":", String(r))), (r = this.l) && (this.g && r.charAt(0) != "/" && t.push("/"), t.push(VT(r, r.charAt(0) == "/" ? mBt : pBt, !0))), (r = this.i.toString()) && t.push("?", r), (r = this.o) && t.push("#", VT(r, gBt)), t.join("")
};

function Vv(t) {
    return new Yw(t)
}

function aP(t, e, r) {
    t.j = r ? zT(e, !0) : e, t.j && (t.j = t.j.replace(/:$/, ""))
}

function oP(t, e) {
    if (e) {
        if (e = Number(e), isNaN(e) || 0 > e) throw Error("Bad port number " + e);
        t.m = e
    } else t.m = null
}

function u0e(t, e, r) {
    e instanceof HA ? (t.i = e, yBt(t.i, t.h)) : (r || (e = VT(e, vBt)), t.i = new HA(e, t.h))
}

function Ka(t, e, r) {
    t.i.set(e, r)
}

function LL(t) {
    return Ka(t, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), t
}

function zT(t, e) {
    return t ? e ? decodeURI(t.replace(/%25/g, "%2525")) : decodeURIComponent(t) : ""
}

function VT(t, e, r) {
    return typeof t == "string" ? (t = encodeURI(t).replace(e, hBt), r && (t = t.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), t) : null
}

function hBt(t) {
    return t = t.charCodeAt(0), "%" + (t >> 4 & 15).toString(16) + (t & 15).toString(16)
}

var f0e = /[#\/\?@]/g, pBt = /[#\?:]/g, mBt = /[#\?]/g, vBt = /[#\?@]/g, gBt = /#/g;

function HA(t, e) {
    this.h = this.g = null, this.i = t || null, this.j = !!e
}

function I1(t) {
    t.g || (t.g = new Map, t.h = 0, t.i && dBt(t.i, function (e, r) {
        t.add(decodeURIComponent(e.replace(/\+/g, " ")), r)
    }))
}

Rr = HA.prototype;
Rr.add = function (t, e) {
    I1(this), this.i = null, t = c3(this, t);
    var r = this.g.get(t);
    return r || this.g.set(t, r = []), r.push(e), this.h += 1, this
};

function LTe(t, e) {
    I1(t), e = c3(t, e), t.g.has(e) && (t.i = null, t.h -= t.g.get(e).length, t.g.delete(e))
}

function BTe(t, e) {
    return I1(t), e = c3(t, e), t.g.has(e)
}

Rr.forEach = function (t, e) {
    I1(this), this.g.forEach(function (r, n) {
        r.forEach(function (i) {
            t.call(e, i, n, this)
        }, this)
    }, this)
};
Rr.oa = function () {
    I1(this);
    const t = Array.from(this.g.values()), e = Array.from(this.g.keys()), r = [];
    for (let n = 0; n < e.length; n++) {
        const i = t[n];
        for (let a = 0; a < i.length; a++) r.push(e[n])
    }
    return r
};
Rr.W = function (t) {
    I1(this);
    let e = [];
    if (typeof t == "string") BTe(this, t) && (e = e.concat(this.g.get(c3(this, t)))); else {
        t = Array.from(this.g.values());
        for (let r = 0; r < t.length; r++) e = e.concat(t[r])
    }
    return e
};
Rr.set = function (t, e) {
    return I1(this), this.i = null, t = c3(this, t), BTe(this, t) && (this.h -= this.g.get(t).length), this.g.set(t, [e]), this.h += 1, this
};
Rr.get = function (t, e) {
    return t ? (t = this.W(t), 0 < t.length ? String(t[0]) : e) : e
};

function $Te(t, e, r) {
    LTe(t, e), 0 < r.length && (t.i = null, t.g.set(c3(t, e), mee(r)), t.h += r.length)
}

Rr.toString = function () {
    if (this.i) return this.i;
    if (!this.g) return "";
    const t = [], e = Array.from(this.g.keys());
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        const a = encodeURIComponent(String(n)), o = this.W(n);
        for (n = 0; n < o.length; n++) {
            var i = a;
            o[n] !== "" && (i += "=" + encodeURIComponent(String(o[n]))), t.push(i)
        }
    }
    return this.i = t.join("&")
};

function c3(t, e) {
    return e = String(e), t.j && (e = e.toLowerCase()), e
}

function yBt(t, e) {
    e && !t.j && (I1(t), t.i = null, t.g.forEach(function (r, n) {
        var i = n.toLowerCase();
        n != i && (LTe(this, n), $Te(this, i, r))
    }, t)), t.j = e
}

var bBt = class {
    constructor(e, r) {
        this.h = e, this.g = r
    }
};

function FTe(t) {
    this.l = t || wBt, yn.PerformanceNavigationTiming ? (t = yn.performance.getEntriesByType("navigation"), t = 0 < t.length && (t[0].nextHopProtocol == "hq" || t[0].nextHopProtocol == "h2")) : t = !!(yn.g && yn.g.Ga && yn.g.Ga() && yn.g.Ga().$b), this.j = t ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = []
}

var wBt = 10;

function UTe(t) {
    return t.h ? !0 : t.g ? t.g.size >= t.j : !1
}

function jTe(t) {
    return t.h ? 1 : t.g ? t.g.size : 0
}

function cY(t, e) {
    return t.h ? t.h == e : t.g ? t.g.has(e) : !1
}

function kee(t, e) {
    t.g ? t.g.add(e) : t.h = e
}

function zTe(t, e) {
    t.h && t.h == e ? t.h = null : t.g && t.g.has(e) && t.g.delete(e)
}

FTe.prototype.cancel = function () {
    if (this.i = VTe(this), this.h) this.h.cancel(), this.h = null; else if (this.g && this.g.size !== 0) {
        for (const t of this.g.values()) t.cancel();
        this.g.clear()
    }
};

function VTe(t) {
    if (t.h != null) return t.i.concat(t.h.D);
    if (t.g != null && t.g.size !== 0) {
        let e = t.i;
        for (const r of t.g.values()) e = e.concat(r.D);
        return e
    }
    return mee(t.i)
}

function Ree() {
}

Ree.prototype.stringify = function (t) {
    return yn.JSON.stringify(t, void 0)
};
Ree.prototype.parse = function (t) {
    return yn.JSON.parse(t, void 0)
};

function SBt() {
    this.g = new Ree
}

function _Bt(t, e, r) {
    const n = r || "";
    try {
        PTe(t, function (i, a) {
            let o = i;
            xI(i) && (o = xee(i)), e.push(n + a + "=" + encodeURIComponent(o))
        })
    } catch (i) {
        throw e.push(n + "type=" + encodeURIComponent("_badmap")), i
    }
}

function xBt(t, e) {
    const r = new DL;
    if (yn.Image) {
        const n = new Image;
        n.onload = z7(H7, r, n, "TestLoadImage: loaded", !0, e), n.onerror = z7(H7, r, n, "TestLoadImage: error", !1, e), n.onabort = z7(H7, r, n, "TestLoadImage: abort", !1, e), n.ontimeout = z7(H7, r, n, "TestLoadImage: timeout", !1, e), yn.setTimeout(function () {
            n.ontimeout && n.ontimeout()
        }, 1e4), n.src = t
    } else e(!1)
}

function H7(t, e, r, n, i) {
    try {
        e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, i(n)
    } catch {
    }
}

function kI(t) {
    this.l = t.ac || null, this.j = t.jb || !1
}

Kc(kI, Cee);
kI.prototype.g = function () {
    return new BL(this.l, this.j)
};
kI.prototype.i = function (t) {
    return function () {
        return t
    }
}({});

function BL(t, e) {
    rc.call(this), this.D = t, this.u = e, this.m = void 0, this.readyState = Dee, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null
}

Kc(BL, rc);
var Dee = 0;
Rr = BL.prototype;
Rr.open = function (t, e) {
    if (this.readyState != Dee) throw this.abort(), Error("Error reopening a connection");
    this.C = t, this.B = e, this.readyState = 1, WA(this)
};
Rr.send = function (t) {
    if (this.readyState != 1) throw this.abort(), Error("need to call open() first. ");
    this.g = !0;
    const e = {headers: this.v, method: this.C, credentials: this.m, cache: void 0};
    t && (e.body = t), (this.D || yn).fetch(new Request(this.B, e)).then(this.Wa.bind(this), this.ga.bind(this))
};
Rr.abort = function () {
    this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {
    }), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, RI(this)), this.readyState = Dee
};
Rr.Wa = function (t) {
    if (this.g && (this.l = t, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = t.headers, this.readyState = 2, WA(this)), this.g && (this.readyState = 3, WA(this), this.g))) if (this.responseType === "arraybuffer") t.arrayBuffer().then(this.Ua.bind(this), this.ga.bind(this)); else if (typeof yn.ReadableStream < "u" && "body" in t) {
        if (this.j = t.body.getReader(), this.u) {
            if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
            this.response = []
        } else this.response = this.responseText = "", this.A = new TextDecoder;
        HTe(this)
    } else t.text().then(this.Va.bind(this), this.ga.bind(this))
};

function HTe(t) {
    t.j.read().then(t.Ta.bind(t)).catch(t.ga.bind(t))
}

Rr.Ta = function (t) {
    if (this.g) {
        if (this.u && t.value) this.response.push(t.value); else if (!this.u) {
            var e = t.value ? t.value : new Uint8Array(0);
            (e = this.A.decode(e, {stream: !t.done})) && (this.response = this.responseText += e)
        }
        t.done ? RI(this) : WA(this), this.readyState == 3 && HTe(this)
    }
};
Rr.Va = function (t) {
    this.g && (this.response = this.responseText = t, RI(this))
};
Rr.Ua = function (t) {
    this.g && (this.response = t, RI(this))
};
Rr.ga = function () {
    this.g && RI(this)
};

function RI(t) {
    t.readyState = 4, t.l = null, t.j = null, t.A = null, WA(t)
}

Rr.setRequestHeader = function (t, e) {
    this.v.append(t, e)
};
Rr.getResponseHeader = function (t) {
    return this.h && this.h.get(t.toLowerCase()) || ""
};
Rr.getAllResponseHeaders = function () {
    if (!this.h) return "";
    const t = [], e = this.h.entries();
    for (var r = e.next(); !r.done;) r = r.value, t.push(r[0] + ": " + r[1]), r = e.next();
    return t.join(`\r
`)
};

function WA(t) {
    t.onreadystatechange && t.onreadystatechange.call(t)
}

Object.defineProperty(BL.prototype, "withCredentials", {
    get: function () {
        return this.m === "include"
    }, set: function (t) {
        this.m = t ? "include" : "same-origin"
    }
});
var EBt = yn.JSON.parse;

function Do(t) {
    rc.call(this), this.headers = new Map, this.u = t || null, this.h = !1, this.C = this.g = null, this.H = "", this.m = 0, this.j = "", this.l = this.F = this.v = this.D = !1, this.B = 0, this.A = null, this.J = WTe, this.K = this.L = !1
}

Kc(Do, rc);
var WTe = "", TBt = /^https?$/i, CBt = ["POST", "PUT"];
Rr = Do.prototype;
Rr.Ka = function (t) {
    this.L = t
};
Rr.da = function (t, e, r, n) {
    if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + t);
    e = e ? e.toUpperCase() : "GET", this.H = t, this.j = "", this.m = 0, this.D = !1, this.h = !0, this.g = this.u ? this.u.g() : iY.g(), this.C = this.u ? l0e(this.u) : l0e(iY), this.g.onreadystatechange = Cl(this.Ha, this);
    try {
        this.F = !0, this.g.open(e, String(t), !0), this.F = !1
    } catch (a) {
        d0e(this, a);
        return
    }
    if (t = r || "", r = new Map(this.headers), n) if (Object.getPrototypeOf(n) === Object.prototype) for (var i in n) r.set(i, n[i]); else if (typeof n.keys == "function" && typeof n.get == "function") for (const a of n.keys()) r.set(a, n.get(a)); else throw Error("Unknown input type for opt_headers: " + String(n));
    n = Array.from(r.keys()).find(a => a.toLowerCase() == "content-type"), i = yn.FormData && t instanceof yn.FormData, !(0 <= sTe(CBt, e)) || n || i || r.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    for (const [a, o] of r) this.g.setRequestHeader(a, o);
    this.J && (this.g.responseType = this.J), "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
    try {
        KTe(this), 0 < this.B && ((this.K = ABt(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = Cl(this.qa, this)) : this.A = Tee(this.qa, this.B, this)), this.v = !0, this.g.send(t), this.v = !1
    } catch (a) {
        d0e(this, a)
    }
};

function ABt(t) {
    return hE && HLt() && typeof t.timeout == "number" && t.ontimeout !== void 0
}

Rr.qa = function () {
    typeof pee < "u" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, Wc(this, "timeout"), this.abort(8))
};

function d0e(t, e) {
    t.h = !1, t.g && (t.l = !0, t.g.abort(), t.l = !1), t.j = e, t.m = 5, qTe(t), $L(t)
}

function qTe(t) {
    t.D || (t.D = !0, Wc(t, "complete"), Wc(t, "error"))
}

Rr.abort = function (t) {
    this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = t || 7, Wc(this, "complete"), Wc(this, "abort"), $L(this))
};
Rr.M = function () {
    this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), $L(this, !0)), Do.X.M.call(this)
};
Rr.Ha = function () {
    this.s || (this.F || this.v || this.l ? GTe(this) : this.fb())
};
Rr.fb = function () {
    GTe(this)
};

function GTe(t) {
    if (t.h && typeof pee < "u" && (!t.C[1] || mv(t) != 4 || t.aa() != 2)) {
        if (t.v && mv(t) == 4) Tee(t.Ha, 0, t); else if (Wc(t, "readystatechange"), mv(t) == 4) {
            t.h = !1;
            try {
                const s = t.aa();
                e:switch (s) {
                    case 200:
                    case 201:
                    case 202:
                    case 204:
                    case 206:
                    case 304:
                    case 1223:
                        var e = !0;
                        break e;
                    default:
                        e = !1
                }
                var r;
                if (!(r = e)) {
                    var n;
                    if (n = s === 0) {
                        var i = String(t.H).match(NTe)[1] || null;
                        if (!i && yn.self && yn.self.location) {
                            var a = yn.self.location.protocol;
                            i = a.substr(0, a.length - 1)
                        }
                        n = !TBt.test(i ? i.toLowerCase() : "")
                    }
                    r = n
                }
                if (r) Wc(t, "complete"), Wc(t, "success"); else {
                    t.m = 6;
                    try {
                        var o = 2 < mv(t) ? t.g.statusText : ""
                    } catch {
                        o = ""
                    }
                    t.j = o + " [" + t.aa() + "]", qTe(t)
                }
            } finally {
                $L(t)
            }
        }
    }
}

function $L(t, e) {
    if (t.g) {
        KTe(t);
        const r = t.g, n = t.C[0] ? tP : null;
        t.g = null, t.C = null, e || Wc(t, "ready");
        try {
            r.onreadystatechange = n
        } catch {
        }
    }
}

function KTe(t) {
    t.g && t.K && (t.g.ontimeout = null), t.A && (yn.clearTimeout(t.A), t.A = null)
}

function mv(t) {
    return t.g ? t.g.readyState : 0
}

Rr.aa = function () {
    try {
        return 2 < mv(this) ? this.g.status : -1
    } catch {
        return -1
    }
};
Rr.fa = function () {
    try {
        return this.g ? this.g.responseText : ""
    } catch {
        return ""
    }
};
Rr.Sa = function (t) {
    if (this.g) {
        var e = this.g.responseText;
        return t && e.indexOf(t) == 0 && (e = e.substring(t.length)), EBt(e)
    }
};

function h0e(t) {
    try {
        if (!t.g) return null;
        if ("response" in t.g) return t.g.response;
        switch (t.J) {
            case WTe:
            case"text":
                return t.g.responseText;
            case"arraybuffer":
                if ("mozResponseArrayBuffer" in t.g) return t.g.mozResponseArrayBuffer
        }
        return null
    } catch {
        return null
    }
}

Rr.Ea = function () {
    return this.m
};
Rr.Oa = function () {
    return typeof this.j == "string" ? this.j : String(this.j)
};

function YTe(t) {
    let e = "";
    return yee(t, function (r, n) {
        e += n, e += ":", e += r, e += `\r
`
    }), e
}

function Mee(t, e, r) {
    e:{
        for (n in r) {
            var n = !1;
            break e
        }
        n = !0
    }
    n || (r = YTe(r), typeof t == "string" ? r != null && encodeURIComponent(String(r)) : Ka(t, e, r))
}

function dT(t, e, r) {
    return r && r.internalChannelParams && r.internalChannelParams[t] || e
}

function XTe(t) {
    this.Ca = 0, this.i = [], this.j = new DL, this.ka = this.sa = this.F = this.V = this.g = this.za = this.D = this.ia = this.o = this.S = this.s = null, this.ab = this.U = 0, this.Za = dT("failFast", !1, t), this.L = this.v = this.u = this.m = this.l = null, this.Y = !0, this.pa = this.Ba = this.T = -1, this.Z = this.A = this.C = 0, this.Xa = dT("baseRetryDelayMs", 5e3, t), this.bb = dT("retryDelaySeedMs", 1e4, t), this.$a = dT("forwardChannelMaxRetries", 2, t), this.ta = dT("forwardChannelRequestTimeoutMs", 2e4, t), this.ra = t && t.xmlHttpFactory || void 0, this.Da = t && t.Zb || !1, this.J = void 0, this.H = t && t.supportsCrossDomainXhr || !1, this.I = "", this.h = new FTe(t && t.concurrentRequestLimit), this.Fa = new SBt, this.O = t && t.fastHandshake || !1, this.N = t && t.encodeInitMessageHeaders || !1, this.O && this.N && (this.N = !1), this.Ya = t && t.Xb || !1, t && t.Aa && this.j.Aa(), t && t.forceLongPolling && (this.Y = !1), this.$ = !this.O && this.Y && t && t.detectBufferingProxy || !1, this.ja = void 0, this.P = 0, this.K = !1, this.la = this.B = null
}

Rr = XTe.prototype;
Rr.ma = 8;
Rr.G = 1;

function Oee(t) {
    if (QTe(t), t.G == 3) {
        var e = t.U++, r = Vv(t.F);
        Ka(r, "SID", t.I), Ka(r, "RID", e), Ka(r, "TYPE", "terminate"), DI(t, r), e = new AI(t, t.j, e, void 0), e.K = 2, e.v = LL(Vv(r)), r = !1, yn.navigator && yn.navigator.sendBeacon && (r = yn.navigator.sendBeacon(e.v.toString(), "")), !r && yn.Image && (new Image().src = e.v, r = !0), r || (e.g = aCe(e.l, null), e.g.da(e.v)), e.F = Date.now(), II(e)
    }
    nCe(t)
}

function FL(t) {
    t.g && (Nee(t), t.g.cancel(), t.g = null)
}

function QTe(t) {
    FL(t), t.u && (yn.clearTimeout(t.u), t.u = null), sP(t), t.h.cancel(), t.m && (typeof t.m == "number" && yn.clearTimeout(t.m), t.m = null)
}

function UL(t) {
    UTe(t.h) || t.m || (t.m = !0, bTe(t.Ja, t), t.C = 0)
}

function IBt(t, e) {
    return jTe(t.h) >= t.h.j - (t.m ? 1 : 0) ? !1 : t.m ? (t.i = e.D.concat(t.i), !0) : t.G == 1 || t.G == 2 || t.C >= (t.Za ? 0 : t.$a) ? !1 : (t.m = TI(Cl(t.Ja, t, e), rCe(t, t.C)), t.C++, !0)
}

Rr.Ja = function (t) {
    if (this.m) if (this.m = null, this.G == 1) {
        if (!t) {
            this.U = Math.floor(1e5 * Math.random()), t = this.U++;
            const i = new AI(this, this.j, t, void 0);
            let a = this.s;
            if (this.S && (a ? (a = fTe(a), dTe(a, this.S)) : a = this.S), this.o !== null || this.N || (i.H = a, a = null), this.O) e:{
                for (var e = 0, r = 0; r < this.i.length; r++) {
                    t:{
                        var n = this.i[r];
                        if ("__data__" in n.g && (n = n.g.__data__, typeof n == "string")) {
                            n = n.length;
                            break t
                        }
                        n = void 0
                    }
                    if (n === void 0) break;
                    if (e += n, 4096 < e) {
                        e = r;
                        break e
                    }
                    if (e === 4096 || r === this.i.length - 1) {
                        e = r + 1;
                        break e
                    }
                }
                e = 1e3
            } else e = 1e3;
            e = ZTe(this, i, e), r = Vv(this.F), Ka(r, "RID", t), Ka(r, "CVER", 22), this.D && Ka(r, "X-HTTP-Session-Id", this.D), DI(this, r), a && (this.N ? e = "headers=" + encodeURIComponent(String(YTe(a))) + "&" + e : this.o && Mee(r, this.o, a)), kee(this.h, i), this.Ya && Ka(r, "TYPE", "init"), this.O ? (Ka(r, "$req", e), Ka(r, "SID", "null"), i.Z = !0, oY(i, r, null)) : oY(i, r, e), this.G = 2
        }
    } else this.G == 3 && (t ? p0e(this, t) : this.i.length == 0 || UTe(this.h) || p0e(this))
};

function p0e(t, e) {
    var r;
    e ? r = e.m : r = t.U++;
    const n = Vv(t.F);
    Ka(n, "SID", t.I), Ka(n, "RID", r), Ka(n, "AID", t.T), DI(t, n), t.o && t.s && Mee(n, t.o, t.s), r = new AI(t, t.j, r, t.C + 1), t.o === null && (r.H = t.s), e && (t.i = e.D.concat(t.i)), e = ZTe(t, r, 1e3), r.setTimeout(Math.round(.5 * t.ta) + Math.round(.5 * t.ta * Math.random())), kee(t.h, r), oY(r, n, e)
}

function DI(t, e) {
    t.ia && yee(t.ia, function (r, n) {
        Ka(e, n, r)
    }), t.l && PTe({}, function (r, n) {
        Ka(e, n, r)
    })
}

function ZTe(t, e, r) {
    r = Math.min(t.i.length, r);
    var n = t.l ? Cl(t.l.Ra, t.l, t) : null;
    e:{
        var i = t.i;
        let a = -1;
        for (; ;) {
            const o = ["count=" + r];
            a == -1 ? 0 < r ? (a = i[0].h, o.push("ofs=" + a)) : a = 0 : o.push("ofs=" + a);
            let s = !0;
            for (let l = 0; l < r; l++) {
                let f = i[l].h;
                const d = i[l].g;
                if (f -= a, 0 > f) a = Math.max(0, i[l].h - 100), s = !1; else try {
                    _Bt(d, o, "req" + f + "_")
                } catch {
                    n && n(d)
                }
            }
            if (s) {
                n = o.join("&");
                break e
            }
        }
    }
    return t = t.i.splice(0, r), e.D = t, n
}

function JTe(t) {
    t.g || t.u || (t.Z = 1, bTe(t.Ia, t), t.A = 0)
}

function Pee(t) {
    return t.g || t.u || 3 <= t.A ? !1 : (t.Z++, t.u = TI(Cl(t.Ia, t), rCe(t, t.A)), t.A++, !0)
}

Rr.Ia = function () {
    if (this.u = null, eCe(this), this.$ && !(this.K || this.g == null || 0 >= this.P)) {
        var t = 2 * this.P;
        this.j.info("BP detection timer enabled: " + t), this.B = TI(Cl(this.eb, this), t)
    }
};
Rr.eb = function () {
    this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.L = !1, this.K = !0, lu(10), FL(this), eCe(this))
};

function Nee(t) {
    t.B != null && (yn.clearTimeout(t.B), t.B = null)
}

function eCe(t) {
    t.g = new AI(t, t.j, "rpc", t.Z), t.o === null && (t.g.H = t.s), t.g.N = 0;
    var e = Vv(t.sa);
    Ka(e, "RID", "rpc"), Ka(e, "SID", t.I), Ka(e, "CI", t.L ? "0" : "1"), Ka(e, "AID", t.T), Ka(e, "TYPE", "xmlhttp"), DI(t, e), t.o && t.s && Mee(e, t.o, t.s), t.J && t.g.setTimeout(t.J);
    var r = t.g;
    t = t.ka, r.K = 1, r.v = LL(Vv(e)), r.s = null, r.P = !0, RTe(r, t)
}

Rr.cb = function () {
    this.v != null && (this.v = null, FL(this), Pee(this), lu(19))
};

function sP(t) {
    t.v != null && (yn.clearTimeout(t.v), t.v = null)
}

function tCe(t, e) {
    var r = null;
    if (t.g == e) {
        sP(t), Nee(t), t.g = null;
        var n = 2
    } else if (cY(t.h, e)) r = e.D, zTe(t.h, e), n = 1; else return;
    if (t.G != 0) {
        if (t.pa = e.Y, e.i) if (n == 1) {
            r = e.s ? e.s.length : 0, e = Date.now() - e.F;
            var i = t.C;
            n = ML(), Wc(n, new CTe(n, r)), UL(t)
        } else JTe(t); else if (i = e.o, i == 3 || i == 0 && 0 < t.pa || !(n == 1 && IBt(t, e) || n == 2 && Pee(t))) switch (r && 0 < r.length && (e = t.h, e.i = e.i.concat(r)), i) {
            case 1:
                Ow(t, 5);
                break;
            case 4:
                Ow(t, 10);
                break;
            case 3:
                Ow(t, 6);
                break;
            default:
                Ow(t, 2)
        }
    }
}

function rCe(t, e) {
    let r = t.Xa + Math.floor(Math.random() * t.bb);
    return t.l || (r *= 2), r * e
}

function Ow(t, e) {
    if (t.j.info("Error code " + e), e == 2) {
        var r = null;
        t.l && (r = null);
        var n = Cl(t.kb, t);
        r || (r = new Yw("//www.google.com/images/cleardot.gif"), yn.location && yn.location.protocol == "http" || aP(r, "https"), LL(r)), xBt(r.toString(), n)
    } else lu(2);
    t.G = 0, t.l && t.l.va(e), nCe(t), QTe(t)
}

Rr.kb = function (t) {
    t ? (this.j.info("Successfully pinged google.com"), lu(2)) : (this.j.info("Failed to ping google.com"), lu(1))
};

function nCe(t) {
    if (t.G = 0, t.la = [], t.l) {
        const e = VTe(t.h);
        (e.length != 0 || t.i.length != 0) && (n0e(t.la, e), n0e(t.la, t.i), t.h.i.length = 0, mee(t.i), t.i.length = 0), t.l.ua()
    }
}

function iCe(t, e, r) {
    var n = r instanceof Yw ? Vv(r) : new Yw(r, void 0);
    if (n.g != "") e && (n.g = e + "." + n.g), oP(n, n.m); else {
        var i = yn.location;
        n = i.protocol, e = e ? e + "." + i.hostname : i.hostname, i = +i.port;
        var a = new Yw(null, void 0);
        n && aP(a, n), e && (a.g = e), i && oP(a, i), r && (a.l = r), n = a
    }
    return r = t.D, e = t.za, r && e && Ka(n, r, e), Ka(n, "VER", t.ma), DI(t, n), n
}

function aCe(t, e, r) {
    if (e && !t.H) throw Error("Can't create secondary domain capable XhrIo object.");
    return e = r && t.Da && !t.ra ? new Do(new kI({jb: !0})) : new Do(t.ra), e.Ka(t.H), e
}

function oCe() {
}

Rr = oCe.prototype;
Rr.xa = function () {
};
Rr.wa = function () {
};
Rr.va = function () {
};
Rr.ua = function () {
};
Rr.Ra = function () {
};

function cP() {
    if (hE && !(10 <= Number(WLt))) throw Error("Environmental error: no available transport.")
}

cP.prototype.g = function (t, e) {
    return new Xf(t, e)
};

function Xf(t, e) {
    rc.call(this), this.g = new XTe(e), this.l = t, this.h = e && e.messageUrlParams || null, t = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (t ? t["X-Client-Protocol"] = "webchannel" : t = {"X-Client-Protocol": "webchannel"}), this.g.s = t, t = e && e.initMessageHeaders || null, e && e.messageContentType && (t ? t["X-WebChannel-Content-Type"] = e.messageContentType : t = {"X-WebChannel-Content-Type": e.messageContentType}), e && e.ya && (t ? t["X-WebChannel-Client-Profile"] = e.ya : t = {"X-WebChannel-Client-Profile": e.ya}), this.g.S = t, (t = e && e.Yb) && !rP(t) && (this.g.o = t), this.A = e && e.supportsCrossDomainXhr || !1, this.v = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !rP(e) && (this.g.D = e, t = this.h, t !== null && e in t && (t = this.h, e in t && delete t[e])), this.j = new l3(this)
}

Kc(Xf, rc);
Xf.prototype.m = function () {
    this.g.l = this.j, this.A && (this.g.H = !0);
    var t = this.g, e = this.l, r = this.h || void 0;
    lu(0), t.V = e, t.ia = r || {}, t.L = t.Y, t.F = iCe(t, null, t.V), UL(t)
};
Xf.prototype.close = function () {
    Oee(this.g)
};
Xf.prototype.u = function (t) {
    var e = this.g;
    if (typeof t == "string") {
        var r = {};
        r.__data__ = t, t = r
    } else this.v && (r = {}, r.__data__ = xee(t), t = r);
    e.i.push(new bBt(e.ab++, t)), e.G == 3 && UL(e)
};
Xf.prototype.M = function () {
    this.g.l = null, delete this.j, Oee(this.g), delete this.g, Xf.X.M.call(this)
};

function sCe(t) {
    Aee.call(this);
    var e = t.__sm__;
    if (e) {
        e:{
            for (const r in e) {
                t = r;
                break e
            }
            t = void 0
        }
        (this.i = t) && (t = this.i, e = e !== null && t in e ? e[t] : void 0), this.data = e
    } else this.data = t
}

Kc(sCe, Aee);

function cCe() {
    Iee.call(this), this.status = 1
}

Kc(cCe, Iee);

function l3(t) {
    this.g = t
}

Kc(l3, oCe);
l3.prototype.xa = function () {
    Wc(this.g, "a")
};
l3.prototype.wa = function (t) {
    Wc(this.g, new sCe(t))
};
l3.prototype.va = function (t) {
    Wc(this.g, new cCe)
};
l3.prototype.ua = function () {
    Wc(this.g, "b")
};
cP.prototype.createWebChannel = cP.prototype.g;
Xf.prototype.send = Xf.prototype.u;
Xf.prototype.open = Xf.prototype.m;
Xf.prototype.close = Xf.prototype.close;
OL.NO_ERROR = 0;
OL.TIMEOUT = 8;
OL.HTTP_ERROR = 6;
ATe.COMPLETE = "complete";
ITe.EventType = CI;
CI.OPEN = "a";
CI.CLOSE = "b";
CI.ERROR = "c";
CI.MESSAGE = "d";
rc.prototype.listen = rc.prototype.N;
Do.prototype.listenOnce = Do.prototype.O;
Do.prototype.getLastError = Do.prototype.Oa;
Do.prototype.getLastErrorCode = Do.prototype.Ea;
Do.prototype.getStatus = Do.prototype.aa;
Do.prototype.getResponseJson = Do.prototype.Sa;
Do.prototype.getResponseText = Do.prototype.fa;
Do.prototype.send = Do.prototype.da;
Do.prototype.setWithCredentials = Do.prototype.Ka;
var kBt = function () {
    return new cP
}, RBt = function () {
    return ML()
}, HH = OL, DBt = ATe, MBt = QS, m0e = {
    sb: 0,
    vb: 1,
    wb: 2,
    Pb: 3,
    Ub: 4,
    Rb: 5,
    Sb: 6,
    Qb: 7,
    Ob: 8,
    Tb: 9,
    PROXY: 10,
    NOPROXY: 11,
    Mb: 12,
    Ib: 13,
    Jb: 14,
    Hb: 15,
    Kb: 16,
    Lb: 17,
    ob: 18,
    nb: 19,
    pb: 20
}, OBt = kI, W7 = ITe, PBt = Do;
const v0e = "@firebase/firestore";

class Qs {
    constructor(e) {
        this.uid = e
    }

    isAuthenticated() {
        return this.uid != null
    }

    toKey() {
        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
    }

    isEqual(e) {
        return e.uid === this.uid
    }
}

Qs.UNAUTHENTICATED = new Qs(null), Qs.GOOGLE_CREDENTIALS = new Qs("google-credentials-uid"), Qs.FIRST_PARTY = new Qs("first-party-uid"), Qs.MOCK_USER = new Qs("mock-user");
let u3 = "9.17.1";
const a1 = new dee("@firebase/firestore");

function lY() {
    return a1.logLevel
}

function NBt(t) {
    a1.setLogLevel(t)
}

function It(t, ...e) {
    if (a1.logLevel <= Ri.DEBUG) {
        const r = e.map(Lee);
        a1.debug(`Firestore (${u3}): ${t}`, ...r)
    }
}

function Vo(t, ...e) {
    if (a1.logLevel <= Ri.ERROR) {
        const r = e.map(Lee);
        a1.error(`Firestore (${u3}): ${t}`, ...r)
    }
}

function bS(t, ...e) {
    if (a1.logLevel <= Ri.WARN) {
        const r = e.map(Lee);
        a1.warn(`Firestore (${u3}): ${t}`, ...r)
    }
}

function Lee(t) {
    if (typeof t == "string") return t;
    try {
        return e = t, JSON.stringify(e)
    } catch {
        return t
    }
    var e
}

function lr(t = "Unexpected state") {
    const e = `FIRESTORE (${u3}) INTERNAL ASSERTION FAILED: ` + t;
    throw Vo(e), new Error(e)
}

function Er(t, e) {
    t || lr()
}

function LBt(t, e) {
    t || lr()
}

function Ht(t, e) {
    return t
}

const at = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
};

class yt extends tg {
    constructor(e, r) {
        super(e, r), this.code = e, this.message = r, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
    }
}

class Ls {
    constructor() {
        this.promise = new Promise((e, r) => {
            this.resolve = e, this.reject = r
        })
    }
}

class lCe {
    constructor(e, r) {
        this.user = r, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${e}`)
    }
}

class uCe {
    getToken() {
        return Promise.resolve(null)
    }

    invalidateToken() {
    }

    start(e, r) {
        e.enqueueRetryable(() => r(Qs.UNAUTHENTICATED))
    }

    shutdown() {
    }
}

class BBt {
    constructor(e) {
        this.token = e, this.changeListener = null
    }

    getToken() {
        return Promise.resolve(this.token)
    }

    invalidateToken() {
    }

    start(e, r) {
        this.changeListener = r, e.enqueueRetryable(() => r(this.token.user))
    }

    shutdown() {
        this.changeListener = null
    }
}

class $Bt {
    constructor(e) {
        this.t = e, this.currentUser = Qs.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null
    }

    start(e, r) {
        let n = this.i;
        const i = l => this.i !== n ? (n = this.i, r(l)) : Promise.resolve();
        let a = new Ls;
        this.o = () => {
            this.i++, this.currentUser = this.u(), a.resolve(), a = new Ls, e.enqueueRetryable(() => i(this.currentUser))
        };
        const o = () => {
            const l = a;
            e.enqueueRetryable(async () => {
                await l.promise, await i(this.currentUser)
            })
        }, s = l => {
            It("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = l, this.auth.addAuthTokenListener(this.o), o()
        };
        this.t.onInit(l => s(l)), setTimeout(() => {
            if (!this.auth) {
                const l = this.t.getImmediate({optional: !0});
                l ? s(l) : (It("FirebaseAuthCredentialsProvider", "Auth not yet detected"), a.resolve(), a = new Ls)
            }
        }, 0), o()
    }

    getToken() {
        const e = this.i, r = this.forceRefresh;
        return this.forceRefresh = !1, this.auth ? this.auth.getToken(r).then(n => this.i !== e ? (It("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : n ? (Er(typeof n.accessToken == "string"), new lCe(n.accessToken, this.currentUser)) : null) : Promise.resolve(null)
    }

    invalidateToken() {
        this.forceRefresh = !0
    }

    shutdown() {
        this.auth && this.auth.removeAuthTokenListener(this.o)
    }

    u() {
        const e = this.auth && this.auth.getUid();
        return Er(e === null || typeof e == "string"), new Qs(e)
    }
}

class FBt {
    constructor(e, r, n, i) {
        this.h = e, this.l = r, this.m = n, this.g = i, this.type = "FirstParty", this.user = Qs.FIRST_PARTY, this.p = new Map
    }

    I() {
        return this.g ? this.g() : (Er(!(typeof this.h != "object" || this.h === null || !this.h.auth || !this.h.auth.getAuthHeaderValueForFirstParty)), this.h.auth.getAuthHeaderValueForFirstParty([]))
    }

    get headers() {
        this.p.set("X-Goog-AuthUser", this.l);
        const e = this.I();
        return e && this.p.set("Authorization", e), this.m && this.p.set("X-Goog-Iam-Authorization-Token", this.m), this.p
    }
}

class UBt {
    constructor(e, r, n, i) {
        this.h = e, this.l = r, this.m = n, this.g = i
    }

    getToken() {
        return Promise.resolve(new FBt(this.h, this.l, this.m, this.g))
    }

    start(e, r) {
        e.enqueueRetryable(() => r(Qs.FIRST_PARTY))
    }

    shutdown() {
    }

    invalidateToken() {
    }
}

class fCe {
    constructor(e) {
        this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
    }
}

class jBt {
    constructor(e) {
        this.T = e, this.forceRefresh = !1, this.appCheck = null, this.A = null
    }

    start(e, r) {
        const n = a => {
            a.error != null && It("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${a.error.message}`);
            const o = a.token !== this.A;
            return this.A = a.token, It("FirebaseAppCheckTokenProvider", `Received ${o ? "new" : "existing"} token.`), o ? r(a.token) : Promise.resolve()
        };
        this.o = a => {
            e.enqueueRetryable(() => n(a))
        };
        const i = a => {
            It("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = a, this.appCheck.addTokenListener(this.o)
        };
        this.T.onInit(a => i(a)), setTimeout(() => {
            if (!this.appCheck) {
                const a = this.T.getImmediate({optional: !0});
                a ? i(a) : It("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
            }
        }, 0)
    }

    getToken() {
        const e = this.forceRefresh;
        return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then(r => r ? (Er(typeof r.token == "string"), this.A = r.token, new fCe(r.token)) : null) : Promise.resolve(null)
    }

    invalidateToken() {
        this.forceRefresh = !0
    }

    shutdown() {
        this.appCheck && this.appCheck.removeTokenListener(this.o)
    }
}

class zBt {
    getToken() {
        return Promise.resolve(new fCe(""))
    }

    invalidateToken() {
    }

    start(e, r) {
    }

    shutdown() {
    }
}

function VBt(t) {
    const e = typeof self < "u" && (self.crypto || self.msCrypto), r = new Uint8Array(t);
    if (e && typeof e.getRandomValues == "function") e.getRandomValues(r); else for (let n = 0; n < t; n++) r[n] = Math.floor(256 * Math.random());
    return r
}

class dCe {
    static R() {
        const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
            r = Math.floor(256 / e.length) * e.length;
        let n = "";
        for (; n.length < 20;) {
            const i = VBt(40);
            for (let a = 0; a < i.length; ++a) n.length < 20 && i[a] < r && (n += e.charAt(i[a] % e.length))
        }
        return n
    }
}

function gn(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
}

function pE(t, e, r) {
    return t.length === e.length && t.every((n, i) => r(n, e[i]))
}

function hCe(t) {
    return t + "\0"
}

class Ca {
    constructor(e, r) {
        if (this.seconds = e, this.nanoseconds = r, r < 0) throw new yt(at.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + r);
        if (r >= 1e9) throw new yt(at.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + r);
        if (e < -62135596800) throw new yt(at.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
        if (e >= 253402300800) throw new yt(at.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e)
    }

    static now() {
        return Ca.fromMillis(Date.now())
    }

    static fromDate(e) {
        return Ca.fromMillis(e.getTime())
    }

    static fromMillis(e) {
        const r = Math.floor(e / 1e3), n = Math.floor(1e6 * (e - 1e3 * r));
        return new Ca(r, n)
    }

    toDate() {
        return new Date(this.toMillis())
    }

    toMillis() {
        return 1e3 * this.seconds + this.nanoseconds / 1e6
    }

    _compareTo(e) {
        return this.seconds === e.seconds ? gn(this.nanoseconds, e.nanoseconds) : gn(this.seconds, e.seconds)
    }

    isEqual(e) {
        return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
    }

    toString() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
    }

    toJSON() {
        return {seconds: this.seconds, nanoseconds: this.nanoseconds}
    }

    valueOf() {
        const e = this.seconds - -62135596800;
        return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
    }
}

class Fr {
    constructor(e) {
        this.timestamp = e
    }

    static fromTimestamp(e) {
        return new Fr(e)
    }

    static min() {
        return new Fr(new Ca(0, 0))
    }

    static max() {
        return new Fr(new Ca(253402300799, 999999999))
    }

    compareTo(e) {
        return this.timestamp._compareTo(e.timestamp)
    }

    isEqual(e) {
        return this.timestamp.isEqual(e.timestamp)
    }

    toMicroseconds() {
        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
    }

    toString() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")"
    }

    toTimestamp() {
        return this.timestamp
    }
}

class qA {
    constructor(e, r, n) {
        r === void 0 ? r = 0 : r > e.length && lr(), n === void 0 ? n = e.length - r : n > e.length - r && lr(), this.segments = e, this.offset = r, this.len = n
    }

    get length() {
        return this.len
    }

    isEqual(e) {
        return qA.comparator(this, e) === 0
    }

    child(e) {
        const r = this.segments.slice(this.offset, this.limit());
        return e instanceof qA ? e.forEach(n => {
            r.push(n)
        }) : r.push(e), this.construct(r)
    }

    limit() {
        return this.offset + this.length
    }

    popFirst(e) {
        return e = e === void 0 ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e)
    }

    popLast() {
        return this.construct(this.segments, this.offset, this.length - 1)
    }

    firstSegment() {
        return this.segments[this.offset]
    }

    lastSegment() {
        return this.get(this.length - 1)
    }

    get(e) {
        return this.segments[this.offset + e]
    }

    isEmpty() {
        return this.length === 0
    }

    isPrefixOf(e) {
        if (e.length < this.length) return !1;
        for (let r = 0; r < this.length; r++) if (this.get(r) !== e.get(r)) return !1;
        return !0
    }

    isImmediateParentOf(e) {
        if (this.length + 1 !== e.length) return !1;
        for (let r = 0; r < this.length; r++) if (this.get(r) !== e.get(r)) return !1;
        return !0
    }

    forEach(e) {
        for (let r = this.offset, n = this.limit(); r < n; r++) e(this.segments[r])
    }

    toArray() {
        return this.segments.slice(this.offset, this.limit())
    }

    static comparator(e, r) {
        const n = Math.min(e.length, r.length);
        for (let i = 0; i < n; i++) {
            const a = e.get(i), o = r.get(i);
            if (a < o) return -1;
            if (a > o) return 1
        }
        return e.length < r.length ? -1 : e.length > r.length ? 1 : 0
    }
}

class Ei extends qA {
    construct(e, r, n) {
        return new Ei(e, r, n)
    }

    canonicalString() {
        return this.toArray().join("/")
    }

    toString() {
        return this.canonicalString()
    }

    static fromString(...e) {
        const r = [];
        for (const n of e) {
            if (n.indexOf("//") >= 0) throw new yt(at.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
            r.push(...n.split("/").filter(i => i.length > 0))
        }
        return new Ei(r)
    }

    static emptyPath() {
        return new Ei([])
    }
}

const HBt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;

class Io extends qA {
    construct(e, r, n) {
        return new Io(e, r, n)
    }

    static isValidIdentifier(e) {
        return HBt.test(e)
    }

    canonicalString() {
        return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Io.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".")
    }

    toString() {
        return this.canonicalString()
    }

    isKeyField() {
        return this.length === 1 && this.get(0) === "__name__"
    }

    static keyField() {
        return new Io(["__name__"])
    }

    static fromServerFormat(e) {
        const r = [];
        let n = "", i = 0;
        const a = () => {
            if (n.length === 0) throw new yt(at.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
            r.push(n), n = ""
        };
        let o = !1;
        for (; i < e.length;) {
            const s = e[i];
            if (s === "\\") {
                if (i + 1 === e.length) throw new yt(at.INVALID_ARGUMENT, "Path has trailing escape character: " + e);
                const l = e[i + 1];
                if (l !== "\\" && l !== "." && l !== "`") throw new yt(at.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e);
                n += l, i += 2
            } else s === "`" ? (o = !o, i++) : s !== "." || o ? (n += s, i++) : (a(), i++)
        }
        if (a(), o) throw new yt(at.INVALID_ARGUMENT, "Unterminated ` in path: " + e);
        return new Io(r)
    }

    static emptyPath() {
        return new Io([])
    }
}

class jt {
    constructor(e) {
        this.path = e
    }

    static fromPath(e) {
        return new jt(Ei.fromString(e))
    }

    static fromName(e) {
        return new jt(Ei.fromString(e).popFirst(5))
    }

    static empty() {
        return new jt(Ei.emptyPath())
    }

    get collectionGroup() {
        return this.path.popLast().lastSegment()
    }

    hasCollectionId(e) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
    }

    getCollectionGroup() {
        return this.path.get(this.path.length - 2)
    }

    getCollectionPath() {
        return this.path.popLast()
    }

    isEqual(e) {
        return e !== null && Ei.comparator(this.path, e.path) === 0
    }

    toString() {
        return this.path.toString()
    }

    static comparator(e, r) {
        return Ei.comparator(e.path, r.path)
    }

    static isDocumentKey(e) {
        return e.length % 2 == 0
    }

    static fromSegments(e) {
        return new jt(new Ei(e.slice()))
    }
}

class lP {
    constructor(e, r, n, i) {
        this.indexId = e, this.collectionGroup = r, this.fields = n, this.indexState = i
    }
}

function uY(t) {
    return t.fields.find(e => e.kind === 2)
}

function sw(t) {
    return t.fields.filter(e => e.kind !== 2)
}

function WBt(t, e) {
    let r = gn(t.collectionGroup, e.collectionGroup);
    if (r !== 0) return r;
    for (let n = 0; n < Math.min(t.fields.length, e.fields.length); ++n) if (r = qBt(t.fields[n], e.fields[n]), r !== 0) return r;
    return gn(t.fields.length, e.fields.length)
}

lP.UNKNOWN_ID = -1;

class sM {
    constructor(e, r) {
        this.fieldPath = e, this.kind = r
    }
}

function qBt(t, e) {
    const r = Io.comparator(t.fieldPath, e.fieldPath);
    return r !== 0 ? r : gn(t.kind, e.kind)
}

class GA {
    constructor(e, r) {
        this.sequenceNumber = e, this.offset = r
    }

    static empty() {
        return new GA(0, Qf.min())
    }
}

function pCe(t, e) {
    const r = t.toTimestamp().seconds, n = t.toTimestamp().nanoseconds + 1,
        i = Fr.fromTimestamp(n === 1e9 ? new Ca(r + 1, 0) : new Ca(r, n));
    return new Qf(i, jt.empty(), e)
}

function mCe(t) {
    return new Qf(t.readTime, t.key, -1)
}

class Qf {
    constructor(e, r, n) {
        this.readTime = e, this.documentKey = r, this.largestBatchId = n
    }

    static min() {
        return new Qf(Fr.min(), jt.empty(), -1)
    }

    static max() {
        return new Qf(Fr.max(), jt.empty(), -1)
    }
}

function Bee(t, e) {
    let r = t.readTime.compareTo(e.readTime);
    return r !== 0 ? r : (r = jt.comparator(t.documentKey, e.documentKey), r !== 0 ? r : gn(t.largestBatchId, e.largestBatchId))
}

const vCe = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";

class gCe {
    constructor() {
        this.onCommittedListeners = []
    }

    addOnCommittedListener(e) {
        this.onCommittedListeners.push(e)
    }

    raiseOnCommittedEvent() {
        this.onCommittedListeners.forEach(e => e())
    }
}

async function k1(t) {
    if (t.code !== at.FAILED_PRECONDITION || t.message !== vCe) throw t;
    It("LocalStore", "Unexpectedly lost primary lease")
}

class Je {
    constructor(e) {
        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e(r => {
            this.isDone = !0, this.result = r, this.nextCallback && this.nextCallback(r)
        }, r => {
            this.isDone = !0, this.error = r, this.catchCallback && this.catchCallback(r)
        })
    }

    catch(e) {
        return this.next(void 0, e)
    }

    next(e, r) {
        return this.callbackAttached && lr(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(r, this.error) : this.wrapSuccess(e, this.result) : new Je((n, i) => {
            this.nextCallback = a => {
                this.wrapSuccess(e, a).next(n, i)
            }, this.catchCallback = a => {
                this.wrapFailure(r, a).next(n, i)
            }
        })
    }

    toPromise() {
        return new Promise((e, r) => {
            this.next(e, r)
        })
    }

    wrapUserFunction(e) {
        try {
            const r = e();
            return r instanceof Je ? r : Je.resolve(r)
        } catch (r) {
            return Je.reject(r)
        }
    }

    wrapSuccess(e, r) {
        return e ? this.wrapUserFunction(() => e(r)) : Je.resolve(r)
    }

    wrapFailure(e, r) {
        return e ? this.wrapUserFunction(() => e(r)) : Je.reject(r)
    }

    static resolve(e) {
        return new Je((r, n) => {
            r(e)
        })
    }

    static reject(e) {
        return new Je((r, n) => {
            n(e)
        })
    }

    static waitFor(e) {
        return new Je((r, n) => {
            let i = 0, a = 0, o = !1;
            e.forEach(s => {
                ++i, s.next(() => {
                    ++a, o && a === i && r()
                }, l => n(l))
            }), o = !0, a === i && r()
        })
    }

    static or(e) {
        let r = Je.resolve(!1);
        for (const n of e) r = r.next(i => i ? Je.resolve(i) : n());
        return r
    }

    static forEach(e, r) {
        const n = [];
        return e.forEach((i, a) => {
            n.push(r.call(this, i, a))
        }), this.waitFor(n)
    }

    static mapArray(e, r) {
        return new Je((n, i) => {
            const a = e.length, o = new Array(a);
            let s = 0;
            for (let l = 0; l < a; l++) {
                const f = l;
                r(e[f]).next(d => {
                    o[f] = d, ++s, s === a && n(o)
                }, d => i(d))
            }
        })
    }

    static doWhile(e, r) {
        return new Je((n, i) => {
            const a = () => {
                e() === !0 ? r().next(() => {
                    a()
                }, i) : n()
            };
            a()
        })
    }
}

class jL {
    constructor(e, r) {
        this.action = e, this.transaction = r, this.aborted = !1, this.P = new Ls, this.transaction.oncomplete = () => {
            this.P.resolve()
        }, this.transaction.onabort = () => {
            r.error ? this.P.reject(new EC(e, r.error)) : this.P.resolve()
        }, this.transaction.onerror = n => {
            const i = $ee(n.target.error);
            this.P.reject(new EC(e, i))
        }
    }

    static open(e, r, n, i) {
        try {
            return new jL(r, e.transaction(i, n))
        } catch (a) {
            throw new EC(r, a)
        }
    }

    get v() {
        return this.P.promise
    }

    abort(e) {
        e && this.P.reject(e), this.aborted || (It("SimpleDb", "Aborting transaction:", e ? e.message : "Client-initiated abort"), this.aborted = !0, this.transaction.abort())
    }

    V() {
        const e = this.transaction;
        this.aborted || typeof e.commit != "function" || e.commit()
    }

    store(e) {
        const r = this.transaction.objectStore(e);
        return new KBt(r)
    }
}

class np {
    constructor(e, r, n) {
        this.name = e, this.version = r, this.S = n, np.D($s()) === 12.2 && Vo("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.")
    }

    static delete(e) {
        return It("SimpleDb", "Removing database:", e), gw(window.indexedDB.deleteDatabase(e)).toPromise()
    }

    static C() {
        if (!eTe()) return !1;
        if (np.N()) return !0;
        const e = $s(), r = np.D(e), n = 0 < r && r < 10, i = np.k(e), a = 0 < i && i < 4.5;
        return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || n || a)
    }

    static N() {
        var e;
        return typeof Ve < "u" && ((e = Ve.env) === null || e === void 0 ? void 0 : e.O) === "YES"
    }

    static M(e, r) {
        return e.store(r)
    }

    static D(e) {
        const r = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = r ? r[1].split("_").slice(0, 2).join(".") : "-1";
        return Number(n)
    }

    static k(e) {
        const r = e.match(/Android ([\d.]+)/i), n = r ? r[1].split(".").slice(0, 2).join(".") : "-1";
        return Number(n)
    }

    async F(e) {
        return this.db || (It("SimpleDb", "Opening database:", this.name), this.db = await new Promise((r, n) => {
            const i = indexedDB.open(this.name, this.version);
            i.onsuccess = a => {
                const o = a.target.result;
                r(o)
            }, i.onblocked = () => {
                n(new EC(e, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."))
            }, i.onerror = a => {
                const o = a.target.error;
                o.name === "VersionError" ? n(new yt(at.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : o.name === "InvalidStateError" ? n(new yt(at.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + o)) : n(new EC(e, o))
            }, i.onupgradeneeded = a => {
                It("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', a.oldVersion);
                const o = a.target.result;
                this.S.$(o, i.transaction, a.oldVersion, this.version).next(() => {
                    It("SimpleDb", "Database upgrade to version " + this.version + " complete")
                })
            }
        })), this.B && (this.db.onversionchange = r => this.B(r)), this.db
    }

    L(e) {
        this.B = e, this.db && (this.db.onversionchange = r => e(r))
    }

    async runTransaction(e, r, n, i) {
        const a = r === "readonly";
        let o = 0;
        for (; ;) {
            ++o;
            try {
                this.db = await this.F(e);
                const s = jL.open(this.db, e, a ? "readonly" : "readwrite", n),
                    l = i(s).next(f => (s.V(), f)).catch(f => (s.abort(f), Je.reject(f))).toPromise();
                return l.catch(() => {
                }), await s.v, l
            } catch (s) {
                const l = s, f = l.name !== "FirebaseError" && o < 3;
                if (It("SimpleDb", "Transaction failed with error:", l.message, "Retrying:", f), this.close(), !f) return Promise.reject(l)
            }
        }
    }

    close() {
        this.db && this.db.close(), this.db = void 0
    }
}

class GBt {
    constructor(e) {
        this.q = e, this.U = !1, this.K = null
    }

    get isDone() {
        return this.U
    }

    get G() {
        return this.K
    }

    set cursor(e) {
        this.q = e
    }

    done() {
        this.U = !0
    }

    j(e) {
        this.K = e
    }

    delete() {
        return gw(this.q.delete())
    }
}

class EC extends yt {
    constructor(e, r) {
        super(at.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${r}`), this.name = "IndexedDbTransactionError"
    }
}

function R1(t) {
    return t.name === "IndexedDbTransactionError"
}

class KBt {
    constructor(e) {
        this.store = e
    }

    put(e, r) {
        let n;
        return r !== void 0 ? (It("SimpleDb", "PUT", this.store.name, e, r), n = this.store.put(r, e)) : (It("SimpleDb", "PUT", this.store.name, "<auto-key>", e), n = this.store.put(e)), gw(n)
    }

    add(e) {
        return It("SimpleDb", "ADD", this.store.name, e, e), gw(this.store.add(e))
    }

    get(e) {
        return gw(this.store.get(e)).next(r => (r === void 0 && (r = null), It("SimpleDb", "GET", this.store.name, e, r), r))
    }

    delete(e) {
        return It("SimpleDb", "DELETE", this.store.name, e), gw(this.store.delete(e))
    }

    count() {
        return It("SimpleDb", "COUNT", this.store.name), gw(this.store.count())
    }

    W(e, r) {
        const n = this.options(e, r);
        if (n.index || typeof this.store.getAll != "function") {
            const i = this.cursor(n), a = [];
            return this.H(i, (o, s) => {
                a.push(s)
            }).next(() => a)
        }
        {
            const i = this.store.getAll(n.range);
            return new Je((a, o) => {
                i.onerror = s => {
                    o(s.target.error)
                }, i.onsuccess = s => {
                    a(s.target.result)
                }
            })
        }
    }

    J(e, r) {
        const n = this.store.getAll(e, r === null ? void 0 : r);
        return new Je((i, a) => {
            n.onerror = o => {
                a(o.target.error)
            }, n.onsuccess = o => {
                i(o.target.result)
            }
        })
    }

    Y(e, r) {
        It("SimpleDb", "DELETE ALL", this.store.name);
        const n = this.options(e, r);
        n.X = !1;
        const i = this.cursor(n);
        return this.H(i, (a, o, s) => s.delete())
    }

    Z(e, r) {
        let n;
        r ? n = e : (n = {}, r = e);
        const i = this.cursor(n);
        return this.H(i, r)
    }

    tt(e) {
        const r = this.cursor({});
        return new Je((n, i) => {
            r.onerror = a => {
                const o = $ee(a.target.error);
                i(o)
            }, r.onsuccess = a => {
                const o = a.target.result;
                o ? e(o.primaryKey, o.value).next(s => {
                    s ? o.continue() : n()
                }) : n()
            }
        })
    }

    H(e, r) {
        const n = [];
        return new Je((i, a) => {
            e.onerror = o => {
                a(o.target.error)
            }, e.onsuccess = o => {
                const s = o.target.result;
                if (!s) return void i();
                const l = new GBt(s), f = r(s.primaryKey, s.value, l);
                if (f instanceof Je) {
                    const d = f.catch(p => (l.done(), Je.reject(p)));
                    n.push(d)
                }
                l.isDone ? i() : l.G === null ? s.continue() : s.continue(l.G)
            }
        }).next(() => Je.waitFor(n))
    }

    options(e, r) {
        let n;
        return e !== void 0 && (typeof e == "string" ? n = e : r = e), {index: n, range: r}
    }

    cursor(e) {
        let r = "next";
        if (e.reverse && (r = "prev"), e.index) {
            const n = this.store.index(e.index);
            return e.X ? n.openKeyCursor(e.range, r) : n.openCursor(e.range, r)
        }
        return this.store.openCursor(e.range, r)
    }
}

function gw(t) {
    return new Je((e, r) => {
        t.onsuccess = n => {
            const i = n.target.result;
            e(i)
        }, t.onerror = n => {
            const i = $ee(n.target.error);
            r(i)
        }
    })
}

let g0e = !1;

function $ee(t) {
    const e = np.D($s());
    if (e >= 12.2 && e < 13) {
        const r = "An internal error was encountered in the Indexed Database server";
        if (t.message.indexOf(r) >= 0) {
            const n = new yt("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${r}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
            return g0e || (g0e = !0, setTimeout(() => {
                throw n
            }, 0)), n
        }
    }
    return t
}

class YBt {
    constructor(e, r) {
        this.asyncQueue = e, this.et = r, this.task = null
    }

    start() {
        this.nt(15e3)
    }

    stop() {
        this.task && (this.task.cancel(), this.task = null)
    }

    get started() {
        return this.task !== null
    }

    nt(e) {
        It("IndexBackiller", `Scheduled in ${e}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", e, async () => {
            this.task = null;
            try {
                It("IndexBackiller", `Documents written: ${await this.et.st()}`)
            } catch (r) {
                R1(r) ? It("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", r) : await k1(r)
            }
            await this.nt(6e4)
        })
    }
}

class XBt {
    constructor(e, r) {
        this.localStore = e, this.persistence = r
    }

    async st(e = 50) {
        return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", r => this.it(r, e))
    }

    it(e, r) {
        const n = new Set;
        let i = r, a = !0;
        return Je.doWhile(() => a === !0 && i > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next(o => {
            if (o !== null && !n.has(o)) return It("IndexBackiller", `Processing collection: ${o}`), this.rt(e, o, i).next(s => {
                i -= s, n.add(o)
            });
            a = !1
        })).next(() => r - i)
    }

    rt(e, r, n) {
        return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, r).next(i => this.localStore.localDocuments.getNextDocuments(e, r, i, n).next(a => {
            const o = a.changes;
            return this.localStore.indexManager.updateIndexEntries(e, o).next(() => this.ot(i, a)).next(s => (It("IndexBackiller", `Updating offset: ${s}`), this.localStore.indexManager.updateCollectionGroup(e, r, s))).next(() => o.size)
        }))
    }

    ot(e, r) {
        let n = e;
        return r.changes.forEach((i, a) => {
            const o = mCe(a);
            Bee(o, n) > 0 && (n = o)
        }), new Qf(n.readTime, n.documentKey, Math.max(r.batchId, e.largestBatchId))
    }
}

class Xu {
    constructor(e, r) {
        this.previousValue = e, r && (r.sequenceNumberHandler = n => this.ut(n), this.ct = n => r.writeSequenceNumber(n))
    }

    ut(e) {
        return this.previousValue = Math.max(e, this.previousValue), this.previousValue
    }

    next() {
        const e = ++this.previousValue;
        return this.ct && this.ct(e), e
    }
}

Xu.at = -1;

class QBt {
    constructor(e, r, n, i, a, o, s, l) {
        this.databaseId = e, this.appId = r, this.persistenceKey = n, this.host = i, this.ssl = a, this.forceLongPolling = o, this.autoDetectLongPolling = s, this.useFetchStreams = l
    }
}

class o1 {
    constructor(e, r) {
        this.projectId = e, this.database = r || "(default)"
    }

    static empty() {
        return new o1("", "")
    }

    get isDefaultDatabase() {
        return this.database === "(default)"
    }

    isEqual(e) {
        return e instanceof o1 && e.projectId === this.projectId && e.database === this.database
    }
}

function y0e(t) {
    let e = 0;
    for (const r in t) Object.prototype.hasOwnProperty.call(t, r) && e++;
    return e
}

function ZS(t, e) {
    for (const r in t) Object.prototype.hasOwnProperty.call(t, r) && e(r, t[r])
}

function yCe(t) {
    for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
    return !0
}

function MI(t) {
    return t == null
}

function KA(t) {
    return t === 0 && 1 / t == -1 / 0
}

function bCe(t) {
    return typeof t == "number" && Number.isInteger(t) && !KA(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER
}

function ZBt() {
    return typeof atob < "u"
}

class Fs {
    constructor(e) {
        this.binaryString = e
    }

    static fromBase64String(e) {
        const r = atob(e);
        return new Fs(r)
    }

    static fromUint8Array(e) {
        const r = function (n) {
            let i = "";
            for (let a = 0; a < n.length; ++a) i += String.fromCharCode(n[a]);
            return i
        }(e);
        return new Fs(r)
    }

    [Symbol.iterator]() {
        let e = 0;
        return {
            next: () => e < this.binaryString.length ? {
                value: this.binaryString.charCodeAt(e++),
                done: !1
            } : {value: void 0, done: !0}
        }
    }

    toBase64() {
        return e = this.binaryString, btoa(e);
        var e
    }

    toUint8Array() {
        return function (e) {
            const r = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n++) r[n] = e.charCodeAt(n);
            return r
        }(this.binaryString)
    }

    approximateByteSize() {
        return 2 * this.binaryString.length
    }

    compareTo(e) {
        return gn(this.binaryString, e.binaryString)
    }

    isEqual(e) {
        return this.binaryString === e.binaryString
    }
}

Fs.EMPTY_BYTE_STRING = new Fs("");
const JBt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);

function s1(t) {
    if (Er(!!t), typeof t == "string") {
        let e = 0;
        const r = JBt.exec(t);
        if (Er(!!r), r[1]) {
            let i = r[1];
            i = (i + "000000000").substr(0, 9), e = Number(i)
        }
        const n = new Date(t);
        return {seconds: Math.floor(n.getTime() / 1e3), nanos: e}
    }
    return {seconds: Co(t.seconds), nanos: Co(t.nanos)}
}

function Co(t) {
    return typeof t == "number" ? t : typeof t == "string" ? Number(t) : 0
}

function wS(t) {
    return typeof t == "string" ? Fs.fromBase64String(t) : Fs.fromUint8Array(t)
}

function Fee(t) {
    var e, r;
    return ((r = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || r === void 0 ? void 0 : r.stringValue) === "server_timestamp"
}

function wCe(t) {
    const e = t.mapValue.fields.__previous_value__;
    return Fee(e) ? wCe(e) : e
}

function YA(t) {
    const e = s1(t.mapValue.fields.__local_write_time__.timestampValue);
    return new Ca(e.seconds, e.nanos)
}

const My = {mapValue: {fields: {__type__: {stringValue: "__max__"}}}}, cM = {nullValue: "NULL_VALUE"};

function SS(t) {
    return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? Fee(t) ? 4 : SCe(t) ? 9007199254740991 : 10 : lr()
}

function K0(t, e) {
    if (t === e) return !0;
    const r = SS(t);
    if (r !== SS(e)) return !1;
    switch (r) {
        case 0:
        case 9007199254740991:
            return !0;
        case 1:
            return t.booleanValue === e.booleanValue;
        case 4:
            return YA(t).isEqual(YA(e));
        case 3:
            return function (n, i) {
                if (typeof n.timestampValue == "string" && typeof i.timestampValue == "string" && n.timestampValue.length === i.timestampValue.length) return n.timestampValue === i.timestampValue;
                const a = s1(n.timestampValue), o = s1(i.timestampValue);
                return a.seconds === o.seconds && a.nanos === o.nanos
            }(t, e);
        case 5:
            return t.stringValue === e.stringValue;
        case 6:
            return function (n, i) {
                return wS(n.bytesValue).isEqual(wS(i.bytesValue))
            }(t, e);
        case 7:
            return t.referenceValue === e.referenceValue;
        case 8:
            return function (n, i) {
                return Co(n.geoPointValue.latitude) === Co(i.geoPointValue.latitude) && Co(n.geoPointValue.longitude) === Co(i.geoPointValue.longitude)
            }(t, e);
        case 2:
            return function (n, i) {
                if ("integerValue" in n && "integerValue" in i) return Co(n.integerValue) === Co(i.integerValue);
                if ("doubleValue" in n && "doubleValue" in i) {
                    const a = Co(n.doubleValue), o = Co(i.doubleValue);
                    return a === o ? KA(a) === KA(o) : isNaN(a) && isNaN(o)
                }
                return !1
            }(t, e);
        case 9:
            return pE(t.arrayValue.values || [], e.arrayValue.values || [], K0);
        case 10:
            return function (n, i) {
                const a = n.mapValue.fields || {}, o = i.mapValue.fields || {};
                if (y0e(a) !== y0e(o)) return !1;
                for (const s in a) if (a.hasOwnProperty(s) && (o[s] === void 0 || !K0(a[s], o[s]))) return !1;
                return !0
            }(t, e);
        default:
            return lr()
    }
}

function XA(t, e) {
    return (t.values || []).find(r => K0(r, e)) !== void 0
}

function c1(t, e) {
    if (t === e) return 0;
    const r = SS(t), n = SS(e);
    if (r !== n) return gn(r, n);
    switch (r) {
        case 0:
        case 9007199254740991:
            return 0;
        case 1:
            return gn(t.booleanValue, e.booleanValue);
        case 2:
            return function (i, a) {
                const o = Co(i.integerValue || i.doubleValue), s = Co(a.integerValue || a.doubleValue);
                return o < s ? -1 : o > s ? 1 : o === s ? 0 : isNaN(o) ? isNaN(s) ? 0 : -1 : 1
            }(t, e);
        case 3:
            return b0e(t.timestampValue, e.timestampValue);
        case 4:
            return b0e(YA(t), YA(e));
        case 5:
            return gn(t.stringValue, e.stringValue);
        case 6:
            return function (i, a) {
                const o = wS(i), s = wS(a);
                return o.compareTo(s)
            }(t.bytesValue, e.bytesValue);
        case 7:
            return function (i, a) {
                const o = i.split("/"), s = a.split("/");
                for (let l = 0; l < o.length && l < s.length; l++) {
                    const f = gn(o[l], s[l]);
                    if (f !== 0) return f
                }
                return gn(o.length, s.length)
            }(t.referenceValue, e.referenceValue);
        case 8:
            return function (i, a) {
                const o = gn(Co(i.latitude), Co(a.latitude));
                return o !== 0 ? o : gn(Co(i.longitude), Co(a.longitude))
            }(t.geoPointValue, e.geoPointValue);
        case 9:
            return function (i, a) {
                const o = i.values || [], s = a.values || [];
                for (let l = 0; l < o.length && l < s.length; ++l) {
                    const f = c1(o[l], s[l]);
                    if (f) return f
                }
                return gn(o.length, s.length)
            }(t.arrayValue, e.arrayValue);
        case 10:
            return function (i, a) {
                if (i === My.mapValue && a === My.mapValue) return 0;
                if (i === My.mapValue) return 1;
                if (a === My.mapValue) return -1;
                const o = i.fields || {}, s = Object.keys(o), l = a.fields || {}, f = Object.keys(l);
                s.sort(), f.sort();
                for (let d = 0; d < s.length && d < f.length; ++d) {
                    const p = gn(s[d], f[d]);
                    if (p !== 0) return p;
                    const g = c1(o[s[d]], l[f[d]]);
                    if (g !== 0) return g
                }
                return gn(s.length, f.length)
            }(t.mapValue, e.mapValue);
        default:
            throw lr()
    }
}

function b0e(t, e) {
    if (typeof t == "string" && typeof e == "string" && t.length === e.length) return gn(t, e);
    const r = s1(t), n = s1(e), i = gn(r.seconds, n.seconds);
    return i !== 0 ? i : gn(r.nanos, n.nanos)
}

function mE(t) {
    return fY(t)
}

function fY(t) {
    return "nullValue" in t ? "null" : "booleanValue" in t ? "" + t.booleanValue : "integerValue" in t ? "" + t.integerValue : "doubleValue" in t ? "" + t.doubleValue : "timestampValue" in t ? function (n) {
        const i = s1(n);
        return `time(${i.seconds},${i.nanos})`
    }(t.timestampValue) : "stringValue" in t ? t.stringValue : "bytesValue" in t ? wS(t.bytesValue).toBase64() : "referenceValue" in t ? (r = t.referenceValue, jt.fromName(r).toString()) : "geoPointValue" in t ? `geo(${(e = t.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t ? function (n) {
        let i = "[", a = !0;
        for (const o of n.values || []) a ? a = !1 : i += ",", i += fY(o);
        return i + "]"
    }(t.arrayValue) : "mapValue" in t ? function (n) {
        const i = Object.keys(n.fields || {}).sort();
        let a = "{", o = !0;
        for (const s of i) o ? o = !1 : a += ",", a += `${s}:${fY(n.fields[s])}`;
        return a + "}"
    }(t.mapValue) : lr();
    var e, r
}

function _S(t, e) {
    return {referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${e.path.canonicalString()}`}
}

function dY(t) {
    return !!t && "integerValue" in t
}

function QA(t) {
    return !!t && "arrayValue" in t
}

function w0e(t) {
    return !!t && "nullValue" in t
}

function S0e(t) {
    return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue))
}

function lM(t) {
    return !!t && "mapValue" in t
}

function TC(t) {
    if (t.geoPointValue) return {geoPointValue: Object.assign({}, t.geoPointValue)};
    if (t.timestampValue && typeof t.timestampValue == "object") return {timestampValue: Object.assign({}, t.timestampValue)};
    if (t.mapValue) {
        const e = {mapValue: {fields: {}}};
        return ZS(t.mapValue.fields, (r, n) => e.mapValue.fields[r] = TC(n)), e
    }
    if (t.arrayValue) {
        const e = {arrayValue: {values: []}};
        for (let r = 0; r < (t.arrayValue.values || []).length; ++r) e.arrayValue.values[r] = TC(t.arrayValue.values[r]);
        return e
    }
    return Object.assign({}, t)
}

function SCe(t) {
    return (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__"
}

function e$t(t) {
    return "nullValue" in t ? cM : "booleanValue" in t ? {booleanValue: !1} : "integerValue" in t || "doubleValue" in t ? {doubleValue: NaN} : "timestampValue" in t ? {timestampValue: {seconds: Number.MIN_SAFE_INTEGER}} : "stringValue" in t ? {stringValue: ""} : "bytesValue" in t ? {bytesValue: ""} : "referenceValue" in t ? _S(o1.empty(), jt.empty()) : "geoPointValue" in t ? {
        geoPointValue: {
            latitude: -90,
            longitude: -180
        }
    } : "arrayValue" in t ? {arrayValue: {}} : "mapValue" in t ? {mapValue: {}} : lr()
}

function t$t(t) {
    return "nullValue" in t ? {booleanValue: !1} : "booleanValue" in t ? {doubleValue: NaN} : "integerValue" in t || "doubleValue" in t ? {timestampValue: {seconds: Number.MIN_SAFE_INTEGER}} : "timestampValue" in t ? {stringValue: ""} : "stringValue" in t ? {bytesValue: ""} : "bytesValue" in t ? _S(o1.empty(), jt.empty()) : "referenceValue" in t ? {
        geoPointValue: {
            latitude: -90,
            longitude: -180
        }
    } : "geoPointValue" in t ? {arrayValue: {}} : "arrayValue" in t ? {mapValue: {}} : "mapValue" in t ? My : lr()
}

function _0e(t, e) {
    const r = c1(t.value, e.value);
    return r !== 0 ? r : t.inclusive && !e.inclusive ? -1 : !t.inclusive && e.inclusive ? 1 : 0
}

function x0e(t, e) {
    const r = c1(t.value, e.value);
    return r !== 0 ? r : t.inclusive && !e.inclusive ? 1 : !t.inclusive && e.inclusive ? -1 : 0
}

class l1 {
    constructor(e, r) {
        this.position = e, this.inclusive = r
    }
}

function E0e(t, e, r) {
    let n = 0;
    for (let i = 0; i < t.position.length; i++) {
        const a = e[i], o = t.position[i];
        if (a.field.isKeyField() ? n = jt.comparator(jt.fromName(o.referenceValue), r.key) : n = c1(o, r.data.field(a.field)), a.dir === "desc" && (n *= -1), n !== 0) break
    }
    return n
}

function T0e(t, e) {
    if (t === null) return e === null;
    if (e === null || t.inclusive !== e.inclusive || t.position.length !== e.position.length) return !1;
    for (let r = 0; r < t.position.length; r++) if (!K0(t.position[r], e.position[r])) return !1;
    return !0
}

class _Ce {
}

class ci extends _Ce {
    constructor(e, r, n) {
        super(), this.field = e, this.op = r, this.value = n
    }

    static create(e, r, n) {
        return e.isKeyField() ? r === "in" || r === "not-in" ? this.createKeyFieldInFilter(e, r, n) : new r$t(e, r, n) : r === "array-contains" ? new a$t(e, n) : r === "in" ? new ICe(e, n) : r === "not-in" ? new o$t(e, n) : r === "array-contains-any" ? new s$t(e, n) : new ci(e, r, n)
    }

    static createKeyFieldInFilter(e, r, n) {
        return r === "in" ? new n$t(e, n) : new i$t(e, n)
    }

    matches(e) {
        const r = e.data.field(this.field);
        return this.op === "!=" ? r !== null && this.matchesComparison(c1(r, this.value)) : r !== null && SS(this.value) === SS(r) && this.matchesComparison(c1(r, this.value))
    }

    matchesComparison(e) {
        switch (this.op) {
            case"<":
                return e < 0;
            case"<=":
                return e <= 0;
            case"==":
                return e === 0;
            case"!=":
                return e !== 0;
            case">":
                return e > 0;
            case">=":
                return e >= 0;
            default:
                return lr()
        }
    }

    isInequality() {
        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0
    }

    getFlattenedFilters() {
        return [this]
    }

    getFilters() {
        return [this]
    }

    getFirstInequalityField() {
        return this.isInequality() ? this.field : null
    }
}

class ra extends _Ce {
    constructor(e, r) {
        super(), this.filters = e, this.op = r, this.ht = null
    }

    static create(e, r) {
        return new ra(e, r)
    }

    matches(e) {
        return vE(this) ? this.filters.find(r => !r.matches(e)) === void 0 : this.filters.find(r => r.matches(e)) !== void 0
    }

    getFlattenedFilters() {
        return this.ht !== null || (this.ht = this.filters.reduce((e, r) => e.concat(r.getFlattenedFilters()), [])), this.ht
    }

    getFilters() {
        return Object.assign([], this.filters)
    }

    getFirstInequalityField() {
        const e = this.lt(r => r.isInequality());
        return e !== null ? e.field : null
    }

    lt(e) {
        for (const r of this.getFlattenedFilters()) if (e(r)) return r;
        return null
    }
}

function vE(t) {
    return t.op === "and"
}

function hY(t) {
    return t.op === "or"
}

function Uee(t) {
    return xCe(t) && vE(t)
}

function xCe(t) {
    for (const e of t.filters) if (e instanceof ra) return !1;
    return !0
}

function pY(t) {
    if (t instanceof ci) return t.field.canonicalString() + t.op.toString() + mE(t.value);
    if (Uee(t)) return t.filters.map(e => pY(e)).join(",");
    {
        const e = t.filters.map(r => pY(r)).join(",");
        return `${t.op}(${e})`
    }
}

function ECe(t, e) {
    return t instanceof ci ? function (r, n) {
        return n instanceof ci && r.op === n.op && r.field.isEqual(n.field) && K0(r.value, n.value)
    }(t, e) : t instanceof ra ? function (r, n) {
        return n instanceof ra && r.op === n.op && r.filters.length === n.filters.length ? r.filters.reduce((i, a, o) => i && ECe(a, n.filters[o]), !0) : !1
    }(t, e) : void lr()
}

function TCe(t, e) {
    const r = t.filters.concat(e);
    return ra.create(r, t.op)
}

function CCe(t) {
    return t instanceof ci ? function (e) {
        return `${e.field.canonicalString()} ${e.op} ${mE(e.value)}`
    }(t) : t instanceof ra ? function (e) {
        return e.op.toString() + " {" + e.getFilters().map(CCe).join(" ,") + "}"
    }(t) : "Filter"
}

class r$t extends ci {
    constructor(e, r, n) {
        super(e, r, n), this.key = jt.fromName(n.referenceValue)
    }

    matches(e) {
        const r = jt.comparator(e.key, this.key);
        return this.matchesComparison(r)
    }
}

class n$t extends ci {
    constructor(e, r) {
        super(e, "in", r), this.keys = ACe("in", r)
    }

    matches(e) {
        return this.keys.some(r => r.isEqual(e.key))
    }
}

class i$t extends ci {
    constructor(e, r) {
        super(e, "not-in", r), this.keys = ACe("not-in", r)
    }

    matches(e) {
        return !this.keys.some(r => r.isEqual(e.key))
    }
}

function ACe(t, e) {
    var r;
    return (((r = e.arrayValue) === null || r === void 0 ? void 0 : r.values) || []).map(n => jt.fromName(n.referenceValue))
}

class a$t extends ci {
    constructor(e, r) {
        super(e, "array-contains", r)
    }

    matches(e) {
        const r = e.data.field(this.field);
        return QA(r) && XA(r.arrayValue, this.value)
    }
}

class ICe extends ci {
    constructor(e, r) {
        super(e, "in", r)
    }

    matches(e) {
        const r = e.data.field(this.field);
        return r !== null && XA(this.value.arrayValue, r)
    }
}

class o$t extends ci {
    constructor(e, r) {
        super(e, "not-in", r)
    }

    matches(e) {
        if (XA(this.value.arrayValue, {nullValue: "NULL_VALUE"})) return !1;
        const r = e.data.field(this.field);
        return r !== null && !XA(this.value.arrayValue, r)
    }
}

class s$t extends ci {
    constructor(e, r) {
        super(e, "array-contains-any", r)
    }

    matches(e) {
        const r = e.data.field(this.field);
        return !(!QA(r) || !r.arrayValue.values) && r.arrayValue.values.some(n => XA(this.value.arrayValue, n))
    }
}

class g4 {
    constructor(e, r = "asc") {
        this.field = e, this.dir = r
    }
}

function c$t(t, e) {
    return t.dir === e.dir && t.field.isEqual(e.field)
}

class Mo {
    constructor(e, r) {
        this.comparator = e, this.root = r || Bc.EMPTY
    }

    insert(e, r) {
        return new Mo(this.comparator, this.root.insert(e, r, this.comparator).copy(null, null, Bc.BLACK, null, null))
    }

    remove(e) {
        return new Mo(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Bc.BLACK, null, null))
    }

    get(e) {
        let r = this.root;
        for (; !r.isEmpty();) {
            const n = this.comparator(e, r.key);
            if (n === 0) return r.value;
            n < 0 ? r = r.left : n > 0 && (r = r.right)
        }
        return null
    }

    indexOf(e) {
        let r = 0, n = this.root;
        for (; !n.isEmpty();) {
            const i = this.comparator(e, n.key);
            if (i === 0) return r + n.left.size;
            i < 0 ? n = n.left : (r += n.left.size + 1, n = n.right)
        }
        return -1
    }

    isEmpty() {
        return this.root.isEmpty()
    }

    get size() {
        return this.root.size
    }

    minKey() {
        return this.root.minKey()
    }

    maxKey() {
        return this.root.maxKey()
    }

    inorderTraversal(e) {
        return this.root.inorderTraversal(e)
    }

    forEach(e) {
        this.inorderTraversal((r, n) => (e(r, n), !1))
    }

    toString() {
        const e = [];
        return this.inorderTraversal((r, n) => (e.push(`${r}:${n}`), !1)), `{${e.join(", ")}}`
    }

    reverseTraversal(e) {
        return this.root.reverseTraversal(e)
    }

    getIterator() {
        return new q7(this.root, null, this.comparator, !1)
    }

    getIteratorFrom(e) {
        return new q7(this.root, e, this.comparator, !1)
    }

    getReverseIterator() {
        return new q7(this.root, null, this.comparator, !0)
    }

    getReverseIteratorFrom(e) {
        return new q7(this.root, e, this.comparator, !0)
    }
}

class q7 {
    constructor(e, r, n, i) {
        this.isReverse = i, this.nodeStack = [];
        let a = 1;
        for (; !e.isEmpty();) if (a = r ? n(e.key, r) : 1, r && i && (a *= -1), a < 0) e = this.isReverse ? e.left : e.right; else {
            if (a === 0) {
                this.nodeStack.push(e);
                break
            }
            this.nodeStack.push(e), e = this.isReverse ? e.right : e.left
        }
    }

    getNext() {
        let e = this.nodeStack.pop();
        const r = {key: e.key, value: e.value};
        if (this.isReverse) for (e = e.left; !e.isEmpty();) this.nodeStack.push(e), e = e.right; else for (e = e.right; !e.isEmpty();) this.nodeStack.push(e), e = e.left;
        return r
    }

    hasNext() {
        return this.nodeStack.length > 0
    }

    peek() {
        if (this.nodeStack.length === 0) return null;
        const e = this.nodeStack[this.nodeStack.length - 1];
        return {key: e.key, value: e.value}
    }
}

class Bc {
    constructor(e, r, n, i, a) {
        this.key = e, this.value = r, this.color = n ?? Bc.RED, this.left = i ?? Bc.EMPTY, this.right = a ?? Bc.EMPTY, this.size = this.left.size + 1 + this.right.size
    }

    copy(e, r, n, i, a) {
        return new Bc(e ?? this.key, r ?? this.value, n ?? this.color, i ?? this.left, a ?? this.right)
    }

    isEmpty() {
        return !1
    }

    inorderTraversal(e) {
        return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
    }

    reverseTraversal(e) {
        return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
    }

    min() {
        return this.left.isEmpty() ? this : this.left.min()
    }

    minKey() {
        return this.min().key
    }

    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey()
    }

    insert(e, r, n) {
        let i = this;
        const a = n(e, i.key);
        return i = a < 0 ? i.copy(null, null, null, i.left.insert(e, r, n), null) : a === 0 ? i.copy(null, r, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, r, n)), i.fixUp()
    }

    removeMin() {
        if (this.left.isEmpty()) return Bc.EMPTY;
        let e = this;
        return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp()
    }

    remove(e, r) {
        let n, i = this;
        if (r(e, i.key) < 0) i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, r), null); else {
            if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), r(e, i.key) === 0) {
                if (i.right.isEmpty()) return Bc.EMPTY;
                n = i.right.min(), i = i.copy(n.key, n.value, null, null, i.right.removeMin())
            }
            i = i.copy(null, null, null, null, i.right.remove(e, r))
        }
        return i.fixUp()
    }

    isRed() {
        return this.color
    }

    fixUp() {
        let e = this;
        return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e
    }

    moveRedLeft() {
        let e = this.colorFlip();
        return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e
    }

    moveRedRight() {
        let e = this.colorFlip();
        return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e
    }

    rotateLeft() {
        const e = this.copy(null, null, Bc.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, e, null)
    }

    rotateRight() {
        const e = this.copy(null, null, Bc.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, e)
    }

    colorFlip() {
        const e = this.left.copy(null, null, !this.left.color, null, null),
            r = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, e, r)
    }

    checkMaxDepth() {
        const e = this.check();
        return Math.pow(2, e) <= this.size + 1
    }

    check() {
        if (this.isRed() && this.left.isRed() || this.right.isRed()) throw lr();
        const e = this.left.check();
        if (e !== this.right.check()) throw lr();
        return e + (this.isRed() ? 0 : 1)
    }
}

Bc.EMPTY = null, Bc.RED = !0, Bc.BLACK = !1;
Bc.EMPTY = new class {
    constructor() {
        this.size = 0
    }

    get key() {
        throw lr()
    }

    get value() {
        throw lr()
    }

    get color() {
        throw lr()
    }

    get left() {
        throw lr()
    }

    get right() {
        throw lr()
    }

    copy(t, e, r, n, i) {
        return this
    }

    insert(t, e, r) {
        return new Bc(t, e)
    }

    remove(t, e) {
        return this
    }

    isEmpty() {
        return !0
    }

    inorderTraversal(t) {
        return !1
    }

    reverseTraversal(t) {
        return !1
    }

    minKey() {
        return null
    }

    maxKey() {
        return null
    }

    isRed() {
        return !1
    }

    checkMaxDepth() {
        return !0
    }

    check() {
        return 0
    }
};

class fa {
    constructor(e) {
        this.comparator = e, this.data = new Mo(this.comparator)
    }

    has(e) {
        return this.data.get(e) !== null
    }

    first() {
        return this.data.minKey()
    }

    last() {
        return this.data.maxKey()
    }

    get size() {
        return this.data.size
    }

    indexOf(e) {
        return this.data.indexOf(e)
    }

    forEach(e) {
        this.data.inorderTraversal((r, n) => (e(r), !1))
    }

    forEachInRange(e, r) {
        const n = this.data.getIteratorFrom(e[0]);
        for (; n.hasNext();) {
            const i = n.getNext();
            if (this.comparator(i.key, e[1]) >= 0) return;
            r(i.key)
        }
    }

    forEachWhile(e, r) {
        let n;
        for (n = r !== void 0 ? this.data.getIteratorFrom(r) : this.data.getIterator(); n.hasNext();) if (!e(n.getNext().key)) return
    }

    firstAfterOrEqual(e) {
        const r = this.data.getIteratorFrom(e);
        return r.hasNext() ? r.getNext().key : null
    }

    getIterator() {
        return new C0e(this.data.getIterator())
    }

    getIteratorFrom(e) {
        return new C0e(this.data.getIteratorFrom(e))
    }

    add(e) {
        return this.copy(this.data.remove(e).insert(e, !0))
    }

    delete(e) {
        return this.has(e) ? this.copy(this.data.remove(e)) : this
    }

    isEmpty() {
        return this.data.isEmpty()
    }

    unionWith(e) {
        let r = this;
        return r.size < e.size && (r = e, e = this), e.forEach(n => {
            r = r.add(n)
        }), r
    }

    isEqual(e) {
        if (!(e instanceof fa) || this.size !== e.size) return !1;
        const r = this.data.getIterator(), n = e.data.getIterator();
        for (; r.hasNext();) {
            const i = r.getNext().key, a = n.getNext().key;
            if (this.comparator(i, a) !== 0) return !1
        }
        return !0
    }

    toArray() {
        const e = [];
        return this.forEach(r => {
            e.push(r)
        }), e
    }

    toString() {
        const e = [];
        return this.forEach(r => e.push(r)), "SortedSet(" + e.toString() + ")"
    }

    copy(e) {
        const r = new fa(this.comparator);
        return r.data = e, r
    }
}

class C0e {
    constructor(e) {
        this.iter = e
    }

    getNext() {
        return this.iter.getNext().key
    }

    hasNext() {
        return this.iter.hasNext()
    }
}

function cx(t) {
    return t.hasNext() ? t.getNext() : void 0
}

class Qu {
    constructor(e) {
        this.fields = e, e.sort(Io.comparator)
    }

    static empty() {
        return new Qu([])
    }

    unionWith(e) {
        let r = new fa(Io.comparator);
        for (const n of this.fields) r = r.add(n);
        for (const n of e) r = r.add(n);
        return new Qu(r.toArray())
    }

    covers(e) {
        for (const r of this.fields) if (r.isPrefixOf(e)) return !0;
        return !1
    }

    isEqual(e) {
        return pE(this.fields, e.fields, (r, n) => r.isEqual(n))
    }
}

class Vc {
    constructor(e) {
        this.value = e
    }

    static empty() {
        return new Vc({mapValue: {}})
    }

    field(e) {
        if (e.isEmpty()) return this.value;
        {
            let r = this.value;
            for (let n = 0; n < e.length - 1; ++n) if (r = (r.mapValue.fields || {})[e.get(n)], !lM(r)) return null;
            return r = (r.mapValue.fields || {})[e.lastSegment()], r || null
        }
    }

    set(e, r) {
        this.getFieldsMap(e.popLast())[e.lastSegment()] = TC(r)
    }

    setAll(e) {
        let r = Io.emptyPath(), n = {}, i = [];
        e.forEach((o, s) => {
            if (!r.isImmediateParentOf(s)) {
                const l = this.getFieldsMap(r);
                this.applyChanges(l, n, i), n = {}, i = [], r = s.popLast()
            }
            o ? n[s.lastSegment()] = TC(o) : i.push(s.lastSegment())
        });
        const a = this.getFieldsMap(r);
        this.applyChanges(a, n, i)
    }

    delete(e) {
        const r = this.field(e.popLast());
        lM(r) && r.mapValue.fields && delete r.mapValue.fields[e.lastSegment()]
    }

    isEqual(e) {
        return K0(this.value, e.value)
    }

    getFieldsMap(e) {
        let r = this.value;
        r.mapValue.fields || (r.mapValue = {fields: {}});
        for (let n = 0; n < e.length; ++n) {
            let i = r.mapValue.fields[e.get(n)];
            lM(i) && i.mapValue.fields || (i = {mapValue: {fields: {}}}, r.mapValue.fields[e.get(n)] = i), r = i
        }
        return r.mapValue.fields
    }

    applyChanges(e, r, n) {
        ZS(r, (i, a) => e[i] = a);
        for (const i of n) delete e[i]
    }

    clone() {
        return new Vc(TC(this.value))
    }
}

function kCe(t) {
    const e = [];
    return ZS(t.fields, (r, n) => {
        const i = new Io([r]);
        if (lM(n)) {
            const a = kCe(n.mapValue).fields;
            if (a.length === 0) e.push(i); else for (const o of a) e.push(i.child(o))
        } else e.push(i)
    }), new Qu(e)
}

class ja {
    constructor(e, r, n, i, a, o, s) {
        this.key = e, this.documentType = r, this.version = n, this.readTime = i, this.createTime = a, this.data = o, this.documentState = s
    }

    static newInvalidDocument(e) {
        return new ja(e, 0, Fr.min(), Fr.min(), Fr.min(), Vc.empty(), 0)
    }

    static newFoundDocument(e, r, n, i) {
        return new ja(e, 1, r, Fr.min(), n, i, 0)
    }

    static newNoDocument(e, r) {
        return new ja(e, 2, r, Fr.min(), Fr.min(), Vc.empty(), 0)
    }

    static newUnknownDocument(e, r) {
        return new ja(e, 3, r, Fr.min(), Fr.min(), Vc.empty(), 2)
    }

    convertToFoundDocument(e, r) {
        return !this.createTime.isEqual(Fr.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = e), this.version = e, this.documentType = 1, this.data = r, this.documentState = 0, this
    }

    convertToNoDocument(e) {
        return this.version = e, this.documentType = 2, this.data = Vc.empty(), this.documentState = 0, this
    }

    convertToUnknownDocument(e) {
        return this.version = e, this.documentType = 3, this.data = Vc.empty(), this.documentState = 2, this
    }

    setHasCommittedMutations() {
        return this.documentState = 2, this
    }

    setHasLocalMutations() {
        return this.documentState = 1, this.version = Fr.min(), this
    }

    setReadTime(e) {
        return this.readTime = e, this
    }

    get hasLocalMutations() {
        return this.documentState === 1
    }

    get hasCommittedMutations() {
        return this.documentState === 2
    }

    get hasPendingWrites() {
        return this.hasLocalMutations || this.hasCommittedMutations
    }

    isValidDocument() {
        return this.documentType !== 0
    }

    isFoundDocument() {
        return this.documentType === 1
    }

    isNoDocument() {
        return this.documentType === 2
    }

    isUnknownDocument() {
        return this.documentType === 3
    }

    isEqual(e) {
        return e instanceof ja && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data)
    }

    mutableCopy() {
        return new ja(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState)
    }

    toString() {
        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
    }
}

class l$t {
    constructor(e, r = null, n = [], i = [], a = null, o = null, s = null) {
        this.path = e, this.collectionGroup = r, this.orderBy = n, this.filters = i, this.limit = a, this.startAt = o, this.endAt = s, this.ft = null
    }
}

function mY(t, e = null, r = [], n = [], i = null, a = null, o = null) {
    return new l$t(t, e, r, n, i, a, o)
}

function xS(t) {
    const e = Ht(t);
    if (e.ft === null) {
        let r = e.path.canonicalString();
        e.collectionGroup !== null && (r += "|cg:" + e.collectionGroup), r += "|f:", r += e.filters.map(n => pY(n)).join(","), r += "|ob:", r += e.orderBy.map(n => function (i) {
            return i.field.canonicalString() + i.dir
        }(n)).join(","), MI(e.limit) || (r += "|l:", r += e.limit), e.startAt && (r += "|lb:", r += e.startAt.inclusive ? "b:" : "a:", r += e.startAt.position.map(n => mE(n)).join(",")), e.endAt && (r += "|ub:", r += e.endAt.inclusive ? "a:" : "b:", r += e.endAt.position.map(n => mE(n)).join(",")), e.ft = r
    }
    return e.ft
}

function OI(t, e) {
    if (t.limit !== e.limit || t.orderBy.length !== e.orderBy.length) return !1;
    for (let r = 0; r < t.orderBy.length; r++) if (!c$t(t.orderBy[r], e.orderBy[r])) return !1;
    if (t.filters.length !== e.filters.length) return !1;
    for (let r = 0; r < t.filters.length; r++) if (!ECe(t.filters[r], e.filters[r])) return !1;
    return t.collectionGroup === e.collectionGroup && !!t.path.isEqual(e.path) && !!T0e(t.startAt, e.startAt) && T0e(t.endAt, e.endAt)
}

function uP(t) {
    return jt.isDocumentKey(t.path) && t.collectionGroup === null && t.filters.length === 0
}

function fP(t, e) {
    return t.filters.filter(r => r instanceof ci && r.field.isEqual(e))
}

function A0e(t, e, r) {
    let n = cM, i = !0;
    for (const a of fP(t, e)) {
        let o = cM, s = !0;
        switch (a.op) {
            case"<":
            case"<=":
                o = e$t(a.value);
                break;
            case"==":
            case"in":
            case">=":
                o = a.value;
                break;
            case">":
                o = a.value, s = !1;
                break;
            case"!=":
            case"not-in":
                o = cM
        }
        _0e({value: n, inclusive: i}, {value: o, inclusive: s}) < 0 && (n = o, i = s)
    }
    if (r !== null) {
        for (let a = 0; a < t.orderBy.length; ++a) if (t.orderBy[a].field.isEqual(e)) {
            const o = r.position[a];
            _0e({value: n, inclusive: i}, {value: o, inclusive: r.inclusive}) < 0 && (n = o, i = r.inclusive);
            break
        }
    }
    return {value: n, inclusive: i}
}

function I0e(t, e, r) {
    let n = My, i = !0;
    for (const a of fP(t, e)) {
        let o = My, s = !0;
        switch (a.op) {
            case">=":
            case">":
                o = t$t(a.value), s = !1;
                break;
            case"==":
            case"in":
            case"<=":
                o = a.value;
                break;
            case"<":
                o = a.value, s = !1;
                break;
            case"!=":
            case"not-in":
                o = My
        }
        x0e({value: n, inclusive: i}, {value: o, inclusive: s}) > 0 && (n = o, i = s)
    }
    if (r !== null) {
        for (let a = 0; a < t.orderBy.length; ++a) if (t.orderBy[a].field.isEqual(e)) {
            const o = r.position[a];
            x0e({value: n, inclusive: i}, {value: o, inclusive: r.inclusive}) > 0 && (n = o, i = r.inclusive);
            break
        }
    }
    return {value: n, inclusive: i}
}

class rg {
    constructor(e, r = null, n = [], i = [], a = null, o = "F", s = null, l = null) {
        this.path = e, this.collectionGroup = r, this.explicitOrderBy = n, this.filters = i, this.limit = a, this.limitType = o, this.startAt = s, this.endAt = l, this.dt = null, this._t = null
    }
}

function RCe(t, e, r, n, i, a, o, s) {
    return new rg(t, e, r, n, i, a, o, s)
}

function f3(t) {
    return new rg(t)
}

function k0e(t) {
    return t.filters.length === 0 && t.limit === null && t.startAt == null && t.endAt == null && (t.explicitOrderBy.length === 0 || t.explicitOrderBy.length === 1 && t.explicitOrderBy[0].field.isKeyField())
}

function jee(t) {
    return t.explicitOrderBy.length > 0 ? t.explicitOrderBy[0].field : null
}

function zL(t) {
    for (const e of t.filters) {
        const r = e.getFirstInequalityField();
        if (r !== null) return r
    }
    return null
}

function zee(t) {
    return t.collectionGroup !== null
}

function Xw(t) {
    const e = Ht(t);
    if (e.dt === null) {
        e.dt = [];
        const r = zL(e), n = jee(e);
        if (r !== null && n === null) r.isKeyField() || e.dt.push(new g4(r)), e.dt.push(new g4(Io.keyField(), "asc")); else {
            let i = !1;
            for (const a of e.explicitOrderBy) e.dt.push(a), a.field.isKeyField() && (i = !0);
            if (!i) {
                const a = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
                e.dt.push(new g4(Io.keyField(), a))
            }
        }
    }
    return e.dt
}

function vu(t) {
    const e = Ht(t);
    if (!e._t) if (e.limitType === "F") e._t = mY(e.path, e.collectionGroup, Xw(e), e.filters, e.limit, e.startAt, e.endAt); else {
        const r = [];
        for (const a of Xw(e)) {
            const o = a.dir === "desc" ? "asc" : "desc";
            r.push(new g4(a.field, o))
        }
        const n = e.endAt ? new l1(e.endAt.position, e.endAt.inclusive) : null,
            i = e.startAt ? new l1(e.startAt.position, e.startAt.inclusive) : null;
        e._t = mY(e.path, e.collectionGroup, r, e.filters, e.limit, n, i)
    }
    return e._t
}

function vY(t, e) {
    e.getFirstInequalityField(), zL(t);
    const r = t.filters.concat([e]);
    return new rg(t.path, t.collectionGroup, t.explicitOrderBy.slice(), r, t.limit, t.limitType, t.startAt, t.endAt)
}

function dP(t, e, r) {
    return new rg(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), e, r, t.startAt, t.endAt)
}

function PI(t, e) {
    return OI(vu(t), vu(e)) && t.limitType === e.limitType
}

function DCe(t) {
    return `${xS(vu(t))}|lt:${t.limitType}`
}

function gY(t) {
    return `Query(target=${function (e) {
        let r = e.path.canonicalString();
        return e.collectionGroup !== null && (r += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (r += `, filters: [${e.filters.map(n => CCe(n)).join(", ")}]`), MI(e.limit) || (r += ", limit: " + e.limit), e.orderBy.length > 0 && (r += `, orderBy: [${e.orderBy.map(n => function (i) {
            return `${i.field.canonicalString()} (${i.dir})`
        }(n)).join(", ")}]`), e.startAt && (r += ", startAt: ", r += e.startAt.inclusive ? "b:" : "a:", r += e.startAt.position.map(n => mE(n)).join(",")), e.endAt && (r += ", endAt: ", r += e.endAt.inclusive ? "a:" : "b:", r += e.endAt.position.map(n => mE(n)).join(",")), `Target(${r})`
    }(vu(t))}; limitType=${t.limitType})`
}

function NI(t, e) {
    return e.isFoundDocument() && function (r, n) {
        const i = n.key.path;
        return r.collectionGroup !== null ? n.key.hasCollectionId(r.collectionGroup) && r.path.isPrefixOf(i) : jt.isDocumentKey(r.path) ? r.path.isEqual(i) : r.path.isImmediateParentOf(i)
    }(t, e) && function (r, n) {
        for (const i of Xw(r)) if (!i.field.isKeyField() && n.data.field(i.field) === null) return !1;
        return !0
    }(t, e) && function (r, n) {
        for (const i of r.filters) if (!i.matches(n)) return !1;
        return !0
    }(t, e) && function (r, n) {
        return !(r.startAt && !function (i, a, o) {
            const s = E0e(i, a, o);
            return i.inclusive ? s <= 0 : s < 0
        }(r.startAt, Xw(r), n) || r.endAt && !function (i, a, o) {
            const s = E0e(i, a, o);
            return i.inclusive ? s >= 0 : s > 0
        }(r.endAt, Xw(r), n))
    }(t, e)
}

function MCe(t) {
    return t.collectionGroup || (t.path.length % 2 == 1 ? t.path.lastSegment() : t.path.get(t.path.length - 2))
}

function OCe(t) {
    return (e, r) => {
        let n = !1;
        for (const i of Xw(t)) {
            const a = u$t(i, e, r);
            if (a !== 0) return a;
            n = n || i.field.isKeyField()
        }
        return 0
    }
}

function u$t(t, e, r) {
    const n = t.field.isKeyField() ? jt.comparator(e.key, r.key) : function (i, a, o) {
        const s = a.data.field(i), l = o.data.field(i);
        return s !== null && l !== null ? c1(s, l) : lr()
    }(t.field, e, r);
    switch (t.dir) {
        case"asc":
            return n;
        case"desc":
            return -1 * n;
        default:
            return lr()
    }
}

function PCe(t, e) {
    if (t.wt) {
        if (isNaN(e)) return {doubleValue: "NaN"};
        if (e === 1 / 0) return {doubleValue: "Infinity"};
        if (e === -1 / 0) return {doubleValue: "-Infinity"}
    }
    return {doubleValue: KA(e) ? "-0" : e}
}

function NCe(t) {
    return {integerValue: "" + t}
}

function LCe(t, e) {
    return bCe(e) ? NCe(e) : PCe(t, e)
}

class VL {
    constructor() {
        this._ = void 0
    }
}

function f$t(t, e, r) {
    return t instanceof gE ? function (n, i) {
        const a = {
            fields: {
                __type__: {stringValue: "server_timestamp"},
                __local_write_time__: {timestampValue: {seconds: n.seconds, nanos: n.nanoseconds}}
            }
        };
        return i && (a.fields.__previous_value__ = i), {mapValue: a}
    }(r, e) : t instanceof ES ? $Ce(t, e) : t instanceof TS ? FCe(t, e) : function (n, i) {
        const a = BCe(n, i), o = R0e(a) + R0e(n.gt);
        return dY(a) && dY(n.gt) ? NCe(o) : PCe(n.yt, o)
    }(t, e)
}

function d$t(t, e, r) {
    return t instanceof ES ? $Ce(t, e) : t instanceof TS ? FCe(t, e) : r
}

function BCe(t, e) {
    return t instanceof yE ? dY(r = e) || function (n) {
        return !!n && "doubleValue" in n
    }(r) ? e : {integerValue: 0} : null;
    var r
}

class gE extends VL {
}

class ES extends VL {
    constructor(e) {
        super(), this.elements = e
    }
}

function $Ce(t, e) {
    const r = UCe(e);
    for (const n of t.elements) r.some(i => K0(i, n)) || r.push(n);
    return {arrayValue: {values: r}}
}

class TS extends VL {
    constructor(e) {
        super(), this.elements = e
    }
}

function FCe(t, e) {
    let r = UCe(e);
    for (const n of t.elements) r = r.filter(i => !K0(i, n));
    return {arrayValue: {values: r}}
}

class yE extends VL {
    constructor(e, r) {
        super(), this.yt = e, this.gt = r
    }
}

function R0e(t) {
    return Co(t.integerValue || t.doubleValue)
}

function UCe(t) {
    return QA(t) && t.arrayValue.values ? t.arrayValue.values.slice() : []
}

class LI {
    constructor(e, r) {
        this.field = e, this.transform = r
    }
}

function h$t(t, e) {
    return t.field.isEqual(e.field) && function (r, n) {
        return r instanceof ES && n instanceof ES || r instanceof TS && n instanceof TS ? pE(r.elements, n.elements, K0) : r instanceof yE && n instanceof yE ? K0(r.gt, n.gt) : r instanceof gE && n instanceof gE
    }(t.transform, e.transform)
}

class p$t {
    constructor(e, r) {
        this.version = e, this.transformResults = r
    }
}

class Ya {
    constructor(e, r) {
        this.updateTime = e, this.exists = r
    }

    static none() {
        return new Ya
    }

    static exists(e) {
        return new Ya(void 0, e)
    }

    static updateTime(e) {
        return new Ya(e)
    }

    get isNone() {
        return this.updateTime === void 0 && this.exists === void 0
    }

    isEqual(e) {
        return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
    }
}

function uM(t, e) {
    return t.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t.updateTime) : t.exists === void 0 || t.exists === e.isFoundDocument()
}

class HL {
}

function jCe(t, e) {
    if (!t.hasLocalMutations || e && e.fields.length === 0) return null;
    if (e === null) return t.isNoDocument() ? new h3(t.key, Ya.none()) : new d3(t.key, t.data, Ya.none());
    {
        const r = t.data, n = Vc.empty();
        let i = new fa(Io.comparator);
        for (let a of e.fields) if (!i.has(a)) {
            let o = r.field(a);
            o === null && a.length > 1 && (a = a.popLast(), o = r.field(a)), o === null ? n.delete(a) : n.set(a, o), i = i.add(a)
        }
        return new ng(t.key, n, new Qu(i.toArray()), Ya.none())
    }
}

function m$t(t, e, r) {
    t instanceof d3 ? function (n, i, a) {
        const o = n.value.clone(), s = M0e(n.fieldTransforms, i, a.transformResults);
        o.setAll(s), i.convertToFoundDocument(a.version, o).setHasCommittedMutations()
    }(t, e, r) : t instanceof ng ? function (n, i, a) {
        if (!uM(n.precondition, i)) return void i.convertToUnknownDocument(a.version);
        const o = M0e(n.fieldTransforms, i, a.transformResults), s = i.data;
        s.setAll(zCe(n)), s.setAll(o), i.convertToFoundDocument(a.version, s).setHasCommittedMutations()
    }(t, e, r) : function (n, i, a) {
        i.convertToNoDocument(a.version).setHasCommittedMutations()
    }(0, e, r)
}

function CC(t, e, r, n) {
    return t instanceof d3 ? function (i, a, o, s) {
        if (!uM(i.precondition, a)) return o;
        const l = i.value.clone(), f = O0e(i.fieldTransforms, s, a);
        return l.setAll(f), a.convertToFoundDocument(a.version, l).setHasLocalMutations(), null
    }(t, e, r, n) : t instanceof ng ? function (i, a, o, s) {
        if (!uM(i.precondition, a)) return o;
        const l = O0e(i.fieldTransforms, s, a), f = a.data;
        return f.setAll(zCe(i)), f.setAll(l), a.convertToFoundDocument(a.version, f).setHasLocalMutations(), o === null ? null : o.unionWith(i.fieldMask.fields).unionWith(i.fieldTransforms.map(d => d.field))
    }(t, e, r, n) : function (i, a, o) {
        return uM(i.precondition, a) ? (a.convertToNoDocument(a.version).setHasLocalMutations(), null) : o
    }(t, e, r)
}

function v$t(t, e) {
    let r = null;
    for (const n of t.fieldTransforms) {
        const i = e.data.field(n.field), a = BCe(n.transform, i || null);
        a != null && (r === null && (r = Vc.empty()), r.set(n.field, a))
    }
    return r || null
}

function D0e(t, e) {
    return t.type === e.type && !!t.key.isEqual(e.key) && !!t.precondition.isEqual(e.precondition) && !!function (r, n) {
        return r === void 0 && n === void 0 || !(!r || !n) && pE(r, n, (i, a) => h$t(i, a))
    }(t.fieldTransforms, e.fieldTransforms) && (t.type === 0 ? t.value.isEqual(e.value) : t.type !== 1 || t.data.isEqual(e.data) && t.fieldMask.isEqual(e.fieldMask))
}

class d3 extends HL {
    constructor(e, r, n, i = []) {
        super(), this.key = e, this.value = r, this.precondition = n, this.fieldTransforms = i, this.type = 0
    }

    getFieldMask() {
        return null
    }
}

class ng extends HL {
    constructor(e, r, n, i, a = []) {
        super(), this.key = e, this.data = r, this.fieldMask = n, this.precondition = i, this.fieldTransforms = a, this.type = 1
    }

    getFieldMask() {
        return this.fieldMask
    }
}

function zCe(t) {
    const e = new Map;
    return t.fieldMask.fields.forEach(r => {
        if (!r.isEmpty()) {
            const n = t.data.field(r);
            e.set(r, n)
        }
    }), e
}

function M0e(t, e, r) {
    const n = new Map;
    Er(t.length === r.length);
    for (let i = 0; i < r.length; i++) {
        const a = t[i], o = a.transform, s = e.data.field(a.field);
        n.set(a.field, d$t(o, s, r[i]))
    }
    return n
}

function O0e(t, e, r) {
    const n = new Map;
    for (const i of t) {
        const a = i.transform, o = r.data.field(i.field);
        n.set(i.field, f$t(a, o, e))
    }
    return n
}

class h3 extends HL {
    constructor(e, r) {
        super(), this.key = e, this.precondition = r, this.type = 2, this.fieldTransforms = []
    }

    getFieldMask() {
        return null
    }
}

class Vee extends HL {
    constructor(e, r) {
        super(), this.key = e, this.precondition = r, this.type = 3, this.fieldTransforms = []
    }

    getFieldMask() {
        return null
    }
}

class g$t {
    constructor(e) {
        this.count = e
    }
}

var ts, _i;

function VCe(t) {
    switch (t) {
        default:
            return lr();
        case at.CANCELLED:
        case at.UNKNOWN:
        case at.DEADLINE_EXCEEDED:
        case at.RESOURCE_EXHAUSTED:
        case at.INTERNAL:
        case at.UNAVAILABLE:
        case at.UNAUTHENTICATED:
            return !1;
        case at.INVALID_ARGUMENT:
        case at.NOT_FOUND:
        case at.ALREADY_EXISTS:
        case at.PERMISSION_DENIED:
        case at.FAILED_PRECONDITION:
        case at.ABORTED:
        case at.OUT_OF_RANGE:
        case at.UNIMPLEMENTED:
        case at.DATA_LOSS:
            return !0
    }
}

function HCe(t) {
    if (t === void 0) return Vo("GRPC error has no .code"), at.UNKNOWN;
    switch (t) {
        case ts.OK:
            return at.OK;
        case ts.CANCELLED:
            return at.CANCELLED;
        case ts.UNKNOWN:
            return at.UNKNOWN;
        case ts.DEADLINE_EXCEEDED:
            return at.DEADLINE_EXCEEDED;
        case ts.RESOURCE_EXHAUSTED:
            return at.RESOURCE_EXHAUSTED;
        case ts.INTERNAL:
            return at.INTERNAL;
        case ts.UNAVAILABLE:
            return at.UNAVAILABLE;
        case ts.UNAUTHENTICATED:
            return at.UNAUTHENTICATED;
        case ts.INVALID_ARGUMENT:
            return at.INVALID_ARGUMENT;
        case ts.NOT_FOUND:
            return at.NOT_FOUND;
        case ts.ALREADY_EXISTS:
            return at.ALREADY_EXISTS;
        case ts.PERMISSION_DENIED:
            return at.PERMISSION_DENIED;
        case ts.FAILED_PRECONDITION:
            return at.FAILED_PRECONDITION;
        case ts.ABORTED:
            return at.ABORTED;
        case ts.OUT_OF_RANGE:
            return at.OUT_OF_RANGE;
        case ts.UNIMPLEMENTED:
            return at.UNIMPLEMENTED;
        case ts.DATA_LOSS:
            return at.DATA_LOSS;
        default:
            return lr()
    }
}

(_i = ts || (ts = {}))[_i.OK = 0] = "OK", _i[_i.CANCELLED = 1] = "CANCELLED", _i[_i.UNKNOWN = 2] = "UNKNOWN", _i[_i.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", _i[_i.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", _i[_i.NOT_FOUND = 5] = "NOT_FOUND", _i[_i.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", _i[_i.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", _i[_i.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", _i[_i.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", _i[_i.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", _i[_i.ABORTED = 10] = "ABORTED", _i[_i.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", _i[_i.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", _i[_i.INTERNAL = 13] = "INTERNAL", _i[_i.UNAVAILABLE = 14] = "UNAVAILABLE", _i[_i.DATA_LOSS = 15] = "DATA_LOSS";

class D1 {
    constructor(e, r) {
        this.mapKeyFn = e, this.equalsFn = r, this.inner = {}, this.innerSize = 0
    }

    get(e) {
        const r = this.mapKeyFn(e), n = this.inner[r];
        if (n !== void 0) {
            for (const [i, a] of n) if (this.equalsFn(i, e)) return a
        }
    }

    has(e) {
        return this.get(e) !== void 0
    }

    set(e, r) {
        const n = this.mapKeyFn(e), i = this.inner[n];
        if (i === void 0) return this.inner[n] = [[e, r]], void this.innerSize++;
        for (let a = 0; a < i.length; a++) if (this.equalsFn(i[a][0], e)) return void (i[a] = [e, r]);
        i.push([e, r]), this.innerSize++
    }

    delete(e) {
        const r = this.mapKeyFn(e), n = this.inner[r];
        if (n === void 0) return !1;
        for (let i = 0; i < n.length; i++) if (this.equalsFn(n[i][0], e)) return n.length === 1 ? delete this.inner[r] : n.splice(i, 1), this.innerSize--, !0;
        return !1
    }

    forEach(e) {
        ZS(this.inner, (r, n) => {
            for (const [i, a] of n) e(i, a)
        })
    }

    isEmpty() {
        return yCe(this.inner)
    }

    size() {
        return this.innerSize
    }
}

const y$t = new Mo(jt.comparator);

function Zu() {
    return y$t
}

const WCe = new Mo(jt.comparator);

function HT(...t) {
    let e = WCe;
    for (const r of t) e = e.insert(r.key, r);
    return e
}

function qCe(t) {
    let e = WCe;
    return t.forEach((r, n) => e = e.insert(r, n.overlayedDocument)), e
}

function C0() {
    return AC()
}

function GCe() {
    return AC()
}

function AC() {
    return new D1(t => t.toString(), (t, e) => t.isEqual(e))
}

const b$t = new Mo(jt.comparator), w$t = new fa(jt.comparator);

function Tn(...t) {
    let e = w$t;
    for (const r of t) e = e.add(r);
    return e
}

const S$t = new fa(gn);

function WL() {
    return S$t
}

class BI {
    constructor(e, r, n, i, a) {
        this.snapshotVersion = e, this.targetChanges = r, this.targetMismatches = n, this.documentUpdates = i, this.resolvedLimboDocuments = a
    }

    static createSynthesizedRemoteEventForCurrentChange(e, r, n) {
        const i = new Map;
        return i.set(e, $I.createSynthesizedTargetChangeForCurrentChange(e, r, n)), new BI(Fr.min(), i, WL(), Zu(), Tn())
    }
}

class $I {
    constructor(e, r, n, i, a) {
        this.resumeToken = e, this.current = r, this.addedDocuments = n, this.modifiedDocuments = i, this.removedDocuments = a
    }

    static createSynthesizedTargetChangeForCurrentChange(e, r, n) {
        return new $I(n, r, Tn(), Tn(), Tn())
    }
}

class fM {
    constructor(e, r, n, i) {
        this.It = e, this.removedTargetIds = r, this.key = n, this.Tt = i
    }
}

class KCe {
    constructor(e, r) {
        this.targetId = e, this.Et = r
    }
}

class YCe {
    constructor(e, r, n = Fs.EMPTY_BYTE_STRING, i = null) {
        this.state = e, this.targetIds = r, this.resumeToken = n, this.cause = i
    }
}

class P0e {
    constructor() {
        this.At = 0, this.Rt = L0e(), this.bt = Fs.EMPTY_BYTE_STRING, this.Pt = !1, this.vt = !0
    }

    get current() {
        return this.Pt
    }

    get resumeToken() {
        return this.bt
    }

    get Vt() {
        return this.At !== 0
    }

    get St() {
        return this.vt
    }

    Dt(e) {
        e.approximateByteSize() > 0 && (this.vt = !0, this.bt = e)
    }

    Ct() {
        let e = Tn(), r = Tn(), n = Tn();
        return this.Rt.forEach((i, a) => {
            switch (a) {
                case 0:
                    e = e.add(i);
                    break;
                case 2:
                    r = r.add(i);
                    break;
                case 1:
                    n = n.add(i);
                    break;
                default:
                    lr()
            }
        }), new $I(this.bt, this.Pt, e, r, n)
    }

    xt() {
        this.vt = !1, this.Rt = L0e()
    }

    Nt(e, r) {
        this.vt = !0, this.Rt = this.Rt.insert(e, r)
    }

    kt(e) {
        this.vt = !0, this.Rt = this.Rt.remove(e)
    }

    Ot() {
        this.At += 1
    }

    Mt() {
        this.At -= 1
    }

    Ft() {
        this.vt = !0, this.Pt = !0
    }
}

class _$t {
    constructor(e) {
        this.$t = e, this.Bt = new Map, this.Lt = Zu(), this.qt = N0e(), this.Ut = new fa(gn)
    }

    Kt(e) {
        for (const r of e.It) e.Tt && e.Tt.isFoundDocument() ? this.Gt(r, e.Tt) : this.Qt(r, e.key, e.Tt);
        for (const r of e.removedTargetIds) this.Qt(r, e.key, e.Tt)
    }

    jt(e) {
        this.forEachTarget(e, r => {
            const n = this.Wt(r);
            switch (e.state) {
                case 0:
                    this.zt(r) && n.Dt(e.resumeToken);
                    break;
                case 1:
                    n.Mt(), n.Vt || n.xt(), n.Dt(e.resumeToken);
                    break;
                case 2:
                    n.Mt(), n.Vt || this.removeTarget(r);
                    break;
                case 3:
                    this.zt(r) && (n.Ft(), n.Dt(e.resumeToken));
                    break;
                case 4:
                    this.zt(r) && (this.Ht(r), n.Dt(e.resumeToken));
                    break;
                default:
                    lr()
            }
        })
    }

    forEachTarget(e, r) {
        e.targetIds.length > 0 ? e.targetIds.forEach(r) : this.Bt.forEach((n, i) => {
            this.zt(i) && r(i)
        })
    }

    Jt(e) {
        const r = e.targetId, n = e.Et.count, i = this.Yt(r);
        if (i) {
            const a = i.target;
            if (uP(a)) if (n === 0) {
                const o = new jt(a.path);
                this.Qt(r, o, ja.newNoDocument(o, Fr.min()))
            } else Er(n === 1); else this.Xt(r) !== n && (this.Ht(r), this.Ut = this.Ut.add(r))
        }
    }

    Zt(e) {
        const r = new Map;
        this.Bt.forEach((a, o) => {
            const s = this.Yt(o);
            if (s) {
                if (a.current && uP(s.target)) {
                    const l = new jt(s.target.path);
                    this.Lt.get(l) !== null || this.te(o, l) || this.Qt(o, l, ja.newNoDocument(l, e))
                }
                a.St && (r.set(o, a.Ct()), a.xt())
            }
        });
        let n = Tn();
        this.qt.forEach((a, o) => {
            let s = !0;
            o.forEachWhile(l => {
                const f = this.Yt(l);
                return !f || f.purpose === 2 || (s = !1, !1)
            }), s && (n = n.add(a))
        }), this.Lt.forEach((a, o) => o.setReadTime(e));
        const i = new BI(e, r, this.Ut, this.Lt, n);
        return this.Lt = Zu(), this.qt = N0e(), this.Ut = new fa(gn), i
    }

    Gt(e, r) {
        if (!this.zt(e)) return;
        const n = this.te(e, r.key) ? 2 : 0;
        this.Wt(e).Nt(r.key, n), this.Lt = this.Lt.insert(r.key, r), this.qt = this.qt.insert(r.key, this.ee(r.key).add(e))
    }

    Qt(e, r, n) {
        if (!this.zt(e)) return;
        const i = this.Wt(e);
        this.te(e, r) ? i.Nt(r, 1) : i.kt(r), this.qt = this.qt.insert(r, this.ee(r).delete(e)), n && (this.Lt = this.Lt.insert(r, n))
    }

    removeTarget(e) {
        this.Bt.delete(e)
    }

    Xt(e) {
        const r = this.Wt(e).Ct();
        return this.$t.getRemoteKeysForTarget(e).size + r.addedDocuments.size - r.removedDocuments.size
    }

    Ot(e) {
        this.Wt(e).Ot()
    }

    Wt(e) {
        let r = this.Bt.get(e);
        return r || (r = new P0e, this.Bt.set(e, r)), r
    }

    ee(e) {
        let r = this.qt.get(e);
        return r || (r = new fa(gn), this.qt = this.qt.insert(e, r)), r
    }

    zt(e) {
        const r = this.Yt(e) !== null;
        return r || It("WatchChangeAggregator", "Detected inactive target", e), r
    }

    Yt(e) {
        const r = this.Bt.get(e);
        return r && r.Vt ? null : this.$t.ne(e)
    }

    Ht(e) {
        this.Bt.set(e, new P0e), this.$t.getRemoteKeysForTarget(e).forEach(r => {
            this.Qt(e, r, null)
        })
    }

    te(e, r) {
        return this.$t.getRemoteKeysForTarget(e).has(r)
    }
}

function N0e() {
    return new Mo(jt.comparator)
}

function L0e() {
    return new Mo(jt.comparator)
}

const x$t = {asc: "ASCENDING", desc: "DESCENDING"}, E$t = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
}, T$t = {and: "AND", or: "OR"};

class C$t {
    constructor(e, r) {
        this.databaseId = e, this.wt = r
    }
}

function bE(t, e) {
    return t.wt ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : {
        seconds: "" + e.seconds,
        nanos: e.nanoseconds
    }
}

function XCe(t, e) {
    return t.wt ? e.toBase64() : e.toUint8Array()
}

function A$t(t, e) {
    return bE(t, e.toTimestamp())
}

function qo(t) {
    return Er(!!t), Fr.fromTimestamp(function (e) {
        const r = s1(e);
        return new Ca(r.seconds, r.nanos)
    }(t))
}

function Hee(t, e) {
    return function (r) {
        return new Ei(["projects", r.projectId, "databases", r.database])
    }(t).child("documents").child(e).canonicalString()
}

function QCe(t) {
    const e = Ei.fromString(t);
    return Er(aAe(e)), e
}

function ZA(t, e) {
    return Hee(t.databaseId, e.path)
}

function $0(t, e) {
    const r = QCe(e);
    if (r.get(1) !== t.databaseId.projectId) throw new yt(at.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + r.get(1) + " vs " + t.databaseId.projectId);
    if (r.get(3) !== t.databaseId.database) throw new yt(at.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + r.get(3) + " vs " + t.databaseId.database);
    return new jt(JCe(r))
}

function yY(t, e) {
    return Hee(t.databaseId, e)
}

function ZCe(t) {
    const e = QCe(t);
    return e.length === 4 ? Ei.emptyPath() : JCe(e)
}

function JA(t) {
    return new Ei(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString()
}

function JCe(t) {
    return Er(t.length > 4 && t.get(4) === "documents"), t.popFirst(5)
}

function B0e(t, e, r) {
    return {name: ZA(t, e), fields: r.value.mapValue.fields}
}

function eAe(t, e, r) {
    const n = $0(t, e.name), i = qo(e.updateTime), a = e.createTime ? qo(e.createTime) : Fr.min(),
        o = new Vc({mapValue: {fields: e.fields}}), s = ja.newFoundDocument(n, i, a, o);
    return r && s.setHasCommittedMutations(), r ? s.setHasCommittedMutations() : s
}

function I$t(t, e) {
    return "found" in e ? function (r, n) {
        Er(!!n.found);
        const i = $0(r, n.found.name), a = qo(n.found.updateTime),
            o = n.found.createTime ? qo(n.found.createTime) : Fr.min(),
            s = new Vc({mapValue: {fields: n.found.fields}});
        return ja.newFoundDocument(i, a, o, s)
    }(t, e) : "missing" in e ? function (r, n) {
        Er(!!n.missing), Er(!!n.readTime);
        const i = $0(r, n.missing), a = qo(n.readTime);
        return ja.newNoDocument(i, a)
    }(t, e) : lr()
}

function k$t(t, e) {
    let r;
    if ("targetChange" in e) {
        const n = function (l) {
            return l === "NO_CHANGE" ? 0 : l === "ADD" ? 1 : l === "REMOVE" ? 2 : l === "CURRENT" ? 3 : l === "RESET" ? 4 : lr()
        }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], a = function (l, f) {
            return l.wt ? (Er(f === void 0 || typeof f == "string"), Fs.fromBase64String(f || "")) : (Er(f === void 0 || f instanceof Uint8Array), Fs.fromUint8Array(f || new Uint8Array))
        }(t, e.targetChange.resumeToken), o = e.targetChange.cause, s = o && function (l) {
            const f = l.code === void 0 ? at.UNKNOWN : HCe(l.code);
            return new yt(f, l.message || "")
        }(o);
        r = new YCe(n, i, a, s || null)
    } else if ("documentChange" in e) {
        const n = e.documentChange, i = $0(t, n.document.name), a = qo(n.document.updateTime),
            o = n.document.createTime ? qo(n.document.createTime) : Fr.min(),
            s = new Vc({mapValue: {fields: n.document.fields}}), l = ja.newFoundDocument(i, a, o, s),
            f = n.targetIds || [], d = n.removedTargetIds || [];
        r = new fM(f, d, l.key, l)
    } else if ("documentDelete" in e) {
        const n = e.documentDelete, i = $0(t, n.document), a = n.readTime ? qo(n.readTime) : Fr.min(),
            o = ja.newNoDocument(i, a), s = n.removedTargetIds || [];
        r = new fM([], s, o.key, o)
    } else if ("documentRemove" in e) {
        const n = e.documentRemove, i = $0(t, n.document), a = n.removedTargetIds || [];
        r = new fM([], a, i, null)
    } else {
        if (!("filter" in e)) return lr();
        {
            const n = e.filter, i = n.count || 0, a = new g$t(i), o = n.targetId;
            r = new KCe(o, a)
        }
    }
    return r
}

function e8(t, e) {
    let r;
    if (e instanceof d3) r = {update: B0e(t, e.key, e.value)}; else if (e instanceof h3) r = {delete: ZA(t, e.key)}; else if (e instanceof ng) r = {
        update: B0e(t, e.key, e.data),
        updateMask: N$t(e.fieldMask)
    }; else {
        if (!(e instanceof Vee)) return lr();
        r = {verify: ZA(t, e.key)}
    }
    return e.fieldTransforms.length > 0 && (r.updateTransforms = e.fieldTransforms.map(n => function (i, a) {
        const o = a.transform;
        if (o instanceof gE) return {fieldPath: a.field.canonicalString(), setToServerValue: "REQUEST_TIME"};
        if (o instanceof ES) return {fieldPath: a.field.canonicalString(), appendMissingElements: {values: o.elements}};
        if (o instanceof TS) return {fieldPath: a.field.canonicalString(), removeAllFromArray: {values: o.elements}};
        if (o instanceof yE) return {fieldPath: a.field.canonicalString(), increment: o.gt};
        throw lr()
    }(0, n))), e.precondition.isNone || (r.currentDocument = function (n, i) {
        return i.updateTime !== void 0 ? {updateTime: A$t(n, i.updateTime)} : i.exists !== void 0 ? {exists: i.exists} : lr()
    }(t, e.precondition)), r
}

function bY(t, e) {
    const r = e.currentDocument ? function (i) {
        return i.updateTime !== void 0 ? Ya.updateTime(qo(i.updateTime)) : i.exists !== void 0 ? Ya.exists(i.exists) : Ya.none()
    }(e.currentDocument) : Ya.none(), n = e.updateTransforms ? e.updateTransforms.map(i => function (a, o) {
        let s = null;
        if ("setToServerValue" in o) Er(o.setToServerValue === "REQUEST_TIME"), s = new gE; else if ("appendMissingElements" in o) {
            const f = o.appendMissingElements.values || [];
            s = new ES(f)
        } else if ("removeAllFromArray" in o) {
            const f = o.removeAllFromArray.values || [];
            s = new TS(f)
        } else "increment" in o ? s = new yE(a, o.increment) : lr();
        const l = Io.fromServerFormat(o.fieldPath);
        return new LI(l, s)
    }(t, i)) : [];
    if (e.update) {
        const i = $0(t, e.update.name), a = new Vc({mapValue: {fields: e.update.fields}});
        if (e.updateMask) {
            const o = function (s) {
                const l = s.fieldPaths || [];
                return new Qu(l.map(f => Io.fromServerFormat(f)))
            }(e.updateMask);
            return new ng(i, a, o, r, n)
        }
        return new d3(i, a, r, n)
    }
    if (e.delete) {
        const i = $0(t, e.delete);
        return new h3(i, r)
    }
    if (e.verify) {
        const i = $0(t, e.verify);
        return new Vee(i, r)
    }
    return lr()
}

function R$t(t, e) {
    return t && t.length > 0 ? (Er(e !== void 0), t.map(r => function (n, i) {
        let a = n.updateTime ? qo(n.updateTime) : qo(i);
        return a.isEqual(Fr.min()) && (a = qo(i)), new p$t(a, n.transformResults || [])
    }(r, e))) : []
}

function tAe(t, e) {
    return {documents: [yY(t, e.path)]}
}

function Wee(t, e) {
    const r = {structuredQuery: {}}, n = e.path;
    e.collectionGroup !== null ? (r.parent = yY(t, n), r.structuredQuery.from = [{
        collectionId: e.collectionGroup,
        allDescendants: !0
    }]) : (r.parent = yY(t, n.popLast()), r.structuredQuery.from = [{collectionId: n.lastSegment()}]);
    const i = function (l) {
        if (l.length !== 0) return iAe(ra.create(l, "and"))
    }(e.filters);
    i && (r.structuredQuery.where = i);
    const a = function (l) {
        if (l.length !== 0) return l.map(f => function (d) {
            return {field: bx(d.field), direction: M$t(d.dir)}
        }(f))
    }(e.orderBy);
    a && (r.structuredQuery.orderBy = a);
    const o = function (l, f) {
        return l.wt || MI(f) ? f : {value: f}
    }(t, e.limit);
    var s;
    return o !== null && (r.structuredQuery.limit = o), e.startAt && (r.structuredQuery.startAt = {
        before: (s = e.startAt).inclusive,
        values: s.position
    }), e.endAt && (r.structuredQuery.endAt = function (l) {
        return {before: !l.inclusive, values: l.position}
    }(e.endAt)), r
}

function rAe(t) {
    let e = ZCe(t.parent);
    const r = t.structuredQuery, n = r.from ? r.from.length : 0;
    let i = null;
    if (n > 0) {
        Er(n === 1);
        const d = r.from[0];
        d.allDescendants ? i = d.collectionId : e = e.child(d.collectionId)
    }
    let a = [];
    r.where && (a = function (d) {
        const p = nAe(d);
        return p instanceof ra && Uee(p) ? p.getFilters() : [p]
    }(r.where));
    let o = [];
    r.orderBy && (o = r.orderBy.map(d => function (p) {
        return new g4(wx(p.field), function (g) {
            switch (g) {
                case"ASCENDING":
                    return "asc";
                case"DESCENDING":
                    return "desc";
                default:
                    return
            }
        }(p.direction))
    }(d)));
    let s = null;
    r.limit && (s = function (d) {
        let p;
        return p = typeof d == "object" ? d.value : d, MI(p) ? null : p
    }(r.limit));
    let l = null;
    r.startAt && (l = function (d) {
        const p = !!d.before, g = d.values || [];
        return new l1(g, p)
    }(r.startAt));
    let f = null;
    return r.endAt && (f = function (d) {
        const p = !d.before, g = d.values || [];
        return new l1(g, p)
    }(r.endAt)), RCe(e, i, o, a, s, "F", l, f)
}

function D$t(t, e) {
    const r = function (n, i) {
        switch (i) {
            case 0:
                return null;
            case 1:
                return "existence-filter-mismatch";
            case 2:
                return "limbo-document";
            default:
                return lr()
        }
    }(0, e.purpose);
    return r == null ? null : {"goog-listen-tags": r}
}

function nAe(t) {
    return t.unaryFilter !== void 0 ? function (e) {
        switch (e.unaryFilter.op) {
            case"IS_NAN":
                const r = wx(e.unaryFilter.field);
                return ci.create(r, "==", {doubleValue: NaN});
            case"IS_NULL":
                const n = wx(e.unaryFilter.field);
                return ci.create(n, "==", {nullValue: "NULL_VALUE"});
            case"IS_NOT_NAN":
                const i = wx(e.unaryFilter.field);
                return ci.create(i, "!=", {doubleValue: NaN});
            case"IS_NOT_NULL":
                const a = wx(e.unaryFilter.field);
                return ci.create(a, "!=", {nullValue: "NULL_VALUE"});
            default:
                return lr()
        }
    }(t) : t.fieldFilter !== void 0 ? function (e) {
        return ci.create(wx(e.fieldFilter.field), function (r) {
            switch (r) {
                case"EQUAL":
                    return "==";
                case"NOT_EQUAL":
                    return "!=";
                case"GREATER_THAN":
                    return ">";
                case"GREATER_THAN_OR_EQUAL":
                    return ">=";
                case"LESS_THAN":
                    return "<";
                case"LESS_THAN_OR_EQUAL":
                    return "<=";
                case"ARRAY_CONTAINS":
                    return "array-contains";
                case"IN":
                    return "in";
                case"NOT_IN":
                    return "not-in";
                case"ARRAY_CONTAINS_ANY":
                    return "array-contains-any";
                default:
                    return lr()
            }
        }(e.fieldFilter.op), e.fieldFilter.value)
    }(t) : t.compositeFilter !== void 0 ? function (e) {
        return ra.create(e.compositeFilter.filters.map(r => nAe(r)), function (r) {
            switch (r) {
                case"AND":
                    return "and";
                case"OR":
                    return "or";
                default:
                    return lr()
            }
        }(e.compositeFilter.op))
    }(t) : lr()
}

function M$t(t) {
    return x$t[t]
}

function O$t(t) {
    return E$t[t]
}

function P$t(t) {
    return T$t[t]
}

function bx(t) {
    return {fieldPath: t.canonicalString()}
}

function wx(t) {
    return Io.fromServerFormat(t.fieldPath)
}

function iAe(t) {
    return t instanceof ci ? function (e) {
        if (e.op === "==") {
            if (S0e(e.value)) return {unaryFilter: {field: bx(e.field), op: "IS_NAN"}};
            if (w0e(e.value)) return {unaryFilter: {field: bx(e.field), op: "IS_NULL"}}
        } else if (e.op === "!=") {
            if (S0e(e.value)) return {unaryFilter: {field: bx(e.field), op: "IS_NOT_NAN"}};
            if (w0e(e.value)) return {unaryFilter: {field: bx(e.field), op: "IS_NOT_NULL"}}
        }
        return {fieldFilter: {field: bx(e.field), op: O$t(e.op), value: e.value}}
    }(t) : t instanceof ra ? function (e) {
        const r = e.getFilters().map(n => iAe(n));
        return r.length === 1 ? r[0] : {compositeFilter: {op: P$t(e.op), filters: r}}
    }(t) : lr()
}

function N$t(t) {
    const e = [];
    return t.fields.forEach(r => e.push(r.canonicalString())), {fieldPaths: e}
}

function aAe(t) {
    return t.length >= 4 && t.get(0) === "projects" && t.get(2) === "databases"
}

function fu(t) {
    let e = "";
    for (let r = 0; r < t.length; r++) e.length > 0 && (e = $0e(e)), e = L$t(t.get(r), e);
    return $0e(e)
}

function L$t(t, e) {
    let r = e;
    const n = t.length;
    for (let i = 0; i < n; i++) {
        const a = t.charAt(i);
        switch (a) {
            case"\0":
                r += "";
                break;
            case"":
                r += "";
                break;
            default:
                r += a
        }
    }
    return r
}

function $0e(t) {
    return t + ""
}

function A0(t) {
    const e = t.length;
    if (Er(e >= 2), e === 2) return Er(t.charAt(0) === "" && t.charAt(1) === ""), Ei.emptyPath();
    const r = e - 2, n = [];
    let i = "";
    for (let a = 0; a < e;) {
        const o = t.indexOf("", a);
        switch ((o < 0 || o > r) && lr(), t.charAt(o + 1)) {
            case"":
                const s = t.substring(a, o);
                let l;
                i.length === 0 ? l = s : (i += s, l = i, i = ""), n.push(l);
                break;
            case"":
                i += t.substring(a, o), i += "\0";
                break;
            case"":
                i += t.substring(a, o + 1);
                break;
            default:
                lr()
        }
        a = o + 2
    }
    return new Ei(n)
}

const F0e = ["userId", "batchId"];

function dM(t, e) {
    return [t, fu(e)]
}

function oAe(t, e, r) {
    return [t, fu(e), r]
}

const B$t = {}, $$t = ["prefixPath", "collectionGroup", "readTime", "documentId"],
    F$t = ["prefixPath", "collectionGroup", "documentId"],
    U$t = ["collectionGroup", "readTime", "prefixPath", "documentId"], j$t = ["canonicalId", "targetId"],
    z$t = ["targetId", "path"], V$t = ["path", "targetId"], H$t = ["collectionId", "parent"], W$t = ["indexId", "uid"],
    q$t = ["uid", "sequenceNumber"],
    G$t = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"],
    K$t = ["indexId", "uid", "orderedDocumentKey"], Y$t = ["userId", "collectionPath", "documentId"],
    X$t = ["userId", "collectionPath", "largestBatchId"], Q$t = ["userId", "collectionGroup", "largestBatchId"],
    sAe = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"],
    Z$t = [...sAe, "documentOverlays"],
    cAe = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"],
    lAe = cAe, J$t = [...lAe, "indexConfiguration", "indexState", "indexEntries"];

class wY extends gCe {
    constructor(e, r) {
        super(), this.se = e, this.currentSequenceNumber = r
    }
}

function lc(t, e) {
    const r = Ht(t);
    return np.M(r.se, e)
}

class qee {
    constructor(e, r, n, i) {
        this.batchId = e, this.localWriteTime = r, this.baseMutations = n, this.mutations = i
    }

    applyToRemoteDocument(e, r) {
        const n = r.mutationResults;
        for (let i = 0; i < this.mutations.length; i++) {
            const a = this.mutations[i];
            a.key.isEqual(e.key) && m$t(a, e, n[i])
        }
    }

    applyToLocalView(e, r) {
        for (const n of this.baseMutations) n.key.isEqual(e.key) && (r = CC(n, e, r, this.localWriteTime));
        for (const n of this.mutations) n.key.isEqual(e.key) && (r = CC(n, e, r, this.localWriteTime));
        return r
    }

    applyToLocalDocumentSet(e, r) {
        const n = GCe();
        return this.mutations.forEach(i => {
            const a = e.get(i.key), o = a.overlayedDocument;
            let s = this.applyToLocalView(o, a.mutatedFields);
            s = r.has(i.key) ? null : s;
            const l = jCe(o, s);
            l !== null && n.set(i.key, l), o.isValidDocument() || o.convertToNoDocument(Fr.min())
        }), n
    }

    keys() {
        return this.mutations.reduce((e, r) => e.add(r.key), Tn())
    }

    isEqual(e) {
        return this.batchId === e.batchId && pE(this.mutations, e.mutations, (r, n) => D0e(r, n)) && pE(this.baseMutations, e.baseMutations, (r, n) => D0e(r, n))
    }
}

class Gee {
    constructor(e, r, n, i) {
        this.batch = e, this.commitVersion = r, this.mutationResults = n, this.docVersions = i
    }

    static from(e, r, n) {
        Er(e.mutations.length === n.length);
        let i = b$t;
        const a = e.mutations;
        for (let o = 0; o < a.length; o++) i = i.insert(a[o].key, n[o].version);
        return new Gee(e, r, n, i)
    }
}

class Kee {
    constructor(e, r) {
        this.largestBatchId = e, this.mutation = r
    }

    getKey() {
        return this.mutation.key
    }

    isEqual(e) {
        return e !== null && this.mutation === e.mutation
    }

    toString() {
        return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
    }
}

class Wy {
    constructor(e, r, n, i, a = Fr.min(), o = Fr.min(), s = Fs.EMPTY_BYTE_STRING) {
        this.target = e, this.targetId = r, this.purpose = n, this.sequenceNumber = i, this.snapshotVersion = a, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = s
    }

    withSequenceNumber(e) {
        return new Wy(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken)
    }

    withResumeToken(e, r) {
        return new Wy(this.target, this.targetId, this.purpose, this.sequenceNumber, r, this.lastLimboFreeSnapshotVersion, e)
    }

    withLastLimboFreeSnapshotVersion(e) {
        return new Wy(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken)
    }
}

class uAe {
    constructor(e) {
        this.ie = e
    }
}

function eFt(t, e) {
    let r;
    if (e.document) r = eAe(t.ie, e.document, !!e.hasCommittedMutations); else if (e.noDocument) {
        const n = jt.fromSegments(e.noDocument.path), i = AS(e.noDocument.readTime);
        r = ja.newNoDocument(n, i), e.hasCommittedMutations && r.setHasCommittedMutations()
    } else {
        if (!e.unknownDocument) return lr();
        {
            const n = jt.fromSegments(e.unknownDocument.path), i = AS(e.unknownDocument.version);
            r = ja.newUnknownDocument(n, i)
        }
    }
    return e.readTime && r.setReadTime(function (n) {
        const i = new Ca(n[0], n[1]);
        return Fr.fromTimestamp(i)
    }(e.readTime)), r
}

function U0e(t, e) {
    const r = e.key, n = {
        prefixPath: r.getCollectionPath().popLast().toArray(),
        collectionGroup: r.collectionGroup,
        documentId: r.path.lastSegment(),
        readTime: hP(e.readTime),
        hasCommittedMutations: e.hasCommittedMutations
    };
    if (e.isFoundDocument()) n.document = function (i, a) {
        return {
            name: ZA(i, a.key),
            fields: a.data.value.mapValue.fields,
            updateTime: bE(i, a.version.toTimestamp()),
            createTime: bE(i, a.createTime.toTimestamp())
        }
    }(t.ie, e); else if (e.isNoDocument()) n.noDocument = {path: r.path.toArray(), readTime: CS(e.version)}; else {
        if (!e.isUnknownDocument()) return lr();
        n.unknownDocument = {path: r.path.toArray(), version: CS(e.version)}
    }
    return n
}

function hP(t) {
    const e = t.toTimestamp();
    return [e.seconds, e.nanoseconds]
}

function CS(t) {
    const e = t.toTimestamp();
    return {seconds: e.seconds, nanoseconds: e.nanoseconds}
}

function AS(t) {
    const e = new Ca(t.seconds, t.nanoseconds);
    return Fr.fromTimestamp(e)
}

function yw(t, e) {
    const r = (e.baseMutations || []).map(a => bY(t.ie, a));
    for (let a = 0; a < e.mutations.length - 1; ++a) {
        const o = e.mutations[a];
        if (a + 1 < e.mutations.length && e.mutations[a + 1].transform !== void 0) {
            const s = e.mutations[a + 1];
            o.updateTransforms = s.transform.fieldTransforms, e.mutations.splice(a + 1, 1), ++a
        }
    }
    const n = e.mutations.map(a => bY(t.ie, a)), i = Ca.fromMillis(e.localWriteTimeMs);
    return new qee(e.batchId, i, r, n)
}

function WT(t) {
    const e = AS(t.readTime),
        r = t.lastLimboFreeSnapshotVersion !== void 0 ? AS(t.lastLimboFreeSnapshotVersion) : Fr.min();
    let n;
    var i;
    return t.query.documents !== void 0 ? (Er((i = t.query).documents.length === 1), n = vu(f3(ZCe(i.documents[0])))) : n = function (a) {
        return vu(rAe(a))
    }(t.query), new Wy(n, t.targetId, 0, t.lastListenSequenceNumber, e, r, Fs.fromBase64String(t.resumeToken))
}

function fAe(t, e) {
    const r = CS(e.snapshotVersion), n = CS(e.lastLimboFreeSnapshotVersion);
    let i;
    i = uP(e.target) ? tAe(t.ie, e.target) : Wee(t.ie, e.target);
    const a = e.resumeToken.toBase64();
    return {
        targetId: e.targetId,
        canonicalId: xS(e.target),
        readTime: r,
        resumeToken: a,
        lastListenSequenceNumber: e.sequenceNumber,
        lastLimboFreeSnapshotVersion: n,
        query: i
    }
}

function Yee(t) {
    const e = rAe({parent: t.parent, structuredQuery: t.structuredQuery});
    return t.limitType === "LAST" ? dP(e, e.limit, "L") : e
}

function WH(t, e) {
    return new Kee(e.largestBatchId, bY(t.ie, e.overlayMutation))
}

function j0e(t, e) {
    const r = e.path.lastSegment();
    return [t, fu(e.path.popLast()), r]
}

function z0e(t, e, r, n) {
    return {
        indexId: t,
        uid: e.uid || "",
        sequenceNumber: r,
        readTime: CS(n.readTime),
        documentKey: fu(n.documentKey.path),
        largestBatchId: n.largestBatchId
    }
}

class tFt {
    getBundleMetadata(e, r) {
        return V0e(e).get(r).next(n => {
            if (n) return {id: (i = n).bundleId, createTime: AS(i.createTime), version: i.version};
            var i
        })
    }

    saveBundleMetadata(e, r) {
        return V0e(e).put({bundleId: (n = r).id, createTime: CS(qo(n.createTime)), version: n.version});
        var n
    }

    getNamedQuery(e, r) {
        return H0e(e).get(r).next(n => {
            if (n) return {name: (i = n).name, query: Yee(i.bundledQuery), readTime: AS(i.readTime)};
            var i
        })
    }

    saveNamedQuery(e, r) {
        return H0e(e).put(function (n) {
            return {name: n.name, readTime: CS(qo(n.readTime)), bundledQuery: n.bundledQuery}
        }(r))
    }
}

function V0e(t) {
    return lc(t, "bundles")
}

function H0e(t) {
    return lc(t, "namedQueries")
}

class qL {
    constructor(e, r) {
        this.yt = e, this.userId = r
    }

    static re(e, r) {
        const n = r.uid || "";
        return new qL(e, n)
    }

    getOverlay(e, r) {
        return hT(e).get(j0e(this.userId, r)).next(n => n ? WH(this.yt, n) : null)
    }

    getOverlays(e, r) {
        const n = C0();
        return Je.forEach(r, i => this.getOverlay(e, i).next(a => {
            a !== null && n.set(i, a)
        })).next(() => n)
    }

    saveOverlays(e, r, n) {
        const i = [];
        return n.forEach((a, o) => {
            const s = new Kee(r, o);
            i.push(this.oe(e, s))
        }), Je.waitFor(i)
    }

    removeOverlaysForBatchId(e, r, n) {
        const i = new Set;
        r.forEach(o => i.add(fu(o.getCollectionPath())));
        const a = [];
        return i.forEach(o => {
            const s = IDBKeyRange.bound([this.userId, o, n], [this.userId, o, n + 1], !1, !0);
            a.push(hT(e).Y("collectionPathOverlayIndex", s))
        }), Je.waitFor(a)
    }

    getOverlaysForCollection(e, r, n) {
        const i = C0(), a = fu(r),
            o = IDBKeyRange.bound([this.userId, a, n], [this.userId, a, Number.POSITIVE_INFINITY], !0);
        return hT(e).W("collectionPathOverlayIndex", o).next(s => {
            for (const l of s) {
                const f = WH(this.yt, l);
                i.set(f.getKey(), f)
            }
            return i
        })
    }

    getOverlaysForCollectionGroup(e, r, n, i) {
        const a = C0();
        let o;
        const s = IDBKeyRange.bound([this.userId, r, n], [this.userId, r, Number.POSITIVE_INFINITY], !0);
        return hT(e).Z({index: "collectionGroupOverlayIndex", range: s}, (l, f, d) => {
            const p = WH(this.yt, f);
            a.size() < i || p.largestBatchId === o ? (a.set(p.getKey(), p), o = p.largestBatchId) : d.done()
        }).next(() => a)
    }

    oe(e, r) {
        return hT(e).put(function (n, i, a) {
            const [o, s, l] = j0e(i, a.mutation.key);
            return {
                userId: i,
                collectionPath: s,
                documentId: l,
                collectionGroup: a.mutation.key.getCollectionGroup(),
                largestBatchId: a.largestBatchId,
                overlayMutation: e8(n.ie, a.mutation)
            }
        }(this.yt, this.userId, r))
    }
}

function hT(t) {
    return lc(t, "documentOverlays")
}

class bw {
    constructor() {
    }

    ue(e, r) {
        this.ce(e, r), r.ae()
    }

    ce(e, r) {
        if ("nullValue" in e) this.he(r, 5); else if ("booleanValue" in e) this.he(r, 10), r.le(e.booleanValue ? 1 : 0); else if ("integerValue" in e) this.he(r, 15), r.le(Co(e.integerValue)); else if ("doubleValue" in e) {
            const n = Co(e.doubleValue);
            isNaN(n) ? this.he(r, 13) : (this.he(r, 15), KA(n) ? r.le(0) : r.le(n))
        } else if ("timestampValue" in e) {
            const n = e.timestampValue;
            this.he(r, 20), typeof n == "string" ? r.fe(n) : (r.fe(`${n.seconds || ""}`), r.le(n.nanos || 0))
        } else if ("stringValue" in e) this.de(e.stringValue, r), this._e(r); else if ("bytesValue" in e) this.he(r, 30), r.we(wS(e.bytesValue)), this._e(r); else if ("referenceValue" in e) this.me(e.referenceValue, r); else if ("geoPointValue" in e) {
            const n = e.geoPointValue;
            this.he(r, 45), r.le(n.latitude || 0), r.le(n.longitude || 0)
        } else "mapValue" in e ? SCe(e) ? this.he(r, Number.MAX_SAFE_INTEGER) : (this.ge(e.mapValue, r), this._e(r)) : "arrayValue" in e ? (this.ye(e.arrayValue, r), this._e(r)) : lr()
    }

    de(e, r) {
        this.he(r, 25), this.pe(e, r)
    }

    pe(e, r) {
        r.fe(e)
    }

    ge(e, r) {
        const n = e.fields || {};
        this.he(r, 55);
        for (const i of Object.keys(n)) this.de(i, r), this.ce(n[i], r)
    }

    ye(e, r) {
        const n = e.values || [];
        this.he(r, 50);
        for (const i of n) this.ce(i, r)
    }

    me(e, r) {
        this.he(r, 37), jt.fromName(e).path.forEach(n => {
            this.he(r, 60), this.pe(n, r)
        })
    }

    he(e, r) {
        e.le(r)
    }

    _e(e) {
        e.le(2)
    }
}

bw.Ie = new bw;

function rFt(t) {
    if (t === 0) return 8;
    let e = 0;
    return !(t >> 4) && (e += 4, t <<= 4), !(t >> 6) && (e += 2, t <<= 2), !(t >> 7) && (e += 1), e
}

function W0e(t) {
    const e = 64 - function (r) {
        let n = 0;
        for (let i = 0; i < 8; ++i) {
            const a = rFt(255 & r[i]);
            if (n += a, a !== 8) break
        }
        return n
    }(t);
    return Math.ceil(e / 8)
}

class nFt {
    constructor() {
        this.buffer = new Uint8Array(1024), this.position = 0
    }

    Te(e) {
        const r = e[Symbol.iterator]();
        let n = r.next();
        for (; !n.done;) this.Ee(n.value), n = r.next();
        this.Ae()
    }

    Re(e) {
        const r = e[Symbol.iterator]();
        let n = r.next();
        for (; !n.done;) this.be(n.value), n = r.next();
        this.Pe()
    }

    ve(e) {
        for (const r of e) {
            const n = r.charCodeAt(0);
            if (n < 128) this.Ee(n); else if (n < 2048) this.Ee(960 | n >>> 6), this.Ee(128 | 63 & n); else if (r < "\uD800" || "\uDBFF" < r) this.Ee(480 | n >>> 12), this.Ee(128 | 63 & n >>> 6), this.Ee(128 | 63 & n); else {
                const i = r.codePointAt(0);
                this.Ee(240 | i >>> 18), this.Ee(128 | 63 & i >>> 12), this.Ee(128 | 63 & i >>> 6), this.Ee(128 | 63 & i)
            }
        }
        this.Ae()
    }

    Ve(e) {
        for (const r of e) {
            const n = r.charCodeAt(0);
            if (n < 128) this.be(n); else if (n < 2048) this.be(960 | n >>> 6), this.be(128 | 63 & n); else if (r < "\uD800" || "\uDBFF" < r) this.be(480 | n >>> 12), this.be(128 | 63 & n >>> 6), this.be(128 | 63 & n); else {
                const i = r.codePointAt(0);
                this.be(240 | i >>> 18), this.be(128 | 63 & i >>> 12), this.be(128 | 63 & i >>> 6), this.be(128 | 63 & i)
            }
        }
        this.Pe()
    }

    Se(e) {
        const r = this.De(e), n = W0e(r);
        this.Ce(1 + n), this.buffer[this.position++] = 255 & n;
        for (let i = r.length - n; i < r.length; ++i) this.buffer[this.position++] = 255 & r[i]
    }

    xe(e) {
        const r = this.De(e), n = W0e(r);
        this.Ce(1 + n), this.buffer[this.position++] = ~(255 & n);
        for (let i = r.length - n; i < r.length; ++i) this.buffer[this.position++] = ~(255 & r[i])
    }

    Ne() {
        this.ke(255), this.ke(255)
    }

    Oe() {
        this.Me(255), this.Me(255)
    }

    reset() {
        this.position = 0
    }

    seed(e) {
        this.Ce(e.length), this.buffer.set(e, this.position), this.position += e.length
    }

    Fe() {
        return this.buffer.slice(0, this.position)
    }

    De(e) {
        const r = function (i) {
            const a = new DataView(new ArrayBuffer(8));
            return a.setFloat64(0, i, !1), new Uint8Array(a.buffer)
        }(e), n = (128 & r[0]) != 0;
        r[0] ^= n ? 255 : 128;
        for (let i = 1; i < r.length; ++i) r[i] ^= n ? 255 : 0;
        return r
    }

    Ee(e) {
        const r = 255 & e;
        r === 0 ? (this.ke(0), this.ke(255)) : r === 255 ? (this.ke(255), this.ke(0)) : this.ke(r)
    }

    be(e) {
        const r = 255 & e;
        r === 0 ? (this.Me(0), this.Me(255)) : r === 255 ? (this.Me(255), this.Me(0)) : this.Me(e)
    }

    Ae() {
        this.ke(0), this.ke(1)
    }

    Pe() {
        this.Me(0), this.Me(1)
    }

    ke(e) {
        this.Ce(1), this.buffer[this.position++] = e
    }

    Me(e) {
        this.Ce(1), this.buffer[this.position++] = ~e
    }

    Ce(e) {
        const r = e + this.position;
        if (r <= this.buffer.length) return;
        let n = 2 * this.buffer.length;
        n < r && (n = r);
        const i = new Uint8Array(n);
        i.set(this.buffer), this.buffer = i
    }
}

class iFt {
    constructor(e) {
        this.$e = e
    }

    we(e) {
        this.$e.Te(e)
    }

    fe(e) {
        this.$e.ve(e)
    }

    le(e) {
        this.$e.Se(e)
    }

    ae() {
        this.$e.Ne()
    }
}

class aFt {
    constructor(e) {
        this.$e = e
    }

    we(e) {
        this.$e.Re(e)
    }

    fe(e) {
        this.$e.Ve(e)
    }

    le(e) {
        this.$e.xe(e)
    }

    ae() {
        this.$e.Oe()
    }
}

class pT {
    constructor() {
        this.$e = new nFt, this.Be = new iFt(this.$e), this.Le = new aFt(this.$e)
    }

    seed(e) {
        this.$e.seed(e)
    }

    qe(e) {
        return e === 0 ? this.Be : this.Le
    }

    Fe() {
        return this.$e.Fe()
    }

    reset() {
        this.$e.reset()
    }
}

class ww {
    constructor(e, r, n, i) {
        this.indexId = e, this.documentKey = r, this.arrayValue = n, this.directionalValue = i
    }

    Ue() {
        const e = this.directionalValue.length, r = e === 0 || this.directionalValue[e - 1] === 255 ? e + 1 : e,
            n = new Uint8Array(r);
        return n.set(this.directionalValue, 0), r !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new ww(this.indexId, this.documentKey, this.arrayValue, n)
    }
}

function fy(t, e) {
    let r = t.indexId - e.indexId;
    return r !== 0 ? r : (r = q0e(t.arrayValue, e.arrayValue), r !== 0 ? r : (r = q0e(t.directionalValue, e.directionalValue), r !== 0 ? r : jt.comparator(t.documentKey, e.documentKey)))
}

function q0e(t, e) {
    for (let r = 0; r < t.length && r < e.length; ++r) {
        const n = t[r] - e[r];
        if (n !== 0) return n
    }
    return t.length - e.length
}

class oFt {
    constructor(e) {
        this.collectionId = e.collectionGroup != null ? e.collectionGroup : e.path.lastSegment(), this.Ke = e.orderBy, this.Ge = [];
        for (const r of e.filters) {
            const n = r;
            n.isInequality() ? this.Qe = n : this.Ge.push(n)
        }
    }

    je(e) {
        Er(e.collectionGroup === this.collectionId);
        const r = uY(e);
        if (r !== void 0 && !this.We(r)) return !1;
        const n = sw(e);
        let i = 0, a = 0;
        for (; i < n.length && this.We(n[i]); ++i) ;
        if (i === n.length) return !0;
        if (this.Qe !== void 0) {
            const o = n[i];
            if (!this.ze(this.Qe, o) || !this.He(this.Ke[a++], o)) return !1;
            ++i
        }
        for (; i < n.length; ++i) {
            const o = n[i];
            if (a >= this.Ke.length || !this.He(this.Ke[a++], o)) return !1
        }
        return !0
    }

    We(e) {
        for (const r of this.Ge) if (this.ze(r, e)) return !0;
        return !1
    }

    ze(e, r) {
        if (e === void 0 || !e.field.isEqual(r.fieldPath)) return !1;
        const n = e.op === "array-contains" || e.op === "array-contains-any";
        return r.kind === 2 === n
    }

    He(e, r) {
        return !!e.field.isEqual(r.fieldPath) && (r.kind === 0 && e.dir === "asc" || r.kind === 1 && e.dir === "desc")
    }
}

function dAe(t) {
    var e, r;
    if (Er(t instanceof ci || t instanceof ra), t instanceof ci) {
        if (t instanceof ICe) {
            const i = ((r = (e = t.value.arrayValue) === null || e === void 0 ? void 0 : e.values) === null || r === void 0 ? void 0 : r.map(a => ci.create(t.field, "==", a))) || [];
            return ra.create(i, "or")
        }
        return t
    }
    const n = t.filters.map(i => dAe(i));
    return ra.create(n, t.op)
}

function sFt(t) {
    if (t.getFilters().length === 0) return [];
    const e = xY(dAe(t));
    return Er(hAe(e)), SY(e) || _Y(e) ? [e] : e.getFilters()
}

function SY(t) {
    return t instanceof ci
}

function _Y(t) {
    return t instanceof ra && Uee(t)
}

function hAe(t) {
    return SY(t) || _Y(t) || function (e) {
        if (e instanceof ra && hY(e)) {
            for (const r of e.getFilters()) if (!SY(r) && !_Y(r)) return !1;
            return !0
        }
        return !1
    }(t)
}

function xY(t) {
    if (Er(t instanceof ci || t instanceof ra), t instanceof ci) return t;
    if (t.filters.length === 1) return xY(t.filters[0]);
    const e = t.filters.map(n => xY(n));
    let r = ra.create(e, t.op);
    return r = pP(r), hAe(r) ? r : (Er(r instanceof ra), Er(vE(r)), Er(r.filters.length > 1), r.filters.reduce((n, i) => Xee(n, i)))
}

function Xee(t, e) {
    let r;
    return Er(t instanceof ci || t instanceof ra), Er(e instanceof ci || e instanceof ra), r = t instanceof ci ? e instanceof ci ? function (n, i) {
        return ra.create([n, i], "and")
    }(t, e) : G0e(t, e) : e instanceof ci ? G0e(e, t) : function (n, i) {
        if (Er(n.filters.length > 0 && i.filters.length > 0), vE(n) && vE(i)) return TCe(n, i.getFilters());
        const a = hY(n) ? n : i, o = hY(n) ? i : n, s = a.filters.map(l => Xee(l, o));
        return ra.create(s, "or")
    }(t, e), pP(r)
}

function G0e(t, e) {
    if (vE(e)) return TCe(e, t.getFilters());
    {
        const r = e.filters.map(n => Xee(t, n));
        return ra.create(r, "or")
    }
}

function pP(t) {
    if (Er(t instanceof ci || t instanceof ra), t instanceof ci) return t;
    const e = t.getFilters();
    if (e.length === 1) return pP(e[0]);
    if (xCe(t)) return t;
    const r = e.map(i => pP(i)), n = [];
    return r.forEach(i => {
        i instanceof ci ? n.push(i) : i instanceof ra && (i.op === t.op ? n.push(...i.filters) : n.push(i))
    }), n.length === 1 ? n[0] : ra.create(n, t.op)
}

class cFt {
    constructor() {
        this.Je = new Qee
    }

    addToCollectionParentIndex(e, r) {
        return this.Je.add(r), Je.resolve()
    }

    getCollectionParents(e, r) {
        return Je.resolve(this.Je.getEntries(r))
    }

    addFieldIndex(e, r) {
        return Je.resolve()
    }

    deleteFieldIndex(e, r) {
        return Je.resolve()
    }

    getDocumentsMatchingTarget(e, r) {
        return Je.resolve(null)
    }

    getIndexType(e, r) {
        return Je.resolve(0)
    }

    getFieldIndexes(e, r) {
        return Je.resolve([])
    }

    getNextCollectionGroupToUpdate(e) {
        return Je.resolve(null)
    }

    getMinOffset(e, r) {
        return Je.resolve(Qf.min())
    }

    getMinOffsetFromCollectionGroup(e, r) {
        return Je.resolve(Qf.min())
    }

    updateCollectionGroup(e, r, n) {
        return Je.resolve()
    }

    updateIndexEntries(e, r) {
        return Je.resolve()
    }
}

class Qee {
    constructor() {
        this.index = {}
    }

    add(e) {
        const r = e.lastSegment(), n = e.popLast(), i = this.index[r] || new fa(Ei.comparator), a = !i.has(n);
        return this.index[r] = i.add(n), a
    }

    has(e) {
        const r = e.lastSegment(), n = e.popLast(), i = this.index[r];
        return i && i.has(n)
    }

    getEntries(e) {
        return (this.index[e] || new fa(Ei.comparator)).toArray()
    }
}

const G7 = new Uint8Array(0);

class lFt {
    constructor(e, r) {
        this.user = e, this.databaseId = r, this.Ye = new Qee, this.Xe = new D1(n => xS(n), (n, i) => OI(n, i)), this.uid = e.uid || ""
    }

    addToCollectionParentIndex(e, r) {
        if (!this.Ye.has(r)) {
            const n = r.lastSegment(), i = r.popLast();
            e.addOnCommittedListener(() => {
                this.Ye.add(r)
            });
            const a = {collectionId: n, parent: fu(i)};
            return K0e(e).put(a)
        }
        return Je.resolve()
    }

    getCollectionParents(e, r) {
        const n = [], i = IDBKeyRange.bound([r, ""], [hCe(r), ""], !1, !0);
        return K0e(e).W(i).next(a => {
            for (const o of a) {
                if (o.collectionId !== r) break;
                n.push(A0(o.parent))
            }
            return n
        })
    }

    addFieldIndex(e, r) {
        const n = K7(e), i = function (o) {
            return {
                indexId: o.indexId,
                collectionGroup: o.collectionGroup,
                fields: o.fields.map(s => [s.fieldPath.canonicalString(), s.kind])
            }
        }(r);
        delete i.indexId;
        const a = n.add(i);
        if (r.indexState) {
            const o = vT(e);
            return a.next(s => {
                o.put(z0e(s, this.user, r.indexState.sequenceNumber, r.indexState.offset))
            })
        }
        return a.next()
    }

    deleteFieldIndex(e, r) {
        const n = K7(e), i = vT(e), a = mT(e);
        return n.delete(r.indexId).next(() => i.delete(IDBKeyRange.bound([r.indexId], [r.indexId + 1], !1, !0))).next(() => a.delete(IDBKeyRange.bound([r.indexId], [r.indexId + 1], !1, !0)))
    }

    getDocumentsMatchingTarget(e, r) {
        const n = mT(e);
        let i = !0;
        const a = new Map;
        return Je.forEach(this.Ze(r), o => this.tn(e, o).next(s => {
            i && (i = !!s), a.set(o, s)
        })).next(() => {
            if (i) {
                let o = Tn();
                const s = [];
                return Je.forEach(a, (l, f) => {
                    var d;
                    It("IndexedDbIndexManager", `Using index ${d = l, `id=${d.indexId}|cg=${d.collectionGroup}|f=${d.fields.map(F => `${F.fieldPath}:${F.kind}`).join(",")}`} to execute ${xS(r)}`);
                    const p = function (F, V) {
                            const Y = uY(V);
                            if (Y === void 0) return null;
                            for (const ee of fP(F, Y.fieldPath)) switch (ee.op) {
                                case"array-contains-any":
                                    return ee.value.arrayValue.values || [];
                                case"array-contains":
                                    return [ee.value]
                            }
                            return null
                        }(f, l), g = function (F, V) {
                            const Y = new Map;
                            for (const ee of sw(V)) for (const oe of fP(F, ee.fieldPath)) switch (oe.op) {
                                case"==":
                                case"in":
                                    Y.set(ee.fieldPath.canonicalString(), oe.value);
                                    break;
                                case"not-in":
                                case"!=":
                                    return Y.set(ee.fieldPath.canonicalString(), oe.value), Array.from(Y.values())
                            }
                            return null
                        }(f, l), b = function (F, V) {
                            const Y = [];
                            let ee = !0;
                            for (const oe of sw(V)) {
                                const G = oe.kind === 0 ? A0e(F, oe.fieldPath, F.startAt) : I0e(F, oe.fieldPath, F.startAt);
                                Y.push(G.value), ee && (ee = G.inclusive)
                            }
                            return new l1(Y, ee)
                        }(f, l), S = function (F, V) {
                            const Y = [];
                            let ee = !0;
                            for (const oe of sw(V)) {
                                const G = oe.kind === 0 ? I0e(F, oe.fieldPath, F.endAt) : A0e(F, oe.fieldPath, F.endAt);
                                Y.push(G.value), ee && (ee = G.inclusive)
                            }
                            return new l1(Y, ee)
                        }(f, l), T = this.en(l, f, b), I = this.en(l, f, S), N = this.nn(l, f, g),
                        P = this.sn(l.indexId, p, T, b.inclusive, I, S.inclusive, N);
                    return Je.forEach(P, F => n.J(F, r.limit).next(V => {
                        V.forEach(Y => {
                            const ee = jt.fromSegments(Y.documentKey);
                            o.has(ee) || (o = o.add(ee), s.push(ee))
                        })
                    }))
                }).next(() => s)
            }
            return Je.resolve(null)
        })
    }

    Ze(e) {
        let r = this.Xe.get(e);
        return r || (e.filters.length === 0 ? r = [e] : r = sFt(ra.create(e.filters, "and")).map(n => mY(e.path, e.collectionGroup, e.orderBy, n.getFilters(), e.limit, e.startAt, e.endAt)), this.Xe.set(e, r), r)
    }

    sn(e, r, n, i, a, o, s) {
        const l = (r != null ? r.length : 1) * Math.max(n.length, a.length), f = l / (r != null ? r.length : 1), d = [];
        for (let p = 0; p < l; ++p) {
            const g = r ? this.rn(r[p / f]) : G7, b = this.on(e, g, n[p % f], i), S = this.un(e, g, a[p % f], o),
                T = s.map(I => this.on(e, g, I, !0));
            d.push(...this.createRange(b, S, T))
        }
        return d
    }

    on(e, r, n, i) {
        const a = new ww(e, jt.empty(), r, n);
        return i ? a : a.Ue()
    }

    un(e, r, n, i) {
        const a = new ww(e, jt.empty(), r, n);
        return i ? a.Ue() : a
    }

    tn(e, r) {
        const n = new oFt(r), i = r.collectionGroup != null ? r.collectionGroup : r.path.lastSegment();
        return this.getFieldIndexes(e, i).next(a => {
            let o = null;
            for (const s of a) n.je(s) && (!o || s.fields.length > o.fields.length) && (o = s);
            return o
        })
    }

    getIndexType(e, r) {
        let n = 2;
        const i = this.Ze(r);
        return Je.forEach(i, a => this.tn(e, a).next(o => {
            o ? n !== 0 && o.fields.length < function (s) {
                let l = new fa(Io.comparator), f = !1;
                for (const d of s.filters) for (const p of d.getFlattenedFilters()) p.field.isKeyField() || (p.op === "array-contains" || p.op === "array-contains-any" ? f = !0 : l = l.add(p.field));
                for (const d of s.orderBy) d.field.isKeyField() || (l = l.add(d.field));
                return l.size + (f ? 1 : 0)
            }(a) && (n = 1) : n = 0
        })).next(() => function (a) {
            return a.limit !== null
        }(r) && i.length > 1 && n === 2 ? 1 : n)
    }

    cn(e, r) {
        const n = new pT;
        for (const i of sw(e)) {
            const a = r.data.field(i.fieldPath);
            if (a == null) return null;
            const o = n.qe(i.kind);
            bw.Ie.ue(a, o)
        }
        return n.Fe()
    }

    rn(e) {
        const r = new pT;
        return bw.Ie.ue(e, r.qe(0)), r.Fe()
    }

    an(e, r) {
        const n = new pT;
        return bw.Ie.ue(_S(this.databaseId, r), n.qe(function (i) {
            const a = sw(i);
            return a.length === 0 ? 0 : a[a.length - 1].kind
        }(e))), n.Fe()
    }

    nn(e, r, n) {
        if (n === null) return [];
        let i = [];
        i.push(new pT);
        let a = 0;
        for (const o of sw(e)) {
            const s = n[a++];
            for (const l of i) if (this.hn(r, o.fieldPath) && QA(s)) i = this.ln(i, o, s); else {
                const f = l.qe(o.kind);
                bw.Ie.ue(s, f)
            }
        }
        return this.fn(i)
    }

    en(e, r, n) {
        return this.nn(e, r, n.position)
    }

    fn(e) {
        const r = [];
        for (let n = 0; n < e.length; ++n) r[n] = e[n].Fe();
        return r
    }

    ln(e, r, n) {
        const i = [...e], a = [];
        for (const o of n.arrayValue.values || []) for (const s of i) {
            const l = new pT;
            l.seed(s.Fe()), bw.Ie.ue(o, l.qe(r.kind)), a.push(l)
        }
        return a
    }

    hn(e, r) {
        return !!e.filters.find(n => n instanceof ci && n.field.isEqual(r) && (n.op === "in" || n.op === "not-in"))
    }

    getFieldIndexes(e, r) {
        const n = K7(e), i = vT(e);
        return (r ? n.W("collectionGroupIndex", IDBKeyRange.bound(r, r)) : n.W()).next(a => {
            const o = [];
            return Je.forEach(a, s => i.get([s.indexId, this.uid]).next(l => {
                o.push(function (f, d) {
                    const p = d ? new GA(d.sequenceNumber, new Qf(AS(d.readTime), new jt(A0(d.documentKey)), d.largestBatchId)) : GA.empty(),
                        g = f.fields.map(([b, S]) => new sM(Io.fromServerFormat(b), S));
                    return new lP(f.indexId, f.collectionGroup, g, p)
                }(s, l))
            })).next(() => o)
        })
    }

    getNextCollectionGroupToUpdate(e) {
        return this.getFieldIndexes(e).next(r => r.length === 0 ? null : (r.sort((n, i) => {
            const a = n.indexState.sequenceNumber - i.indexState.sequenceNumber;
            return a !== 0 ? a : gn(n.collectionGroup, i.collectionGroup)
        }), r[0].collectionGroup))
    }

    updateCollectionGroup(e, r, n) {
        const i = K7(e), a = vT(e);
        return this.dn(e).next(o => i.W("collectionGroupIndex", IDBKeyRange.bound(r, r)).next(s => Je.forEach(s, l => a.put(z0e(l.indexId, this.user, o, n)))))
    }

    updateIndexEntries(e, r) {
        const n = new Map;
        return Je.forEach(r, (i, a) => {
            const o = n.get(i.collectionGroup);
            return (o ? Je.resolve(o) : this.getFieldIndexes(e, i.collectionGroup)).next(s => (n.set(i.collectionGroup, s), Je.forEach(s, l => this._n(e, i, l).next(f => {
                const d = this.wn(a, l);
                return f.isEqual(d) ? Je.resolve() : this.mn(e, a, l, f, d)
            }))))
        })
    }

    gn(e, r, n, i) {
        return mT(e).put({
            indexId: i.indexId,
            uid: this.uid,
            arrayValue: i.arrayValue,
            directionalValue: i.directionalValue,
            orderedDocumentKey: this.an(n, r.key),
            documentKey: r.key.path.toArray()
        })
    }

    yn(e, r, n, i) {
        return mT(e).delete([i.indexId, this.uid, i.arrayValue, i.directionalValue, this.an(n, r.key), r.key.path.toArray()])
    }

    _n(e, r, n) {
        const i = mT(e);
        let a = new fa(fy);
        return i.Z({
            index: "documentKeyIndex",
            range: IDBKeyRange.only([n.indexId, this.uid, this.an(n, r)])
        }, (o, s) => {
            a = a.add(new ww(n.indexId, r, s.arrayValue, s.directionalValue))
        }).next(() => a)
    }

    wn(e, r) {
        let n = new fa(fy);
        const i = this.cn(r, e);
        if (i == null) return n;
        const a = uY(r);
        if (a != null) {
            const o = e.data.field(a.fieldPath);
            if (QA(o)) for (const s of o.arrayValue.values || []) n = n.add(new ww(r.indexId, e.key, this.rn(s), i))
        } else n = n.add(new ww(r.indexId, e.key, G7, i));
        return n
    }

    mn(e, r, n, i, a) {
        It("IndexedDbIndexManager", "Updating index entries for document '%s'", r.key);
        const o = [];
        return function (s, l, f, d, p) {
            const g = s.getIterator(), b = l.getIterator();
            let S = cx(g), T = cx(b);
            for (; S || T;) {
                let I = !1, N = !1;
                if (S && T) {
                    const P = f(S, T);
                    P < 0 ? N = !0 : P > 0 && (I = !0)
                } else S != null ? N = !0 : I = !0;
                I ? (d(T), T = cx(b)) : N ? (p(S), S = cx(g)) : (S = cx(g), T = cx(b))
            }
        }(i, a, fy, s => {
            o.push(this.gn(e, r, n, s))
        }, s => {
            o.push(this.yn(e, r, n, s))
        }), Je.waitFor(o)
    }

    dn(e) {
        let r = 1;
        return vT(e).Z({
            index: "sequenceNumberIndex",
            reverse: !0,
            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
        }, (n, i, a) => {
            a.done(), r = i.sequenceNumber + 1
        }).next(() => r)
    }

    createRange(e, r, n) {
        n = n.sort((o, s) => fy(o, s)).filter((o, s, l) => !s || fy(o, l[s - 1]) !== 0);
        const i = [];
        i.push(e);
        for (const o of n) {
            const s = fy(o, e), l = fy(o, r);
            if (s === 0) i[0] = e.Ue(); else if (s > 0 && l < 0) i.push(o), i.push(o.Ue()); else if (l > 0) break
        }
        i.push(r);
        const a = [];
        for (let o = 0; o < i.length; o += 2) {
            if (this.pn(i[o], i[o + 1])) return [];
            const s = [i[o].indexId, this.uid, i[o].arrayValue, i[o].directionalValue, G7, []],
                l = [i[o + 1].indexId, this.uid, i[o + 1].arrayValue, i[o + 1].directionalValue, G7, []];
            a.push(IDBKeyRange.bound(s, l))
        }
        return a
    }

    pn(e, r) {
        return fy(e, r) > 0
    }

    getMinOffsetFromCollectionGroup(e, r) {
        return this.getFieldIndexes(e, r).next(Y0e)
    }

    getMinOffset(e, r) {
        return Je.mapArray(this.Ze(r), n => this.tn(e, n).next(i => i || lr())).next(Y0e)
    }
}

function K0e(t) {
    return lc(t, "collectionParents")
}

function mT(t) {
    return lc(t, "indexEntries")
}

function K7(t) {
    return lc(t, "indexConfiguration")
}

function vT(t) {
    return lc(t, "indexState")
}

function Y0e(t) {
    Er(t.length !== 0);
    let e = t[0].indexState.offset, r = e.largestBatchId;
    for (let n = 1; n < t.length; n++) {
        const i = t[n].indexState.offset;
        Bee(i, e) < 0 && (e = i), r < i.largestBatchId && (r = i.largestBatchId)
    }
    return new Qf(e.readTime, e.documentKey, r)
}

const X0e = {didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0};

class qu {
    constructor(e, r, n) {
        this.cacheSizeCollectionThreshold = e, this.percentileToCollect = r, this.maximumSequenceNumbersToCollect = n
    }

    static withCacheSize(e) {
        return new qu(e, qu.DEFAULT_COLLECTION_PERCENTILE, qu.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)
    }
}

function pAe(t, e, r) {
    const n = t.store("mutations"), i = t.store("documentMutations"), a = [], o = IDBKeyRange.only(r.batchId);
    let s = 0;
    const l = n.Z({range: o}, (d, p, g) => (s++, g.delete()));
    a.push(l.next(() => {
        Er(s === 1)
    }));
    const f = [];
    for (const d of r.mutations) {
        const p = oAe(e, d.key.path, r.batchId);
        a.push(i.delete(p)), f.push(d.key)
    }
    return Je.waitFor(a).next(() => f)
}

function mP(t) {
    if (!t) return 0;
    let e;
    if (t.document) e = t.document; else if (t.unknownDocument) e = t.unknownDocument; else {
        if (!t.noDocument) throw lr();
        e = t.noDocument
    }
    return JSON.stringify(e).length
}

qu.DEFAULT_COLLECTION_PERCENTILE = 10, qu.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, qu.DEFAULT = new qu(41943040, qu.DEFAULT_COLLECTION_PERCENTILE, qu.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), qu.DISABLED = new qu(-1, 0, 0);

class GL {
    constructor(e, r, n, i) {
        this.userId = e, this.yt = r, this.indexManager = n, this.referenceDelegate = i, this.In = {}
    }

    static re(e, r, n, i) {
        Er(e.uid !== "");
        const a = e.isAuthenticated() ? e.uid : "";
        return new GL(a, r, n, i)
    }

    checkEmpty(e) {
        let r = !0;
        const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
        return dy(e).Z({index: "userMutationsIndex", range: n}, (i, a, o) => {
            r = !1, o.done()
        }).next(() => r)
    }

    addMutationBatch(e, r, n, i) {
        const a = Sx(e), o = dy(e);
        return o.add({}).next(s => {
            Er(typeof s == "number");
            const l = new qee(s, r, n, i), f = function (g, b, S) {
                const T = S.baseMutations.map(N => e8(g.ie, N)), I = S.mutations.map(N => e8(g.ie, N));
                return {
                    userId: b,
                    batchId: S.batchId,
                    localWriteTimeMs: S.localWriteTime.toMillis(),
                    baseMutations: T,
                    mutations: I
                }
            }(this.yt, this.userId, l), d = [];
            let p = new fa((g, b) => gn(g.canonicalString(), b.canonicalString()));
            for (const g of i) {
                const b = oAe(this.userId, g.key.path, s);
                p = p.add(g.key.path.popLast()), d.push(o.put(f)), d.push(a.put(b, B$t))
            }
            return p.forEach(g => {
                d.push(this.indexManager.addToCollectionParentIndex(e, g))
            }), e.addOnCommittedListener(() => {
                this.In[s] = l.keys()
            }), Je.waitFor(d).next(() => l)
        })
    }

    lookupMutationBatch(e, r) {
        return dy(e).get(r).next(n => n ? (Er(n.userId === this.userId), yw(this.yt, n)) : null)
    }

    Tn(e, r) {
        return this.In[r] ? Je.resolve(this.In[r]) : this.lookupMutationBatch(e, r).next(n => {
            if (n) {
                const i = n.keys();
                return this.In[r] = i, i
            }
            return null
        })
    }

    getNextMutationBatchAfterBatchId(e, r) {
        const n = r + 1, i = IDBKeyRange.lowerBound([this.userId, n]);
        let a = null;
        return dy(e).Z({index: "userMutationsIndex", range: i}, (o, s, l) => {
            s.userId === this.userId && (Er(s.batchId >= n), a = yw(this.yt, s)), l.done()
        }).next(() => a)
    }

    getHighestUnacknowledgedBatchId(e) {
        const r = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
        let n = -1;
        return dy(e).Z({index: "userMutationsIndex", range: r, reverse: !0}, (i, a, o) => {
            n = a.batchId, o.done()
        }).next(() => n)
    }

    getAllMutationBatches(e) {
        const r = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
        return dy(e).W("userMutationsIndex", r).next(n => n.map(i => yw(this.yt, i)))
    }

    getAllMutationBatchesAffectingDocumentKey(e, r) {
        const n = dM(this.userId, r.path), i = IDBKeyRange.lowerBound(n), a = [];
        return Sx(e).Z({range: i}, (o, s, l) => {
            const [f, d, p] = o, g = A0(d);
            if (f === this.userId && r.path.isEqual(g)) return dy(e).get(p).next(b => {
                if (!b) throw lr();
                Er(b.userId === this.userId), a.push(yw(this.yt, b))
            });
            l.done()
        }).next(() => a)
    }

    getAllMutationBatchesAffectingDocumentKeys(e, r) {
        let n = new fa(gn);
        const i = [];
        return r.forEach(a => {
            const o = dM(this.userId, a.path), s = IDBKeyRange.lowerBound(o), l = Sx(e).Z({range: s}, (f, d, p) => {
                const [g, b, S] = f, T = A0(b);
                g === this.userId && a.path.isEqual(T) ? n = n.add(S) : p.done()
            });
            i.push(l)
        }), Je.waitFor(i).next(() => this.En(e, n))
    }

    getAllMutationBatchesAffectingQuery(e, r) {
        const n = r.path, i = n.length + 1, a = dM(this.userId, n), o = IDBKeyRange.lowerBound(a);
        let s = new fa(gn);
        return Sx(e).Z({range: o}, (l, f, d) => {
            const [p, g, b] = l, S = A0(g);
            p === this.userId && n.isPrefixOf(S) ? S.length === i && (s = s.add(b)) : d.done()
        }).next(() => this.En(e, s))
    }

    En(e, r) {
        const n = [], i = [];
        return r.forEach(a => {
            i.push(dy(e).get(a).next(o => {
                if (o === null) throw lr();
                Er(o.userId === this.userId), n.push(yw(this.yt, o))
            }))
        }), Je.waitFor(i).next(() => n)
    }

    removeMutationBatch(e, r) {
        return pAe(e.se, this.userId, r).next(n => (e.addOnCommittedListener(() => {
            this.An(r.batchId)
        }), Je.forEach(n, i => this.referenceDelegate.markPotentiallyOrphaned(e, i))))
    }

    An(e) {
        delete this.In[e]
    }

    performConsistencyCheck(e) {
        return this.checkEmpty(e).next(r => {
            if (!r) return Je.resolve();
            const n = IDBKeyRange.lowerBound([this.userId]), i = [];
            return Sx(e).Z({range: n}, (a, o, s) => {
                if (a[0] === this.userId) {
                    const l = A0(a[1]);
                    i.push(l)
                } else s.done()
            }).next(() => {
                Er(i.length === 0)
            })
        })
    }

    containsKey(e, r) {
        return mAe(e, this.userId, r)
    }

    Rn(e) {
        return vAe(e).get(this.userId).next(r => r || {
            userId: this.userId,
            lastAcknowledgedBatchId: -1,
            lastStreamToken: ""
        })
    }
}

function mAe(t, e, r) {
    const n = dM(e, r.path), i = n[1], a = IDBKeyRange.lowerBound(n);
    let o = !1;
    return Sx(t).Z({range: a, X: !0}, (s, l, f) => {
        const [d, p, g] = s;
        d === e && p === i && (o = !0), f.done()
    }).next(() => o)
}

function dy(t) {
    return lc(t, "mutations")
}

function Sx(t) {
    return lc(t, "documentMutations")
}

function vAe(t) {
    return lc(t, "mutationQueues")
}

class IS {
    constructor(e) {
        this.bn = e
    }

    next() {
        return this.bn += 2, this.bn
    }

    static Pn() {
        return new IS(0)
    }

    static vn() {
        return new IS(-1)
    }
}

class uFt {
    constructor(e, r) {
        this.referenceDelegate = e, this.yt = r
    }

    allocateTargetId(e) {
        return this.Vn(e).next(r => {
            const n = new IS(r.highestTargetId);
            return r.highestTargetId = n.next(), this.Sn(e, r).next(() => r.highestTargetId)
        })
    }

    getLastRemoteSnapshotVersion(e) {
        return this.Vn(e).next(r => Fr.fromTimestamp(new Ca(r.lastRemoteSnapshotVersion.seconds, r.lastRemoteSnapshotVersion.nanoseconds)))
    }

    getHighestSequenceNumber(e) {
        return this.Vn(e).next(r => r.highestListenSequenceNumber)
    }

    setTargetsMetadata(e, r, n) {
        return this.Vn(e).next(i => (i.highestListenSequenceNumber = r, n && (i.lastRemoteSnapshotVersion = n.toTimestamp()), r > i.highestListenSequenceNumber && (i.highestListenSequenceNumber = r), this.Sn(e, i)))
    }

    addTargetData(e, r) {
        return this.Dn(e, r).next(() => this.Vn(e).next(n => (n.targetCount += 1, this.Cn(r, n), this.Sn(e, n))))
    }

    updateTargetData(e, r) {
        return this.Dn(e, r)
    }

    removeTargetData(e, r) {
        return this.removeMatchingKeysForTargetId(e, r.targetId).next(() => lx(e).delete(r.targetId)).next(() => this.Vn(e)).next(n => (Er(n.targetCount > 0), n.targetCount -= 1, this.Sn(e, n)))
    }

    removeTargets(e, r, n) {
        let i = 0;
        const a = [];
        return lx(e).Z((o, s) => {
            const l = WT(s);
            l.sequenceNumber <= r && n.get(l.targetId) === null && (i++, a.push(this.removeTargetData(e, l)))
        }).next(() => Je.waitFor(a)).next(() => i)
    }

    forEachTarget(e, r) {
        return lx(e).Z((n, i) => {
            const a = WT(i);
            r(a)
        })
    }

    Vn(e) {
        return Q0e(e).get("targetGlobalKey").next(r => (Er(r !== null), r))
    }

    Sn(e, r) {
        return Q0e(e).put("targetGlobalKey", r)
    }

    Dn(e, r) {
        return lx(e).put(fAe(this.yt, r))
    }

    Cn(e, r) {
        let n = !1;
        return e.targetId > r.highestTargetId && (r.highestTargetId = e.targetId, n = !0), e.sequenceNumber > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = e.sequenceNumber, n = !0), n
    }

    getTargetCount(e) {
        return this.Vn(e).next(r => r.targetCount)
    }

    getTargetData(e, r) {
        const n = xS(r), i = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
        let a = null;
        return lx(e).Z({range: i, index: "queryTargetsIndex"}, (o, s, l) => {
            const f = WT(s);
            OI(r, f.target) && (a = f, l.done())
        }).next(() => a)
    }

    addMatchingKeys(e, r, n) {
        const i = [], a = xy(e);
        return r.forEach(o => {
            const s = fu(o.path);
            i.push(a.put({targetId: n, path: s})), i.push(this.referenceDelegate.addReference(e, n, o))
        }), Je.waitFor(i)
    }

    removeMatchingKeys(e, r, n) {
        const i = xy(e);
        return Je.forEach(r, a => {
            const o = fu(a.path);
            return Je.waitFor([i.delete([n, o]), this.referenceDelegate.removeReference(e, n, a)])
        })
    }

    removeMatchingKeysForTargetId(e, r) {
        const n = xy(e), i = IDBKeyRange.bound([r], [r + 1], !1, !0);
        return n.delete(i)
    }

    getMatchingKeysForTargetId(e, r) {
        const n = IDBKeyRange.bound([r], [r + 1], !1, !0), i = xy(e);
        let a = Tn();
        return i.Z({range: n, X: !0}, (o, s, l) => {
            const f = A0(o[1]), d = new jt(f);
            a = a.add(d)
        }).next(() => a)
    }

    containsKey(e, r) {
        const n = fu(r.path), i = IDBKeyRange.bound([n], [hCe(n)], !1, !0);
        let a = 0;
        return xy(e).Z({index: "documentTargetsIndex", X: !0, range: i}, ([o, s], l, f) => {
            o !== 0 && (a++, f.done())
        }).next(() => a > 0)
    }

    ne(e, r) {
        return lx(e).get(r).next(n => n ? WT(n) : null)
    }
}

function lx(t) {
    return lc(t, "targets")
}

function Q0e(t) {
    return lc(t, "targetGlobal")
}

function xy(t) {
    return lc(t, "targetDocuments")
}

function Z0e([t, e], [r, n]) {
    const i = gn(t, r);
    return i === 0 ? gn(e, n) : i
}

class fFt {
    constructor(e) {
        this.xn = e, this.buffer = new fa(Z0e), this.Nn = 0
    }

    kn() {
        return ++this.Nn
    }

    On(e) {
        const r = [e, this.kn()];
        if (this.buffer.size < this.xn) this.buffer = this.buffer.add(r); else {
            const n = this.buffer.last();
            Z0e(r, n) < 0 && (this.buffer = this.buffer.delete(n).add(r))
        }
    }

    get maxValue() {
        return this.buffer.last()[0]
    }
}

class dFt {
    constructor(e, r, n) {
        this.garbageCollector = e, this.asyncQueue = r, this.localStore = n, this.Mn = null
    }

    start() {
        this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Fn(6e4)
    }

    stop() {
        this.Mn && (this.Mn.cancel(), this.Mn = null)
    }

    get started() {
        return this.Mn !== null
    }

    Fn(e) {
        It("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.Mn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
            this.Mn = null;
            try {
                await this.localStore.collectGarbage(this.garbageCollector)
            } catch (r) {
                R1(r) ? It("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", r) : await k1(r)
            }
            await this.Fn(3e5)
        })
    }
}

class hFt {
    constructor(e, r) {
        this.$n = e, this.params = r
    }

    calculateTargetCount(e, r) {
        return this.$n.Bn(e).next(n => Math.floor(r / 100 * n))
    }

    nthSequenceNumber(e, r) {
        if (r === 0) return Je.resolve(Xu.at);
        const n = new fFt(r);
        return this.$n.forEachTarget(e, i => n.On(i.sequenceNumber)).next(() => this.$n.Ln(e, i => n.On(i))).next(() => n.maxValue)
    }

    removeTargets(e, r, n) {
        return this.$n.removeTargets(e, r, n)
    }

    removeOrphanedDocuments(e, r) {
        return this.$n.removeOrphanedDocuments(e, r)
    }

    collect(e, r) {
        return this.params.cacheSizeCollectionThreshold === -1 ? (It("LruGarbageCollector", "Garbage collection skipped; disabled"), Je.resolve(X0e)) : this.getCacheSize(e).next(n => n < this.params.cacheSizeCollectionThreshold ? (It("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), X0e) : this.qn(e, r))
    }

    getCacheSize(e) {
        return this.$n.getCacheSize(e)
    }

    qn(e, r) {
        let n, i, a, o, s, l, f;
        const d = Date.now();
        return this.calculateTargetCount(e, this.params.percentileToCollect).next(p => (p > this.params.maximumSequenceNumbersToCollect ? (It("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${p}`), i = this.params.maximumSequenceNumbersToCollect) : i = p, o = Date.now(), this.nthSequenceNumber(e, i))).next(p => (n = p, s = Date.now(), this.removeTargets(e, n, r))).next(p => (a = p, l = Date.now(), this.removeOrphanedDocuments(e, n))).next(p => (f = Date.now(), lY() <= Ri.DEBUG && It("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${o - d}ms
	Determined least recently used ${i} in ` + (s - o) + `ms
	Removed ${a} targets in ` + (l - s) + `ms
	Removed ${p} documents in ` + (f - l) + `ms
Total Duration: ${f - d}ms`), Je.resolve({
            didRun: !0,
            sequenceNumbersCollected: i,
            targetsRemoved: a,
            documentsRemoved: p
        })))
    }
}

class pFt {
    constructor(e, r) {
        this.db = e, this.garbageCollector = function (n, i) {
            return new hFt(n, i)
        }(this, r)
    }

    Bn(e) {
        const r = this.Un(e);
        return this.db.getTargetCache().getTargetCount(e).next(n => r.next(i => n + i))
    }

    Un(e) {
        let r = 0;
        return this.Ln(e, n => {
            r++
        }).next(() => r)
    }

    forEachTarget(e, r) {
        return this.db.getTargetCache().forEachTarget(e, r)
    }

    Ln(e, r) {
        return this.Kn(e, (n, i) => r(i))
    }

    addReference(e, r, n) {
        return Y7(e, n)
    }

    removeReference(e, r, n) {
        return Y7(e, n)
    }

    removeTargets(e, r, n) {
        return this.db.getTargetCache().removeTargets(e, r, n)
    }

    markPotentiallyOrphaned(e, r) {
        return Y7(e, r)
    }

    Gn(e, r) {
        return function (n, i) {
            let a = !1;
            return vAe(n).tt(o => mAe(n, o, i).next(s => (s && (a = !0), Je.resolve(!s)))).next(() => a)
        }(e, r)
    }

    removeOrphanedDocuments(e, r) {
        const n = this.db.getRemoteDocumentCache().newChangeBuffer(), i = [];
        let a = 0;
        return this.Kn(e, (o, s) => {
            if (s <= r) {
                const l = this.Gn(e, o).next(f => {
                    if (!f) return a++, n.getEntry(e, o).next(() => (n.removeEntry(o, Fr.min()), xy(e).delete([0, fu(o.path)])))
                });
                i.push(l)
            }
        }).next(() => Je.waitFor(i)).next(() => n.apply(e)).next(() => a)
    }

    removeTarget(e, r) {
        const n = r.withSequenceNumber(e.currentSequenceNumber);
        return this.db.getTargetCache().updateTargetData(e, n)
    }

    updateLimboDocument(e, r) {
        return Y7(e, r)
    }

    Kn(e, r) {
        const n = xy(e);
        let i, a = Xu.at;
        return n.Z({index: "documentTargetsIndex"}, ([o, s], {path: l, sequenceNumber: f}) => {
            o === 0 ? (a !== Xu.at && r(new jt(A0(i)), a), a = f, i = l) : a = Xu.at
        }).next(() => {
            a !== Xu.at && r(new jt(A0(i)), a)
        })
    }

    getCacheSize(e) {
        return this.db.getRemoteDocumentCache().getSize(e)
    }
}

function Y7(t, e) {
    return xy(t).put(function (r, n) {
        return {targetId: 0, path: fu(r.path), sequenceNumber: n}
    }(e, t.currentSequenceNumber))
}

class gAe {
    constructor() {
        this.changes = new D1(e => e.toString(), (e, r) => e.isEqual(r)), this.changesApplied = !1
    }

    addEntry(e) {
        this.assertNotApplied(), this.changes.set(e.key, e)
    }

    removeEntry(e, r) {
        this.assertNotApplied(), this.changes.set(e, ja.newInvalidDocument(e).setReadTime(r))
    }

    getEntry(e, r) {
        this.assertNotApplied();
        const n = this.changes.get(r);
        return n !== void 0 ? Je.resolve(n) : this.getFromCache(e, r)
    }

    getEntries(e, r) {
        return this.getAllFromCache(e, r)
    }

    apply(e) {
        return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e)
    }

    assertNotApplied() {
    }
}

class mFt {
    constructor(e) {
        this.yt = e
    }

    setIndexManager(e) {
        this.indexManager = e
    }

    addEntry(e, r, n) {
        return Qb(e).put(n)
    }

    removeEntry(e, r, n) {
        return Qb(e).delete(function (i, a) {
            const o = i.path.toArray();
            return [o.slice(0, o.length - 2), o[o.length - 2], hP(a), o[o.length - 1]]
        }(r, n))
    }

    updateMetadata(e, r) {
        return this.getMetadata(e).next(n => (n.byteSize += r, this.Qn(e, n)))
    }

    getEntry(e, r) {
        let n = ja.newInvalidDocument(r);
        return Qb(e).Z({index: "documentKeyIndex", range: IDBKeyRange.only(gT(r))}, (i, a) => {
            n = this.jn(r, a)
        }).next(() => n)
    }

    Wn(e, r) {
        let n = {size: 0, document: ja.newInvalidDocument(r)};
        return Qb(e).Z({index: "documentKeyIndex", range: IDBKeyRange.only(gT(r))}, (i, a) => {
            n = {document: this.jn(r, a), size: mP(a)}
        }).next(() => n)
    }

    getEntries(e, r) {
        let n = Zu();
        return this.zn(e, r, (i, a) => {
            const o = this.jn(i, a);
            n = n.insert(i, o)
        }).next(() => n)
    }

    Hn(e, r) {
        let n = Zu(), i = new Mo(jt.comparator);
        return this.zn(e, r, (a, o) => {
            const s = this.jn(a, o);
            n = n.insert(a, s), i = i.insert(a, mP(o))
        }).next(() => ({documents: n, Jn: i}))
    }

    zn(e, r, n) {
        if (r.isEmpty()) return Je.resolve();
        let i = new fa(tme);
        r.forEach(l => i = i.add(l));
        const a = IDBKeyRange.bound(gT(i.first()), gT(i.last())), o = i.getIterator();
        let s = o.getNext();
        return Qb(e).Z({index: "documentKeyIndex", range: a}, (l, f, d) => {
            const p = jt.fromSegments([...f.prefixPath, f.collectionGroup, f.documentId]);
            for (; s && tme(s, p) < 0;) n(s, null), s = o.getNext();
            s && s.isEqual(p) && (n(s, f), s = o.hasNext() ? o.getNext() : null), s ? d.j(gT(s)) : d.done()
        }).next(() => {
            for (; s;) n(s, null), s = o.hasNext() ? o.getNext() : null
        })
    }

    getDocumentsMatchingQuery(e, r, n, i) {
        const a = r.path,
            o = [a.popLast().toArray(), a.lastSegment(), hP(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()],
            s = [a.popLast().toArray(), a.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
        return Qb(e).W(IDBKeyRange.bound(o, s, !0)).next(l => {
            let f = Zu();
            for (const d of l) {
                const p = this.jn(jt.fromSegments(d.prefixPath.concat(d.collectionGroup, d.documentId)), d);
                p.isFoundDocument() && (NI(r, p) || i.has(p.key)) && (f = f.insert(p.key, p))
            }
            return f
        })
    }

    getAllFromCollectionGroup(e, r, n, i) {
        let a = Zu();
        const o = eme(r, n), s = eme(r, Qf.max());
        return Qb(e).Z({index: "collectionGroupIndex", range: IDBKeyRange.bound(o, s, !0)}, (l, f, d) => {
            const p = this.jn(jt.fromSegments(f.prefixPath.concat(f.collectionGroup, f.documentId)), f);
            a = a.insert(p.key, p), a.size === i && d.done()
        }).next(() => a)
    }

    newChangeBuffer(e) {
        return new vFt(this, !!e && e.trackRemovals)
    }

    getSize(e) {
        return this.getMetadata(e).next(r => r.byteSize)
    }

    getMetadata(e) {
        return J0e(e).get("remoteDocumentGlobalKey").next(r => (Er(!!r), r))
    }

    Qn(e, r) {
        return J0e(e).put("remoteDocumentGlobalKey", r)
    }

    jn(e, r) {
        if (r) {
            const n = eFt(this.yt, r);
            if (!(n.isNoDocument() && n.version.isEqual(Fr.min()))) return n
        }
        return ja.newInvalidDocument(e)
    }
}

function yAe(t) {
    return new mFt(t)
}

class vFt extends gAe {
    constructor(e, r) {
        super(), this.Yn = e, this.trackRemovals = r, this.Xn = new D1(n => n.toString(), (n, i) => n.isEqual(i))
    }

    applyChanges(e) {
        const r = [];
        let n = 0, i = new fa((a, o) => gn(a.canonicalString(), o.canonicalString()));
        return this.changes.forEach((a, o) => {
            const s = this.Xn.get(a);
            if (r.push(this.Yn.removeEntry(e, a, s.readTime)), o.isValidDocument()) {
                const l = U0e(this.Yn.yt, o);
                i = i.add(a.path.popLast());
                const f = mP(l);
                n += f - s.size, r.push(this.Yn.addEntry(e, a, l))
            } else if (n -= s.size, this.trackRemovals) {
                const l = U0e(this.Yn.yt, o.convertToNoDocument(Fr.min()));
                r.push(this.Yn.addEntry(e, a, l))
            }
        }), i.forEach(a => {
            r.push(this.Yn.indexManager.addToCollectionParentIndex(e, a))
        }), r.push(this.Yn.updateMetadata(e, n)), Je.waitFor(r)
    }

    getFromCache(e, r) {
        return this.Yn.Wn(e, r).next(n => (this.Xn.set(r, {size: n.size, readTime: n.document.readTime}), n.document))
    }

    getAllFromCache(e, r) {
        return this.Yn.Hn(e, r).next(({documents: n, Jn: i}) => (i.forEach((a, o) => {
            this.Xn.set(a, {size: o, readTime: n.get(a).readTime})
        }), n))
    }
}

function J0e(t) {
    return lc(t, "remoteDocumentGlobal")
}

function Qb(t) {
    return lc(t, "remoteDocumentsV14")
}

function gT(t) {
    const e = t.path.toArray();
    return [e.slice(0, e.length - 2), e[e.length - 2], e[e.length - 1]]
}

function eme(t, e) {
    const r = e.documentKey.path.toArray();
    return [t, hP(e.readTime), r.slice(0, r.length - 2), r.length > 0 ? r[r.length - 1] : ""]
}

function tme(t, e) {
    const r = t.path.toArray(), n = e.path.toArray();
    let i = 0;
    for (let a = 0; a < r.length - 2 && a < n.length - 2; ++a) if (i = gn(r[a], n[a]), i) return i;
    return i = gn(r.length, n.length), i || (i = gn(r[r.length - 2], n[n.length - 2]), i || gn(r[r.length - 1], n[n.length - 1]))
}

class gFt {
    constructor(e, r) {
        this.overlayedDocument = e, this.mutatedFields = r
    }
}

class bAe {
    constructor(e, r, n, i) {
        this.remoteDocumentCache = e, this.mutationQueue = r, this.documentOverlayCache = n, this.indexManager = i
    }

    getDocument(e, r) {
        let n = null;
        return this.documentOverlayCache.getOverlay(e, r).next(i => (n = i, this.remoteDocumentCache.getEntry(e, r))).next(i => (n !== null && CC(n.mutation, i, Qu.empty(), Ca.now()), i))
    }

    getDocuments(e, r) {
        return this.remoteDocumentCache.getEntries(e, r).next(n => this.getLocalViewOfDocuments(e, n, Tn()).next(() => n))
    }

    getLocalViewOfDocuments(e, r, n = Tn()) {
        const i = C0();
        return this.populateOverlays(e, i, r).next(() => this.computeViews(e, r, i, n).next(a => {
            let o = HT();
            return a.forEach((s, l) => {
                o = o.insert(s, l.overlayedDocument)
            }), o
        }))
    }

    getOverlayedDocuments(e, r) {
        const n = C0();
        return this.populateOverlays(e, n, r).next(() => this.computeViews(e, r, n, Tn()))
    }

    populateOverlays(e, r, n) {
        const i = [];
        return n.forEach(a => {
            r.has(a) || i.push(a)
        }), this.documentOverlayCache.getOverlays(e, i).next(a => {
            a.forEach((o, s) => {
                r.set(o, s)
            })
        })
    }

    computeViews(e, r, n, i) {
        let a = Zu();
        const o = AC(), s = AC();
        return r.forEach((l, f) => {
            const d = n.get(f.key);
            i.has(f.key) && (d === void 0 || d.mutation instanceof ng) ? a = a.insert(f.key, f) : d !== void 0 ? (o.set(f.key, d.mutation.getFieldMask()), CC(d.mutation, f, d.mutation.getFieldMask(), Ca.now())) : o.set(f.key, Qu.empty())
        }), this.recalculateAndSaveOverlays(e, a).next(l => (l.forEach((f, d) => o.set(f, d)), r.forEach((f, d) => {
            var p;
            return s.set(f, new gFt(d, (p = o.get(f)) !== null && p !== void 0 ? p : null))
        }), s))
    }

    recalculateAndSaveOverlays(e, r) {
        const n = AC();
        let i = new Mo((o, s) => o - s), a = Tn();
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, r).next(o => {
            for (const s of o) s.keys().forEach(l => {
                const f = r.get(l);
                if (f === null) return;
                let d = n.get(l) || Qu.empty();
                d = s.applyToLocalView(f, d), n.set(l, d);
                const p = (i.get(s.batchId) || Tn()).add(l);
                i = i.insert(s.batchId, p)
            })
        }).next(() => {
            const o = [], s = i.getReverseIterator();
            for (; s.hasNext();) {
                const l = s.getNext(), f = l.key, d = l.value, p = GCe();
                d.forEach(g => {
                    if (!a.has(g)) {
                        const b = jCe(r.get(g), n.get(g));
                        b !== null && p.set(g, b), a = a.add(g)
                    }
                }), o.push(this.documentOverlayCache.saveOverlays(e, f, p))
            }
            return Je.waitFor(o)
        }).next(() => n)
    }

    recalculateAndSaveOverlaysForDocumentKeys(e, r) {
        return this.remoteDocumentCache.getEntries(e, r).next(n => this.recalculateAndSaveOverlays(e, n))
    }

    getDocumentsMatchingQuery(e, r, n) {
        return function (i) {
            return jt.isDocumentKey(i.path) && i.collectionGroup === null && i.filters.length === 0
        }(r) ? this.getDocumentsMatchingDocumentQuery(e, r.path) : zee(r) ? this.getDocumentsMatchingCollectionGroupQuery(e, r, n) : this.getDocumentsMatchingCollectionQuery(e, r, n)
    }

    getNextDocuments(e, r, n, i) {
        return this.remoteDocumentCache.getAllFromCollectionGroup(e, r, n, i).next(a => {
            const o = i - a.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, r, n.largestBatchId, i - a.size) : Je.resolve(C0());
            let s = -1, l = a;
            return o.next(f => Je.forEach(f, (d, p) => (s < p.largestBatchId && (s = p.largestBatchId), a.get(d) ? Je.resolve() : this.remoteDocumentCache.getEntry(e, d).next(g => {
                l = l.insert(d, g)
            }))).next(() => this.populateOverlays(e, f, a)).next(() => this.computeViews(e, l, f, Tn())).next(d => ({
                batchId: s,
                changes: qCe(d)
            })))
        })
    }

    getDocumentsMatchingDocumentQuery(e, r) {
        return this.getDocument(e, new jt(r)).next(n => {
            let i = HT();
            return n.isFoundDocument() && (i = i.insert(n.key, n)), i
        })
    }

    getDocumentsMatchingCollectionGroupQuery(e, r, n) {
        const i = r.collectionGroup;
        let a = HT();
        return this.indexManager.getCollectionParents(e, i).next(o => Je.forEach(o, s => {
            const l = function (f, d) {
                return new rg(d, null, f.explicitOrderBy.slice(), f.filters.slice(), f.limit, f.limitType, f.startAt, f.endAt)
            }(r, s.child(i));
            return this.getDocumentsMatchingCollectionQuery(e, l, n).next(f => {
                f.forEach((d, p) => {
                    a = a.insert(d, p)
                })
            })
        }).next(() => a))
    }

    getDocumentsMatchingCollectionQuery(e, r, n) {
        let i;
        return this.documentOverlayCache.getOverlaysForCollection(e, r.path, n.largestBatchId).next(a => (i = a, this.remoteDocumentCache.getDocumentsMatchingQuery(e, r, n, i))).next(a => {
            i.forEach((s, l) => {
                const f = l.getKey();
                a.get(f) === null && (a = a.insert(f, ja.newInvalidDocument(f)))
            });
            let o = HT();
            return a.forEach((s, l) => {
                const f = i.get(s);
                f !== void 0 && CC(f.mutation, l, Qu.empty(), Ca.now()), NI(r, l) && (o = o.insert(s, l))
            }), o
        })
    }
}

class yFt {
    constructor(e) {
        this.yt = e, this.Zn = new Map, this.ts = new Map
    }

    getBundleMetadata(e, r) {
        return Je.resolve(this.Zn.get(r))
    }

    saveBundleMetadata(e, r) {
        var n;
        return this.Zn.set(r.id, {id: (n = r).id, version: n.version, createTime: qo(n.createTime)}), Je.resolve()
    }

    getNamedQuery(e, r) {
        return Je.resolve(this.ts.get(r))
    }

    saveNamedQuery(e, r) {
        return this.ts.set(r.name, function (n) {
            return {name: n.name, query: Yee(n.bundledQuery), readTime: qo(n.readTime)}
        }(r)), Je.resolve()
    }
}

class bFt {
    constructor() {
        this.overlays = new Mo(jt.comparator), this.es = new Map
    }

    getOverlay(e, r) {
        return Je.resolve(this.overlays.get(r))
    }

    getOverlays(e, r) {
        const n = C0();
        return Je.forEach(r, i => this.getOverlay(e, i).next(a => {
            a !== null && n.set(i, a)
        })).next(() => n)
    }

    saveOverlays(e, r, n) {
        return n.forEach((i, a) => {
            this.oe(e, r, a)
        }), Je.resolve()
    }

    removeOverlaysForBatchId(e, r, n) {
        const i = this.es.get(n);
        return i !== void 0 && (i.forEach(a => this.overlays = this.overlays.remove(a)), this.es.delete(n)), Je.resolve()
    }

    getOverlaysForCollection(e, r, n) {
        const i = C0(), a = r.length + 1, o = new jt(r.child("")), s = this.overlays.getIteratorFrom(o);
        for (; s.hasNext();) {
            const l = s.getNext().value, f = l.getKey();
            if (!r.isPrefixOf(f.path)) break;
            f.path.length === a && l.largestBatchId > n && i.set(l.getKey(), l)
        }
        return Je.resolve(i)
    }

    getOverlaysForCollectionGroup(e, r, n, i) {
        let a = new Mo((f, d) => f - d);
        const o = this.overlays.getIterator();
        for (; o.hasNext();) {
            const f = o.getNext().value;
            if (f.getKey().getCollectionGroup() === r && f.largestBatchId > n) {
                let d = a.get(f.largestBatchId);
                d === null && (d = C0(), a = a.insert(f.largestBatchId, d)), d.set(f.getKey(), f)
            }
        }
        const s = C0(), l = a.getIterator();
        for (; l.hasNext() && (l.getNext().value.forEach((f, d) => s.set(f, d)), !(s.size() >= i));) ;
        return Je.resolve(s)
    }

    oe(e, r, n) {
        const i = this.overlays.get(n.key);
        if (i !== null) {
            const o = this.es.get(i.largestBatchId).delete(n.key);
            this.es.set(i.largestBatchId, o)
        }
        this.overlays = this.overlays.insert(n.key, new Kee(r, n));
        let a = this.es.get(r);
        a === void 0 && (a = Tn(), this.es.set(r, a)), this.es.set(r, a.add(n.key))
    }
}

class Zee {
    constructor() {
        this.ns = new fa(Ys.ss), this.rs = new fa(Ys.os)
    }

    isEmpty() {
        return this.ns.isEmpty()
    }

    addReference(e, r) {
        const n = new Ys(e, r);
        this.ns = this.ns.add(n), this.rs = this.rs.add(n)
    }

    us(e, r) {
        e.forEach(n => this.addReference(n, r))
    }

    removeReference(e, r) {
        this.cs(new Ys(e, r))
    }

    hs(e, r) {
        e.forEach(n => this.removeReference(n, r))
    }

    ls(e) {
        const r = new jt(new Ei([])), n = new Ys(r, e), i = new Ys(r, e + 1), a = [];
        return this.rs.forEachInRange([n, i], o => {
            this.cs(o), a.push(o.key)
        }), a
    }

    fs() {
        this.ns.forEach(e => this.cs(e))
    }

    cs(e) {
        this.ns = this.ns.delete(e), this.rs = this.rs.delete(e)
    }

    ds(e) {
        const r = new jt(new Ei([])), n = new Ys(r, e), i = new Ys(r, e + 1);
        let a = Tn();
        return this.rs.forEachInRange([n, i], o => {
            a = a.add(o.key)
        }), a
    }

    containsKey(e) {
        const r = new Ys(e, 0), n = this.ns.firstAfterOrEqual(r);
        return n !== null && e.isEqual(n.key)
    }
}

class Ys {
    constructor(e, r) {
        this.key = e, this._s = r
    }

    static ss(e, r) {
        return jt.comparator(e.key, r.key) || gn(e._s, r._s)
    }

    static os(e, r) {
        return gn(e._s, r._s) || jt.comparator(e.key, r.key)
    }
}

class wFt {
    constructor(e, r) {
        this.indexManager = e, this.referenceDelegate = r, this.mutationQueue = [], this.ws = 1, this.gs = new fa(Ys.ss)
    }

    checkEmpty(e) {
        return Je.resolve(this.mutationQueue.length === 0)
    }

    addMutationBatch(e, r, n, i) {
        const a = this.ws;
        this.ws++;
        const o = new qee(a, r, n, i);
        this.mutationQueue.push(o);
        for (const s of i) this.gs = this.gs.add(new Ys(s.key, a)), this.indexManager.addToCollectionParentIndex(e, s.key.path.popLast());
        return Je.resolve(o)
    }

    lookupMutationBatch(e, r) {
        return Je.resolve(this.ys(r))
    }

    getNextMutationBatchAfterBatchId(e, r) {
        const n = r + 1, i = this.ps(n), a = i < 0 ? 0 : i;
        return Je.resolve(this.mutationQueue.length > a ? this.mutationQueue[a] : null)
    }

    getHighestUnacknowledgedBatchId() {
        return Je.resolve(this.mutationQueue.length === 0 ? -1 : this.ws - 1)
    }

    getAllMutationBatches(e) {
        return Je.resolve(this.mutationQueue.slice())
    }

    getAllMutationBatchesAffectingDocumentKey(e, r) {
        const n = new Ys(r, 0), i = new Ys(r, Number.POSITIVE_INFINITY), a = [];
        return this.gs.forEachInRange([n, i], o => {
            const s = this.ys(o._s);
            a.push(s)
        }), Je.resolve(a)
    }

    getAllMutationBatchesAffectingDocumentKeys(e, r) {
        let n = new fa(gn);
        return r.forEach(i => {
            const a = new Ys(i, 0), o = new Ys(i, Number.POSITIVE_INFINITY);
            this.gs.forEachInRange([a, o], s => {
                n = n.add(s._s)
            })
        }), Je.resolve(this.Is(n))
    }

    getAllMutationBatchesAffectingQuery(e, r) {
        const n = r.path, i = n.length + 1;
        let a = n;
        jt.isDocumentKey(a) || (a = a.child(""));
        const o = new Ys(new jt(a), 0);
        let s = new fa(gn);
        return this.gs.forEachWhile(l => {
            const f = l.key.path;
            return !!n.isPrefixOf(f) && (f.length === i && (s = s.add(l._s)), !0)
        }, o), Je.resolve(this.Is(s))
    }

    Is(e) {
        const r = [];
        return e.forEach(n => {
            const i = this.ys(n);
            i !== null && r.push(i)
        }), r
    }

    removeMutationBatch(e, r) {
        Er(this.Ts(r.batchId, "removed") === 0), this.mutationQueue.shift();
        let n = this.gs;
        return Je.forEach(r.mutations, i => {
            const a = new Ys(i.key, r.batchId);
            return n = n.delete(a), this.referenceDelegate.markPotentiallyOrphaned(e, i.key)
        }).next(() => {
            this.gs = n
        })
    }

    An(e) {
    }

    containsKey(e, r) {
        const n = new Ys(r, 0), i = this.gs.firstAfterOrEqual(n);
        return Je.resolve(r.isEqual(i && i.key))
    }

    performConsistencyCheck(e) {
        return Je.resolve()
    }

    Ts(e, r) {
        return this.ps(e)
    }

    ps(e) {
        return this.mutationQueue.length === 0 ? 0 : e - this.mutationQueue[0].batchId
    }

    ys(e) {
        const r = this.ps(e);
        return r < 0 || r >= this.mutationQueue.length ? null : this.mutationQueue[r]
    }
}

class SFt {
    constructor(e) {
        this.Es = e, this.docs = new Mo(jt.comparator), this.size = 0
    }

    setIndexManager(e) {
        this.indexManager = e
    }

    addEntry(e, r) {
        const n = r.key, i = this.docs.get(n), a = i ? i.size : 0, o = this.Es(r);
        return this.docs = this.docs.insert(n, {
            document: r.mutableCopy(),
            size: o
        }), this.size += o - a, this.indexManager.addToCollectionParentIndex(e, n.path.popLast())
    }

    removeEntry(e) {
        const r = this.docs.get(e);
        r && (this.docs = this.docs.remove(e), this.size -= r.size)
    }

    getEntry(e, r) {
        const n = this.docs.get(r);
        return Je.resolve(n ? n.document.mutableCopy() : ja.newInvalidDocument(r))
    }

    getEntries(e, r) {
        let n = Zu();
        return r.forEach(i => {
            const a = this.docs.get(i);
            n = n.insert(i, a ? a.document.mutableCopy() : ja.newInvalidDocument(i))
        }), Je.resolve(n)
    }

    getDocumentsMatchingQuery(e, r, n, i) {
        let a = Zu();
        const o = r.path, s = new jt(o.child("")), l = this.docs.getIteratorFrom(s);
        for (; l.hasNext();) {
            const {key: f, value: {document: d}} = l.getNext();
            if (!o.isPrefixOf(f.path)) break;
            f.path.length > o.length + 1 || Bee(mCe(d), n) <= 0 || (i.has(d.key) || NI(r, d)) && (a = a.insert(d.key, d.mutableCopy()))
        }
        return Je.resolve(a)
    }

    getAllFromCollectionGroup(e, r, n, i) {
        lr()
    }

    As(e, r) {
        return Je.forEach(this.docs, n => r(n))
    }

    newChangeBuffer(e) {
        return new _Ft(this)
    }

    getSize(e) {
        return Je.resolve(this.size)
    }
}

class _Ft extends gAe {
    constructor(e) {
        super(), this.Yn = e
    }

    applyChanges(e) {
        const r = [];
        return this.changes.forEach((n, i) => {
            i.isValidDocument() ? r.push(this.Yn.addEntry(e, i)) : this.Yn.removeEntry(n)
        }), Je.waitFor(r)
    }

    getFromCache(e, r) {
        return this.Yn.getEntry(e, r)
    }

    getAllFromCache(e, r) {
        return this.Yn.getEntries(e, r)
    }
}

class xFt {
    constructor(e) {
        this.persistence = e, this.Rs = new D1(r => xS(r), OI), this.lastRemoteSnapshotVersion = Fr.min(), this.highestTargetId = 0, this.bs = 0, this.Ps = new Zee, this.targetCount = 0, this.vs = IS.Pn()
    }

    forEachTarget(e, r) {
        return this.Rs.forEach((n, i) => r(i)), Je.resolve()
    }

    getLastRemoteSnapshotVersion(e) {
        return Je.resolve(this.lastRemoteSnapshotVersion)
    }

    getHighestSequenceNumber(e) {
        return Je.resolve(this.bs)
    }

    allocateTargetId(e) {
        return this.highestTargetId = this.vs.next(), Je.resolve(this.highestTargetId)
    }

    setTargetsMetadata(e, r, n) {
        return n && (this.lastRemoteSnapshotVersion = n), r > this.bs && (this.bs = r), Je.resolve()
    }

    Dn(e) {
        this.Rs.set(e.target, e);
        const r = e.targetId;
        r > this.highestTargetId && (this.vs = new IS(r), this.highestTargetId = r), e.sequenceNumber > this.bs && (this.bs = e.sequenceNumber)
    }

    addTargetData(e, r) {
        return this.Dn(r), this.targetCount += 1, Je.resolve()
    }

    updateTargetData(e, r) {
        return this.Dn(r), Je.resolve()
    }

    removeTargetData(e, r) {
        return this.Rs.delete(r.target), this.Ps.ls(r.targetId), this.targetCount -= 1, Je.resolve()
    }

    removeTargets(e, r, n) {
        let i = 0;
        const a = [];
        return this.Rs.forEach((o, s) => {
            s.sequenceNumber <= r && n.get(s.targetId) === null && (this.Rs.delete(o), a.push(this.removeMatchingKeysForTargetId(e, s.targetId)), i++)
        }), Je.waitFor(a).next(() => i)
    }

    getTargetCount(e) {
        return Je.resolve(this.targetCount)
    }

    getTargetData(e, r) {
        const n = this.Rs.get(r) || null;
        return Je.resolve(n)
    }

    addMatchingKeys(e, r, n) {
        return this.Ps.us(r, n), Je.resolve()
    }

    removeMatchingKeys(e, r, n) {
        this.Ps.hs(r, n);
        const i = this.persistence.referenceDelegate, a = [];
        return i && r.forEach(o => {
            a.push(i.markPotentiallyOrphaned(e, o))
        }), Je.waitFor(a)
    }

    removeMatchingKeysForTargetId(e, r) {
        return this.Ps.ls(r), Je.resolve()
    }

    getMatchingKeysForTargetId(e, r) {
        const n = this.Ps.ds(r);
        return Je.resolve(n)
    }

    containsKey(e, r) {
        return Je.resolve(this.Ps.containsKey(r))
    }
}

class wAe {
    constructor(e, r) {
        this.Vs = {}, this.overlays = {}, this.Ss = new Xu(0), this.Ds = !1, this.Ds = !0, this.referenceDelegate = e(this), this.Cs = new xFt(this), this.indexManager = new cFt, this.remoteDocumentCache = function (n) {
            return new SFt(n)
        }(n => this.referenceDelegate.xs(n)), this.yt = new uAe(r), this.Ns = new yFt(this.yt)
    }

    start() {
        return Promise.resolve()
    }

    shutdown() {
        return this.Ds = !1, Promise.resolve()
    }

    get started() {
        return this.Ds
    }

    setDatabaseDeletedListener() {
    }

    setNetworkEnabled() {
    }

    getIndexManager(e) {
        return this.indexManager
    }

    getDocumentOverlayCache(e) {
        let r = this.overlays[e.toKey()];
        return r || (r = new bFt, this.overlays[e.toKey()] = r), r
    }

    getMutationQueue(e, r) {
        let n = this.Vs[e.toKey()];
        return n || (n = new wFt(r, this.referenceDelegate), this.Vs[e.toKey()] = n), n
    }

    getTargetCache() {
        return this.Cs
    }

    getRemoteDocumentCache() {
        return this.remoteDocumentCache
    }

    getBundleCache() {
        return this.Ns
    }

    runTransaction(e, r, n) {
        It("MemoryPersistence", "Starting transaction:", e);
        const i = new EFt(this.Ss.next());
        return this.referenceDelegate.ks(), n(i).next(a => this.referenceDelegate.Os(i).next(() => a)).toPromise().then(a => (i.raiseOnCommittedEvent(), a))
    }

    Ms(e, r) {
        return Je.or(Object.values(this.Vs).map(n => () => n.containsKey(e, r)))
    }
}

class EFt extends gCe {
    constructor(e) {
        super(), this.currentSequenceNumber = e
    }
}

class KL {
    constructor(e) {
        this.persistence = e, this.Fs = new Zee, this.$s = null
    }

    static Bs(e) {
        return new KL(e)
    }

    get Ls() {
        if (this.$s) return this.$s;
        throw lr()
    }

    addReference(e, r, n) {
        return this.Fs.addReference(n, r), this.Ls.delete(n.toString()), Je.resolve()
    }

    removeReference(e, r, n) {
        return this.Fs.removeReference(n, r), this.Ls.add(n.toString()), Je.resolve()
    }

    markPotentiallyOrphaned(e, r) {
        return this.Ls.add(r.toString()), Je.resolve()
    }

    removeTarget(e, r) {
        this.Fs.ls(r.targetId).forEach(i => this.Ls.add(i.toString()));
        const n = this.persistence.getTargetCache();
        return n.getMatchingKeysForTargetId(e, r.targetId).next(i => {
            i.forEach(a => this.Ls.add(a.toString()))
        }).next(() => n.removeTargetData(e, r))
    }

    ks() {
        this.$s = new Set
    }

    Os(e) {
        const r = this.persistence.getRemoteDocumentCache().newChangeBuffer();
        return Je.forEach(this.Ls, n => {
            const i = jt.fromPath(n);
            return this.qs(e, i).next(a => {
                a || r.removeEntry(i, Fr.min())
            })
        }).next(() => (this.$s = null, r.apply(e)))
    }

    updateLimboDocument(e, r) {
        return this.qs(e, r).next(n => {
            n ? this.Ls.delete(r.toString()) : this.Ls.add(r.toString())
        })
    }

    xs(e) {
        return 0
    }

    qs(e, r) {
        return Je.or([() => Je.resolve(this.Fs.containsKey(r)), () => this.persistence.getTargetCache().containsKey(e, r), () => this.persistence.Ms(e, r)])
    }
}

class TFt {
    constructor(e) {
        this.yt = e
    }

    $(e, r, n, i) {
        const a = new jL("createOrUpgrade", r);
        n < 1 && i >= 1 && (function (s) {
            s.createObjectStore("owner")
        }(e), function (s) {
            s.createObjectStore("mutationQueues", {keyPath: "userId"}), s.createObjectStore("mutations", {
                keyPath: "batchId",
                autoIncrement: !0
            }).createIndex("userMutationsIndex", F0e, {unique: !0}), s.createObjectStore("documentMutations")
        }(e), rme(e), function (s) {
            s.createObjectStore("remoteDocuments")
        }(e));
        let o = Je.resolve();
        return n < 3 && i >= 3 && (n !== 0 && (function (s) {
            s.deleteObjectStore("targetDocuments"), s.deleteObjectStore("targets"), s.deleteObjectStore("targetGlobal")
        }(e), rme(e)), o = o.next(() => function (s) {
            const l = s.store("targetGlobal"), f = {
                highestTargetId: 0,
                highestListenSequenceNumber: 0,
                lastRemoteSnapshotVersion: Fr.min().toTimestamp(),
                targetCount: 0
            };
            return l.put("targetGlobalKey", f)
        }(a))), n < 4 && i >= 4 && (n !== 0 && (o = o.next(() => function (s, l) {
            return l.store("mutations").W().next(f => {
                s.deleteObjectStore("mutations"), s.createObjectStore("mutations", {
                    keyPath: "batchId",
                    autoIncrement: !0
                }).createIndex("userMutationsIndex", F0e, {unique: !0});
                const d = l.store("mutations"), p = f.map(g => d.put(g));
                return Je.waitFor(p)
            })
        }(e, a))), o = o.next(() => {
            (function (s) {
                s.createObjectStore("clientMetadata", {keyPath: "clientId"})
            })(e)
        })), n < 5 && i >= 5 && (o = o.next(() => this.Us(a))), n < 6 && i >= 6 && (o = o.next(() => (function (s) {
            s.createObjectStore("remoteDocumentGlobal")
        }(e), this.Ks(a)))), n < 7 && i >= 7 && (o = o.next(() => this.Gs(a))), n < 8 && i >= 8 && (o = o.next(() => this.Qs(e, a))), n < 9 && i >= 9 && (o = o.next(() => {
            (function (s) {
                s.objectStoreNames.contains("remoteDocumentChanges") && s.deleteObjectStore("remoteDocumentChanges")
            })(e)
        })), n < 10 && i >= 10 && (o = o.next(() => this.js(a))), n < 11 && i >= 11 && (o = o.next(() => {
            (function (s) {
                s.createObjectStore("bundles", {keyPath: "bundleId"})
            })(e), function (s) {
                s.createObjectStore("namedQueries", {keyPath: "name"})
            }(e)
        })), n < 12 && i >= 12 && (o = o.next(() => {
            (function (s) {
                const l = s.createObjectStore("documentOverlays", {keyPath: Y$t});
                l.createIndex("collectionPathOverlayIndex", X$t, {unique: !1}), l.createIndex("collectionGroupOverlayIndex", Q$t, {unique: !1})
            })(e)
        })), n < 13 && i >= 13 && (o = o.next(() => function (s) {
            const l = s.createObjectStore("remoteDocumentsV14", {keyPath: $$t});
            l.createIndex("documentKeyIndex", F$t), l.createIndex("collectionGroupIndex", U$t)
        }(e)).next(() => this.Ws(e, a)).next(() => e.deleteObjectStore("remoteDocuments"))), n < 14 && i >= 14 && (o = o.next(() => this.zs(e, a))), n < 15 && i >= 15 && (o = o.next(() => function (s) {
            s.createObjectStore("indexConfiguration", {
                keyPath: "indexId",
                autoIncrement: !0
            }).createIndex("collectionGroupIndex", "collectionGroup", {unique: !1}), s.createObjectStore("indexState", {keyPath: W$t}).createIndex("sequenceNumberIndex", q$t, {unique: !1}), s.createObjectStore("indexEntries", {keyPath: G$t}).createIndex("documentKeyIndex", K$t, {unique: !1})
        }(e))), o
    }

    Ks(e) {
        let r = 0;
        return e.store("remoteDocuments").Z((n, i) => {
            r += mP(i)
        }).next(() => {
            const n = {byteSize: r};
            return e.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n)
        })
    }

    Us(e) {
        const r = e.store("mutationQueues"), n = e.store("mutations");
        return r.W().next(i => Je.forEach(i, a => {
            const o = IDBKeyRange.bound([a.userId, -1], [a.userId, a.lastAcknowledgedBatchId]);
            return n.W("userMutationsIndex", o).next(s => Je.forEach(s, l => {
                Er(l.userId === a.userId);
                const f = yw(this.yt, l);
                return pAe(e, a.userId, f).next(() => {
                })
            }))
        }))
    }

    Gs(e) {
        const r = e.store("targetDocuments"), n = e.store("remoteDocuments");
        return e.store("targetGlobal").get("targetGlobalKey").next(i => {
            const a = [];
            return n.Z((o, s) => {
                const l = new Ei(o), f = function (d) {
                    return [0, fu(d)]
                }(l);
                a.push(r.get(f).next(d => d ? Je.resolve() : (p => r.put({
                    targetId: 0,
                    path: fu(p),
                    sequenceNumber: i.highestListenSequenceNumber
                }))(l)))
            }).next(() => Je.waitFor(a))
        })
    }

    Qs(e, r) {
        e.createObjectStore("collectionParents", {keyPath: H$t});
        const n = r.store("collectionParents"), i = new Qee, a = o => {
            if (i.add(o)) {
                const s = o.lastSegment(), l = o.popLast();
                return n.put({collectionId: s, parent: fu(l)})
            }
        };
        return r.store("remoteDocuments").Z({X: !0}, (o, s) => {
            const l = new Ei(o);
            return a(l.popLast())
        }).next(() => r.store("documentMutations").Z({X: !0}, ([o, s, l], f) => {
            const d = A0(s);
            return a(d.popLast())
        }))
    }

    js(e) {
        const r = e.store("targets");
        return r.Z((n, i) => {
            const a = WT(i), o = fAe(this.yt, a);
            return r.put(o)
        })
    }

    Ws(e, r) {
        const n = r.store("remoteDocuments"), i = [];
        return n.Z((a, o) => {
            const s = r.store("remoteDocumentsV14"),
                l = (f = o, f.document ? new jt(Ei.fromString(f.document.name).popFirst(5)) : f.noDocument ? jt.fromSegments(f.noDocument.path) : f.unknownDocument ? jt.fromSegments(f.unknownDocument.path) : lr()).path.toArray();
            var f;
            const d = {
                prefixPath: l.slice(0, l.length - 2),
                collectionGroup: l[l.length - 2],
                documentId: l[l.length - 1],
                readTime: o.readTime || [0, 0],
                unknownDocument: o.unknownDocument,
                noDocument: o.noDocument,
                document: o.document,
                hasCommittedMutations: !!o.hasCommittedMutations
            };
            i.push(s.put(d))
        }).next(() => Je.waitFor(i))
    }

    zs(e, r) {
        const n = r.store("mutations"), i = yAe(this.yt), a = new wAe(KL.Bs, this.yt.ie);
        return n.W().next(o => {
            const s = new Map;
            return o.forEach(l => {
                var f;
                let d = (f = s.get(l.userId)) !== null && f !== void 0 ? f : Tn();
                yw(this.yt, l).keys().forEach(p => d = d.add(p)), s.set(l.userId, d)
            }), Je.forEach(s, (l, f) => {
                const d = new Qs(f), p = qL.re(this.yt, d), g = a.getIndexManager(d),
                    b = GL.re(d, this.yt, g, a.referenceDelegate);
                return new bAe(i, b, p, g).recalculateAndSaveOverlaysForDocumentKeys(new wY(r, Xu.at), l).next()
            })
        })
    }
}

function rme(t) {
    t.createObjectStore("targetDocuments", {keyPath: z$t}).createIndex("documentTargetsIndex", V$t, {unique: !0}), t.createObjectStore("targets", {keyPath: "targetId"}).createIndex("queryTargetsIndex", j$t, {unique: !0}), t.createObjectStore("targetGlobal")
}

const qH = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";

class Jee {
    constructor(e, r, n, i, a, o, s, l, f, d, p = 15) {
        if (this.allowTabSynchronization = e, this.persistenceKey = r, this.clientId = n, this.Hs = a, this.window = o, this.document = s, this.Js = f, this.Ys = d, this.Xs = p, this.Ss = null, this.Ds = !1, this.isPrimary = !1, this.networkEnabled = !0, this.Zs = null, this.inForeground = !1, this.ti = null, this.ei = null, this.ni = Number.NEGATIVE_INFINITY, this.si = g => Promise.resolve(), !Jee.C()) throw new yt(at.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
        this.referenceDelegate = new pFt(this, i), this.ii = r + "main", this.yt = new uAe(l), this.ri = new np(this.ii, this.Xs, new TFt(this.yt)), this.Cs = new uFt(this.referenceDelegate, this.yt), this.remoteDocumentCache = yAe(this.yt), this.Ns = new tFt, this.window && this.window.localStorage ? this.oi = this.window.localStorage : (this.oi = null, d === !1 && Vo("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."))
    }

    start() {
        return this.ui().then(() => {
            if (!this.isPrimary && !this.allowTabSynchronization) throw new yt(at.FAILED_PRECONDITION, qH);
            return this.ci(), this.ai(), this.hi(), this.runTransaction("getHighestListenSequenceNumber", "readonly", e => this.Cs.getHighestSequenceNumber(e))
        }).then(e => {
            this.Ss = new Xu(e, this.Js)
        }).then(() => {
            this.Ds = !0
        }).catch(e => (this.ri && this.ri.close(), Promise.reject(e)))
    }

    li(e) {
        return this.si = async r => {
            if (this.started) return e(r)
        }, e(this.isPrimary)
    }

    setDatabaseDeletedListener(e) {
        this.ri.L(async r => {
            r.newVersion === null && await e()
        })
    }

    setNetworkEnabled(e) {
        this.networkEnabled !== e && (this.networkEnabled = e, this.Hs.enqueueAndForget(async () => {
            this.started && await this.ui()
        }))
    }

    ui() {
        return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", e => X7(e).put({
            clientId: this.clientId,
            updateTimeMs: Date.now(),
            networkEnabled: this.networkEnabled,
            inForeground: this.inForeground
        }).next(() => {
            if (this.isPrimary) return this.fi(e).next(r => {
                r || (this.isPrimary = !1, this.Hs.enqueueRetryable(() => this.si(!1)))
            })
        }).next(() => this.di(e)).next(r => this.isPrimary && !r ? this._i(e).next(() => !1) : !!r && this.wi(e).next(() => !0))).catch(e => {
            if (R1(e)) return It("IndexedDbPersistence", "Failed to extend owner lease: ", e), this.isPrimary;
            if (!this.allowTabSynchronization) throw e;
            return It("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), !1
        }).then(e => {
            this.isPrimary !== e && this.Hs.enqueueRetryable(() => this.si(e)), this.isPrimary = e
        })
    }

    fi(e) {
        return yT(e).get("owner").next(r => Je.resolve(this.mi(r)))
    }

    gi(e) {
        return X7(e).delete(this.clientId)
    }

    async yi() {
        if (this.isPrimary && !this.pi(this.ni, 18e5)) {
            this.ni = Date.now();
            const e = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", r => {
                const n = lc(r, "clientMetadata");
                return n.W().next(i => {
                    const a = this.Ii(i, 18e5), o = i.filter(s => a.indexOf(s) === -1);
                    return Je.forEach(o, s => n.delete(s.clientId)).next(() => o)
                })
            }).catch(() => []);
            if (this.oi) for (const r of e) this.oi.removeItem(this.Ti(r.clientId))
        }
    }

    hi() {
        this.ei = this.Hs.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.ui().then(() => this.yi()).then(() => this.hi()))
    }

    mi(e) {
        return !!e && e.ownerId === this.clientId
    }

    di(e) {
        return this.Ys ? Je.resolve(!0) : yT(e).get("owner").next(r => {
            if (r !== null && this.pi(r.leaseTimestampMs, 5e3) && !this.Ei(r.ownerId)) {
                if (this.mi(r) && this.networkEnabled) return !0;
                if (!this.mi(r)) {
                    if (!r.allowTabSynchronization) throw new yt(at.FAILED_PRECONDITION, qH);
                    return !1
                }
            }
            return !(!this.networkEnabled || !this.inForeground) || X7(e).W().next(n => this.Ii(n, 5e3).find(i => {
                if (this.clientId !== i.clientId) {
                    const a = !this.networkEnabled && i.networkEnabled, o = !this.inForeground && i.inForeground,
                        s = this.networkEnabled === i.networkEnabled;
                    if (a || o && s) return !0
                }
                return !1
            }) === void 0)
        }).next(r => (this.isPrimary !== r && It("IndexedDbPersistence", `Client ${r ? "is" : "is not"} eligible for a primary lease.`), r))
    }

    async shutdown() {
        this.Ds = !1, this.Ai(), this.ei && (this.ei.cancel(), this.ei = null), this.Ri(), this.bi(), await this.ri.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], e => {
            const r = new wY(e, Xu.at);
            return this._i(r).next(() => this.gi(r))
        }), this.ri.close(), this.Pi()
    }

    Ii(e, r) {
        return e.filter(n => this.pi(n.updateTimeMs, r) && !this.Ei(n.clientId))
    }

    vi() {
        return this.runTransaction("getActiveClients", "readonly", e => X7(e).W().next(r => this.Ii(r, 18e5).map(n => n.clientId)))
    }

    get started() {
        return this.Ds
    }

    getMutationQueue(e, r) {
        return GL.re(e, this.yt, r, this.referenceDelegate)
    }

    getTargetCache() {
        return this.Cs
    }

    getRemoteDocumentCache() {
        return this.remoteDocumentCache
    }

    getIndexManager(e) {
        return new lFt(e, this.yt.ie.databaseId)
    }

    getDocumentOverlayCache(e) {
        return qL.re(this.yt, e)
    }

    getBundleCache() {
        return this.Ns
    }

    runTransaction(e, r, n) {
        It("IndexedDbPersistence", "Starting transaction:", e);
        const i = r === "readonly" ? "readonly" : "readwrite",
            a = (o = this.Xs) === 15 ? J$t : o === 14 ? lAe : o === 13 ? cAe : o === 12 ? Z$t : o === 11 ? sAe : void lr();
        var o;
        let s;
        return this.ri.runTransaction(e, i, a, l => (s = new wY(l, this.Ss ? this.Ss.next() : Xu.at), r === "readwrite-primary" ? this.fi(s).next(f => !!f || this.di(s)).next(f => {
            if (!f) throw Vo(`Failed to obtain primary lease for action '${e}'.`), this.isPrimary = !1, this.Hs.enqueueRetryable(() => this.si(!1)), new yt(at.FAILED_PRECONDITION, vCe);
            return n(s)
        }).next(f => this.wi(s).next(() => f)) : this.Vi(s).next(() => n(s)))).then(l => (s.raiseOnCommittedEvent(), l))
    }

    Vi(e) {
        return yT(e).get("owner").next(r => {
            if (r !== null && this.pi(r.leaseTimestampMs, 5e3) && !this.Ei(r.ownerId) && !this.mi(r) && !(this.Ys || this.allowTabSynchronization && r.allowTabSynchronization)) throw new yt(at.FAILED_PRECONDITION, qH)
        })
    }

    wi(e) {
        const r = {
            ownerId: this.clientId,
            allowTabSynchronization: this.allowTabSynchronization,
            leaseTimestampMs: Date.now()
        };
        return yT(e).put("owner", r)
    }

    static C() {
        return np.C()
    }

    _i(e) {
        const r = yT(e);
        return r.get("owner").next(n => this.mi(n) ? (It("IndexedDbPersistence", "Releasing primary lease."), r.delete("owner")) : Je.resolve())
    }

    pi(e, r) {
        const n = Date.now();
        return !(e < n - r) && (!(e > n) || (Vo(`Detected an update time that is in the future: ${e} > ${n}`), !1))
    }

    ci() {
        this.document !== null && typeof this.document.addEventListener == "function" && (this.ti = () => {
            this.Hs.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.ui()))
        }, this.document.addEventListener("visibilitychange", this.ti), this.inForeground = this.document.visibilityState === "visible")
    }

    Ri() {
        this.ti && (this.document.removeEventListener("visibilitychange", this.ti), this.ti = null)
    }

    ai() {
        var e;
        typeof ((e = this.window) === null || e === void 0 ? void 0 : e.addEventListener) == "function" && (this.Zs = () => {
            this.Ai(), fNt() && navigator.appVersion.match(/Version\/1[45]/) && this.Hs.enterRestrictedMode(!0), this.Hs.enqueueAndForget(() => this.shutdown())
        }, this.window.addEventListener("pagehide", this.Zs))
    }

    bi() {
        this.Zs && (this.window.removeEventListener("pagehide", this.Zs), this.Zs = null)
    }

    Ei(e) {
        var r;
        try {
            const n = ((r = this.oi) === null || r === void 0 ? void 0 : r.getItem(this.Ti(e))) !== null;
            return It("IndexedDbPersistence", `Client '${e}' ${n ? "is" : "is not"} zombied in LocalStorage`), n
        } catch (n) {
            return Vo("IndexedDbPersistence", "Failed to get zombied client id.", n), !1
        }
    }

    Ai() {
        if (this.oi) try {
            this.oi.setItem(this.Ti(this.clientId), String(Date.now()))
        } catch (e) {
            Vo("Failed to set zombie client id.", e)
        }
    }

    Pi() {
        if (this.oi) try {
            this.oi.removeItem(this.Ti(this.clientId))
        } catch {
        }
    }

    Ti(e) {
        return `firestore_zombie_${this.persistenceKey}_${e}`
    }
}

function yT(t) {
    return lc(t, "owner")
}

function X7(t) {
    return lc(t, "clientMetadata")
}

function ete(t, e) {
    let r = t.projectId;
    return t.isDefaultDatabase || (r += "." + t.database), "firestore/" + e + "/" + r + "/"
}

class tte {
    constructor(e, r, n, i) {
        this.targetId = e, this.fromCache = r, this.Si = n, this.Di = i
    }

    static Ci(e, r) {
        let n = Tn(), i = Tn();
        for (const a of r.docChanges) switch (a.type) {
            case 0:
                n = n.add(a.doc.key);
                break;
            case 1:
                i = i.add(a.doc.key)
        }
        return new tte(e, r.fromCache, n, i)
    }
}

class SAe {
    constructor() {
        this.xi = !1
    }

    initialize(e, r) {
        this.Ni = e, this.indexManager = r, this.xi = !0
    }

    getDocumentsMatchingQuery(e, r, n, i) {
        return this.ki(e, r).next(a => a || this.Oi(e, r, i, n)).next(a => a || this.Mi(e, r))
    }

    ki(e, r) {
        if (k0e(r)) return Je.resolve(null);
        let n = vu(r);
        return this.indexManager.getIndexType(e, n).next(i => i === 0 ? null : (r.limit !== null && i === 1 && (r = dP(r, null, "F"), n = vu(r)), this.indexManager.getDocumentsMatchingTarget(e, n).next(a => {
            const o = Tn(...a);
            return this.Ni.getDocuments(e, o).next(s => this.indexManager.getMinOffset(e, n).next(l => {
                const f = this.Fi(r, s);
                return this.$i(r, f, o, l.readTime) ? this.ki(e, dP(r, null, "F")) : this.Bi(e, f, r, l)
            }))
        })))
    }

    Oi(e, r, n, i) {
        return k0e(r) || i.isEqual(Fr.min()) ? this.Mi(e, r) : this.Ni.getDocuments(e, n).next(a => {
            const o = this.Fi(r, a);
            return this.$i(r, o, n, i) ? this.Mi(e, r) : (lY() <= Ri.DEBUG && It("QueryEngine", "Re-using previous result from %s to execute query: %s", i.toString(), gY(r)), this.Bi(e, o, r, pCe(i, -1)))
        })
    }

    Fi(e, r) {
        let n = new fa(OCe(e));
        return r.forEach((i, a) => {
            NI(e, a) && (n = n.add(a))
        }), n
    }

    $i(e, r, n, i) {
        if (e.limit === null) return !1;
        if (n.size !== r.size) return !0;
        const a = e.limitType === "F" ? r.last() : r.first();
        return !!a && (a.hasPendingWrites || a.version.compareTo(i) > 0)
    }

    Mi(e, r) {
        return lY() <= Ri.DEBUG && It("QueryEngine", "Using full collection scan to execute query:", gY(r)), this.Ni.getDocumentsMatchingQuery(e, r, Qf.min())
    }

    Bi(e, r, n, i) {
        return this.Ni.getDocumentsMatchingQuery(e, n, i).next(a => (r.forEach(o => {
            a = a.insert(o.key, o)
        }), a))
    }
}

class CFt {
    constructor(e, r, n, i) {
        this.persistence = e, this.Li = r, this.yt = i, this.qi = new Mo(gn), this.Ui = new D1(a => xS(a), OI), this.Ki = new Map, this.Gi = e.getRemoteDocumentCache(), this.Cs = e.getTargetCache(), this.Ns = e.getBundleCache(), this.Qi(n)
    }

    Qi(e) {
        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new bAe(this.Gi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Gi.setIndexManager(this.indexManager), this.Li.initialize(this.localDocuments, this.indexManager)
    }

    collectGarbage(e) {
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", r => e.collect(r, this.qi))
    }
}

function _Ae(t, e, r, n) {
    return new CFt(t, e, r, n)
}

async function xAe(t, e) {
    const r = Ht(t);
    return await r.persistence.runTransaction("Handle user change", "readonly", n => {
        let i;
        return r.mutationQueue.getAllMutationBatches(n).next(a => (i = a, r.Qi(e), r.mutationQueue.getAllMutationBatches(n))).next(a => {
            const o = [], s = [];
            let l = Tn();
            for (const f of i) {
                o.push(f.batchId);
                for (const d of f.mutations) l = l.add(d.key)
            }
            for (const f of a) {
                s.push(f.batchId);
                for (const d of f.mutations) l = l.add(d.key)
            }
            return r.localDocuments.getDocuments(n, l).next(f => ({ji: f, removedBatchIds: o, addedBatchIds: s}))
        })
    })
}

function AFt(t, e) {
    const r = Ht(t);
    return r.persistence.runTransaction("Acknowledge batch", "readwrite-primary", n => {
        const i = e.batch.keys(), a = r.Gi.newChangeBuffer({trackRemovals: !0});
        return function (o, s, l, f) {
            const d = l.batch, p = d.keys();
            let g = Je.resolve();
            return p.forEach(b => {
                g = g.next(() => f.getEntry(s, b)).next(S => {
                    const T = l.docVersions.get(b);
                    Er(T !== null), S.version.compareTo(T) < 0 && (d.applyToRemoteDocument(S, l), S.isValidDocument() && (S.setReadTime(l.commitVersion), f.addEntry(S)))
                })
            }), g.next(() => o.mutationQueue.removeMutationBatch(s, d))
        }(r, n, e, a).next(() => a.apply(n)).next(() => r.mutationQueue.performConsistencyCheck(n)).next(() => r.documentOverlayCache.removeOverlaysForBatchId(n, i, e.batch.batchId)).next(() => r.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(n, function (o) {
            let s = Tn();
            for (let l = 0; l < o.mutationResults.length; ++l) o.mutationResults[l].transformResults.length > 0 && (s = s.add(o.batch.mutations[l].key));
            return s
        }(e))).next(() => r.localDocuments.getDocuments(n, i))
    })
}

function EAe(t) {
    const e = Ht(t);
    return e.persistence.runTransaction("Get last remote snapshot version", "readonly", r => e.Cs.getLastRemoteSnapshotVersion(r))
}

function IFt(t, e) {
    const r = Ht(t), n = e.snapshotVersion;
    let i = r.qi;
    return r.persistence.runTransaction("Apply remote event", "readwrite-primary", a => {
        const o = r.Gi.newChangeBuffer({trackRemovals: !0});
        i = r.qi;
        const s = [];
        e.targetChanges.forEach((d, p) => {
            const g = i.get(p);
            if (!g) return;
            s.push(r.Cs.removeMatchingKeys(a, d.removedDocuments, p).next(() => r.Cs.addMatchingKeys(a, d.addedDocuments, p)));
            let b = g.withSequenceNumber(a.currentSequenceNumber);
            e.targetMismatches.has(p) ? b = b.withResumeToken(Fs.EMPTY_BYTE_STRING, Fr.min()).withLastLimboFreeSnapshotVersion(Fr.min()) : d.resumeToken.approximateByteSize() > 0 && (b = b.withResumeToken(d.resumeToken, n)), i = i.insert(p, b), function (S, T, I) {
                return S.resumeToken.approximateByteSize() === 0 || T.snapshotVersion.toMicroseconds() - S.snapshotVersion.toMicroseconds() >= 3e8 ? !0 : I.addedDocuments.size + I.modifiedDocuments.size + I.removedDocuments.size > 0
            }(g, b, d) && s.push(r.Cs.updateTargetData(a, b))
        });
        let l = Zu(), f = Tn();
        if (e.documentUpdates.forEach(d => {
            e.resolvedLimboDocuments.has(d) && s.push(r.persistence.referenceDelegate.updateLimboDocument(a, d))
        }), s.push(TAe(a, o, e.documentUpdates).next(d => {
            l = d.Wi, f = d.zi
        })), !n.isEqual(Fr.min())) {
            const d = r.Cs.getLastRemoteSnapshotVersion(a).next(p => r.Cs.setTargetsMetadata(a, a.currentSequenceNumber, n));
            s.push(d)
        }
        return Je.waitFor(s).next(() => o.apply(a)).next(() => r.localDocuments.getLocalViewOfDocuments(a, l, f)).next(() => l)
    }).then(a => (r.qi = i, a))
}

function TAe(t, e, r) {
    let n = Tn(), i = Tn();
    return r.forEach(a => n = n.add(a)), e.getEntries(t, n).next(a => {
        let o = Zu();
        return r.forEach((s, l) => {
            const f = a.get(s);
            l.isFoundDocument() !== f.isFoundDocument() && (i = i.add(s)), l.isNoDocument() && l.version.isEqual(Fr.min()) ? (e.removeEntry(s, l.readTime), o = o.insert(s, l)) : !f.isValidDocument() || l.version.compareTo(f.version) > 0 || l.version.compareTo(f.version) === 0 && f.hasPendingWrites ? (e.addEntry(l), o = o.insert(s, l)) : It("LocalStore", "Ignoring outdated watch update for ", s, ". Current version:", f.version, " Watch version:", l.version)
        }), {Wi: o, zi: i}
    })
}

function kFt(t, e) {
    const r = Ht(t);
    return r.persistence.runTransaction("Get next mutation batch", "readonly", n => (e === void 0 && (e = -1), r.mutationQueue.getNextMutationBatchAfterBatchId(n, e)))
}

function wE(t, e) {
    const r = Ht(t);
    return r.persistence.runTransaction("Allocate target", "readwrite", n => {
        let i;
        return r.Cs.getTargetData(n, e).next(a => a ? (i = a, Je.resolve(i)) : r.Cs.allocateTargetId(n).next(o => (i = new Wy(e, o, 0, n.currentSequenceNumber), r.Cs.addTargetData(n, i).next(() => i))))
    }).then(n => {
        const i = r.qi.get(n.targetId);
        return (i === null || n.snapshotVersion.compareTo(i.snapshotVersion) > 0) && (r.qi = r.qi.insert(n.targetId, n), r.Ui.set(e, n.targetId)), n
    })
}

async function SE(t, e, r) {
    const n = Ht(t), i = n.qi.get(e), a = r ? "readwrite" : "readwrite-primary";
    try {
        r || await n.persistence.runTransaction("Release target", a, o => n.persistence.referenceDelegate.removeTarget(o, i))
    } catch (o) {
        if (!R1(o)) throw o;
        It("LocalStore", `Failed to update sequence numbers for target ${e}: ${o}`)
    }
    n.qi = n.qi.remove(e), n.Ui.delete(i.target)
}

function vP(t, e, r) {
    const n = Ht(t);
    let i = Fr.min(), a = Tn();
    return n.persistence.runTransaction("Execute query", "readonly", o => function (s, l, f) {
        const d = Ht(s), p = d.Ui.get(f);
        return p !== void 0 ? Je.resolve(d.qi.get(p)) : d.Cs.getTargetData(l, f)
    }(n, o, vu(e)).next(s => {
        if (s) return i = s.lastLimboFreeSnapshotVersion, n.Cs.getMatchingKeysForTargetId(o, s.targetId).next(l => {
            a = l
        })
    }).next(() => n.Li.getDocumentsMatchingQuery(o, e, r ? i : Fr.min(), r ? a : Tn())).next(s => (IAe(n, MCe(e), s), {
        documents: s,
        Hi: a
    })))
}

function CAe(t, e) {
    const r = Ht(t), n = Ht(r.Cs), i = r.qi.get(e);
    return i ? Promise.resolve(i.target) : r.persistence.runTransaction("Get target data", "readonly", a => n.ne(a, e).next(o => o ? o.target : null))
}

function AAe(t, e) {
    const r = Ht(t), n = r.Ki.get(e) || Fr.min();
    return r.persistence.runTransaction("Get new document changes", "readonly", i => r.Gi.getAllFromCollectionGroup(i, e, pCe(n, -1), Number.MAX_SAFE_INTEGER)).then(i => (IAe(r, e, i), i))
}

function IAe(t, e, r) {
    let n = t.Ki.get(e) || Fr.min();
    r.forEach((i, a) => {
        a.readTime.compareTo(n) > 0 && (n = a.readTime)
    }), t.Ki.set(e, n)
}

async function RFt(t, e, r, n) {
    const i = Ht(t);
    let a = Tn(), o = Zu();
    for (const f of r) {
        const d = e.Ji(f.metadata.name);
        f.document && (a = a.add(d));
        const p = e.Yi(f);
        p.setReadTime(e.Xi(f.metadata.readTime)), o = o.insert(d, p)
    }
    const s = i.Gi.newChangeBuffer({trackRemovals: !0}), l = await wE(i, function (f) {
        return vu(f3(Ei.fromString(`__bundle__/docs/${f}`)))
    }(n));
    return i.persistence.runTransaction("Apply bundle documents", "readwrite", f => TAe(f, s, o).next(d => (s.apply(f), d)).next(d => i.Cs.removeMatchingKeysForTargetId(f, l.targetId).next(() => i.Cs.addMatchingKeys(f, a, l.targetId)).next(() => i.localDocuments.getLocalViewOfDocuments(f, d.Wi, d.zi)).next(() => d.Wi)))
}

async function DFt(t, e, r = Tn()) {
    const n = await wE(t, vu(Yee(e.bundledQuery))), i = Ht(t);
    return i.persistence.runTransaction("Save named query", "readwrite", a => {
        const o = qo(e.readTime);
        if (n.snapshotVersion.compareTo(o) >= 0) return i.Ns.saveNamedQuery(a, e);
        const s = n.withResumeToken(Fs.EMPTY_BYTE_STRING, o);
        return i.qi = i.qi.insert(s.targetId, s), i.Cs.updateTargetData(a, s).next(() => i.Cs.removeMatchingKeysForTargetId(a, n.targetId)).next(() => i.Cs.addMatchingKeys(a, r, n.targetId)).next(() => i.Ns.saveNamedQuery(a, e))
    })
}

function nme(t, e) {
    return `firestore_clients_${t}_${e}`
}

function ime(t, e, r) {
    let n = `firestore_mutations_${t}_${r}`;
    return e.isAuthenticated() && (n += `_${e.uid}`), n
}

function GH(t, e) {
    return `firestore_targets_${t}_${e}`
}

class gP {
    constructor(e, r, n, i) {
        this.user = e, this.batchId = r, this.state = n, this.error = i
    }

    static Zi(e, r, n) {
        const i = JSON.parse(n);
        let a,
            o = typeof i == "object" && ["pending", "acknowledged", "rejected"].indexOf(i.state) !== -1 && (i.error === void 0 || typeof i.error == "object");
        return o && i.error && (o = typeof i.error.message == "string" && typeof i.error.code == "string", o && (a = new yt(i.error.code, i.error.message))), o ? new gP(e, r, i.state, a) : (Vo("SharedClientState", `Failed to parse mutation state for ID '${r}': ${n}`), null)
    }

    tr() {
        const e = {state: this.state, updateTimeMs: Date.now()};
        return this.error && (e.error = {code: this.error.code, message: this.error.message}), JSON.stringify(e)
    }
}

class IC {
    constructor(e, r, n) {
        this.targetId = e, this.state = r, this.error = n
    }

    static Zi(e, r) {
        const n = JSON.parse(r);
        let i,
            a = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
        return a && n.error && (a = typeof n.error.message == "string" && typeof n.error.code == "string", a && (i = new yt(n.error.code, n.error.message))), a ? new IC(e, n.state, i) : (Vo("SharedClientState", `Failed to parse target state for ID '${e}': ${r}`), null)
    }

    tr() {
        const e = {state: this.state, updateTimeMs: Date.now()};
        return this.error && (e.error = {code: this.error.code, message: this.error.message}), JSON.stringify(e)
    }
}

class yP {
    constructor(e, r) {
        this.clientId = e, this.activeTargetIds = r
    }

    static Zi(e, r) {
        const n = JSON.parse(r);
        let i = typeof n == "object" && n.activeTargetIds instanceof Array, a = WL();
        for (let o = 0; i && o < n.activeTargetIds.length; ++o) i = bCe(n.activeTargetIds[o]), a = a.add(n.activeTargetIds[o]);
        return i ? new yP(e, a) : (Vo("SharedClientState", `Failed to parse client data for instance '${e}': ${r}`), null)
    }
}

class rte {
    constructor(e, r) {
        this.clientId = e, this.onlineState = r
    }

    static Zi(e) {
        const r = JSON.parse(e);
        return typeof r == "object" && ["Unknown", "Online", "Offline"].indexOf(r.onlineState) !== -1 && typeof r.clientId == "string" ? new rte(r.clientId, r.onlineState) : (Vo("SharedClientState", `Failed to parse online state: ${e}`), null)
    }
}

class EY {
    constructor() {
        this.activeTargetIds = WL()
    }

    er(e) {
        this.activeTargetIds = this.activeTargetIds.add(e)
    }

    nr(e) {
        this.activeTargetIds = this.activeTargetIds.delete(e)
    }

    tr() {
        const e = {activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now()};
        return JSON.stringify(e)
    }
}

class KH {
    constructor(e, r, n, i, a) {
        this.window = e, this.Hs = r, this.persistenceKey = n, this.sr = i, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.ir = this.rr.bind(this), this.ur = new Mo(gn), this.started = !1, this.cr = [];
        const o = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        this.storage = this.window.localStorage, this.currentUser = a, this.ar = nme(this.persistenceKey, this.sr), this.hr = function (s) {
            return `firestore_sequence_number_${s}`
        }(this.persistenceKey), this.ur = this.ur.insert(this.sr, new EY), this.lr = new RegExp(`^firestore_clients_${o}_([^_]*)$`), this.dr = new RegExp(`^firestore_mutations_${o}_(\\d+)(?:_(.*))?$`), this._r = new RegExp(`^firestore_targets_${o}_(\\d+)$`), this.wr = function (s) {
            return `firestore_online_state_${s}`
        }(this.persistenceKey), this.mr = function (s) {
            return `firestore_bundle_loaded_v2_${s}`
        }(this.persistenceKey), this.window.addEventListener("storage", this.ir)
    }

    static C(e) {
        return !(!e || !e.localStorage)
    }

    async start() {
        const e = await this.syncEngine.vi();
        for (const n of e) {
            if (n === this.sr) continue;
            const i = this.getItem(nme(this.persistenceKey, n));
            if (i) {
                const a = yP.Zi(n, i);
                a && (this.ur = this.ur.insert(a.clientId, a))
            }
        }
        this.gr();
        const r = this.storage.getItem(this.wr);
        if (r) {
            const n = this.yr(r);
            n && this.pr(n)
        }
        for (const n of this.cr) this.rr(n);
        this.cr = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = !0
    }

    writeSequenceNumber(e) {
        this.setItem(this.hr, JSON.stringify(e))
    }

    getAllActiveQueryTargets() {
        return this.Ir(this.ur)
    }

    isActiveQueryTarget(e) {
        let r = !1;
        return this.ur.forEach((n, i) => {
            i.activeTargetIds.has(e) && (r = !0)
        }), r
    }

    addPendingMutation(e) {
        this.Tr(e, "pending")
    }

    updateMutationState(e, r, n) {
        this.Tr(e, r, n), this.Er(e)
    }

    addLocalQueryTarget(e) {
        let r = "not-current";
        if (this.isActiveQueryTarget(e)) {
            const n = this.storage.getItem(GH(this.persistenceKey, e));
            if (n) {
                const i = IC.Zi(e, n);
                i && (r = i.state)
            }
        }
        return this.Ar.er(e), this.gr(), r
    }

    removeLocalQueryTarget(e) {
        this.Ar.nr(e), this.gr()
    }

    isLocalQueryTarget(e) {
        return this.Ar.activeTargetIds.has(e)
    }

    clearQueryState(e) {
        this.removeItem(GH(this.persistenceKey, e))
    }

    updateQueryState(e, r, n) {
        this.Rr(e, r, n)
    }

    handleUserChange(e, r, n) {
        r.forEach(i => {
            this.Er(i)
        }), this.currentUser = e, n.forEach(i => {
            this.addPendingMutation(i)
        })
    }

    setOnlineState(e) {
        this.br(e)
    }

    notifyBundleLoaded(e) {
        this.Pr(e)
    }

    shutdown() {
        this.started && (this.window.removeEventListener("storage", this.ir), this.removeItem(this.ar), this.started = !1)
    }

    getItem(e) {
        const r = this.storage.getItem(e);
        return It("SharedClientState", "READ", e, r), r
    }

    setItem(e, r) {
        It("SharedClientState", "SET", e, r), this.storage.setItem(e, r)
    }

    removeItem(e) {
        It("SharedClientState", "REMOVE", e), this.storage.removeItem(e)
    }

    rr(e) {
        const r = e;
        if (r.storageArea === this.storage) {
            if (It("SharedClientState", "EVENT", r.key, r.newValue), r.key === this.ar) return void Vo("Received WebStorage notification for local change. Another client might have garbage-collected our state");
            this.Hs.enqueueRetryable(async () => {
                if (this.started) {
                    if (r.key !== null) {
                        if (this.lr.test(r.key)) {
                            if (r.newValue == null) {
                                const n = this.vr(r.key);
                                return this.Vr(n, null)
                            }
                            {
                                const n = this.Sr(r.key, r.newValue);
                                if (n) return this.Vr(n.clientId, n)
                            }
                        } else if (this.dr.test(r.key)) {
                            if (r.newValue !== null) {
                                const n = this.Dr(r.key, r.newValue);
                                if (n) return this.Cr(n)
                            }
                        } else if (this._r.test(r.key)) {
                            if (r.newValue !== null) {
                                const n = this.Nr(r.key, r.newValue);
                                if (n) return this.kr(n)
                            }
                        } else if (r.key === this.wr) {
                            if (r.newValue !== null) {
                                const n = this.yr(r.newValue);
                                if (n) return this.pr(n)
                            }
                        } else if (r.key === this.hr) {
                            const n = function (i) {
                                let a = Xu.at;
                                if (i != null) try {
                                    const o = JSON.parse(i);
                                    Er(typeof o == "number"), a = o
                                } catch (o) {
                                    Vo("SharedClientState", "Failed to read sequence number from WebStorage", o)
                                }
                                return a
                            }(r.newValue);
                            n !== Xu.at && this.sequenceNumberHandler(n)
                        } else if (r.key === this.mr) {
                            const n = this.Or(r.newValue);
                            await Promise.all(n.map(i => this.syncEngine.Mr(i)))
                        }
                    }
                } else this.cr.push(r)
            })
        }
    }

    get Ar() {
        return this.ur.get(this.sr)
    }

    gr() {
        this.setItem(this.ar, this.Ar.tr())
    }

    Tr(e, r, n) {
        const i = new gP(this.currentUser, e, r, n), a = ime(this.persistenceKey, this.currentUser, e);
        this.setItem(a, i.tr())
    }

    Er(e) {
        const r = ime(this.persistenceKey, this.currentUser, e);
        this.removeItem(r)
    }

    br(e) {
        const r = {clientId: this.sr, onlineState: e};
        this.storage.setItem(this.wr, JSON.stringify(r))
    }

    Rr(e, r, n) {
        const i = GH(this.persistenceKey, e), a = new IC(e, r, n);
        this.setItem(i, a.tr())
    }

    Pr(e) {
        const r = JSON.stringify(Array.from(e));
        this.setItem(this.mr, r)
    }

    vr(e) {
        const r = this.lr.exec(e);
        return r ? r[1] : null
    }

    Sr(e, r) {
        const n = this.vr(e);
        return yP.Zi(n, r)
    }

    Dr(e, r) {
        const n = this.dr.exec(e), i = Number(n[1]), a = n[2] !== void 0 ? n[2] : null;
        return gP.Zi(new Qs(a), i, r)
    }

    Nr(e, r) {
        const n = this._r.exec(e), i = Number(n[1]);
        return IC.Zi(i, r)
    }

    yr(e) {
        return rte.Zi(e)
    }

    Or(e) {
        return JSON.parse(e)
    }

    async Cr(e) {
        if (e.user.uid === this.currentUser.uid) return this.syncEngine.Fr(e.batchId, e.state, e.error);
        It("SharedClientState", `Ignoring mutation for non-active user ${e.user.uid}`)
    }

    kr(e) {
        return this.syncEngine.$r(e.targetId, e.state, e.error)
    }

    Vr(e, r) {
        const n = r ? this.ur.insert(e, r) : this.ur.remove(e), i = this.Ir(this.ur), a = this.Ir(n), o = [], s = [];
        return a.forEach(l => {
            i.has(l) || o.push(l)
        }), i.forEach(l => {
            a.has(l) || s.push(l)
        }), this.syncEngine.Br(o, s).then(() => {
            this.ur = n
        })
    }

    pr(e) {
        this.ur.get(e.clientId) && this.onlineStateHandler(e.onlineState)
    }

    Ir(e) {
        let r = WL();
        return e.forEach((n, i) => {
            r = r.unionWith(i.activeTargetIds)
        }), r
    }
}

class kAe {
    constructor() {
        this.Lr = new EY, this.qr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null
    }

    addPendingMutation(e) {
    }

    updateMutationState(e, r, n) {
    }

    addLocalQueryTarget(e) {
        return this.Lr.er(e), this.qr[e] || "not-current"
    }

    updateQueryState(e, r, n) {
        this.qr[e] = r
    }

    removeLocalQueryTarget(e) {
        this.Lr.nr(e)
    }

    isLocalQueryTarget(e) {
        return this.Lr.activeTargetIds.has(e)
    }

    clearQueryState(e) {
        delete this.qr[e]
    }

    getAllActiveQueryTargets() {
        return this.Lr.activeTargetIds
    }

    isActiveQueryTarget(e) {
        return this.Lr.activeTargetIds.has(e)
    }

    start() {
        return this.Lr = new EY, Promise.resolve()
    }

    handleUserChange(e, r, n) {
    }

    setOnlineState(e) {
    }

    shutdown() {
    }

    writeSequenceNumber(e) {
    }

    notifyBundleLoaded(e) {
    }
}

class MFt {
    Ur(e) {
    }

    shutdown() {
    }
}

class ame {
    constructor() {
        this.Kr = () => this.Gr(), this.Qr = () => this.jr(), this.Wr = [], this.zr()
    }

    Ur(e) {
        this.Wr.push(e)
    }

    shutdown() {
        window.removeEventListener("online", this.Kr), window.removeEventListener("offline", this.Qr)
    }

    zr() {
        window.addEventListener("online", this.Kr), window.addEventListener("offline", this.Qr)
    }

    Gr() {
        It("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
        for (const e of this.Wr) e(0)
    }

    jr() {
        It("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
        for (const e of this.Wr) e(1)
    }

    static C() {
        return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0
    }
}

const OFt = {
    BatchGetDocuments: "batchGet",
    Commit: "commit",
    RunQuery: "runQuery",
    RunAggregationQuery: "runAggregationQuery"
};

class PFt {
    constructor(e) {
        this.Hr = e.Hr, this.Jr = e.Jr
    }

    Yr(e) {
        this.Xr = e
    }

    Zr(e) {
        this.eo = e
    }

    onMessage(e) {
        this.no = e
    }

    close() {
        this.Jr()
    }

    send(e) {
        this.Hr(e)
    }

    so() {
        this.Xr()
    }

    io(e) {
        this.eo(e)
    }

    ro(e) {
        this.no(e)
    }
}

class NFt extends class {
    constructor(e) {
        this.databaseInfo = e, this.databaseId = e.databaseId;
        const r = e.ssl ? "https" : "http";
        this.oo = r + "://" + e.host, this.uo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents"
    }

    get co() {
        return !1
    }

    ao(e, r, n, i, a) {
        const o = this.ho(e, r);
        It("RestConnection", "Sending: ", o, n);
        const s = {};
        return this.lo(s, i, a), this.fo(e, o, s, n).then(l => (It("RestConnection", "Received: ", l), l), l => {
            throw bS("RestConnection", `${e} failed with error: `, l, "url: ", o, "request:", n), l
        })
    }

    _o(e, r, n, i, a, o) {
        return this.ao(e, r, n, i, a)
    }

    lo(e, r, n) {
        e["X-Goog-Api-Client"] = "gl-js/ fire/" + u3, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), r && r.headers.forEach((i, a) => e[a] = i), n && n.headers.forEach((i, a) => e[a] = i)
    }

    ho(e, r) {
        const n = OFt[e];
        return `${this.oo}/v1/${r}:${n}`
    }
} {
    constructor(e) {
        super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams
    }

    fo(e, r, n, i) {
        return new Promise((a, o) => {
            const s = new PBt;
            s.setWithCredentials(!0), s.listenOnce(DBt.COMPLETE, () => {
                try {
                    switch (s.getLastErrorCode()) {
                        case HH.NO_ERROR:
                            const f = s.getResponseJson();
                            It("Connection", "XHR received:", JSON.stringify(f)), a(f);
                            break;
                        case HH.TIMEOUT:
                            It("Connection", 'RPC "' + e + '" timed out'), o(new yt(at.DEADLINE_EXCEEDED, "Request time out"));
                            break;
                        case HH.HTTP_ERROR:
                            const d = s.getStatus();
                            if (It("Connection", 'RPC "' + e + '" failed with status:', d, "response text:", s.getResponseText()), d > 0) {
                                let p = s.getResponseJson();
                                Array.isArray(p) && (p = p[0]);
                                const g = p == null ? void 0 : p.error;
                                if (g && g.status && g.message) {
                                    const b = function (S) {
                                        const T = S.toLowerCase().replace(/_/g, "-");
                                        return Object.values(at).indexOf(T) >= 0 ? T : at.UNKNOWN
                                    }(g.status);
                                    o(new yt(b, g.message))
                                } else o(new yt(at.UNKNOWN, "Server responded with status " + s.getStatus()))
                            } else o(new yt(at.UNAVAILABLE, "Connection failed."));
                            break;
                        default:
                            lr()
                    }
                } finally {
                    It("Connection", 'RPC "' + e + '" completed.')
                }
            });
            const l = JSON.stringify(i);
            s.send(r, "POST", l, n, 15)
        })
    }

    wo(e, r, n) {
        const i = [this.oo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], a = kBt(), o = RBt(), s = {
            httpSessionIdParam: "gsessionid",
            initMessageHeaders: {},
            messageUrlParams: {database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},
            sendRawJson: !0,
            supportsCrossDomainXhr: !0,
            internalChannelParams: {forwardChannelRequestTimeoutMs: 6e5},
            forceLongPolling: this.forceLongPolling,
            detectBufferingProxy: this.autoDetectLongPolling
        };
        this.useFetchStreams && (s.xmlHttpFactory = new OBt({})), this.lo(s.initMessageHeaders, r, n), s.encodeInitMessageHeaders = !0;
        const l = i.join("");
        It("Connection", "Creating WebChannel: " + l, s);
        const f = a.createWebChannel(l, s);
        let d = !1, p = !1;
        const g = new PFt({
            Hr: S => {
                p ? It("Connection", "Not sending because WebChannel is closed:", S) : (d || (It("Connection", "Opening WebChannel transport."), f.open(), d = !0), It("Connection", "WebChannel sending:", S), f.send(S))
            }, Jr: () => f.close()
        }), b = (S, T, I) => {
            S.listen(T, N => {
                try {
                    I(N)
                } catch (P) {
                    setTimeout(() => {
                        throw P
                    }, 0)
                }
            })
        };
        return b(f, W7.EventType.OPEN, () => {
            p || It("Connection", "WebChannel transport opened.")
        }), b(f, W7.EventType.CLOSE, () => {
            p || (p = !0, It("Connection", "WebChannel transport closed"), g.io())
        }), b(f, W7.EventType.ERROR, S => {
            p || (p = !0, bS("Connection", "WebChannel transport errored:", S), g.io(new yt(at.UNAVAILABLE, "The operation could not be completed")))
        }), b(f, W7.EventType.MESSAGE, S => {
            var T;
            if (!p) {
                const I = S.data[0];
                Er(!!I);
                const N = I, P = N.error || ((T = N[0]) === null || T === void 0 ? void 0 : T.error);
                if (P) {
                    It("Connection", "WebChannel received error:", P);
                    const F = P.status;
                    let V = function (ee) {
                        const oe = ts[ee];
                        if (oe !== void 0) return HCe(oe)
                    }(F), Y = P.message;
                    V === void 0 && (V = at.INTERNAL, Y = "Unknown error status: " + F + " with message " + P.message), p = !0, g.io(new yt(V, Y)), f.close()
                } else It("Connection", "WebChannel received:", I), g.ro(I)
            }
        }), b(o, MBt.STAT_EVENT, S => {
            S.stat === m0e.PROXY ? It("Connection", "Detected buffering proxy") : S.stat === m0e.NOPROXY && It("Connection", "Detected no buffering proxy")
        }), setTimeout(() => {
            g.so()
        }, 0), g
    }
}

function RAe() {
    return typeof window < "u" ? window : null
}

function hM() {
    return typeof document < "u" ? document : null
}

function FI(t) {
    return new C$t(t, !0)
}

class nte {
    constructor(e, r, n = 1e3, i = 1.5, a = 6e4) {
        this.Hs = e, this.timerId = r, this.mo = n, this.yo = i, this.po = a, this.Io = 0, this.To = null, this.Eo = Date.now(), this.reset()
    }

    reset() {
        this.Io = 0
    }

    Ao() {
        this.Io = this.po
    }

    Ro(e) {
        this.cancel();
        const r = Math.floor(this.Io + this.bo()), n = Math.max(0, Date.now() - this.Eo), i = Math.max(0, r - n);
        i > 0 && It("ExponentialBackoff", `Backing off for ${i} ms (base delay: ${this.Io} ms, delay with jitter: ${r} ms, last attempt: ${n} ms ago)`), this.To = this.Hs.enqueueAfterDelay(this.timerId, i, () => (this.Eo = Date.now(), e())), this.Io *= this.yo, this.Io < this.mo && (this.Io = this.mo), this.Io > this.po && (this.Io = this.po)
    }

    Po() {
        this.To !== null && (this.To.skipDelay(), this.To = null)
    }

    cancel() {
        this.To !== null && (this.To.cancel(), this.To = null)
    }

    bo() {
        return (Math.random() - .5) * this.Io
    }
}

class DAe {
    constructor(e, r, n, i, a, o, s, l) {
        this.Hs = e, this.vo = n, this.Vo = i, this.connection = a, this.authCredentialsProvider = o, this.appCheckCredentialsProvider = s, this.listener = l, this.state = 0, this.So = 0, this.Do = null, this.Co = null, this.stream = null, this.xo = new nte(e, r)
    }

    No() {
        return this.state === 1 || this.state === 5 || this.ko()
    }

    ko() {
        return this.state === 2 || this.state === 3
    }

    start() {
        this.state !== 4 ? this.auth() : this.Oo()
    }

    async stop() {
        this.No() && await this.close(0)
    }

    Mo() {
        this.state = 0, this.xo.reset()
    }

    Fo() {
        this.ko() && this.Do === null && (this.Do = this.Hs.enqueueAfterDelay(this.vo, 6e4, () => this.$o()))
    }

    Bo(e) {
        this.Lo(), this.stream.send(e)
    }

    async $o() {
        if (this.ko()) return this.close(0)
    }

    Lo() {
        this.Do && (this.Do.cancel(), this.Do = null)
    }

    qo() {
        this.Co && (this.Co.cancel(), this.Co = null)
    }

    async close(e, r) {
        this.Lo(), this.qo(), this.xo.cancel(), this.So++, e !== 4 ? this.xo.reset() : r && r.code === at.RESOURCE_EXHAUSTED ? (Vo(r.toString()), Vo("Using maximum backoff delay to prevent overloading the backend."), this.xo.Ao()) : r && r.code === at.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Uo(), this.stream.close(), this.stream = null), this.state = e, await this.listener.Zr(r)
    }

    Uo() {
    }

    auth() {
        this.state = 1;
        const e = this.Ko(this.So), r = this.So;
        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([n, i]) => {
            this.So === r && this.Go(n, i)
        }, n => {
            e(() => {
                const i = new yt(at.UNKNOWN, "Fetching auth token failed: " + n.message);
                return this.Qo(i)
            })
        })
    }

    Go(e, r) {
        const n = this.Ko(this.So);
        this.stream = this.jo(e, r), this.stream.Yr(() => {
            n(() => (this.state = 2, this.Co = this.Hs.enqueueAfterDelay(this.Vo, 1e4, () => (this.ko() && (this.state = 3), Promise.resolve())), this.listener.Yr()))
        }), this.stream.Zr(i => {
            n(() => this.Qo(i))
        }), this.stream.onMessage(i => {
            n(() => this.onMessage(i))
        })
    }

    Oo() {
        this.state = 5, this.xo.Ro(async () => {
            this.state = 0, this.start()
        })
    }

    Qo(e) {
        return It("PersistentStream", `close with error: ${e}`), this.stream = null, this.close(4, e)
    }

    Ko(e) {
        return r => {
            this.Hs.enqueueAndForget(() => this.So === e ? r() : (It("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()))
        }
    }
}

class LFt extends DAe {
    constructor(e, r, n, i, a, o) {
        super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", r, n, i, o), this.yt = a
    }

    jo(e, r) {
        return this.connection.wo("Listen", e, r)
    }

    onMessage(e) {
        this.xo.reset();
        const r = k$t(this.yt, e), n = function (i) {
            if (!("targetChange" in i)) return Fr.min();
            const a = i.targetChange;
            return a.targetIds && a.targetIds.length ? Fr.min() : a.readTime ? qo(a.readTime) : Fr.min()
        }(e);
        return this.listener.Wo(r, n)
    }

    zo(e) {
        const r = {};
        r.database = JA(this.yt), r.addTarget = function (i, a) {
            let o;
            const s = a.target;
            return o = uP(s) ? {documents: tAe(i, s)} : {query: Wee(i, s)}, o.targetId = a.targetId, a.resumeToken.approximateByteSize() > 0 ? o.resumeToken = XCe(i, a.resumeToken) : a.snapshotVersion.compareTo(Fr.min()) > 0 && (o.readTime = bE(i, a.snapshotVersion.toTimestamp())), o
        }(this.yt, e);
        const n = D$t(this.yt, e);
        n && (r.labels = n), this.Bo(r)
    }

    Ho(e) {
        const r = {};
        r.database = JA(this.yt), r.removeTarget = e, this.Bo(r)
    }
}

class BFt extends DAe {
    constructor(e, r, n, i, a, o) {
        super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", r, n, i, o), this.yt = a, this.Jo = !1
    }

    get Yo() {
        return this.Jo
    }

    start() {
        this.Jo = !1, this.lastStreamToken = void 0, super.start()
    }

    Uo() {
        this.Jo && this.Xo([])
    }

    jo(e, r) {
        return this.connection.wo("Write", e, r)
    }

    onMessage(e) {
        if (Er(!!e.streamToken), this.lastStreamToken = e.streamToken, this.Jo) {
            this.xo.reset();
            const r = R$t(e.writeResults, e.commitTime), n = qo(e.commitTime);
            return this.listener.Zo(n, r)
        }
        return Er(!e.writeResults || e.writeResults.length === 0), this.Jo = !0, this.listener.tu()
    }

    eu() {
        const e = {};
        e.database = JA(this.yt), this.Bo(e)
    }

    Xo(e) {
        const r = {streamToken: this.lastStreamToken, writes: e.map(n => e8(this.yt, n))};
        this.Bo(r)
    }
}

class $Ft extends class {
} {
    constructor(e, r, n, i) {
        super(), this.authCredentials = e, this.appCheckCredentials = r, this.connection = n, this.yt = i, this.nu = !1
    }

    su() {
        if (this.nu) throw new yt(at.FAILED_PRECONDITION, "The client has already been terminated.")
    }

    ao(e, r, n) {
        return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, a]) => this.connection.ao(e, r, n, i, a)).catch(i => {
            throw i.name === "FirebaseError" ? (i.code === at.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), i) : new yt(at.UNKNOWN, i.toString())
        })
    }

    _o(e, r, n, i) {
        return this.su(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([a, o]) => this.connection._o(e, r, n, a, o, i)).catch(a => {
            throw a.name === "FirebaseError" ? (a.code === at.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), a) : new yt(at.UNKNOWN, a.toString())
        })
    }

    terminate() {
        this.nu = !0
    }
}

async function FFt(t, e) {
    const r = Ht(t), n = function (a, o) {
        const s = Wee(a, o);
        return {
            structuredAggregationQuery: {
                aggregations: [{count: {}, alias: "count_alias"}],
                structuredQuery: s.structuredQuery
            }, parent: s.parent
        }
    }(r.yt, vu(e)), i = n.parent;
    return r.connection.co || delete n.parent, (await r._o("RunAggregationQuery", i, n, 1)).filter(a => !!a.result).map(a => a.result.aggregateFields)
}

class UFt {
    constructor(e, r) {
        this.asyncQueue = e, this.onlineStateHandler = r, this.state = "Unknown", this.iu = 0, this.ru = null, this.ou = !0
    }

    uu() {
        this.iu === 0 && (this.cu("Unknown"), this.ru = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ru = null, this.au("Backend didn't respond within 10 seconds."), this.cu("Offline"), Promise.resolve())))
    }

    hu(e) {
        this.state === "Online" ? this.cu("Unknown") : (this.iu++, this.iu >= 1 && (this.lu(), this.au(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.cu("Offline")))
    }

    set(e) {
        this.lu(), this.iu = 0, e === "Online" && (this.ou = !1), this.cu(e)
    }

    cu(e) {
        e !== this.state && (this.state = e, this.onlineStateHandler(e))
    }

    au(e) {
        const r = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
        this.ou ? (Vo(r), this.ou = !1) : It("OnlineStateTracker", r)
    }

    lu() {
        this.ru !== null && (this.ru.cancel(), this.ru = null)
    }
}

class jFt {
    constructor(e, r, n, i, a) {
        this.localStore = e, this.datastore = r, this.asyncQueue = n, this.remoteSyncer = {}, this.fu = [], this.du = new Map, this._u = new Set, this.wu = [], this.mu = a, this.mu.Ur(o => {
            n.enqueueAndForget(async () => {
                ig(this) && (It("RemoteStore", "Restarting streams for network reachability change."), await async function (s) {
                    const l = Ht(s);
                    l._u.add(4), await p3(l), l.gu.set("Unknown"), l._u.delete(4), await UI(l)
                }(this))
            })
        }), this.gu = new UFt(n, i)
    }
}

async function UI(t) {
    if (ig(t)) for (const e of t.wu) await e(!0)
}

async function p3(t) {
    for (const e of t.wu) await e(!1)
}

function YL(t, e) {
    const r = Ht(t);
    r.du.has(e.targetId) || (r.du.set(e.targetId, e), ote(r) ? ate(r) : v3(r).ko() && ite(r, e))
}

function t8(t, e) {
    const r = Ht(t), n = v3(r);
    r.du.delete(e), n.ko() && MAe(r, e), r.du.size === 0 && (n.ko() ? n.Fo() : ig(r) && r.gu.set("Unknown"))
}

function ite(t, e) {
    t.yu.Ot(e.targetId), v3(t).zo(e)
}

function MAe(t, e) {
    t.yu.Ot(e), v3(t).Ho(e)
}

function ate(t) {
    t.yu = new _$t({
        getRemoteKeysForTarget: e => t.remoteSyncer.getRemoteKeysForTarget(e),
        ne: e => t.du.get(e) || null
    }), v3(t).start(), t.gu.uu()
}

function ote(t) {
    return ig(t) && !v3(t).No() && t.du.size > 0
}

function ig(t) {
    return Ht(t)._u.size === 0
}

function OAe(t) {
    t.yu = void 0
}

async function zFt(t) {
    t.du.forEach((e, r) => {
        ite(t, e)
    })
}

async function VFt(t, e) {
    OAe(t), ote(t) ? (t.gu.hu(e), ate(t)) : t.gu.set("Unknown")
}

async function HFt(t, e, r) {
    if (t.gu.set("Online"), e instanceof YCe && e.state === 2 && e.cause) try {
        await async function (n, i) {
            const a = i.cause;
            for (const o of i.targetIds) n.du.has(o) && (await n.remoteSyncer.rejectListen(o, a), n.du.delete(o), n.yu.removeTarget(o))
        }(t, e)
    } catch (n) {
        It("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n), await bP(t, n)
    } else if (e instanceof fM ? t.yu.Kt(e) : e instanceof KCe ? t.yu.Jt(e) : t.yu.jt(e), !r.isEqual(Fr.min())) try {
        const n = await EAe(t.localStore);
        r.compareTo(n) >= 0 && await function (i, a) {
            const o = i.yu.Zt(a);
            return o.targetChanges.forEach((s, l) => {
                if (s.resumeToken.approximateByteSize() > 0) {
                    const f = i.du.get(l);
                    f && i.du.set(l, f.withResumeToken(s.resumeToken, a))
                }
            }), o.targetMismatches.forEach(s => {
                const l = i.du.get(s);
                if (!l) return;
                i.du.set(s, l.withResumeToken(Fs.EMPTY_BYTE_STRING, l.snapshotVersion)), MAe(i, s);
                const f = new Wy(l.target, s, 1, l.sequenceNumber);
                ite(i, f)
            }), i.remoteSyncer.applyRemoteEvent(o)
        }(t, r)
    } catch (n) {
        It("RemoteStore", "Failed to raise snapshot:", n), await bP(t, n)
    }
}

async function bP(t, e, r) {
    if (!R1(e)) throw e;
    t._u.add(1), await p3(t), t.gu.set("Offline"), r || (r = () => EAe(t.localStore)), t.asyncQueue.enqueueRetryable(async () => {
        It("RemoteStore", "Retrying IndexedDB access"), await r(), t._u.delete(1), await UI(t)
    })
}

function PAe(t, e) {
    return e().catch(r => bP(t, r, e))
}

async function m3(t) {
    const e = Ht(t), r = u1(e);
    let n = e.fu.length > 0 ? e.fu[e.fu.length - 1].batchId : -1;
    for (; WFt(e);) try {
        const i = await kFt(e.localStore, n);
        if (i === null) {
            e.fu.length === 0 && r.Fo();
            break
        }
        n = i.batchId, qFt(e, i)
    } catch (i) {
        await bP(e, i)
    }
    NAe(e) && LAe(e)
}

function WFt(t) {
    return ig(t) && t.fu.length < 10
}

function qFt(t, e) {
    t.fu.push(e);
    const r = u1(t);
    r.ko() && r.Yo && r.Xo(e.mutations)
}

function NAe(t) {
    return ig(t) && !u1(t).No() && t.fu.length > 0
}

function LAe(t) {
    u1(t).start()
}

async function GFt(t) {
    u1(t).eu()
}

async function KFt(t) {
    const e = u1(t);
    for (const r of t.fu) e.Xo(r.mutations)
}

async function YFt(t, e, r) {
    const n = t.fu.shift(), i = Gee.from(n, e, r);
    await PAe(t, () => t.remoteSyncer.applySuccessfulWrite(i)), await m3(t)
}

async function XFt(t, e) {
    e && u1(t).Yo && await async function (r, n) {
        if (i = n.code, VCe(i) && i !== at.ABORTED) {
            const a = r.fu.shift();
            u1(r).Mo(), await PAe(r, () => r.remoteSyncer.rejectFailedWrite(a.batchId, n)), await m3(r)
        }
        var i
    }(t, e), NAe(t) && LAe(t)
}

async function ome(t, e) {
    const r = Ht(t);
    r.asyncQueue.verifyOperationInProgress(), It("RemoteStore", "RemoteStore received new credentials");
    const n = ig(r);
    r._u.add(3), await p3(r), n && r.gu.set("Unknown"), await r.remoteSyncer.handleCredentialChange(e), r._u.delete(3), await UI(r)
}

async function TY(t, e) {
    const r = Ht(t);
    e ? (r._u.delete(2), await UI(r)) : e || (r._u.add(2), await p3(r), r.gu.set("Unknown"))
}

function v3(t) {
    return t.pu || (t.pu = function (e, r, n) {
        const i = Ht(e);
        return i.su(), new LFt(r, i.connection, i.authCredentials, i.appCheckCredentials, i.yt, n)
    }(t.datastore, t.asyncQueue, {
        Yr: zFt.bind(null, t),
        Zr: VFt.bind(null, t),
        Wo: HFt.bind(null, t)
    }), t.wu.push(async e => {
        e ? (t.pu.Mo(), ote(t) ? ate(t) : t.gu.set("Unknown")) : (await t.pu.stop(), OAe(t))
    })), t.pu
}

function u1(t) {
    return t.Iu || (t.Iu = function (e, r, n) {
        const i = Ht(e);
        return i.su(), new BFt(r, i.connection, i.authCredentials, i.appCheckCredentials, i.yt, n)
    }(t.datastore, t.asyncQueue, {
        Yr: GFt.bind(null, t),
        Zr: XFt.bind(null, t),
        tu: KFt.bind(null, t),
        Zo: YFt.bind(null, t)
    }), t.wu.push(async e => {
        e ? (t.Iu.Mo(), await m3(t)) : (await t.Iu.stop(), t.fu.length > 0 && (It("RemoteStore", `Stopping write stream with ${t.fu.length} pending writes`), t.fu = []))
    })), t.Iu
}

class ste {
    constructor(e, r, n, i, a) {
        this.asyncQueue = e, this.timerId = r, this.targetTimeMs = n, this.op = i, this.removalCallback = a, this.deferred = new Ls, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(o => {
        })
    }

    static createAndSchedule(e, r, n, i, a) {
        const o = Date.now() + n, s = new ste(e, r, o, i, a);
        return s.start(n), s
    }

    start(e) {
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e)
    }

    skipDelay() {
        return this.handleDelayElapsed()
    }

    cancel(e) {
        this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new yt(at.CANCELLED, "Operation cancelled" + (e ? ": " + e : ""))))
    }

    handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve())
    }

    clearTimeout() {
        this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null)
    }
}

function g3(t, e) {
    if (Vo("AsyncQueue", `${e}: ${t}`), R1(t)) return new yt(at.UNAVAILABLE, `${e}: ${t}`);
    throw t
}

class y4 {
    constructor(e) {
        this.comparator = e ? (r, n) => e(r, n) || jt.comparator(r.key, n.key) : (r, n) => jt.comparator(r.key, n.key), this.keyedMap = HT(), this.sortedSet = new Mo(this.comparator)
    }

    static emptySet(e) {
        return new y4(e.comparator)
    }

    has(e) {
        return this.keyedMap.get(e) != null
    }

    get(e) {
        return this.keyedMap.get(e)
    }

    first() {
        return this.sortedSet.minKey()
    }

    last() {
        return this.sortedSet.maxKey()
    }

    isEmpty() {
        return this.sortedSet.isEmpty()
    }

    indexOf(e) {
        const r = this.keyedMap.get(e);
        return r ? this.sortedSet.indexOf(r) : -1
    }

    get size() {
        return this.sortedSet.size
    }

    forEach(e) {
        this.sortedSet.inorderTraversal((r, n) => (e(r), !1))
    }

    add(e) {
        const r = this.delete(e.key);
        return r.copy(r.keyedMap.insert(e.key, e), r.sortedSet.insert(e, null))
    }

    delete(e) {
        const r = this.get(e);
        return r ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(r)) : this
    }

    isEqual(e) {
        if (!(e instanceof y4) || this.size !== e.size) return !1;
        const r = this.sortedSet.getIterator(), n = e.sortedSet.getIterator();
        for (; r.hasNext();) {
            const i = r.getNext().key, a = n.getNext().key;
            if (!i.isEqual(a)) return !1
        }
        return !0
    }

    toString() {
        const e = [];
        return this.forEach(r => {
            e.push(r.toString())
        }), e.length === 0 ? "DocumentSet ()" : `DocumentSet (
  ` + e.join(`  
`) + `
)`
    }

    copy(e, r) {
        const n = new y4;
        return n.comparator = this.comparator, n.keyedMap = e, n.sortedSet = r, n
    }
}

class sme {
    constructor() {
        this.Tu = new Mo(jt.comparator)
    }

    track(e) {
        const r = e.doc.key, n = this.Tu.get(r);
        n ? e.type !== 0 && n.type === 3 ? this.Tu = this.Tu.insert(r, e) : e.type === 3 && n.type !== 1 ? this.Tu = this.Tu.insert(r, {
            type: n.type,
            doc: e.doc
        }) : e.type === 2 && n.type === 2 ? this.Tu = this.Tu.insert(r, {
            type: 2,
            doc: e.doc
        }) : e.type === 2 && n.type === 0 ? this.Tu = this.Tu.insert(r, {
            type: 0,
            doc: e.doc
        }) : e.type === 1 && n.type === 0 ? this.Tu = this.Tu.remove(r) : e.type === 1 && n.type === 2 ? this.Tu = this.Tu.insert(r, {
            type: 1,
            doc: n.doc
        }) : e.type === 0 && n.type === 1 ? this.Tu = this.Tu.insert(r, {
            type: 2,
            doc: e.doc
        }) : lr() : this.Tu = this.Tu.insert(r, e)
    }

    Eu() {
        const e = [];
        return this.Tu.inorderTraversal((r, n) => {
            e.push(n)
        }), e
    }
}

class _E {
    constructor(e, r, n, i, a, o, s, l, f) {
        this.query = e, this.docs = r, this.oldDocs = n, this.docChanges = i, this.mutatedKeys = a, this.fromCache = o, this.syncStateChanged = s, this.excludesMetadataChanges = l, this.hasCachedResults = f
    }

    static fromInitialDocuments(e, r, n, i, a) {
        const o = [];
        return r.forEach(s => {
            o.push({type: 0, doc: s})
        }), new _E(e, r, y4.emptySet(r), o, n, i, !0, !1, a)
    }

    get hasPendingWrites() {
        return !this.mutatedKeys.isEmpty()
    }

    isEqual(e) {
        if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && PI(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1;
        const r = this.docChanges, n = e.docChanges;
        if (r.length !== n.length) return !1;
        for (let i = 0; i < r.length; i++) if (r[i].type !== n[i].type || !r[i].doc.isEqual(n[i].doc)) return !1;
        return !0
    }
}

class QFt {
    constructor() {
        this.Au = void 0, this.listeners = []
    }
}

class ZFt {
    constructor() {
        this.queries = new D1(e => DCe(e), PI), this.onlineState = "Unknown", this.Ru = new Set
    }
}

async function cte(t, e) {
    const r = Ht(t), n = e.query;
    let i = !1, a = r.queries.get(n);
    if (a || (i = !0, a = new QFt), i) try {
        a.Au = await r.onListen(n)
    } catch (o) {
        const s = g3(o, `Initialization of query '${gY(e.query)}' failed`);
        return void e.onError(s)
    }
    r.queries.set(n, a), a.listeners.push(e), e.bu(r.onlineState), a.Au && e.Pu(a.Au) && ute(r)
}

async function lte(t, e) {
    const r = Ht(t), n = e.query;
    let i = !1;
    const a = r.queries.get(n);
    if (a) {
        const o = a.listeners.indexOf(e);
        o >= 0 && (a.listeners.splice(o, 1), i = a.listeners.length === 0)
    }
    if (i) return r.queries.delete(n), r.onUnlisten(n)
}

function JFt(t, e) {
    const r = Ht(t);
    let n = !1;
    for (const i of e) {
        const a = i.query, o = r.queries.get(a);
        if (o) {
            for (const s of o.listeners) s.Pu(i) && (n = !0);
            o.Au = i
        }
    }
    n && ute(r)
}

function eUt(t, e, r) {
    const n = Ht(t), i = n.queries.get(e);
    if (i) for (const a of i.listeners) a.onError(r);
    n.queries.delete(e)
}

function ute(t) {
    t.Ru.forEach(e => {
        e.next()
    })
}

class fte {
    constructor(e, r, n) {
        this.query = e, this.vu = r, this.Vu = !1, this.Su = null, this.onlineState = "Unknown", this.options = n || {}
    }

    Pu(e) {
        if (!this.options.includeMetadataChanges) {
            const n = [];
            for (const i of e.docChanges) i.type !== 3 && n.push(i);
            e = new _E(e.query, e.docs, e.oldDocs, n, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults)
        }
        let r = !1;
        return this.Vu ? this.Du(e) && (this.vu.next(e), r = !0) : this.Cu(e, this.onlineState) && (this.xu(e), r = !0), this.Su = e, r
    }

    onError(e) {
        this.vu.error(e)
    }

    bu(e) {
        this.onlineState = e;
        let r = !1;
        return this.Su && !this.Vu && this.Cu(this.Su, e) && (this.xu(this.Su), r = !0), r
    }

    Cu(e, r) {
        if (!e.fromCache) return !0;
        const n = r !== "Offline";
        return (!this.options.Nu || !n) && (!e.docs.isEmpty() || e.hasCachedResults || r === "Offline")
    }

    Du(e) {
        if (e.docChanges.length > 0) return !0;
        const r = this.Su && this.Su.hasPendingWrites !== e.hasPendingWrites;
        return !(!e.syncStateChanged && !r) && this.options.includeMetadataChanges === !0
    }

    xu(e) {
        e = _E.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.Vu = !0, this.vu.next(e)
    }
}

class tUt {
    constructor(e, r) {
        this.ku = e, this.byteLength = r
    }

    Ou() {
        return "metadata" in this.ku
    }
}

class cme {
    constructor(e) {
        this.yt = e
    }

    Ji(e) {
        return $0(this.yt, e)
    }

    Yi(e) {
        return e.metadata.exists ? eAe(this.yt, e.document, !1) : ja.newNoDocument(this.Ji(e.metadata.name), this.Xi(e.metadata.readTime))
    }

    Xi(e) {
        return qo(e)
    }
}

class rUt {
    constructor(e, r, n) {
        this.Mu = e, this.localStore = r, this.yt = n, this.queries = [], this.documents = [], this.collectionGroups = new Set, this.progress = BAe(e)
    }

    Fu(e) {
        this.progress.bytesLoaded += e.byteLength;
        let r = this.progress.documentsLoaded;
        if (e.ku.namedQuery) this.queries.push(e.ku.namedQuery); else if (e.ku.documentMetadata) {
            this.documents.push({metadata: e.ku.documentMetadata}), e.ku.documentMetadata.exists || ++r;
            const n = Ei.fromString(e.ku.documentMetadata.name);
            this.collectionGroups.add(n.get(n.length - 2))
        } else e.ku.document && (this.documents[this.documents.length - 1].document = e.ku.document, ++r);
        return r !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = r, Object.assign({}, this.progress)) : null
    }

    $u(e) {
        const r = new Map, n = new cme(this.yt);
        for (const i of e) if (i.metadata.queries) {
            const a = n.Ji(i.metadata.name);
            for (const o of i.metadata.queries) {
                const s = (r.get(o) || Tn()).add(a);
                r.set(o, s)
            }
        }
        return r
    }

    async complete() {
        const e = await RFt(this.localStore, new cme(this.yt), this.documents, this.Mu.id), r = this.$u(this.documents);
        for (const n of this.queries) await DFt(this.localStore, n, r.get(n.name));
        return this.progress.taskState = "Success", {progress: this.progress, Bu: this.collectionGroups, Lu: e}
    }
}

function BAe(t) {
    return {
        taskState: "Running",
        documentsLoaded: 0,
        bytesLoaded: 0,
        totalDocuments: t.totalDocuments,
        totalBytes: t.totalBytes
    }
}

class $Ae {
    constructor(e) {
        this.key = e
    }
}

class FAe {
    constructor(e) {
        this.key = e
    }
}

class UAe {
    constructor(e, r) {
        this.query = e, this.qu = r, this.Uu = null, this.hasCachedResults = !1, this.current = !1, this.Ku = Tn(), this.mutatedKeys = Tn(), this.Gu = OCe(e), this.Qu = new y4(this.Gu)
    }

    get ju() {
        return this.qu
    }

    Wu(e, r) {
        const n = r ? r.zu : new sme, i = r ? r.Qu : this.Qu;
        let a = r ? r.mutatedKeys : this.mutatedKeys, o = i, s = !1;
        const l = this.query.limitType === "F" && i.size === this.query.limit ? i.last() : null,
            f = this.query.limitType === "L" && i.size === this.query.limit ? i.first() : null;
        if (e.inorderTraversal((d, p) => {
            const g = i.get(d), b = NI(this.query, p) ? p : null, S = !!g && this.mutatedKeys.has(g.key),
                T = !!b && (b.hasLocalMutations || this.mutatedKeys.has(b.key) && b.hasCommittedMutations);
            let I = !1;
            g && b ? g.data.isEqual(b.data) ? S !== T && (n.track({
                type: 3,
                doc: b
            }), I = !0) : this.Hu(g, b) || (n.track({
                type: 2,
                doc: b
            }), I = !0, (l && this.Gu(b, l) > 0 || f && this.Gu(b, f) < 0) && (s = !0)) : !g && b ? (n.track({
                type: 0,
                doc: b
            }), I = !0) : g && !b && (n.track({
                type: 1,
                doc: g
            }), I = !0, (l || f) && (s = !0)), I && (b ? (o = o.add(b), a = T ? a.add(d) : a.delete(d)) : (o = o.delete(d), a = a.delete(d)))
        }), this.query.limit !== null) for (; o.size > this.query.limit;) {
            const d = this.query.limitType === "F" ? o.last() : o.first();
            o = o.delete(d.key), a = a.delete(d.key), n.track({type: 1, doc: d})
        }
        return {Qu: o, zu: n, $i: s, mutatedKeys: a}
    }

    Hu(e, r) {
        return e.hasLocalMutations && r.hasCommittedMutations && !r.hasLocalMutations
    }

    applyChanges(e, r, n) {
        const i = this.Qu;
        this.Qu = e.Qu, this.mutatedKeys = e.mutatedKeys;
        const a = e.zu.Eu();
        a.sort((f, d) => function (p, g) {
            const b = S => {
                switch (S) {
                    case 0:
                        return 1;
                    case 2:
                    case 3:
                        return 2;
                    case 1:
                        return 0;
                    default:
                        return lr()
                }
            };
            return b(p) - b(g)
        }(f.type, d.type) || this.Gu(f.doc, d.doc)), this.Ju(n);
        const o = r ? this.Yu() : [], s = this.Ku.size === 0 && this.current ? 1 : 0, l = s !== this.Uu;
        return this.Uu = s, a.length !== 0 || l ? {
            snapshot: new _E(this.query, e.Qu, i, a, e.mutatedKeys, s === 0, l, !1, !!n && n.resumeToken.approximateByteSize() > 0),
            Xu: o
        } : {Xu: o}
    }

    bu(e) {
        return this.current && e === "Offline" ? (this.current = !1, this.applyChanges({
            Qu: this.Qu,
            zu: new sme,
            mutatedKeys: this.mutatedKeys,
            $i: !1
        }, !1)) : {Xu: []}
    }

    Zu(e) {
        return !this.qu.has(e) && !!this.Qu.has(e) && !this.Qu.get(e).hasLocalMutations
    }

    Ju(e) {
        e && (e.addedDocuments.forEach(r => this.qu = this.qu.add(r)), e.modifiedDocuments.forEach(r => {
        }), e.removedDocuments.forEach(r => this.qu = this.qu.delete(r)), this.current = e.current)
    }

    Yu() {
        if (!this.current) return [];
        const e = this.Ku;
        this.Ku = Tn(), this.Qu.forEach(n => {
            this.Zu(n.key) && (this.Ku = this.Ku.add(n.key))
        });
        const r = [];
        return e.forEach(n => {
            this.Ku.has(n) || r.push(new FAe(n))
        }), this.Ku.forEach(n => {
            e.has(n) || r.push(new $Ae(n))
        }), r
    }

    tc(e) {
        this.qu = e.Hi, this.Ku = Tn();
        const r = this.Wu(e.documents);
        return this.applyChanges(r, !0)
    }

    ec() {
        return _E.fromInitialDocuments(this.query, this.Qu, this.mutatedKeys, this.Uu === 0, this.hasCachedResults)
    }
}

class nUt {
    constructor(e, r, n) {
        this.query = e, this.targetId = r, this.view = n
    }
}

class iUt {
    constructor(e) {
        this.key = e, this.nc = !1
    }
}

class aUt {
    constructor(e, r, n, i, a, o) {
        this.localStore = e, this.remoteStore = r, this.eventManager = n, this.sharedClientState = i, this.currentUser = a, this.maxConcurrentLimboResolutions = o, this.sc = {}, this.ic = new D1(s => DCe(s), PI), this.rc = new Map, this.oc = new Set, this.uc = new Mo(jt.comparator), this.cc = new Map, this.ac = new Zee, this.hc = {}, this.lc = new Map, this.fc = IS.vn(), this.onlineState = "Unknown", this.dc = void 0
    }

    get isPrimaryClient() {
        return this.dc === !0
    }
}

async function oUt(t, e) {
    const r = vte(t);
    let n, i;
    const a = r.ic.get(e);
    if (a) n = a.targetId, r.sharedClientState.addLocalQueryTarget(n), i = a.view.ec(); else {
        const o = await wE(r.localStore, vu(e));
        r.isPrimaryClient && YL(r.remoteStore, o);
        const s = r.sharedClientState.addLocalQueryTarget(o.targetId);
        n = o.targetId, i = await dte(r, e, n, s === "current", o.resumeToken)
    }
    return i
}

async function dte(t, e, r, n, i) {
    t._c = (p, g, b) => async function (S, T, I, N) {
        let P = T.view.Wu(I);
        P.$i && (P = await vP(S.localStore, T.query, !1).then(({documents: Y}) => T.view.Wu(Y, P)));
        const F = N && N.targetChanges.get(T.targetId), V = T.view.applyChanges(P, S.isPrimaryClient, F);
        return CY(S, T.targetId, V.Xu), V.snapshot
    }(t, p, g, b);
    const a = await vP(t.localStore, e, !0), o = new UAe(e, a.Hi), s = o.Wu(a.documents),
        l = $I.createSynthesizedTargetChangeForCurrentChange(r, n && t.onlineState !== "Offline", i),
        f = o.applyChanges(s, t.isPrimaryClient, l);
    CY(t, r, f.Xu);
    const d = new nUt(e, r, o);
    return t.ic.set(e, d), t.rc.has(r) ? t.rc.get(r).push(e) : t.rc.set(r, [e]), f.snapshot
}

async function sUt(t, e) {
    const r = Ht(t), n = r.ic.get(e), i = r.rc.get(n.targetId);
    if (i.length > 1) return r.rc.set(n.targetId, i.filter(a => !PI(a, e))), void r.ic.delete(e);
    r.isPrimaryClient ? (r.sharedClientState.removeLocalQueryTarget(n.targetId), r.sharedClientState.isActiveQueryTarget(n.targetId) || await SE(r.localStore, n.targetId, !1).then(() => {
        r.sharedClientState.clearQueryState(n.targetId), t8(r.remoteStore, n.targetId), xE(r, n.targetId)
    }).catch(k1)) : (xE(r, n.targetId), await SE(r.localStore, n.targetId, !0))
}

async function cUt(t, e, r) {
    const n = gte(t);
    try {
        const i = await function (a, o) {
            const s = Ht(a), l = Ca.now(), f = o.reduce((g, b) => g.add(b.key), Tn());
            let d, p;
            return s.persistence.runTransaction("Locally write mutations", "readwrite", g => {
                let b = Zu(), S = Tn();
                return s.Gi.getEntries(g, f).next(T => {
                    b = T, b.forEach((I, N) => {
                        N.isValidDocument() || (S = S.add(I))
                    })
                }).next(() => s.localDocuments.getOverlayedDocuments(g, b)).next(T => {
                    d = T;
                    const I = [];
                    for (const N of o) {
                        const P = v$t(N, d.get(N.key).overlayedDocument);
                        P != null && I.push(new ng(N.key, P, kCe(P.value.mapValue), Ya.exists(!0)))
                    }
                    return s.mutationQueue.addMutationBatch(g, l, I, o)
                }).next(T => {
                    p = T;
                    const I = T.applyToLocalDocumentSet(d, S);
                    return s.documentOverlayCache.saveOverlays(g, T.batchId, I)
                })
            }).then(() => ({batchId: p.batchId, changes: qCe(d)}))
        }(n.localStore, e);
        n.sharedClientState.addPendingMutation(i.batchId), function (a, o, s) {
            let l = a.hc[a.currentUser.toKey()];
            l || (l = new Mo(gn)), l = l.insert(o, s), a.hc[a.currentUser.toKey()] = l
        }(n, i.batchId, r), await ag(n, i.changes), await m3(n.remoteStore)
    } catch (i) {
        const a = g3(i, "Failed to persist write");
        r.reject(a)
    }
}

async function jAe(t, e) {
    const r = Ht(t);
    try {
        const n = await IFt(r.localStore, e);
        e.targetChanges.forEach((i, a) => {
            const o = r.cc.get(a);
            o && (Er(i.addedDocuments.size + i.modifiedDocuments.size + i.removedDocuments.size <= 1), i.addedDocuments.size > 0 ? o.nc = !0 : i.modifiedDocuments.size > 0 ? Er(o.nc) : i.removedDocuments.size > 0 && (Er(o.nc), o.nc = !1))
        }), await ag(r, n, e)
    } catch (n) {
        await k1(n)
    }
}

function lme(t, e, r) {
    const n = Ht(t);
    if (n.isPrimaryClient && r === 0 || !n.isPrimaryClient && r === 1) {
        const i = [];
        n.ic.forEach((a, o) => {
            const s = o.view.bu(e);
            s.snapshot && i.push(s.snapshot)
        }), function (a, o) {
            const s = Ht(a);
            s.onlineState = o;
            let l = !1;
            s.queries.forEach((f, d) => {
                for (const p of d.listeners) p.bu(o) && (l = !0)
            }), l && ute(s)
        }(n.eventManager, e), i.length && n.sc.Wo(i), n.onlineState = e, n.isPrimaryClient && n.sharedClientState.setOnlineState(e)
    }
}

async function lUt(t, e, r) {
    const n = Ht(t);
    n.sharedClientState.updateQueryState(e, "rejected", r);
    const i = n.cc.get(e), a = i && i.key;
    if (a) {
        let o = new Mo(jt.comparator);
        o = o.insert(a, ja.newNoDocument(a, Fr.min()));
        const s = Tn().add(a), l = new BI(Fr.min(), new Map, new fa(gn), o, s);
        await jAe(n, l), n.uc = n.uc.remove(a), n.cc.delete(e), mte(n)
    } else await SE(n.localStore, e, !1).then(() => xE(n, e, r)).catch(k1)
}

async function uUt(t, e) {
    const r = Ht(t), n = e.batch.batchId;
    try {
        const i = await AFt(r.localStore, e);
        pte(r, n, null), hte(r, n), r.sharedClientState.updateMutationState(n, "acknowledged"), await ag(r, i)
    } catch (i) {
        await k1(i)
    }
}

async function fUt(t, e, r) {
    const n = Ht(t);
    try {
        const i = await function (a, o) {
            const s = Ht(a);
            return s.persistence.runTransaction("Reject batch", "readwrite-primary", l => {
                let f;
                return s.mutationQueue.lookupMutationBatch(l, o).next(d => (Er(d !== null), f = d.keys(), s.mutationQueue.removeMutationBatch(l, d))).next(() => s.mutationQueue.performConsistencyCheck(l)).next(() => s.documentOverlayCache.removeOverlaysForBatchId(l, f, o)).next(() => s.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(l, f)).next(() => s.localDocuments.getDocuments(l, f))
            })
        }(n.localStore, e);
        pte(n, e, r), hte(n, e), n.sharedClientState.updateMutationState(e, "rejected", r), await ag(n, i)
    } catch (i) {
        await k1(i)
    }
}

async function dUt(t, e) {
    const r = Ht(t);
    ig(r.remoteStore) || It("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
    try {
        const n = await function (a) {
            const o = Ht(a);
            return o.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", s => o.mutationQueue.getHighestUnacknowledgedBatchId(s))
        }(r.localStore);
        if (n === -1) return void e.resolve();
        const i = r.lc.get(n) || [];
        i.push(e), r.lc.set(n, i)
    } catch (n) {
        const i = g3(n, "Initialization of waitForPendingWrites() operation failed");
        e.reject(i)
    }
}

function hte(t, e) {
    (t.lc.get(e) || []).forEach(r => {
        r.resolve()
    }), t.lc.delete(e)
}

function pte(t, e, r) {
    const n = Ht(t);
    let i = n.hc[n.currentUser.toKey()];
    if (i) {
        const a = i.get(e);
        a && (r ? a.reject(r) : a.resolve(), i = i.remove(e)), n.hc[n.currentUser.toKey()] = i
    }
}

function xE(t, e, r = null) {
    t.sharedClientState.removeLocalQueryTarget(e);
    for (const n of t.rc.get(e)) t.ic.delete(n), r && t.sc.wc(n, r);
    t.rc.delete(e), t.isPrimaryClient && t.ac.ls(e).forEach(n => {
        t.ac.containsKey(n) || zAe(t, n)
    })
}

function zAe(t, e) {
    t.oc.delete(e.path.canonicalString());
    const r = t.uc.get(e);
    r !== null && (t8(t.remoteStore, r), t.uc = t.uc.remove(e), t.cc.delete(r), mte(t))
}

function CY(t, e, r) {
    for (const n of r) n instanceof $Ae ? (t.ac.addReference(n.key, e), hUt(t, n)) : n instanceof FAe ? (It("SyncEngine", "Document no longer in limbo: " + n.key), t.ac.removeReference(n.key, e), t.ac.containsKey(n.key) || zAe(t, n.key)) : lr()
}

function hUt(t, e) {
    const r = e.key, n = r.path.canonicalString();
    t.uc.get(r) || t.oc.has(n) || (It("SyncEngine", "New document in limbo: " + r), t.oc.add(n), mte(t))
}

function mte(t) {
    for (; t.oc.size > 0 && t.uc.size < t.maxConcurrentLimboResolutions;) {
        const e = t.oc.values().next().value;
        t.oc.delete(e);
        const r = new jt(Ei.fromString(e)), n = t.fc.next();
        t.cc.set(n, new iUt(r)), t.uc = t.uc.insert(r, n), YL(t.remoteStore, new Wy(vu(f3(r.path)), n, 2, Xu.at))
    }
}

async function ag(t, e, r) {
    const n = Ht(t), i = [], a = [], o = [];
    n.ic.isEmpty() || (n.ic.forEach((s, l) => {
        o.push(n._c(l, e, r).then(f => {
            if ((f || r) && n.isPrimaryClient && n.sharedClientState.updateQueryState(l.targetId, f != null && f.fromCache ? "not-current" : "current"), f) {
                i.push(f);
                const d = tte.Ci(l.targetId, f);
                a.push(d)
            }
        }))
    }), await Promise.all(o), n.sc.Wo(i), await async function (s, l) {
        const f = Ht(s);
        try {
            await f.persistence.runTransaction("notifyLocalViewChanges", "readwrite", d => Je.forEach(l, p => Je.forEach(p.Si, g => f.persistence.referenceDelegate.addReference(d, p.targetId, g)).next(() => Je.forEach(p.Di, g => f.persistence.referenceDelegate.removeReference(d, p.targetId, g)))))
        } catch (d) {
            if (!R1(d)) throw d;
            It("LocalStore", "Failed to update sequence numbers: " + d)
        }
        for (const d of l) {
            const p = d.targetId;
            if (!d.fromCache) {
                const g = f.qi.get(p), b = g.snapshotVersion, S = g.withLastLimboFreeSnapshotVersion(b);
                f.qi = f.qi.insert(p, S)
            }
        }
    }(n.localStore, a))
}

async function pUt(t, e) {
    const r = Ht(t);
    if (!r.currentUser.isEqual(e)) {
        It("SyncEngine", "User change. New user:", e.toKey());
        const n = await xAe(r.localStore, e);
        r.currentUser = e, function (i, a) {
            i.lc.forEach(o => {
                o.forEach(s => {
                    s.reject(new yt(at.CANCELLED, a))
                })
            }), i.lc.clear()
        }(r, "'waitForPendingWrites' promise is rejected due to a user change."), r.sharedClientState.handleUserChange(e, n.removedBatchIds, n.addedBatchIds), await ag(r, n.ji)
    }
}

function mUt(t, e) {
    const r = Ht(t), n = r.cc.get(e);
    if (n && n.nc) return Tn().add(n.key);
    {
        let i = Tn();
        const a = r.rc.get(e);
        if (!a) return i;
        for (const o of a) {
            const s = r.ic.get(o);
            i = i.unionWith(s.view.ju)
        }
        return i
    }
}

async function vUt(t, e) {
    const r = Ht(t), n = await vP(r.localStore, e.query, !0), i = e.view.tc(n);
    return r.isPrimaryClient && CY(r, e.targetId, i.Xu), i
}

async function gUt(t, e) {
    const r = Ht(t);
    return AAe(r.localStore, e).then(n => ag(r, n))
}

async function yUt(t, e, r, n) {
    const i = Ht(t), a = await function (o, s) {
        const l = Ht(o), f = Ht(l.mutationQueue);
        return l.persistence.runTransaction("Lookup mutation documents", "readonly", d => f.Tn(d, s).next(p => p ? l.localDocuments.getDocuments(d, p) : Je.resolve(null)))
    }(i.localStore, e);
    a !== null ? (r === "pending" ? await m3(i.remoteStore) : r === "acknowledged" || r === "rejected" ? (pte(i, e, n || null), hte(i, e), function (o, s) {
        Ht(Ht(o).mutationQueue).An(s)
    }(i.localStore, e)) : lr(), await ag(i, a)) : It("SyncEngine", "Cannot apply mutation batch with id: " + e)
}

async function bUt(t, e) {
    const r = Ht(t);
    if (vte(r), gte(r), e === !0 && r.dc !== !0) {
        const n = r.sharedClientState.getAllActiveQueryTargets(), i = await ume(r, n.toArray());
        r.dc = !0, await TY(r.remoteStore, !0);
        for (const a of i) YL(r.remoteStore, a)
    } else if (e === !1 && r.dc !== !1) {
        const n = [];
        let i = Promise.resolve();
        r.rc.forEach((a, o) => {
            r.sharedClientState.isLocalQueryTarget(o) ? n.push(o) : i = i.then(() => (xE(r, o), SE(r.localStore, o, !0))), t8(r.remoteStore, o)
        }), await i, await ume(r, n), function (a) {
            const o = Ht(a);
            o.cc.forEach((s, l) => {
                t8(o.remoteStore, l)
            }), o.ac.fs(), o.cc = new Map, o.uc = new Mo(jt.comparator)
        }(r), r.dc = !1, await TY(r.remoteStore, !1)
    }
}

async function ume(t, e, r) {
    const n = Ht(t), i = [], a = [];
    for (const o of e) {
        let s;
        const l = n.rc.get(o);
        if (l && l.length !== 0) {
            s = await wE(n.localStore, vu(l[0]));
            for (const f of l) {
                const d = n.ic.get(f), p = await vUt(n, d);
                p.snapshot && a.push(p.snapshot)
            }
        } else {
            const f = await CAe(n.localStore, o);
            s = await wE(n.localStore, f), await dte(n, VAe(f), o, !1, s.resumeToken)
        }
        i.push(s)
    }
    return n.sc.Wo(a), i
}

function VAe(t) {
    return RCe(t.path, t.collectionGroup, t.orderBy, t.filters, t.limit, "F", t.startAt, t.endAt)
}

function wUt(t) {
    const e = Ht(t);
    return Ht(Ht(e.localStore).persistence).vi()
}

async function SUt(t, e, r, n) {
    const i = Ht(t);
    if (i.dc) return void It("SyncEngine", "Ignoring unexpected query state notification.");
    const a = i.rc.get(e);
    if (a && a.length > 0) switch (r) {
        case"current":
        case"not-current": {
            const o = await AAe(i.localStore, MCe(a[0])),
                s = BI.createSynthesizedRemoteEventForCurrentChange(e, r === "current", Fs.EMPTY_BYTE_STRING);
            await ag(i, o, s);
            break
        }
        case"rejected":
            await SE(i.localStore, e, !0), xE(i, e, n);
            break;
        default:
            lr()
    }
}

async function _Ut(t, e, r) {
    const n = vte(t);
    if (n.dc) {
        for (const i of e) {
            if (n.rc.has(i)) {
                It("SyncEngine", "Adding an already active target " + i);
                continue
            }
            const a = await CAe(n.localStore, i), o = await wE(n.localStore, a);
            await dte(n, VAe(a), o.targetId, !1, o.resumeToken), YL(n.remoteStore, o)
        }
        for (const i of r) n.rc.has(i) && await SE(n.localStore, i, !1).then(() => {
            t8(n.remoteStore, i), xE(n, i)
        }).catch(k1)
    }
}

function vte(t) {
    const e = Ht(t);
    return e.remoteStore.remoteSyncer.applyRemoteEvent = jAe.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = mUt.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = lUt.bind(null, e), e.sc.Wo = JFt.bind(null, e.eventManager), e.sc.wc = eUt.bind(null, e.eventManager), e
}

function gte(t) {
    const e = Ht(t);
    return e.remoteStore.remoteSyncer.applySuccessfulWrite = uUt.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = fUt.bind(null, e), e
}

function xUt(t, e, r) {
    const n = Ht(t);
    (async function (i, a, o) {
        try {
            const s = await a.getMetadata();
            if (await function (p, g) {
                const b = Ht(p), S = qo(g.createTime);
                return b.persistence.runTransaction("hasNewerBundle", "readonly", T => b.Ns.getBundleMetadata(T, g.id)).then(T => !!T && T.createTime.compareTo(S) >= 0)
            }(i.localStore, s)) return await a.close(), o._completeWith(function (p) {
                return {
                    taskState: "Success",
                    documentsLoaded: p.totalDocuments,
                    bytesLoaded: p.totalBytes,
                    totalDocuments: p.totalDocuments,
                    totalBytes: p.totalBytes
                }
            }(s)), Promise.resolve(new Set);
            o._updateProgress(BAe(s));
            const l = new rUt(s, i.localStore, a.yt);
            let f = await a.mc();
            for (; f;) {
                const p = await l.Fu(f);
                p && o._updateProgress(p), f = await a.mc()
            }
            const d = await l.complete();
            return await ag(i, d.Lu, void 0), await function (p, g) {
                const b = Ht(p);
                return b.persistence.runTransaction("Save bundle", "readwrite", S => b.Ns.saveBundleMetadata(S, g))
            }(i.localStore, s), o._completeWith(d.progress), Promise.resolve(d.Bu)
        } catch (s) {
            return bS("SyncEngine", `Loading bundle failed with ${s}`), o._failWith(s), Promise.resolve(new Set)
        }
    })(n, e, r).then(i => {
        n.sharedClientState.notifyBundleLoaded(i)
    })
}

class HAe {
    constructor() {
        this.synchronizeTabs = !1
    }

    async initialize(e) {
        this.yt = FI(e.databaseInfo.databaseId), this.sharedClientState = this.gc(e), this.persistence = this.yc(e), await this.persistence.start(), this.localStore = this.Ic(e), this.gcScheduler = this.Tc(e, this.localStore), this.indexBackfillerScheduler = this.Ec(e, this.localStore)
    }

    Tc(e, r) {
        return null
    }

    Ec(e, r) {
        return null
    }

    Ic(e) {
        return _Ae(this.persistence, new SAe, e.initialUser, this.yt)
    }

    yc(e) {
        return new wAe(KL.Bs, this.yt)
    }

    gc(e) {
        return new kAe
    }

    async terminate() {
        this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown()
    }
}

class WAe extends HAe {
    constructor(e, r, n) {
        super(), this.Ac = e, this.cacheSizeBytes = r, this.forceOwnership = n, this.synchronizeTabs = !1
    }

    async initialize(e) {
        await super.initialize(e), await this.Ac.initialize(this, e), await gte(this.Ac.syncEngine), await m3(this.Ac.remoteStore), await this.persistence.li(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(), this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(), Promise.resolve()))
    }

    Ic(e) {
        return _Ae(this.persistence, new SAe, e.initialUser, this.yt)
    }

    Tc(e, r) {
        const n = this.persistence.referenceDelegate.garbageCollector;
        return new dFt(n, e.asyncQueue, r)
    }

    Ec(e, r) {
        const n = new XBt(r, this.persistence);
        return new YBt(e.asyncQueue, n)
    }

    yc(e) {
        const r = ete(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey),
            n = this.cacheSizeBytes !== void 0 ? qu.withCacheSize(this.cacheSizeBytes) : qu.DEFAULT;
        return new Jee(this.synchronizeTabs, r, e.clientId, n, e.asyncQueue, RAe(), hM(), this.yt, this.sharedClientState, !!this.forceOwnership)
    }

    gc(e) {
        return new kAe
    }
}

class EUt extends WAe {
    constructor(e, r) {
        super(e, r, !1), this.Ac = e, this.cacheSizeBytes = r, this.synchronizeTabs = !0
    }

    async initialize(e) {
        await super.initialize(e);
        const r = this.Ac.syncEngine;
        this.sharedClientState instanceof KH && (this.sharedClientState.syncEngine = {
            Fr: yUt.bind(null, r),
            $r: SUt.bind(null, r),
            Br: _Ut.bind(null, r),
            vi: wUt.bind(null, r),
            Mr: gUt.bind(null, r)
        }, await this.sharedClientState.start()), await this.persistence.li(async n => {
            await bUt(this.Ac.syncEngine, n), this.gcScheduler && (n && !this.gcScheduler.started ? this.gcScheduler.start() : n || this.gcScheduler.stop()), this.indexBackfillerScheduler && (n && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : n || this.indexBackfillerScheduler.stop())
        })
    }

    gc(e) {
        const r = RAe();
        if (!KH.C(r)) throw new yt(at.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
        const n = ete(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey);
        return new KH(r, e.asyncQueue, n, e.clientId, e.initialUser)
    }
}

class yte {
    async initialize(e, r) {
        this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(r), this.remoteStore = this.createRemoteStore(r), this.eventManager = this.createEventManager(r), this.syncEngine = this.createSyncEngine(r, !e.synchronizeTabs), this.sharedClientState.onlineStateHandler = n => lme(this.syncEngine, n, 1), this.remoteStore.remoteSyncer.handleCredentialChange = pUt.bind(null, this.syncEngine), await TY(this.remoteStore, this.syncEngine.isPrimaryClient))
    }

    createEventManager(e) {
        return new ZFt
    }

    createDatastore(e) {
        const r = FI(e.databaseInfo.databaseId), n = (i = e.databaseInfo, new NFt(i));
        var i;
        return function (a, o, s, l) {
            return new $Ft(a, o, s, l)
        }(e.authCredentials, e.appCheckCredentials, n, r)
    }

    createRemoteStore(e) {
        return r = this.localStore, n = this.datastore, i = e.asyncQueue, a = s => lme(this.syncEngine, s, 0), o = ame.C() ? new ame : new MFt, new jFt(r, n, i, a, o);
        var r, n, i, a, o
    }

    createSyncEngine(e, r) {
        return function (n, i, a, o, s, l, f) {
            const d = new aUt(n, i, a, o, s, l);
            return f && (d.dc = !0), d
        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, r)
    }

    terminate() {
        return async function (e) {
            const r = Ht(e);
            It("RemoteStore", "RemoteStore shutting down."), r._u.add(5), await p3(r), r.mu.shutdown(), r.gu.set("Unknown")
        }(this.remoteStore)
    }
}

function bte(t, e, r) {
    if (!r) throw new yt(at.INVALID_ARGUMENT, `Function ${t}() cannot be called with an empty ${e}.`)
}

function qAe(t, e, r, n) {
    if (e === !0 && n === !0) throw new yt(at.INVALID_ARGUMENT, `${t} and ${r} cannot be used together.`)
}

function fme(t) {
    if (!jt.isDocumentKey(t)) throw new yt(at.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`)
}

function dme(t) {
    if (jt.isDocumentKey(t)) throw new yt(at.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`)
}

function XL(t) {
    if (t === void 0) return "undefined";
    if (t === null) return "null";
    if (typeof t == "string") return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t);
    if (typeof t == "number" || typeof t == "boolean") return "" + t;
    if (typeof t == "object") {
        if (t instanceof Array) return "an array";
        {
            const e = function (r) {
                return r.constructor ? r.constructor.name : null
            }(t);
            return e ? `a custom ${e} object` : "an object"
        }
    }
    return typeof t == "function" ? "a function" : lr()
}

function li(t, e) {
    if ("_delegate" in t && (t = t._delegate), !(t instanceof e)) {
        if (e.name === t.constructor.name) throw new yt(at.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
        {
            const r = XL(t);
            throw new yt(at.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${r}`)
        }
    }
    return t
}

function GAe(t, e) {
    if (e <= 0) throw new yt(at.INVALID_ARGUMENT, `Function ${t}() requires a positive number, but it was: ${e}.`)
}

const hme = new Map;

class pme {
    constructor(e) {
        var r;
        if (e.host === void 0) {
            if (e.ssl !== void 0) throw new yt(at.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            this.host = "firestore.googleapis.com", this.ssl = !0
        } else this.host = e.host, this.ssl = (r = e.ssl) === null || r === void 0 || r;
        if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, e.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040; else {
            if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576) throw new yt(at.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
            this.cacheSizeBytes = e.cacheSizeBytes
        }
        this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.useFetchStreams = !!e.useFetchStreams, qAe("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling)
    }

    isEqual(e) {
        return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams
    }
}

class jI {
    constructor(e, r, n, i) {
        this._authCredentials = e, this._appCheckCredentials = r, this._databaseId = n, this._app = i, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new pme({}), this._settingsFrozen = !1
    }

    get app() {
        if (!this._app) throw new yt(at.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app
    }

    get _initialized() {
        return this._settingsFrozen
    }

    get _terminated() {
        return this._terminateTask !== void 0
    }

    _setSettings(e) {
        if (this._settingsFrozen) throw new yt(at.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        this._settings = new pme(e), e.credentials !== void 0 && (this._authCredentials = function (r) {
            if (!r) return new uCe;
            switch (r.type) {
                case"gapi":
                    const n = r.client;
                    return new UBt(n, r.sessionIndex || "0", r.iamToken || null, r.authTokenFactory || null);
                case"provider":
                    return r.client;
                default:
                    throw new yt(at.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type")
            }
        }(e.credentials))
    }

    _getSettings() {
        return this._settings
    }

    _freezeSettings() {
        return this._settingsFrozen = !0, this._settings
    }

    _delete() {
        return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask
    }

    toJSON() {
        return {app: this._app, databaseId: this._databaseId, settings: this._settings}
    }

    _terminate() {
        return function (e) {
            const r = hme.get(e);
            r && (It("ComponentProvider", "Removing Datastore"), hme.delete(e), r.terminate())
        }(this), Promise.resolve()
    }
}

function KAe(t, e, r, n = {}) {
    var i;
    const a = (t = li(t, jI))._getSettings();
    if (a.host !== "firestore.googleapis.com" && a.host !== e && bS("Host has been set in both settings() and useEmulator(), emulator host will be used"), t._setSettings(Object.assign(Object.assign({}, a), {
        host: `${e}:${r}`,
        ssl: !1
    })), n.mockUserToken) {
        let o, s;
        if (typeof n.mockUserToken == "string") o = n.mockUserToken, s = Qs.MOCK_USER; else {
            o = aNt(n.mockUserToken, (i = t._app) === null || i === void 0 ? void 0 : i.options.projectId);
            const l = n.mockUserToken.sub || n.mockUserToken.user_id;
            if (!l) throw new yt(at.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
            s = new Qs(l)
        }
        t._authCredentials = new BBt(new lCe(o, s))
    }
}

class Ro {
    constructor(e, r, n) {
        this.converter = r, this._key = n, this.type = "document", this.firestore = e
    }

    get _path() {
        return this._key.path
    }

    get id() {
        return this._key.path.lastSegment()
    }

    get path() {
        return this._key.path.canonicalString()
    }

    get parent() {
        return new up(this.firestore, this.converter, this._key.path.popLast())
    }

    withConverter(e) {
        return new Ro(this.firestore, e, this._key)
    }
}

class nc {
    constructor(e, r, n) {
        this.converter = r, this._query = n, this.type = "query", this.firestore = e
    }

    withConverter(e) {
        return new nc(this.firestore, e, this._query)
    }
}

class up extends nc {
    constructor(e, r, n) {
        super(e, r, f3(n)), this._path = n, this.type = "collection"
    }

    get id() {
        return this._query.path.lastSegment()
    }

    get path() {
        return this._query.path.canonicalString()
    }

    get parent() {
        const e = this._path.popLast();
        return e.isEmpty() ? null : new Ro(this.firestore, null, new jt(e))
    }

    withConverter(e) {
        return new up(this.firestore, e, this._path)
    }
}

function id(t, e, ...r) {
    if (t = Tr(t), bte("collection", "path", e), t instanceof jI) {
        const n = Ei.fromString(e, ...r);
        return dme(n), new up(t, null, n)
    }
    {
        if (!(t instanceof Ro || t instanceof up)) throw new yt(at.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const n = t._path.child(Ei.fromString(e, ...r));
        return dme(n), new up(t.firestore, null, n)
    }
}

function TUt(t, e) {
    if (t = li(t, jI), bte("collectionGroup", "collection id", e), e.indexOf("/") >= 0) throw new yt(at.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
    return new nc(t, null, function (r) {
        return new rg(Ei.emptyPath(), r)
    }(e))
}

function ua(t, e, ...r) {
    if (t = Tr(t), arguments.length === 1 && (e = dCe.R()), bte("doc", "path", e), t instanceof jI) {
        const n = Ei.fromString(e, ...r);
        return fme(n), new Ro(t, null, new jt(n))
    }
    {
        if (!(t instanceof Ro || t instanceof up)) throw new yt(at.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const n = t._path.child(Ei.fromString(e, ...r));
        return fme(n), new Ro(t.firestore, t instanceof up ? t.converter : null, new jt(n))
    }
}

function CUt(t, e) {
    return t = Tr(t), e = Tr(e), (t instanceof Ro || t instanceof up) && (e instanceof Ro || e instanceof up) && t.firestore === e.firestore && t.path === e.path && t.converter === e.converter
}

function wte(t, e) {
    return t = Tr(t), e = Tr(e), t instanceof nc && e instanceof nc && t.firestore === e.firestore && PI(t._query, e._query) && t.converter === e.converter
}

function mme(t, e = 10240) {
    let r = 0;
    return {
        async read() {
            if (r < t.byteLength) {
                const n = {value: t.slice(r, r + e), done: !1};
                return r += e, n
            }
            return {done: !0}
        }, async cancel() {
        }, releaseLock() {
        }, closed: Promise.reject("unimplemented")
    }
}

class QL {
    constructor(e) {
        this.observer = e, this.muted = !1
    }

    next(e) {
        this.observer.next && this.Rc(this.observer.next, e)
    }

    error(e) {
        this.observer.error ? this.Rc(this.observer.error, e) : Vo("Uncaught Error in snapshot listener:", e.toString())
    }

    bc() {
        this.muted = !0
    }

    Rc(e, r) {
        this.muted || setTimeout(() => {
            this.muted || e(r)
        }, 0)
    }
}

class AUt {
    constructor(e, r) {
        this.Pc = e, this.yt = r, this.metadata = new Ls, this.buffer = new Uint8Array, this.vc = new TextDecoder("utf-8"), this.Vc().then(n => {
            n && n.Ou() ? this.metadata.resolve(n.ku.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(n == null ? void 0 : n.ku)}`))
        }, n => this.metadata.reject(n))
    }

    close() {
        return this.Pc.cancel()
    }

    async getMetadata() {
        return this.metadata.promise
    }

    async mc() {
        return await this.getMetadata(), this.Vc()
    }

    async Vc() {
        const e = await this.Sc();
        if (e === null) return null;
        const r = this.vc.decode(e), n = Number(r);
        isNaN(n) && this.Dc(`length string (${r}) is not valid number`);
        const i = await this.Cc(n);
        return new tUt(JSON.parse(i), e.length + n)
    }

    xc() {
        return this.buffer.findIndex(e => e === 123)
    }

    async Sc() {
        for (; this.xc() < 0 && !await this.Nc();) ;
        if (this.buffer.length === 0) return null;
        const e = this.xc();
        e < 0 && this.Dc("Reached the end of bundle when a length string is expected.");
        const r = this.buffer.slice(0, e);
        return this.buffer = this.buffer.slice(e), r
    }

    async Cc(e) {
        for (; this.buffer.length < e;) await this.Nc() && this.Dc("Reached the end of bundle when more is expected.");
        const r = this.vc.decode(this.buffer.slice(0, e));
        return this.buffer = this.buffer.slice(e), r
    }

    Dc(e) {
        throw this.Pc.cancel(), new Error(`Invalid bundle format: ${e}`)
    }

    async Nc() {
        const e = await this.Pc.read();
        if (!e.done) {
            const r = new Uint8Array(this.buffer.length + e.value.length);
            r.set(this.buffer), r.set(e.value, this.buffer.length), this.buffer = r
        }
        return e.done
    }
}

class IUt {
    constructor() {
        this.type = "AggregateField"
    }
}

class YAe {
    constructor(e, r) {
        this._data = r, this.type = "AggregateQuerySnapshot", this.query = e
    }

    data() {
        return this._data
    }
}

class kUt {
    constructor(e, r, n) {
        this.query = e, this.datastore = r, this.userDataWriter = n
    }

    run() {
        return FFt(this.datastore, this.query._query).then(e => {
            Er(e[0] !== void 0);
            const r = Object.entries(e[0]).filter(([n, i]) => n === "count_alias").map(([n, i]) => this.userDataWriter.convertValue(i))[0];
            return Er(typeof r == "number"), Promise.resolve(new YAe(this.query, {count: r}))
        })
    }
}

class RUt {
    constructor(e) {
        this.datastore = e, this.readVersions = new Map, this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = new Set
    }

    async lookup(e) {
        if (this.ensureCommitNotCalled(), this.mutations.length > 0) throw new yt(at.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
        const r = await async function (n, i) {
            const a = Ht(n), o = JA(a.yt) + "/documents", s = {documents: i.map(p => ZA(a.yt, p))},
                l = await a._o("BatchGetDocuments", o, s, i.length), f = new Map;
            l.forEach(p => {
                const g = I$t(a.yt, p);
                f.set(g.key.toString(), g)
            });
            const d = [];
            return i.forEach(p => {
                const g = f.get(p.toString());
                Er(!!g), d.push(g)
            }), d
        }(this.datastore, e);
        return r.forEach(n => this.recordVersion(n)), r
    }

    set(e, r) {
        this.write(r.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString())
    }

    update(e, r) {
        try {
            this.write(r.toMutation(e, this.preconditionForUpdate(e)))
        } catch (n) {
            this.lastWriteError = n
        }
        this.writtenDocs.add(e.toString())
    }

    delete(e) {
        this.write(new h3(e, this.precondition(e))), this.writtenDocs.add(e.toString())
    }

    async commit() {
        if (this.ensureCommitNotCalled(), this.lastWriteError) throw this.lastWriteError;
        const e = this.readVersions;
        this.mutations.forEach(r => {
            e.delete(r.key.toString())
        }), e.forEach((r, n) => {
            const i = jt.fromPath(n);
            this.mutations.push(new Vee(i, this.precondition(i)))
        }), await async function (r, n) {
            const i = Ht(r), a = JA(i.yt) + "/documents", o = {writes: n.map(s => e8(i.yt, s))};
            await i.ao("Commit", a, o)
        }(this.datastore, this.mutations), this.committed = !0
    }

    recordVersion(e) {
        let r;
        if (e.isFoundDocument()) r = e.version; else {
            if (!e.isNoDocument()) throw lr();
            r = Fr.min()
        }
        const n = this.readVersions.get(e.key.toString());
        if (n) {
            if (!r.isEqual(n)) throw new yt(at.ABORTED, "Document version changed between two reads.")
        } else this.readVersions.set(e.key.toString(), r)
    }

    precondition(e) {
        const r = this.readVersions.get(e.toString());
        return !this.writtenDocs.has(e.toString()) && r ? r.isEqual(Fr.min()) ? Ya.exists(!1) : Ya.updateTime(r) : Ya.none()
    }

    preconditionForUpdate(e) {
        const r = this.readVersions.get(e.toString());
        if (!this.writtenDocs.has(e.toString()) && r) {
            if (r.isEqual(Fr.min())) throw new yt(at.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
            return Ya.updateTime(r)
        }
        return Ya.exists(!0)
    }

    write(e) {
        this.ensureCommitNotCalled(), this.mutations.push(e)
    }

    ensureCommitNotCalled() {
    }
}

class DUt {
    constructor(e, r, n, i, a) {
        this.asyncQueue = e, this.datastore = r, this.options = n, this.updateFunction = i, this.deferred = a, this.kc = n.maxAttempts, this.xo = new nte(this.asyncQueue, "transaction_retry")
    }

    run() {
        this.kc -= 1, this.Oc()
    }

    Oc() {
        this.xo.Ro(async () => {
            const e = new RUt(this.datastore), r = this.Mc(e);
            r && r.then(n => {
                this.asyncQueue.enqueueAndForget(() => e.commit().then(() => {
                    this.deferred.resolve(n)
                }).catch(i => {
                    this.Fc(i)
                }))
            }).catch(n => {
                this.Fc(n)
            })
        })
    }

    Mc(e) {
        try {
            const r = this.updateFunction(e);
            return !MI(r) && r.catch && r.then ? r : (this.deferred.reject(Error("Transaction callback must return a Promise")), null)
        } catch (r) {
            return this.deferred.reject(r), null
        }
    }

    Fc(e) {
        this.kc > 0 && this.$c(e) ? (this.kc -= 1, this.asyncQueue.enqueueAndForget(() => (this.Oc(), Promise.resolve()))) : this.deferred.reject(e)
    }

    $c(e) {
        if (e.name === "FirebaseError") {
            const r = e.code;
            return r === "aborted" || r === "failed-precondition" || r === "already-exists" || !VCe(r)
        }
        return !1
    }
}

class MUt {
    constructor(e, r, n, i) {
        this.authCredentials = e, this.appCheckCredentials = r, this.asyncQueue = n, this.databaseInfo = i, this.user = Qs.UNAUTHENTICATED, this.clientId = dCe.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async a => {
            It("FirestoreClient", "Received user=", a.uid), await this.authCredentialListener(a), this.user = a
        }), this.appCheckCredentials.start(n, a => (It("FirestoreClient", "Received new app check token=", a), this.appCheckCredentialListener(a, this.user)))
    }

    async getConfiguration() {
        return {
            asyncQueue: this.asyncQueue,
            databaseInfo: this.databaseInfo,
            clientId: this.clientId,
            authCredentials: this.authCredentials,
            appCheckCredentials: this.appCheckCredentials,
            initialUser: this.user,
            maxConcurrentLimboResolutions: 100
        }
    }

    setCredentialChangeListener(e) {
        this.authCredentialListener = e
    }

    setAppCheckTokenChangeListener(e) {
        this.appCheckCredentialListener = e
    }

    verifyNotTerminated() {
        if (this.asyncQueue.isShuttingDown) throw new yt(at.FAILED_PRECONDITION, "The client has already been terminated.")
    }

    terminate() {
        this.asyncQueue.enterRestrictedMode();
        const e = new Ls;
        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
            try {
                this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve()
            } catch (r) {
                const n = g3(r, "Failed to shutdown persistence");
                e.reject(n)
            }
        }), e.promise
    }
}

async function XAe(t, e) {
    t.asyncQueue.verifyOperationInProgress(), It("FirestoreClient", "Initializing OfflineComponentProvider");
    const r = await t.getConfiguration();
    await e.initialize(r);
    let n = r.initialUser;
    t.setCredentialChangeListener(async i => {
        n.isEqual(i) || (await xAe(e.localStore, i), n = i)
    }), e.persistence.setDatabaseDeletedListener(() => t.terminate()), t.offlineComponents = e
}

async function QAe(t, e) {
    t.asyncQueue.verifyOperationInProgress();
    const r = await Ste(t);
    It("FirestoreClient", "Initializing OnlineComponentProvider");
    const n = await t.getConfiguration();
    await e.initialize(r, n), t.setCredentialChangeListener(i => ome(e.remoteStore, i)), t.setAppCheckTokenChangeListener((i, a) => ome(e.remoteStore, a)), t.onlineComponents = e
}

async function Ste(t) {
    return t.offlineComponents || (It("FirestoreClient", "Using default OfflineComponentProvider"), await XAe(t, new HAe)), t.offlineComponents
}

async function ZL(t) {
    return t.onlineComponents || (It("FirestoreClient", "Using default OnlineComponentProvider"), await QAe(t, new yte)), t.onlineComponents
}

function ZAe(t) {
    return Ste(t).then(e => e.persistence)
}

function JL(t) {
    return Ste(t).then(e => e.localStore)
}

function _te(t) {
    return ZL(t).then(e => e.remoteStore)
}

function xte(t) {
    return ZL(t).then(e => e.syncEngine)
}

function JAe(t) {
    return ZL(t).then(e => e.datastore)
}

async function EE(t) {
    const e = await ZL(t), r = e.eventManager;
    return r.onListen = oUt.bind(null, e.syncEngine), r.onUnlisten = sUt.bind(null, e.syncEngine), r
}

function OUt(t) {
    return t.asyncQueue.enqueue(async () => {
        const e = await ZAe(t), r = await _te(t);
        return e.setNetworkEnabled(!0), function (n) {
            const i = Ht(n);
            return i._u.delete(0), UI(i)
        }(r)
    })
}

function PUt(t) {
    return t.asyncQueue.enqueue(async () => {
        const e = await ZAe(t), r = await _te(t);
        return e.setNetworkEnabled(!1), async function (n) {
            const i = Ht(n);
            i._u.add(0), await p3(i), i.gu.set("Offline")
        }(r)
    })
}

function NUt(t, e) {
    const r = new Ls;
    return t.asyncQueue.enqueueAndForget(async () => async function (n, i, a) {
        try {
            const o = await function (s, l) {
                const f = Ht(s);
                return f.persistence.runTransaction("read document", "readonly", d => f.localDocuments.getDocument(d, l))
            }(n, i);
            o.isFoundDocument() ? a.resolve(o) : o.isNoDocument() ? a.resolve(null) : a.reject(new yt(at.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"))
        } catch (o) {
            const s = g3(o, `Failed to get document '${i} from cache`);
            a.reject(s)
        }
    }(await JL(t), e, r)), r.promise
}

function e8e(t, e, r = {}) {
    const n = new Ls;
    return t.asyncQueue.enqueueAndForget(async () => function (i, a, o, s, l) {
        const f = new QL({
            next: p => {
                a.enqueueAndForget(() => lte(i, d));
                const g = p.docs.has(o);
                !g && p.fromCache ? l.reject(new yt(at.UNAVAILABLE, "Failed to get document because the client is offline.")) : g && p.fromCache && s && s.source === "server" ? l.reject(new yt(at.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : l.resolve(p)
            }, error: p => l.reject(p)
        }), d = new fte(f3(o.path), f, {includeMetadataChanges: !0, Nu: !0});
        return cte(i, d)
    }(await EE(t), t.asyncQueue, e, r, n)), n.promise
}

function LUt(t, e) {
    const r = new Ls;
    return t.asyncQueue.enqueueAndForget(async () => async function (n, i, a) {
        try {
            const o = await vP(n, i, !0), s = new UAe(i, o.Hi), l = s.Wu(o.documents), f = s.applyChanges(l, !1);
            a.resolve(f.snapshot)
        } catch (o) {
            const s = g3(o, `Failed to execute query '${i} against cache`);
            a.reject(s)
        }
    }(await JL(t), e, r)), r.promise
}

function t8e(t, e, r = {}) {
    const n = new Ls;
    return t.asyncQueue.enqueueAndForget(async () => function (i, a, o, s, l) {
        const f = new QL({
            next: p => {
                a.enqueueAndForget(() => lte(i, d)), p.fromCache && s.source === "server" ? l.reject(new yt(at.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : l.resolve(p)
            }, error: p => l.reject(p)
        }), d = new fte(o, f, {includeMetadataChanges: !0, Nu: !0});
        return cte(i, d)
    }(await EE(t), t.asyncQueue, e, r, n)), n.promise
}

function BUt(t, e) {
    const r = new QL(e);
    return t.asyncQueue.enqueueAndForget(async () => function (n, i) {
        Ht(n).Ru.add(i), i.next()
    }(await EE(t), r)), () => {
        r.bc(), t.asyncQueue.enqueueAndForget(async () => function (n, i) {
            Ht(n).Ru.delete(i)
        }(await EE(t), r))
    }
}

function $Ut(t, e, r, n) {
    const i = function (a, o) {
        let s;
        return s = typeof a == "string" ? new TextEncoder().encode(a) : a, function (l, f) {
            return new AUt(l, f)
        }(function (l, f) {
            if (l instanceof Uint8Array) return mme(l, f);
            if (l instanceof ArrayBuffer) return mme(new Uint8Array(l), f);
            if (l instanceof ReadableStream) return l.getReader();
            throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream")
        }(s), o)
    }(r, FI(e));
    t.asyncQueue.enqueueAndForget(async () => {
        xUt(await xte(t), i, n)
    })
}

function FUt(t, e) {
    return t.asyncQueue.enqueue(async () => function (r, n) {
        const i = Ht(r);
        return i.persistence.runTransaction("Get named query", "readonly", a => i.Ns.getNamedQuery(a, n))
    }(await JL(t), e))
}

class UUt {
    constructor() {
        this.Bc = Promise.resolve(), this.Lc = [], this.qc = !1, this.Uc = [], this.Kc = null, this.Gc = !1, this.Qc = !1, this.jc = [], this.xo = new nte(this, "async_queue_retry"), this.Wc = () => {
            const r = hM();
            r && It("AsyncQueue", "Visibility state changed to " + r.visibilityState), this.xo.Po()
        };
        const e = hM();
        e && typeof e.addEventListener == "function" && e.addEventListener("visibilitychange", this.Wc)
    }

    get isShuttingDown() {
        return this.qc
    }

    enqueueAndForget(e) {
        this.enqueue(e)
    }

    enqueueAndForgetEvenWhileRestricted(e) {
        this.zc(), this.Hc(e)
    }

    enterRestrictedMode(e) {
        if (!this.qc) {
            this.qc = !0, this.Qc = e || !1;
            const r = hM();
            r && typeof r.removeEventListener == "function" && r.removeEventListener("visibilitychange", this.Wc)
        }
    }

    enqueue(e) {
        if (this.zc(), this.qc) return new Promise(() => {
        });
        const r = new Ls;
        return this.Hc(() => this.qc && this.Qc ? Promise.resolve() : (e().then(r.resolve, r.reject), r.promise)).then(() => r.promise)
    }

    enqueueRetryable(e) {
        this.enqueueAndForget(() => (this.Lc.push(e), this.Jc()))
    }

    async Jc() {
        if (this.Lc.length !== 0) {
            try {
                await this.Lc[0](), this.Lc.shift(), this.xo.reset()
            } catch (e) {
                if (!R1(e)) throw e;
                It("AsyncQueue", "Operation failed with retryable error: " + e)
            }
            this.Lc.length > 0 && this.xo.Ro(() => this.Jc())
        }
    }

    Hc(e) {
        const r = this.Bc.then(() => (this.Gc = !0, e().catch(n => {
            this.Kc = n, this.Gc = !1;
            const i = function (a) {
                let o = a.message || "";
                return a.stack && (o = a.stack.includes(a.message) ? a.stack : a.message + `
` + a.stack), o
            }(n);
            throw Vo("INTERNAL UNHANDLED ERROR: ", i), n
        }).then(n => (this.Gc = !1, n))));
        return this.Bc = r, r
    }

    enqueueAfterDelay(e, r, n) {
        this.zc(), this.jc.indexOf(e) > -1 && (r = 0);
        const i = ste.createAndSchedule(this, e, r, n, a => this.Yc(a));
        return this.Uc.push(i), i
    }

    zc() {
        this.Kc && lr()
    }

    verifyOperationInProgress() {
    }

    async Xc() {
        let e;
        do e = this.Bc, await e; while (e !== this.Bc)
    }

    Zc(e) {
        for (const r of this.Uc) if (r.timerId === e) return !0;
        return !1
    }

    ta(e) {
        return this.Xc().then(() => {
            this.Uc.sort((r, n) => r.targetTimeMs - n.targetTimeMs);
            for (const r of this.Uc) if (r.skipDelay(), e !== "all" && r.timerId === e) break;
            return this.Xc()
        })
    }

    ea(e) {
        this.jc.push(e)
    }

    Yc(e) {
        const r = this.Uc.indexOf(e);
        this.Uc.splice(r, 1)
    }
}

function AY(t) {
    return function (e, r) {
        if (typeof e != "object" || e === null) return !1;
        const n = e;
        for (const i of r) if (i in n && typeof n[i] == "function") return !0;
        return !1
    }(t, ["next", "error", "complete"])
}

class r8e {
    constructor() {
        this._progressObserver = {}, this._taskCompletionResolver = new Ls, this._lastProgress = {
            taskState: "Running",
            totalBytes: 0,
            totalDocuments: 0,
            bytesLoaded: 0,
            documentsLoaded: 0
        }
    }

    onProgress(e, r, n) {
        this._progressObserver = {next: e, error: r, complete: n}
    }

    catch(e) {
        return this._taskCompletionResolver.promise.catch(e)
    }

    then(e, r) {
        return this._taskCompletionResolver.promise.then(e, r)
    }

    _completeWith(e) {
        this._updateProgress(e), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(e)
    }

    _failWith(e) {
        this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(e), this._taskCompletionResolver.reject(e)
    }

    _updateProgress(e) {
        this._lastProgress = e, this._progressObserver.next && this._progressObserver.next(e)
    }
}

const jUt = -1;

class Ia extends jI {
    constructor(e, r, n, i) {
        super(e, r, n, i), this.type = "firestore", this._queue = new UUt, this._persistenceKey = (i == null ? void 0 : i.name) || "[DEFAULT]"
    }

    _terminate() {
        return this._firestoreClient || n8e(this), this._firestoreClient.terminate()
    }
}

function zUt(t, e, r) {
    r || (r = "(default)");
    const n = SI(t, "firestore");
    if (n.isInitialized(r)) {
        const i = n.getImmediate({identifier: r}), a = n.getOptions(r);
        if (fE(a, e)) return i;
        throw new yt(at.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.")
    }
    if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576) throw new yt(at.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
    return n.initialize({options: e, instanceIdentifier: r})
}

function VUt(t, e) {
    const r = typeof t == "object" ? t : iTe(), n = typeof t == "string" ? t : e || "(default)",
        i = SI(r, "firestore").getImmediate({identifier: n});
    if (!i._initialized) {
        const a = rNt("firestore");
        a && KAe(i, ...a)
    }
    return i
}

function Go(t) {
    return t._firestoreClient || n8e(t), t._firestoreClient.verifyNotTerminated(), t._firestoreClient
}

function n8e(t) {
    var e;
    const r = t._freezeSettings(), n = function (i, a, o, s) {
        return new QBt(i, a, o, s.host, s.ssl, s.experimentalForceLongPolling, s.experimentalAutoDetectLongPolling, s.useFetchStreams)
    }(t._databaseId, ((e = t._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t._persistenceKey, r);
    t._firestoreClient = new MUt(t._authCredentials, t._appCheckCredentials, t._queue, n)
}

function HUt(t, e) {
    a8e(t = li(t, Ia));
    const r = Go(t), n = t._freezeSettings(), i = new yte;
    return i8e(r, i, new WAe(i, n.cacheSizeBytes, e == null ? void 0 : e.forceOwnership))
}

function WUt(t) {
    a8e(t = li(t, Ia));
    const e = Go(t), r = t._freezeSettings(), n = new yte;
    return i8e(e, n, new EUt(n, r.cacheSizeBytes))
}

function i8e(t, e, r) {
    const n = new Ls;
    return t.asyncQueue.enqueue(async () => {
        try {
            await XAe(t, r), await QAe(t, e), n.resolve()
        } catch (i) {
            const a = i;
            if (!function (o) {
                return o.name === "FirebaseError" ? o.code === at.FAILED_PRECONDITION || o.code === at.UNIMPLEMENTED : typeof DOMException < "u" && o instanceof DOMException ? o.code === 22 || o.code === 20 || o.code === 11 : !0
            }(a)) throw a;
            bS("Error enabling offline persistence. Falling back to persistence disabled: " + a), n.reject(a)
        }
    }).then(() => n.promise)
}

function qUt(t) {
    if (t._initialized && !t._terminated) throw new yt(at.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
    const e = new Ls;
    return t._queue.enqueueAndForgetEvenWhileRestricted(async () => {
        try {
            await async function (r) {
                if (!np.C()) return Promise.resolve();
                const n = r + "main";
                await np.delete(n)
            }(ete(t._databaseId, t._persistenceKey)), e.resolve()
        } catch (r) {
            e.reject(r)
        }
    }), e.promise
}

function GUt(t) {
    return function (e) {
        const r = new Ls;
        return e.asyncQueue.enqueueAndForget(async () => dUt(await xte(e), r)), r.promise
    }(Go(t = li(t, Ia)))
}

function KUt(t) {
    return OUt(Go(t = li(t, Ia)))
}

function YUt(t) {
    return PUt(Go(t = li(t, Ia)))
}

function XUt(t) {
    return wLt(t.app, "firestore", t._databaseId.database), t._delete()
}

function QUt(t, e) {
    const r = Go(t = li(t, Ia)), n = new r8e;
    return $Ut(r, t._databaseId, e, n), n
}

function ZUt(t, e) {
    return FUt(Go(t = li(t, Ia)), e).then(r => r ? new nc(t, null, r.query) : null)
}

function a8e(t) {
    if (t._initialized || t._terminated) throw new yt(at.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.")
}

class f1 {
    constructor(e) {
        this._byteString = e
    }

    static fromBase64String(e) {
        try {
            return new f1(Fs.fromBase64String(e))
        } catch (r) {
            throw new yt(at.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + r)
        }
    }

    static fromUint8Array(e) {
        return new f1(Fs.fromUint8Array(e))
    }

    toBase64() {
        return this._byteString.toBase64()
    }

    toUint8Array() {
        return this._byteString.toUint8Array()
    }

    toString() {
        return "Bytes(base64: " + this.toBase64() + ")"
    }

    isEqual(e) {
        return this._byteString.isEqual(e._byteString)
    }
}

class M1 {
    constructor(...e) {
        for (let r = 0; r < e.length; ++r) if (e[r].length === 0) throw new yt(at.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
        this._internalPath = new Io(e)
    }

    isEqual(e) {
        return this._internalPath.isEqual(e._internalPath)
    }
}

function JUt() {
    return new M1("__name__")
}

class O1 {
    constructor(e) {
        this._methodName = e
    }
}

class eB {
    constructor(e, r) {
        if (!isFinite(e) || e < -90 || e > 90) throw new yt(at.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e);
        if (!isFinite(r) || r < -180 || r > 180) throw new yt(at.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + r);
        this._lat = e, this._long = r
    }

    get latitude() {
        return this._lat
    }

    get longitude() {
        return this._long
    }

    isEqual(e) {
        return this._lat === e._lat && this._long === e._long
    }

    toJSON() {
        return {latitude: this._lat, longitude: this._long}
    }

    _compareTo(e) {
        return gn(this._lat, e._lat) || gn(this._long, e._long)
    }
}

const ejt = /^__.*__$/;

class tjt {
    constructor(e, r, n) {
        this.data = e, this.fieldMask = r, this.fieldTransforms = n
    }

    toMutation(e, r) {
        return this.fieldMask !== null ? new ng(e, this.data, this.fieldMask, r, this.fieldTransforms) : new d3(e, this.data, r, this.fieldTransforms)
    }
}

class o8e {
    constructor(e, r, n) {
        this.data = e, this.fieldMask = r, this.fieldTransforms = n
    }

    toMutation(e, r) {
        return new ng(e, this.data, this.fieldMask, r, this.fieldTransforms)
    }
}

function s8e(t) {
    switch (t) {
        case 0:
        case 2:
        case 1:
            return !0;
        case 3:
        case 4:
            return !1;
        default:
            throw lr()
    }
}

class tB {
    constructor(e, r, n, i, a, o) {
        this.settings = e, this.databaseId = r, this.yt = n, this.ignoreUndefinedProperties = i, a === void 0 && this.na(), this.fieldTransforms = a || [], this.fieldMask = o || []
    }

    get path() {
        return this.settings.path
    }

    get sa() {
        return this.settings.sa
    }

    ia(e) {
        return new tB(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.yt, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask)
    }

    ra(e) {
        var r;
        const n = (r = this.path) === null || r === void 0 ? void 0 : r.child(e), i = this.ia({path: n, oa: !1});
        return i.ua(e), i
    }

    ca(e) {
        var r;
        const n = (r = this.path) === null || r === void 0 ? void 0 : r.child(e), i = this.ia({path: n, oa: !1});
        return i.na(), i
    }

    aa(e) {
        return this.ia({path: void 0, oa: !0})
    }

    ha(e) {
        return wP(e, this.settings.methodName, this.settings.la || !1, this.path, this.settings.fa)
    }

    contains(e) {
        return this.fieldMask.find(r => e.isPrefixOf(r)) !== void 0 || this.fieldTransforms.find(r => e.isPrefixOf(r.field)) !== void 0
    }

    na() {
        if (this.path) for (let e = 0; e < this.path.length; e++) this.ua(this.path.get(e))
    }

    ua(e) {
        if (e.length === 0) throw this.ha("Document fields must not be empty");
        if (s8e(this.sa) && ejt.test(e)) throw this.ha('Document fields cannot begin and end with "__"')
    }
}

class rjt {
    constructor(e, r, n) {
        this.databaseId = e, this.ignoreUndefinedProperties = r, this.yt = n || FI(e)
    }

    da(e, r, n, i = !1) {
        return new tB({
            sa: e,
            methodName: r,
            fa: n,
            path: Io.emptyPath(),
            oa: !1,
            la: i
        }, this.databaseId, this.yt, this.ignoreUndefinedProperties)
    }
}

function JS(t) {
    const e = t._freezeSettings(), r = FI(t._databaseId);
    return new rjt(t._databaseId, !!e.ignoreUndefinedProperties, r)
}

function rB(t, e, r, n, i, a = {}) {
    const o = t.da(a.merge || a.mergeFields ? 2 : 0, e, r, i);
    Ate("Data must be an object, but it was:", o, n);
    const s = u8e(n, o);
    let l, f;
    if (a.merge) l = new Qu(o.fieldMask), f = o.fieldTransforms; else if (a.mergeFields) {
        const d = [];
        for (const p of a.mergeFields) {
            const g = IY(e, p, r);
            if (!o.contains(g)) throw new yt(at.INVALID_ARGUMENT, `Field '${g}' is specified in your field mask but missing from your input data.`);
            d8e(d, g) || d.push(g)
        }
        l = new Qu(d), f = o.fieldTransforms.filter(p => l.covers(p.field))
    } else l = null, f = o.fieldTransforms;
    return new tjt(new Vc(s), l, f)
}

class zI extends O1 {
    _toFieldTransform(e) {
        if (e.sa !== 2) throw e.sa === 1 ? e.ha(`${this._methodName}() can only appear at the top level of your update data`) : e.ha(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
        return e.fieldMask.push(e.path), null
    }

    isEqual(e) {
        return e instanceof zI
    }
}

function c8e(t, e, r) {
    return new tB({
        sa: 3,
        fa: e.settings.fa,
        methodName: t._methodName,
        oa: r
    }, e.databaseId, e.yt, e.ignoreUndefinedProperties)
}

class Ete extends O1 {
    _toFieldTransform(e) {
        return new LI(e.path, new gE)
    }

    isEqual(e) {
        return e instanceof Ete
    }
}

class njt extends O1 {
    constructor(e, r) {
        super(e), this._a = r
    }

    _toFieldTransform(e) {
        const r = c8e(this, e, !0), n = this._a.map(a => e2(a, r)), i = new ES(n);
        return new LI(e.path, i)
    }

    isEqual(e) {
        return this === e
    }
}

class ijt extends O1 {
    constructor(e, r) {
        super(e), this._a = r
    }

    _toFieldTransform(e) {
        const r = c8e(this, e, !0), n = this._a.map(a => e2(a, r)), i = new TS(n);
        return new LI(e.path, i)
    }

    isEqual(e) {
        return this === e
    }
}

class ajt extends O1 {
    constructor(e, r) {
        super(e), this.wa = r
    }

    _toFieldTransform(e) {
        const r = new yE(e.yt, LCe(e.yt, this.wa));
        return new LI(e.path, r)
    }

    isEqual(e) {
        return this === e
    }
}

function Tte(t, e, r, n) {
    const i = t.da(1, e, r);
    Ate("Data must be an object, but it was:", i, n);
    const a = [], o = Vc.empty();
    ZS(n, (l, f) => {
        const d = nB(e, l, r);
        f = Tr(f);
        const p = i.ca(d);
        if (f instanceof zI) a.push(d); else {
            const g = e2(f, p);
            g != null && (a.push(d), o.set(d, g))
        }
    });
    const s = new Qu(a);
    return new o8e(o, s, i.fieldTransforms)
}

function Cte(t, e, r, n, i, a) {
    const o = t.da(1, e, r), s = [IY(e, n, r)], l = [i];
    if (a.length % 2 != 0) throw new yt(at.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
    for (let g = 0; g < a.length; g += 2) s.push(IY(e, a[g])), l.push(a[g + 1]);
    const f = [], d = Vc.empty();
    for (let g = s.length - 1; g >= 0; --g) if (!d8e(f, s[g])) {
        const b = s[g];
        let S = l[g];
        S = Tr(S);
        const T = o.ca(b);
        if (S instanceof zI) f.push(b); else {
            const I = e2(S, T);
            I != null && (f.push(b), d.set(b, I))
        }
    }
    const p = new Qu(f);
    return new o8e(d, p, o.fieldTransforms)
}

function l8e(t, e, r, n = !1) {
    return e2(r, t.da(n ? 4 : 3, e))
}

function e2(t, e) {
    if (f8e(t = Tr(t))) return Ate("Unsupported field value:", e, t), u8e(t, e);
    if (t instanceof O1) return function (r, n) {
        if (!s8e(n.sa)) throw n.ha(`${r._methodName}() can only be used with update() and set()`);
        if (!n.path) throw n.ha(`${r._methodName}() is not currently supported inside arrays`);
        const i = r._toFieldTransform(n);
        i && n.fieldTransforms.push(i)
    }(t, e), null;
    if (t === void 0 && e.ignoreUndefinedProperties) return null;
    if (e.path && e.fieldMask.push(e.path), t instanceof Array) {
        if (e.settings.oa && e.sa !== 4) throw e.ha("Nested arrays are not supported");
        return function (r, n) {
            const i = [];
            let a = 0;
            for (const o of r) {
                let s = e2(o, n.aa(a));
                s == null && (s = {nullValue: "NULL_VALUE"}), i.push(s), a++
            }
            return {arrayValue: {values: i}}
        }(t, e)
    }
    return function (r, n) {
        if ((r = Tr(r)) === null) return {nullValue: "NULL_VALUE"};
        if (typeof r == "number") return LCe(n.yt, r);
        if (typeof r == "boolean") return {booleanValue: r};
        if (typeof r == "string") return {stringValue: r};
        if (r instanceof Date) {
            const i = Ca.fromDate(r);
            return {timestampValue: bE(n.yt, i)}
        }
        if (r instanceof Ca) {
            const i = new Ca(r.seconds, 1e3 * Math.floor(r.nanoseconds / 1e3));
            return {timestampValue: bE(n.yt, i)}
        }
        if (r instanceof eB) return {geoPointValue: {latitude: r.latitude, longitude: r.longitude}};
        if (r instanceof f1) return {bytesValue: XCe(n.yt, r._byteString)};
        if (r instanceof Ro) {
            const i = n.databaseId, a = r.firestore._databaseId;
            if (!a.isEqual(i)) throw n.ha(`Document reference is for database ${a.projectId}/${a.database} but should be for database ${i.projectId}/${i.database}`);
            return {referenceValue: Hee(r.firestore._databaseId || n.databaseId, r._key.path)}
        }
        throw n.ha(`Unsupported field value: ${XL(r)}`)
    }(t, e)
}

function u8e(t, e) {
    const r = {};
    return yCe(t) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : ZS(t, (n, i) => {
        const a = e2(i, e.ra(n));
        a != null && (r[n] = a)
    }), {mapValue: {fields: r}}
}

function f8e(t) {
    return !(typeof t != "object" || t === null || t instanceof Array || t instanceof Date || t instanceof Ca || t instanceof eB || t instanceof f1 || t instanceof Ro || t instanceof O1)
}

function Ate(t, e, r) {
    if (!f8e(r) || !function (n) {
        return typeof n == "object" && n !== null && (Object.getPrototypeOf(n) === Object.prototype || Object.getPrototypeOf(n) === null)
    }(r)) {
        const n = XL(r);
        throw n === "an object" ? e.ha(t + " a custom object") : e.ha(t + " " + n)
    }
}

function IY(t, e, r) {
    if ((e = Tr(e)) instanceof M1) return e._internalPath;
    if (typeof e == "string") return nB(t, e);
    throw wP("Field path arguments must be of type string or ", t, !1, void 0, r)
}

const ojt = new RegExp("[~\\*/\\[\\]]");

function nB(t, e, r) {
    if (e.search(ojt) >= 0) throw wP(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t, !1, void 0, r);
    try {
        return new M1(...e.split("."))._internalPath
    } catch {
        throw wP(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t, !1, void 0, r)
    }
}

function wP(t, e, r, n, i) {
    const a = n && !n.isEmpty(), o = i !== void 0;
    let s = `Function ${e}() called with invalid data`;
    r && (s += " (via `toFirestore()`)"), s += ". ";
    let l = "";
    return (a || o) && (l += " (found", a && (l += ` in field ${n}`), o && (l += ` in document ${i}`), l += ")"), new yt(at.INVALID_ARGUMENT, s + t + l)
}

function d8e(t, e) {
    return t.some(r => r.isEqual(e))
}

class r8 {
    constructor(e, r, n, i, a) {
        this._firestore = e, this._userDataWriter = r, this._key = n, this._document = i, this._converter = a
    }

    get id() {
        return this._key.path.lastSegment()
    }

    get ref() {
        return new Ro(this._firestore, this._converter, this._key)
    }

    exists() {
        return this._document !== null
    }

    data() {
        if (this._document) {
            if (this._converter) {
                const e = new sjt(this._firestore, this._userDataWriter, this._key, this._document, null);
                return this._converter.fromFirestore(e)
            }
            return this._userDataWriter.convertValue(this._document.data.value)
        }
    }

    get(e) {
        if (this._document) {
            const r = this._document.data.field(iB("DocumentSnapshot.get", e));
            if (r !== null) return this._userDataWriter.convertValue(r)
        }
    }
}

class sjt extends r8 {
    data() {
        return super.data()
    }
}

function iB(t, e) {
    return typeof e == "string" ? nB(t, e) : e instanceof M1 ? e._internalPath : e._delegate._internalPath
}

function h8e(t) {
    if (t.limitType === "L" && t.explicitOrderBy.length === 0) throw new yt(at.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause")
}

class Ite {
}

class y3 extends Ite {
}

function Qa(t, e, ...r) {
    let n = [];
    e instanceof Ite && n.push(e), n = n.concat(r), function (i) {
        const a = i.filter(s => s instanceof t2).length, o = i.filter(s => s instanceof b3).length;
        if (a > 1 || a > 0 && o > 0) throw new yt(at.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")
    }(n);
    for (const i of n) t = i._apply(t);
    return t
}

class b3 extends y3 {
    constructor(e, r, n) {
        super(), this._field = e, this._op = r, this._value = n, this.type = "where"
    }

    static _create(e, r, n) {
        return new b3(e, r, n)
    }

    _apply(e) {
        const r = this._parse(e);
        return m8e(e._query, r), new nc(e.firestore, e.converter, vY(e._query, r))
    }

    _parse(e) {
        const r = JS(e.firestore);
        return function (i, a, o, s, l, f, d) {
            let p;
            if (l.isKeyField()) {
                if (f === "array-contains" || f === "array-contains-any") throw new yt(at.INVALID_ARGUMENT, `Invalid Query. You can't perform '${f}' queries on documentId().`);
                if (f === "in" || f === "not-in") {
                    gme(d, f);
                    const g = [];
                    for (const b of d) g.push(vme(s, i, b));
                    p = {arrayValue: {values: g}}
                } else p = vme(s, i, d)
            } else f !== "in" && f !== "not-in" && f !== "array-contains-any" || gme(d, f), p = l8e(o, a, d, f === "in" || f === "not-in");
            return ci.create(l, f, p)
        }(e._query, "where", r, e.firestore._databaseId, this._field, this._op, this._value)
    }
}

function Li(t, e, r) {
    const n = e, i = iB("where", t);
    return b3._create(i, n, r)
}

class t2 extends Ite {
    constructor(e, r) {
        super(), this.type = e, this._queryConstraints = r
    }

    static _create(e, r) {
        return new t2(e, r)
    }

    _parse(e) {
        const r = this._queryConstraints.map(n => n._parse(e)).filter(n => n.getFilters().length > 0);
        return r.length === 1 ? r[0] : ra.create(r, this._getOperator())
    }

    _apply(e) {
        const r = this._parse(e);
        return r.getFilters().length === 0 ? e : (function (n, i) {
            let a = n;
            const o = i.getFlattenedFilters();
            for (const s of o) m8e(a, s), a = vY(a, s)
        }(e._query, r), new nc(e.firestore, e.converter, vY(e._query, r)))
    }

    _getQueryConstraints() {
        return this._queryConstraints
    }

    _getOperator() {
        return this.type === "and" ? "and" : "or"
    }
}

function cjt(...t) {
    return t.forEach(e => g8e("or", e)), t2._create("or", t)
}

function ljt(...t) {
    return t.forEach(e => g8e("and", e)), t2._create("and", t)
}

class aB extends y3 {
    constructor(e, r) {
        super(), this._field = e, this._direction = r, this.type = "orderBy"
    }

    static _create(e, r) {
        return new aB(e, r)
    }

    _apply(e) {
        const r = function (n, i, a) {
            if (n.startAt !== null) throw new yt(at.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
            if (n.endAt !== null) throw new yt(at.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
            const o = new g4(i, a);
            return function (s, l) {
                if (jee(s) === null) {
                    const f = zL(s);
                    f !== null && v8e(s, f, l.field)
                }
            }(n, o), o
        }(e._query, this._field, this._direction);
        return new nc(e.firestore, e.converter, function (n, i) {
            const a = n.explicitOrderBy.concat([i]);
            return new rg(n.path, n.collectionGroup, a, n.filters.slice(), n.limit, n.limitType, n.startAt, n.endAt)
        }(e._query, r))
    }
}

function Qw(t, e = "asc") {
    const r = e, n = iB("orderBy", t);
    return aB._create(n, r)
}

class VI extends y3 {
    constructor(e, r, n) {
        super(), this.type = e, this._limit = r, this._limitType = n
    }

    static _create(e, r, n) {
        return new VI(e, r, n)
    }

    _apply(e) {
        return new nc(e.firestore, e.converter, dP(e._query, this._limit, this._limitType))
    }
}

function w3(t) {
    return GAe("limit", t), VI._create("limit", t, "F")
}

function ujt(t) {
    return GAe("limitToLast", t), VI._create("limitToLast", t, "L")
}

class HI extends y3 {
    constructor(e, r, n) {
        super(), this.type = e, this._docOrFields = r, this._inclusive = n
    }

    static _create(e, r, n) {
        return new HI(e, r, n)
    }

    _apply(e) {
        const r = p8e(e, this.type, this._docOrFields, this._inclusive);
        return new nc(e.firestore, e.converter, function (n, i) {
            return new rg(n.path, n.collectionGroup, n.explicitOrderBy.slice(), n.filters.slice(), n.limit, n.limitType, i, n.endAt)
        }(e._query, r))
    }
}

function fjt(...t) {
    return HI._create("startAt", t, !0)
}

function djt(...t) {
    return HI._create("startAfter", t, !1)
}

class WI extends y3 {
    constructor(e, r, n) {
        super(), this.type = e, this._docOrFields = r, this._inclusive = n
    }

    static _create(e, r, n) {
        return new WI(e, r, n)
    }

    _apply(e) {
        const r = p8e(e, this.type, this._docOrFields, this._inclusive);
        return new nc(e.firestore, e.converter, function (n, i) {
            return new rg(n.path, n.collectionGroup, n.explicitOrderBy.slice(), n.filters.slice(), n.limit, n.limitType, n.startAt, i)
        }(e._query, r))
    }
}

function hjt(...t) {
    return WI._create("endBefore", t, !1)
}

function pjt(...t) {
    return WI._create("endAt", t, !0)
}

function p8e(t, e, r, n) {
    if (r[0] = Tr(r[0]), r[0] instanceof r8) return function (i, a, o, s, l) {
        if (!s) throw new yt(at.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${o}().`);
        const f = [];
        for (const d of Xw(i)) if (d.field.isKeyField()) f.push(_S(a, s.key)); else {
            const p = s.data.field(d.field);
            if (Fee(p)) throw new yt(at.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + d.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
            if (p === null) {
                const g = d.field.canonicalString();
                throw new yt(at.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${g}' (used as the orderBy) does not exist.`)
            }
            f.push(p)
        }
        return new l1(f, l)
    }(t._query, t.firestore._databaseId, e, r[0]._document, n);
    {
        const i = JS(t.firestore);
        return function (a, o, s, l, f, d) {
            const p = a.explicitOrderBy;
            if (f.length > p.length) throw new yt(at.INVALID_ARGUMENT, `Too many arguments provided to ${l}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
            const g = [];
            for (let b = 0; b < f.length; b++) {
                const S = f[b];
                if (p[b].field.isKeyField()) {
                    if (typeof S != "string") throw new yt(at.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${l}(), but got a ${typeof S}`);
                    if (!zee(a) && S.indexOf("/") !== -1) throw new yt(at.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${l}() must be a plain document ID, but '${S}' contains a slash.`);
                    const T = a.path.child(Ei.fromString(S));
                    if (!jt.isDocumentKey(T)) throw new yt(at.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${l}() must result in a valid document path, but '${T}' is not because it contains an odd number of segments.`);
                    const I = new jt(T);
                    g.push(_S(o, I))
                } else {
                    const T = l8e(s, l, S);
                    g.push(T)
                }
            }
            return new l1(g, d)
        }(t._query, t.firestore._databaseId, i, e, r, n)
    }
}

function vme(t, e, r) {
    if (typeof (r = Tr(r)) == "string") {
        if (r === "") throw new yt(at.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
        if (!zee(e) && r.indexOf("/") !== -1) throw new yt(at.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${r}' contains a '/' character.`);
        const n = e.path.child(Ei.fromString(r));
        if (!jt.isDocumentKey(n)) throw new yt(at.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${n}' is not because it has an odd number of segments (${n.length}).`);
        return _S(t, new jt(n))
    }
    if (r instanceof Ro) return _S(t, r._key);
    throw new yt(at.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${XL(r)}.`)
}

function gme(t, e) {
    if (!Array.isArray(t) || t.length === 0) throw new yt(at.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
    if (t.length > 10) throw new yt(at.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`)
}

function m8e(t, e) {
    if (e.isInequality()) {
        const n = zL(t), i = e.field;
        if (n !== null && !n.isEqual(i)) throw new yt(at.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n.toString()}' and '${i.toString()}'`);
        const a = jee(t);
        a !== null && v8e(t, i, a)
    }
    const r = function (n, i) {
        for (const a of n) for (const o of a.getFlattenedFilters()) if (i.indexOf(o.op) >= 0) return o.op;
        return null
    }(t.filters, function (n) {
        switch (n) {
            case"!=":
                return ["!=", "not-in"];
            case"array-contains":
                return ["array-contains", "array-contains-any", "not-in"];
            case"in":
                return ["array-contains-any", "in", "not-in"];
            case"array-contains-any":
                return ["array-contains", "array-contains-any", "in", "not-in"];
            case"not-in":
                return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
                return []
        }
    }(e.op));
    if (r !== null) throw r === e.op ? new yt(at.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new yt(at.INVALID_ARGUMENT, `Invalid query. You cannot use '${e.op.toString()}' filters with '${r.toString()}' filters.`)
}

function v8e(t, e, r) {
    if (!r.isEqual(e)) throw new yt(at.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${r.toString()}' instead.`)
}

function g8e(t, e) {
    if (!(e instanceof b3 || e instanceof t2)) throw new yt(at.INVALID_ARGUMENT, `Function ${t}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`)
}

class kte {
    convertValue(e, r = "none") {
        switch (SS(e)) {
            case 0:
                return null;
            case 1:
                return e.booleanValue;
            case 2:
                return Co(e.integerValue || e.doubleValue);
            case 3:
                return this.convertTimestamp(e.timestampValue);
            case 4:
                return this.convertServerTimestamp(e, r);
            case 5:
                return e.stringValue;
            case 6:
                return this.convertBytes(wS(e.bytesValue));
            case 7:
                return this.convertReference(e.referenceValue);
            case 8:
                return this.convertGeoPoint(e.geoPointValue);
            case 9:
                return this.convertArray(e.arrayValue, r);
            case 10:
                return this.convertObject(e.mapValue, r);
            default:
                throw lr()
        }
    }

    convertObject(e, r) {
        const n = {};
        return ZS(e.fields, (i, a) => {
            n[i] = this.convertValue(a, r)
        }), n
    }

    convertGeoPoint(e) {
        return new eB(Co(e.latitude), Co(e.longitude))
    }

    convertArray(e, r) {
        return (e.values || []).map(n => this.convertValue(n, r))
    }

    convertServerTimestamp(e, r) {
        switch (r) {
            case"previous":
                const n = wCe(e);
                return n == null ? null : this.convertValue(n, r);
            case"estimate":
                return this.convertTimestamp(YA(e));
            default:
                return null
        }
    }

    convertTimestamp(e) {
        const r = s1(e);
        return new Ca(r.seconds, r.nanos)
    }

    convertDocumentKey(e, r) {
        const n = Ei.fromString(e);
        Er(aAe(n));
        const i = new o1(n.get(1), n.get(3)), a = new jt(n.popFirst(5));
        return i.isEqual(r) || Vo(`Document ${a} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${r.projectId}/${r.database}) instead.`), a
    }
}

function oB(t, e, r) {
    let n;
    return n = t ? r && (r.merge || r.mergeFields) ? t.toFirestore(e, r) : t.toFirestore(e) : e, n
}

class mjt extends kte {
    constructor(e) {
        super(), this.firestore = e
    }

    convertBytes(e) {
        return new f1(e)
    }

    convertReference(e) {
        const r = this.convertDocumentKey(e, this.firestore._databaseId);
        return new Ro(this.firestore, null, r)
    }
}

class Oy {
    constructor(e, r) {
        this.hasPendingWrites = e, this.fromCache = r
    }

    isEqual(e) {
        return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache
    }
}

class kS extends r8 {
    constructor(e, r, n, i, a, o) {
        super(e, r, n, i, o), this._firestore = e, this._firestoreImpl = e, this.metadata = a
    }

    exists() {
        return super.exists()
    }

    data(e = {}) {
        if (this._document) {
            if (this._converter) {
                const r = new kC(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
                return this._converter.fromFirestore(r, e)
            }
            return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps)
        }
    }

    get(e, r = {}) {
        if (this._document) {
            const n = this._document.data.field(iB("DocumentSnapshot.get", e));
            if (n !== null) return this._userDataWriter.convertValue(n, r.serverTimestamps)
        }
    }
}

class kC extends kS {
    data(e = {}) {
        return super.data(e)
    }
}

class RS {
    constructor(e, r, n, i) {
        this._firestore = e, this._userDataWriter = r, this._snapshot = i, this.metadata = new Oy(i.hasPendingWrites, i.fromCache), this.query = n
    }

    get docs() {
        const e = [];
        return this.forEach(r => e.push(r)), e
    }

    get size() {
        return this._snapshot.docs.size
    }

    get empty() {
        return this.size === 0
    }

    forEach(e, r) {
        this._snapshot.docs.forEach(n => {
            e.call(r, new kC(this._firestore, this._userDataWriter, n.key, n, new Oy(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter))
        })
    }

    docChanges(e = {}) {
        const r = !!e.includeMetadataChanges;
        if (r && this._snapshot.excludesMetadataChanges) throw new yt(at.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === r || (this._cachedChanges = function (n, i) {
            if (n._snapshot.oldDocs.isEmpty()) {
                let a = 0;
                return n._snapshot.docChanges.map(o => ({
                    type: "added",
                    doc: new kC(n._firestore, n._userDataWriter, o.doc.key, o.doc, new Oy(n._snapshot.mutatedKeys.has(o.doc.key), n._snapshot.fromCache), n.query.converter),
                    oldIndex: -1,
                    newIndex: a++
                }))
            }
            {
                let a = n._snapshot.oldDocs;
                return n._snapshot.docChanges.filter(o => i || o.type !== 3).map(o => {
                    const s = new kC(n._firestore, n._userDataWriter, o.doc.key, o.doc, new Oy(n._snapshot.mutatedKeys.has(o.doc.key), n._snapshot.fromCache), n.query.converter);
                    let l = -1, f = -1;
                    return o.type !== 0 && (l = a.indexOf(o.doc.key), a = a.delete(o.doc.key)), o.type !== 1 && (a = a.add(o.doc), f = a.indexOf(o.doc.key)), {
                        type: vjt(o.type),
                        doc: s,
                        oldIndex: l,
                        newIndex: f
                    }
                })
            }
        }(this, r), this._cachedChangesIncludeMetadataChanges = r), this._cachedChanges
    }
}

function vjt(t) {
    switch (t) {
        case 0:
            return "added";
        case 2:
        case 3:
            return "modified";
        case 1:
            return "removed";
        default:
            return lr()
    }
}

function gjt(t, e) {
    return t instanceof kS && e instanceof kS ? t._firestore === e._firestore && t._key.isEqual(e._key) && (t._document === null ? e._document === null : t._document.isEqual(e._document)) && t._converter === e._converter : t instanceof RS && e instanceof RS && t._firestore === e._firestore && wte(t.query, e.query) && t.metadata.isEqual(e.metadata) && t._snapshot.isEqual(e._snapshot)
}

function TE(t) {
    t = li(t, Ro);
    const e = li(t.firestore, Ia);
    return e8e(Go(e), t._key).then(r => Rte(e, t, r))
}

class P1 extends kte {
    constructor(e) {
        super(), this.firestore = e
    }

    convertBytes(e) {
        return new f1(e)
    }

    convertReference(e) {
        const r = this.convertDocumentKey(e, this.firestore._databaseId);
        return new Ro(this.firestore, null, r)
    }
}

function yjt(t) {
    t = li(t, Ro);
    const e = li(t.firestore, Ia), r = Go(e), n = new P1(e);
    return NUt(r, t._key).then(i => new kS(e, n, t._key, i, new Oy(i !== null && i.hasLocalMutations, !0), t.converter))
}

function bjt(t) {
    t = li(t, Ro);
    const e = li(t.firestore, Ia);
    return e8e(Go(e), t._key, {source: "server"}).then(r => Rte(e, t, r))
}

function gu(t) {
    t = li(t, nc);
    const e = li(t.firestore, Ia), r = Go(e), n = new P1(e);
    return h8e(t._query), t8e(r, t._query).then(i => new RS(e, n, t, i))
}

function wjt(t) {
    t = li(t, nc);
    const e = li(t.firestore, Ia), r = Go(e), n = new P1(e);
    return LUt(r, t._query).then(i => new RS(e, n, t, i))
}

function Sjt(t) {
    t = li(t, nc);
    const e = li(t.firestore, Ia), r = Go(e), n = new P1(e);
    return t8e(r, t._query, {source: "server"}).then(i => new RS(e, n, t, i))
}

function kY(t, e, r) {
    t = li(t, Ro);
    const n = li(t.firestore, Ia), i = oB(t.converter, e, r);
    return S3(n, [rB(JS(n), "setDoc", t._key, i, t.converter !== null, r).toMutation(t._key, Ya.none())])
}

function zf(t, e, r, ...n) {
    t = li(t, Ro);
    const i = li(t.firestore, Ia), a = JS(i);
    let o;
    return o = typeof (e = Tr(e)) == "string" || e instanceof M1 ? Cte(a, "updateDoc", t._key, e, r, n) : Tte(a, "updateDoc", t._key, e), S3(i, [o.toMutation(t._key, Ya.exists(!0))])
}

function ic(t) {
    return S3(li(t.firestore, Ia), [new h3(t._key, Ya.none())])
}

function im(t, e) {
    const r = li(t.firestore, Ia), n = ua(t), i = oB(t.converter, e);
    return S3(r, [rB(JS(t.firestore), "addDoc", n._key, i, t.converter !== null, {}).toMutation(n._key, Ya.exists(!1))]).then(() => n)
}

function Ip(t, ...e) {
    var r, n, i;
    t = Tr(t);
    let a = {includeMetadataChanges: !1}, o = 0;
    typeof e[o] != "object" || AY(e[o]) || (a = e[o], o++);
    const s = {includeMetadataChanges: a.includeMetadataChanges};
    if (AY(e[o])) {
        const p = e[o];
        e[o] = (r = p.next) === null || r === void 0 ? void 0 : r.bind(p), e[o + 1] = (n = p.error) === null || n === void 0 ? void 0 : n.bind(p), e[o + 2] = (i = p.complete) === null || i === void 0 ? void 0 : i.bind(p)
    }
    let l, f, d;
    if (t instanceof Ro) f = li(t.firestore, Ia), d = f3(t._key.path), l = {
        next: p => {
            e[o] && e[o](Rte(f, t, p))
        }, error: e[o + 1], complete: e[o + 2]
    }; else {
        const p = li(t, nc);
        f = li(p.firestore, Ia), d = p._query;
        const g = new P1(f);
        l = {
            next: b => {
                e[o] && e[o](new RS(f, g, p, b))
            }, error: e[o + 1], complete: e[o + 2]
        }, h8e(t._query)
    }
    return function (p, g, b, S) {
        const T = new QL(S), I = new fte(g, T, b);
        return p.asyncQueue.enqueueAndForget(async () => cte(await EE(p), I)), () => {
            T.bc(), p.asyncQueue.enqueueAndForget(async () => lte(await EE(p), I))
        }
    }(Go(f), d, s, l)
}

function _jt(t, e) {
    return BUt(Go(t = li(t, Ia)), AY(e) ? e : {next: e})
}

function S3(t, e) {
    return function (r, n) {
        const i = new Ls;
        return r.asyncQueue.enqueueAndForget(async () => cUt(await xte(r), n, i)), i.promise
    }(Go(t), e)
}

function Rte(t, e, r) {
    const n = r.docs.get(e._key), i = new P1(t);
    return new kS(t, i, e._key, n, new Oy(r.hasPendingWrites, r.fromCache), e.converter)
}

function xjt(t, e) {
    return wte(t.query, e.query) && fE(t.data(), e.data())
}

function Ejt(t) {
    const e = li(t.firestore, Ia);
    return function (r, n, i) {
        const a = new Ls;
        return r.asyncQueue.enqueueAndForget(async () => {
            try {
                if (ig(await _te(r))) {
                    const o = await JAe(r), s = new kUt(n, o, i).run();
                    a.resolve(s)
                } else a.reject(new yt(at.UNAVAILABLE, "Failed to get count result because the client is offline."))
            } catch (o) {
                a.reject(o)
            }
        }), a.promise
    }(Go(e), t, new P1(e))
}

const Tjt = {maxAttempts: 5};

class y8e {
    constructor(e, r) {
        this._firestore = e, this._commitHandler = r, this._mutations = [], this._committed = !1, this._dataReader = JS(e)
    }

    set(e, r, n) {
        this._verifyNotCommitted();
        const i = Ey(e, this._firestore), a = oB(i.converter, r, n),
            o = rB(this._dataReader, "WriteBatch.set", i._key, a, i.converter !== null, n);
        return this._mutations.push(o.toMutation(i._key, Ya.none())), this
    }

    update(e, r, n, ...i) {
        this._verifyNotCommitted();
        const a = Ey(e, this._firestore);
        let o;
        return o = typeof (r = Tr(r)) == "string" || r instanceof M1 ? Cte(this._dataReader, "WriteBatch.update", a._key, r, n, i) : Tte(this._dataReader, "WriteBatch.update", a._key, r), this._mutations.push(o.toMutation(a._key, Ya.exists(!0))), this
    }

    delete(e) {
        this._verifyNotCommitted();
        const r = Ey(e, this._firestore);
        return this._mutations = this._mutations.concat(new h3(r._key, Ya.none())), this
    }

    commit() {
        return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve()
    }

    _verifyNotCommitted() {
        if (this._committed) throw new yt(at.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.")
    }
}

function Ey(t, e) {
    if ((t = Tr(t)).firestore !== e) throw new yt(at.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
    return t
}

class b8e extends class {
    constructor(e, r) {
        this._firestore = e, this._transaction = r, this._dataReader = JS(e)
    }

    get(e) {
        const r = Ey(e, this._firestore), n = new mjt(this._firestore);
        return this._transaction.lookup([r._key]).then(i => {
            if (!i || i.length !== 1) return lr();
            const a = i[0];
            if (a.isFoundDocument()) return new r8(this._firestore, n, a.key, a, r.converter);
            if (a.isNoDocument()) return new r8(this._firestore, n, r._key, null, r.converter);
            throw lr()
        })
    }

    set(e, r, n) {
        const i = Ey(e, this._firestore), a = oB(i.converter, r, n),
            o = rB(this._dataReader, "Transaction.set", i._key, a, i.converter !== null, n);
        return this._transaction.set(i._key, o), this
    }

    update(e, r, n, ...i) {
        const a = Ey(e, this._firestore);
        let o;
        return o = typeof (r = Tr(r)) == "string" || r instanceof M1 ? Cte(this._dataReader, "Transaction.update", a._key, r, n, i) : Tte(this._dataReader, "Transaction.update", a._key, r), this._transaction.update(a._key, o), this
    }

    delete(e) {
        const r = Ey(e, this._firestore);
        return this._transaction.delete(r._key), this
    }
} {
    constructor(e, r) {
        super(e, r), this._firestore = e
    }

    get(e) {
        const r = Ey(e, this._firestore), n = new P1(this._firestore);
        return super.get(e).then(i => new kS(this._firestore, n, r._key, i._document, new Oy(!1, !1), r.converter))
    }
}

function Cjt(t, e, r) {
    t = li(t, Ia);
    const n = Object.assign(Object.assign({}, Tjt), r);
    return function (i) {
        if (i.maxAttempts < 1) throw new yt(at.INVALID_ARGUMENT, "Max attempts must be at least 1")
    }(n), function (i, a, o) {
        const s = new Ls;
        return i.asyncQueue.enqueueAndForget(async () => {
            const l = await JAe(i);
            new DUt(i.asyncQueue, l, o, a, s).run()
        }), s.promise
    }(Go(t), i => e(new b8e(t, i)), n)
}

function Ajt() {
    return new zI("deleteField")
}

function Ti() {
    return new Ete("serverTimestamp")
}

function Dte(...t) {
    return new njt("arrayUnion", t)
}

function Mte(...t) {
    return new ijt("arrayRemove", t)
}

function Ijt(t) {
    return new ajt("increment", t)
}

function kjt(t) {
    return Go(t = li(t, Ia)), new y8e(t, e => S3(t, e))
}

function Rjt(t, e) {
    var r;
    const n = Go(t = li(t, Ia));
    if (!(!((r = n.offlineComponents) === null || r === void 0) && r.indexBackfillerScheduler)) return bS("Cannot enable indexes when persistence is disabled"), Promise.resolve();
    const i = function (a) {
        const o = typeof a == "string" ? function (l) {
            try {
                return JSON.parse(l)
            } catch (f) {
                throw new yt(at.INVALID_ARGUMENT, "Failed to parse JSON: " + (f == null ? void 0 : f.message))
            }
        }(a) : a, s = [];
        if (Array.isArray(o.indexes)) for (const l of o.indexes) {
            const f = yme(l, "collectionGroup"), d = [];
            if (Array.isArray(l.fields)) for (const p of l.fields) {
                const g = nB("setIndexConfiguration", yme(p, "fieldPath"));
                p.arrayConfig === "CONTAINS" ? d.push(new sM(g, 2)) : p.order === "ASCENDING" ? d.push(new sM(g, 0)) : p.order === "DESCENDING" && d.push(new sM(g, 1))
            }
            s.push(new lP(lP.UNKNOWN_ID, f, d, GA.empty()))
        }
        return s
    }(e);
    return JL(n).then(a => async function (o, s) {
        const l = Ht(o), f = l.indexManager, d = [];
        return l.persistence.runTransaction("Configure indexes", "readwrite", p => f.getFieldIndexes(p).next(g => function (b, S, T, I, N) {
            b = [...b], S = [...S], b.sort(T), S.sort(T);
            const P = b.length, F = S.length;
            let V = 0, Y = 0;
            for (; V < F && Y < P;) {
                const ee = T(b[Y], S[V]);
                ee < 0 ? N(b[Y++]) : ee > 0 ? I(S[V++]) : (V++, Y++)
            }
            for (; V < F;) I(S[V++]);
            for (; Y < P;) N(b[Y++])
        }(g, s, WBt, b => {
            d.push(f.addFieldIndex(p, b))
        }, b => {
            d.push(f.deleteFieldIndex(p, b))
        })).next(() => Je.waitFor(d)))
    }(a, i))
}

function yme(t, e) {
    if (typeof t[e] != "string") throw new yt(at.INVALID_ARGUMENT, "Missing string value for: " + e);
    return t[e]
}

(function (t, e = !0) {
    (function (r) {
        u3 = r
    })(_I), dE(new vS("firestore", (r, {instanceIdentifier: n, options: i}) => {
        const a = r.getProvider("app").getImmediate(),
            o = new Ia(new $Bt(r.getProvider("auth-internal")), new jBt(r.getProvider("app-check-internal")), function (s, l) {
                if (!Object.prototype.hasOwnProperty.apply(s.options, ["projectId"])) throw new yt(at.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
                return new o1(s.options.projectId, l)
            }(a, n), a);
        return i = Object.assign({useFetchStreams: e}, i), o._setSettings(i), o
    }, "PUBLIC").setMultipleInstances(!0)), Kw(v0e, "3.8.3", t), Kw(v0e, "3.8.3", "esm2017")
})();
const Djt = Object.freeze(Object.defineProperty({
        __proto__: null,
        AbstractUserDataWriter: kte,
        AggregateField: IUt,
        AggregateQuerySnapshot: YAe,
        Bytes: f1,
        CACHE_SIZE_UNLIMITED: jUt,
        CollectionReference: up,
        DocumentReference: Ro,
        DocumentSnapshot: kS,
        FieldPath: M1,
        FieldValue: O1,
        Firestore: Ia,
        FirestoreError: yt,
        GeoPoint: eB,
        LoadBundleTask: r8e,
        Query: nc,
        QueryCompositeFilterConstraint: t2,
        QueryConstraint: y3,
        QueryDocumentSnapshot: kC,
        QueryEndAtConstraint: WI,
        QueryFieldFilterConstraint: b3,
        QueryLimitConstraint: VI,
        QueryOrderByConstraint: aB,
        QuerySnapshot: RS,
        QueryStartAtConstraint: HI,
        SnapshotMetadata: Oy,
        Timestamp: Ca,
        Transaction: b8e,
        WriteBatch: y8e,
        _DatabaseId: o1,
        _DocumentKey: jt,
        _EmptyAppCheckTokenProvider: zBt,
        _EmptyAuthCredentialsProvider: uCe,
        _FieldPath: Io,
        _cast: li,
        _debugAssert: LBt,
        _isBase64Available: ZBt,
        _logWarn: bS,
        _validateIsNotUsedTogether: qAe,
        addDoc: im,
        aggregateQuerySnapshotEqual: xjt,
        and: ljt,
        arrayRemove: Mte,
        arrayUnion: Dte,
        clearIndexedDbPersistence: qUt,
        collection: id,
        collectionGroup: TUt,
        connectFirestoreEmulator: KAe,
        deleteDoc: ic,
        deleteField: Ajt,
        disableNetwork: YUt,
        doc: ua,
        documentId: JUt,
        enableIndexedDbPersistence: HUt,
        enableMultiTabIndexedDbPersistence: WUt,
        enableNetwork: KUt,
        endAt: pjt,
        endBefore: hjt,
        ensureFirestoreConfigured: Go,
        executeWrite: S3,
        getCountFromServer: Ejt,
        getDoc: TE,
        getDocFromCache: yjt,
        getDocFromServer: bjt,
        getDocs: gu,
        getDocsFromCache: wjt,
        getDocsFromServer: Sjt,
        getFirestore: VUt,
        increment: Ijt,
        initializeFirestore: zUt,
        limit: w3,
        limitToLast: ujt,
        loadBundle: QUt,
        namedQuery: ZUt,
        onSnapshot: Ip,
        onSnapshotsInSync: _jt,
        or: cjt,
        orderBy: Qw,
        query: Qa,
        queryEqual: wte,
        refEqual: CUt,
        runTransaction: Cjt,
        serverTimestamp: Ti,
        setDoc: kY,
        setIndexConfiguration: Rjt,
        setLogLevel: NBt,
        snapshotEqual: gjt,
        startAfter: djt,
        startAt: fjt,
        terminate: XUt,
        updateDoc: zf,
        waitForPendingWrites: GUt,
        where: Li,
        writeBatch: kjt
    }, Symbol.toStringTag, {value: "Module"})),
    Mjt = ["priceUsdCross", "priceUsdInvertedCross", "watchlistPriceUsdPercentage"], Ojt = pt(Ra, sr, (t, e) => {
        const r = id(t, nOt);
        return {
            findByUserIdSnapshot(n) {
                const i = Qa(r, Li("userId", "==", n.userId));
                return Ip(i, a => {
                    const o = [];
                    for (const s of a.docs) {
                        const l = s.data({serverTimestamps: "estimate"}), f = dMt.safeParse({...l, id: s.id});
                        if (f.success) {
                            const d = f.data.trigger.type;
                            Mjt.includes(d) || o.push(f.data)
                        } else e.error({
                            event: {
                                id: "failedOnParsingAlertEntity",
                                data: {id: s.id, userId: n.userId, error: f.error}
                            }
                        })
                    }
                    n.onResult(o)
                }, a => {
                    a.code !== "permission-denied" && (e.error({
                        event: {
                            id: "failedOnQueryingAlerts",
                            data: {userId: n.userId, error: a}
                        }
                    }), n.onError(a))
                })
            }, async create(n, i) {
                await im(r, {
                    schemaVersion: i.schemaVersion,
                    userId: n,
                    partitionId: IOt(),
                    trigger: i.trigger,
                    channels: i.channels,
                    enabled: i.enabled,
                    createdAt: Ti(),
                    updatedAt: Ti(),
                    triggeredAt: null,
                    note: i.note
                }).catch(a => {
                    e.error({event: {id: "failedOnCreatingAnAlert", data: {userId: n, error: a, input: i}}})
                })
            }, async update(n, i) {
                await zf(ua(r, n), {...i, updatedAt: Ti()}).catch(a => {
                    e.error({event: {id: "failedOnUpdatingAnAlert", data: {id: n, error: a, input: i}}})
                })
            }, async delete(n) {
                await ic(ua(r, n)).catch(i => {
                    e.error({event: {id: "failedOnDeletingAnAlert", data: {id: n, error: i}}})
                })
            }, async deleteAllByUserId(n) {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingAlerts", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingAlert", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    }), Pjt = pt(Ra, sr, (t, e) => {
        const r = id(t, iOt);
        return {
            create: async (n, i) => {
                await im(r, {
                    schemaVersion: i.schemaVersion,
                    userId: n,
                    provider: i.provider,
                    token: i.token,
                    createdAt: Ti(),
                    updatedAt: Ti()
                }).catch(a => {
                    e.error({event: {id: "failedOnCreatingAuthProvider", data: {userId: n, error: a, input: i}}})
                })
            }, findByUserId: n => new ia(i => {
                const a = Qa(r, Li("userId", "==", n));
                return Ip(a, {
                    next: s => {
                        const l = [];
                        s.forEach(f => {
                            const d = f.data({serverTimestamps: "estimate"}), p = WMt.safeParse({...d, id: f.id});
                            if (!p.success) {
                                e.error({
                                    event: {
                                        id: "failedOnParsingAuthProviderEntityOnfindByUserId",
                                        data: {id: f.id, error: p.error}
                                    }
                                });
                                return
                            }
                            l.push(p.data)
                        }), i.next(l)
                    }, error: s => {
                        e.error({
                            event: {
                                id: "failedOnFindingAuthProvidersByUserId",
                                data: {userId: n, error: s}
                            }
                        }), i.error(s)
                    }, complete: () => i.complete()
                })
            }), delete: async n => {
                await ic(ua(r, n)).catch(i => {
                    e.error({event: {id: "failedOnDeletingAuthProvider", data: {id: n, error: i}}})
                })
            }, deleteAllByUserId: async n => {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingAuthProviders", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingAuthProviders", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    });
const Njt = {PHONE: "phone"}, Ljt = {
    FACEBOOK: "facebook.com",
    GITHUB: "github.com",
    GOOGLE: "google.com",
    PASSWORD: "password",
    PHONE: "phone",
    TWITTER: "twitter.com"
}, Bjt = {
    EMAIL_LINK: "emailLink",
    EMAIL_PASSWORD: "password",
    FACEBOOK: "facebook.com",
    GITHUB: "github.com",
    GOOGLE: "google.com",
    PHONE: "phone",
    TWITTER: "twitter.com"
}, $jt = {LINK: "link", REAUTHENTICATE: "reauthenticate", SIGN_IN: "signIn"}, Fjt = {
    EMAIL_SIGNIN: "EMAIL_SIGNIN",
    PASSWORD_RESET: "PASSWORD_RESET",
    RECOVER_EMAIL: "RECOVER_EMAIL",
    REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION",
    VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL",
    VERIFY_EMAIL: "VERIFY_EMAIL"
};

function Ujt() {
    return {
        "admin-restricted-operation": "This operation is restricted to administrators only.",
        "argument-error": "",
        "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
        "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
        "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
        "code-expired": "The SMS code has expired. Please re-send the verification code to try again.",
        "cordova-not-ready": "Cordova framework is not ready.",
        "cors-unsupported": "This browser is not supported.",
        "credential-already-in-use": "This credential is already associated with a different user account.",
        "custom-token-mismatch": "The custom token corresponds to a different audience.",
        "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.",
        "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
        "email-change-needs-verification": "Multi-factor users must always have a verified email.",
        "email-already-in-use": "The email address is already in use by another account.",
        "emulator-config-failed": 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.',
        "expired-action-code": "The action code has expired.",
        "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
        "internal-error": "An internal AuthError has occurred.",
        "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
        "invalid-app-id": "The mobile app identifier is not registed for the current project.",
        "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
        "invalid-auth-event": "An internal AuthError has occurred.",
        "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.",
        "invalid-continue-uri": "The continue URL provided in the request is invalid.",
        "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
        "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.",
        "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.",
        "invalid-email": "The email address is badly formatted.",
        "invalid-emulator-scheme": "Emulator URL must start with a valid scheme (http:// or https://).",
        "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.",
        "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.",
        "invalid-credential": "The supplied auth credential is malformed or has expired.",
        "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
        "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.",
        "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
        "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.",
        "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
        "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
        "wrong-password": "The password is invalid or the user does not have a password.",
        "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.",
        "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
        "invalid-provider-id": "The specified provider ID is invalid.",
        "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
        "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
        "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.",
        "invalid-tenant-id": "The Auth instance's tenant ID is invalid.",
        "login-blocked": "Login blocked by user-provided method: {$originalMessage}",
        "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
        "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
        "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
        "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.",
        "missing-continue-uri": "A continue URL must be provided in the request.",
        "missing-iframe-start": "An internal AuthError has occurred.",
        "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.",
        "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
        "missing-multi-factor-info": "No second factor identifier is provided.",
        "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.",
        "missing-phone-number": "To send verification codes, provide a phone number for the recipient.",
        "missing-verification-id": "The phone auth credential was created with an empty verification ID.",
        "app-deleted": "This instance of FirebaseApp has been deleted.",
        "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.",
        "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.",
        "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
        "network-request-failed": "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.",
        "no-auth-event": "An internal AuthError has occurred.",
        "no-such-provider": "User was not linked to an account with the given provider.",
        "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.",
        "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
        "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
        "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.",
        "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.",
        "provider-already-linked": "User can only be linked to one identity for the given provider.",
        "quota-exceeded": "The project's quota for this operation has been exceeded.",
        "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.",
        "redirect-operation-pending": "A redirect sign-in operation is already pending.",
        "rejected-credential": "The request contains malformed or mismatching credentials.",
        "second-factor-already-in-use": "The second factor is already enrolled on this account.",
        "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.",
        "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID",
        timeout: "The operation has timed out.",
        "user-token-expired": "The user's credential is no longer valid. The user must sign in again.",
        "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
        "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
        "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
        "unsupported-persistence-type": "The current environment does not support the specified persistence type.",
        "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.",
        "unverified-email": "The operation requires a verified email.",
        "user-cancelled": "The user did not grant your application the permissions it requested.",
        "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.",
        "user-disabled": "The user account has been disabled by an administrator.",
        "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.",
        "user-signed-out": "",
        "weak-password": "The password must be 6 characters long or more.",
        "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled.",
        "already-initialized": "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance."
    }
}

function w8e() {
    return {"dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}
}

const jjt = Ujt, S8e = w8e, _8e = new wI("auth", "Firebase", w8e()), zjt = {
    ADMIN_ONLY_OPERATION: "auth/admin-restricted-operation",
    ARGUMENT_ERROR: "auth/argument-error",
    APP_NOT_AUTHORIZED: "auth/app-not-authorized",
    APP_NOT_INSTALLED: "auth/app-not-installed",
    CAPTCHA_CHECK_FAILED: "auth/captcha-check-failed",
    CODE_EXPIRED: "auth/code-expired",
    CORDOVA_NOT_READY: "auth/cordova-not-ready",
    CORS_UNSUPPORTED: "auth/cors-unsupported",
    CREDENTIAL_ALREADY_IN_USE: "auth/credential-already-in-use",
    CREDENTIAL_MISMATCH: "auth/custom-token-mismatch",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "auth/requires-recent-login",
    DEPENDENT_SDK_INIT_BEFORE_AUTH: "auth/dependent-sdk-initialized-before-auth",
    DYNAMIC_LINK_NOT_ACTIVATED: "auth/dynamic-link-not-activated",
    EMAIL_CHANGE_NEEDS_VERIFICATION: "auth/email-change-needs-verification",
    EMAIL_EXISTS: "auth/email-already-in-use",
    EMULATOR_CONFIG_FAILED: "auth/emulator-config-failed",
    EXPIRED_OOB_CODE: "auth/expired-action-code",
    EXPIRED_POPUP_REQUEST: "auth/cancelled-popup-request",
    INTERNAL_ERROR: "auth/internal-error",
    INVALID_API_KEY: "auth/invalid-api-key",
    INVALID_APP_CREDENTIAL: "auth/invalid-app-credential",
    INVALID_APP_ID: "auth/invalid-app-id",
    INVALID_AUTH: "auth/invalid-user-token",
    INVALID_AUTH_EVENT: "auth/invalid-auth-event",
    INVALID_CERT_HASH: "auth/invalid-cert-hash",
    INVALID_CODE: "auth/invalid-verification-code",
    INVALID_CONTINUE_URI: "auth/invalid-continue-uri",
    INVALID_CORDOVA_CONFIGURATION: "auth/invalid-cordova-configuration",
    INVALID_CUSTOM_TOKEN: "auth/invalid-custom-token",
    INVALID_DYNAMIC_LINK_DOMAIN: "auth/invalid-dynamic-link-domain",
    INVALID_EMAIL: "auth/invalid-email",
    INVALID_EMULATOR_SCHEME: "auth/invalid-emulator-scheme",
    INVALID_IDP_RESPONSE: "auth/invalid-credential",
    INVALID_MESSAGE_PAYLOAD: "auth/invalid-message-payload",
    INVALID_MFA_SESSION: "auth/invalid-multi-factor-session",
    INVALID_OAUTH_CLIENT_ID: "auth/invalid-oauth-client-id",
    INVALID_OAUTH_PROVIDER: "auth/invalid-oauth-provider",
    INVALID_OOB_CODE: "auth/invalid-action-code",
    INVALID_ORIGIN: "auth/unauthorized-domain",
    INVALID_PASSWORD: "auth/wrong-password",
    INVALID_PERSISTENCE: "auth/invalid-persistence-type",
    INVALID_PHONE_NUMBER: "auth/invalid-phone-number",
    INVALID_PROVIDER_ID: "auth/invalid-provider-id",
    INVALID_RECIPIENT_EMAIL: "auth/invalid-recipient-email",
    INVALID_SENDER: "auth/invalid-sender",
    INVALID_SESSION_INFO: "auth/invalid-verification-id",
    INVALID_TENANT_ID: "auth/invalid-tenant-id",
    MFA_INFO_NOT_FOUND: "auth/multi-factor-info-not-found",
    MFA_REQUIRED: "auth/multi-factor-auth-required",
    MISSING_ANDROID_PACKAGE_NAME: "auth/missing-android-pkg-name",
    MISSING_APP_CREDENTIAL: "auth/missing-app-credential",
    MISSING_AUTH_DOMAIN: "auth/auth-domain-config-required",
    MISSING_CODE: "auth/missing-verification-code",
    MISSING_CONTINUE_URI: "auth/missing-continue-uri",
    MISSING_IFRAME_START: "auth/missing-iframe-start",
    MISSING_IOS_BUNDLE_ID: "auth/missing-ios-bundle-id",
    MISSING_OR_INVALID_NONCE: "auth/missing-or-invalid-nonce",
    MISSING_MFA_INFO: "auth/missing-multi-factor-info",
    MISSING_MFA_SESSION: "auth/missing-multi-factor-session",
    MISSING_PHONE_NUMBER: "auth/missing-phone-number",
    MISSING_SESSION_INFO: "auth/missing-verification-id",
    MODULE_DESTROYED: "auth/app-deleted",
    NEED_CONFIRMATION: "auth/account-exists-with-different-credential",
    NETWORK_REQUEST_FAILED: "auth/network-request-failed",
    NULL_USER: "auth/null-user",
    NO_AUTH_EVENT: "auth/no-auth-event",
    NO_SUCH_PROVIDER: "auth/no-such-provider",
    OPERATION_NOT_ALLOWED: "auth/operation-not-allowed",
    OPERATION_NOT_SUPPORTED: "auth/operation-not-supported-in-this-environment",
    POPUP_BLOCKED: "auth/popup-blocked",
    POPUP_CLOSED_BY_USER: "auth/popup-closed-by-user",
    PROVIDER_ALREADY_LINKED: "auth/provider-already-linked",
    QUOTA_EXCEEDED: "auth/quota-exceeded",
    REDIRECT_CANCELLED_BY_USER: "auth/redirect-cancelled-by-user",
    REDIRECT_OPERATION_PENDING: "auth/redirect-operation-pending",
    REJECTED_CREDENTIAL: "auth/rejected-credential",
    SECOND_FACTOR_ALREADY_ENROLLED: "auth/second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "auth/maximum-second-factor-count-exceeded",
    TENANT_ID_MISMATCH: "auth/tenant-id-mismatch",
    TIMEOUT: "auth/timeout",
    TOKEN_EXPIRED: "auth/user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "auth/too-many-requests",
    UNAUTHORIZED_DOMAIN: "auth/unauthorized-continue-uri",
    UNSUPPORTED_FIRST_FACTOR: "auth/unsupported-first-factor",
    UNSUPPORTED_PERSISTENCE: "auth/unsupported-persistence-type",
    UNSUPPORTED_TENANT_OPERATION: "auth/unsupported-tenant-operation",
    UNVERIFIED_EMAIL: "auth/unverified-email",
    USER_CANCELLED: "auth/user-cancelled",
    USER_DELETED: "auth/user-not-found",
    USER_DISABLED: "auth/user-disabled",
    USER_MISMATCH: "auth/user-mismatch",
    USER_SIGNED_OUT: "auth/user-signed-out",
    WEAK_PASSWORD: "auth/weak-password",
    WEB_STORAGE_UNSUPPORTED: "auth/web-storage-unsupported",
    ALREADY_INITIALIZED: "auth/already-initialized"
};
const bme = new dee("@firebase/auth");

function pM(t, ...e) {
    bme.logLevel <= Ri.ERROR && bme.error(`Auth (${_I}): ${t}`, ...e)
}

function ff(t, ...e) {
    throw Ote(t, ...e)
}

function Vf(t, ...e) {
    return Ote(t, ...e)
}

function x8e(t, e, r) {
    const n = Object.assign(Object.assign({}, S8e()), {[e]: r});
    return new wI("auth", "Firebase", n).create(e, {appName: t.name})
}

function _3(t, e, r) {
    const n = r;
    if (!(e instanceof n)) throw n.name !== e.constructor.name && ff(t, "argument-error"), x8e(t, "argument-error", `Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`)
}

function Ote(t, ...e) {
    if (typeof t != "string") {
        const r = e[0], n = [...e.slice(1)];
        return n[0] && (n[0].appName = t.name), t._errorFactory.create(r, ...n)
    }
    return _8e.create(t, ...e)
}

function Lt(t, e, ...r) {
    if (!t) throw Ote(e, ...r)
}

function I0(t) {
    const e = "INTERNAL ASSERTION FAILED: " + t;
    throw pM(e), new Error(e)
}

function Hv(t, e) {
    t || I0(e)
}

const wme = new Map;

function vv(t) {
    Hv(t instanceof Function, "Expected a class definition");
    let e = wme.get(t);
    return e ? (Hv(e instanceof t, "Instance stored in cache mismatched with class"), e) : (e = new t, wme.set(t, e), e)
}

function E8e(t, e) {
    const r = SI(t, "auth");
    if (r.isInitialized()) {
        const i = r.getImmediate(), a = r.getOptions();
        if (fE(a, e ?? {})) return i;
        ff(i, "already-initialized")
    }
    return r.initialize({options: e})
}

function Vjt(t, e) {
    const r = (e == null ? void 0 : e.persistence) || [], n = (Array.isArray(r) ? r : [r]).map(vv);
    e != null && e.errorMap && t._updateErrorMap(e.errorMap), t._initializeWithPersistence(n, e == null ? void 0 : e.popupRedirectResolver)
}

function n8() {
    var t;
    return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href) || ""
}

function Pte() {
    return Sme() === "http:" || Sme() === "https:"
}

function Sme() {
    var t;
    return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol) || null
}

function Hjt() {
    return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && (Pte() || cNt() || "connection" in navigator) ? navigator.onLine : !0
}

function Wjt() {
    if (typeof navigator > "u") return null;
    const t = navigator;
    return t.languages && t.languages[0] || t.language || null
}

class qI {
    constructor(e, r) {
        this.shortDelay = e, this.longDelay = r, Hv(r > e, "Short delay should be less than long delay!"), this.isMobile = oNt() || lNt()
    }

    get() {
        return Hjt() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay)
    }
}

function Nte(t, e) {
    Hv(t.emulator, "Emulator should always be set here");
    const {url: r} = t.emulator;
    return e ? `${r}${e.startsWith("/") ? e.slice(1) : e}` : r
}

class T8e {
    static initialize(e, r, n) {
        this.fetchImpl = e, r && (this.headersImpl = r), n && (this.responseImpl = n)
    }

    static fetch() {
        if (this.fetchImpl) return this.fetchImpl;
        if (typeof self < "u" && "fetch" in self) return self.fetch;
        I0("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }

    static headers() {
        if (this.headersImpl) return this.headersImpl;
        if (typeof self < "u" && "Headers" in self) return self.Headers;
        I0("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }

    static response() {
        if (this.responseImpl) return this.responseImpl;
        if (typeof self < "u" && "Response" in self) return self.Response;
        I0("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
}

const qjt = {
    CREDENTIAL_MISMATCH: "custom-token-mismatch",
    MISSING_CUSTOM_TOKEN: "internal-error",
    INVALID_IDENTIFIER: "invalid-email",
    MISSING_CONTINUE_URI: "internal-error",
    INVALID_PASSWORD: "wrong-password",
    MISSING_PASSWORD: "internal-error",
    EMAIL_EXISTS: "email-already-in-use",
    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
    INVALID_IDP_RESPONSE: "invalid-credential",
    INVALID_PENDING_TOKEN: "invalid-credential",
    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
    MISSING_REQ_TYPE: "internal-error",
    EMAIL_NOT_FOUND: "user-not-found",
    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
    EXPIRED_OOB_CODE: "expired-action-code",
    INVALID_OOB_CODE: "invalid-action-code",
    MISSING_OOB_CODE: "internal-error",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
    INVALID_ID_TOKEN: "invalid-user-token",
    TOKEN_EXPIRED: "user-token-expired",
    USER_NOT_FOUND: "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
    INVALID_CODE: "invalid-verification-code",
    INVALID_SESSION_INFO: "invalid-verification-id",
    INVALID_TEMPORARY_PROOF: "invalid-credential",
    MISSING_SESSION_INFO: "missing-verification-id",
    SESSION_EXPIRED: "code-expired",
    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error"
};
const Gjt = new qI(3e4, 6e4);

function zs(t, e) {
    return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), {tenantId: t.tenantId}) : e
}

async function uc(t, e, r, n, i = {}) {
    return C8e(t, i, async () => {
        let a = {}, o = {};
        n && (e === "GET" ? o = n : a = {body: JSON.stringify(n)});
        const s = s3(Object.assign({key: t.config.apiKey}, o)).slice(1), l = await t._getAdditionalHeaders();
        return l["Content-Type"] = "application/json", t.languageCode && (l["X-Firebase-Locale"] = t.languageCode), T8e.fetch()(A8e(t, t.config.apiHost, r, s), Object.assign({
            method: e,
            headers: l,
            referrerPolicy: "no-referrer"
        }, a))
    })
}

async function C8e(t, e, r) {
    t._canInitEmulator = !1;
    const n = Object.assign(Object.assign({}, qjt), e);
    try {
        const i = new Kjt(t), a = await Promise.race([r(), i.promise]);
        i.clearNetworkTimeout();
        const o = await a.json();
        if ("needConfirmation" in o) throw qT(t, "account-exists-with-different-credential", o);
        if (a.ok && !("errorMessage" in o)) return o;
        {
            const s = a.ok ? o.errorMessage : o.error.message, [l, f] = s.split(" : ");
            if (l === "FEDERATED_USER_ID_ALREADY_LINKED") throw qT(t, "credential-already-in-use", o);
            if (l === "EMAIL_EXISTS") throw qT(t, "email-already-in-use", o);
            if (l === "USER_DISABLED") throw qT(t, "user-disabled", o);
            const d = n[l] || l.toLowerCase().replace(/[_\s]+/g, "-");
            if (f) throw x8e(t, d, f);
            ff(t, d)
        }
    } catch (i) {
        if (i instanceof tg) throw i;
        ff(t, "network-request-failed")
    }
}

async function og(t, e, r, n, i = {}) {
    const a = await uc(t, e, r, n, i);
    return "mfaPendingCredential" in a && ff(t, "multi-factor-auth-required", {_serverResponse: a}), a
}

function A8e(t, e, r, n) {
    const i = `${e}${r}?${n}`;
    return t.config.emulator ? Nte(t.config, i) : `${t.config.apiScheme}://${i}`
}

class Kjt {
    constructor(e) {
        this.auth = e, this.timer = null, this.promise = new Promise((r, n) => {
            this.timer = setTimeout(() => n(Vf(this.auth, "network-request-failed")), Gjt.get())
        })
    }

    clearNetworkTimeout() {
        clearTimeout(this.timer)
    }
}

function qT(t, e, r) {
    const n = {appName: t.name};
    r.email && (n.email = r.email), r.phoneNumber && (n.phoneNumber = r.phoneNumber);
    const i = Vf(t, e, n);
    return i.customData._tokenResponse = r, i
}

async function Yjt(t, e) {
    return uc(t, "POST", "/v1/accounts:delete", e)
}

async function Xjt(t, e) {
    return uc(t, "POST", "/v1/accounts:update", e)
}

async function Qjt(t, e) {
    return uc(t, "POST", "/v1/accounts:lookup", e)
}

function RC(t) {
    if (t) try {
        const e = new Date(Number(t));
        if (!isNaN(e.getTime())) return e.toUTCString()
    } catch {
    }
}

function Zjt(t, e = !1) {
    return Tr(t).getIdToken(e)
}

async function I8e(t, e = !1) {
    const r = Tr(t), n = await r.getIdToken(e), i = sB(n);
    Lt(i && i.exp && i.auth_time && i.iat, r.auth, "internal-error");
    const a = typeof i.firebase == "object" ? i.firebase : void 0, o = a == null ? void 0 : a.sign_in_provider;
    return {
        claims: i,
        token: n,
        authTime: RC(YH(i.auth_time)),
        issuedAtTime: RC(YH(i.iat)),
        expirationTime: RC(YH(i.exp)),
        signInProvider: o || null,
        signInSecondFactor: (a == null ? void 0 : a.sign_in_second_factor) || null
    }
}

function YH(t) {
    return Number(t) * 1e3
}

function sB(t) {
    const [e, r, n] = t.split(".");
    if (e === void 0 || r === void 0 || n === void 0) return pM("JWT malformed, contained fewer than 3 sections"), null;
    try {
        const i = ZO(r);
        return i ? JSON.parse(i) : (pM("Failed to decode base64 JWT payload"), null)
    } catch (i) {
        return pM("Caught error parsing JWT payload as JSON", i == null ? void 0 : i.toString()), null
    }
}

function Jjt(t) {
    const e = sB(t);
    return Lt(e, "internal-error"), Lt(typeof e.exp < "u", "internal-error"), Lt(typeof e.iat < "u", "internal-error"), Number(e.exp) - Number(e.iat)
}

async function Wv(t, e, r = !1) {
    if (r) return e;
    try {
        return await e
    } catch (n) {
        throw n instanceof tg && ezt(n) && t.auth.currentUser === t && await t.auth.signOut(), n
    }
}

function ezt({code: t}) {
    return t === "auth/user-disabled" || t === "auth/user-token-expired"
}

class tzt {
    constructor(e) {
        this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4
    }

    _start() {
        this.isRunning || (this.isRunning = !0, this.schedule())
    }

    _stop() {
        this.isRunning && (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId))
    }

    getInterval(e) {
        var r;
        if (e) {
            const n = this.errorBackoff;
            return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4), n
        } else {
            this.errorBackoff = 3e4;
            const i = ((r = this.user.stsTokenManager.expirationTime) !== null && r !== void 0 ? r : 0) - Date.now() - 3e5;
            return Math.max(0, i)
        }
    }

    schedule(e = !1) {
        if (!this.isRunning) return;
        const r = this.getInterval(e);
        this.timerId = setTimeout(async () => {
            await this.iteration()
        }, r)
    }

    async iteration() {
        try {
            await this.user.getIdToken(!0)
        } catch (e) {
            (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0);
            return
        }
        this.schedule()
    }
}

class k8e {
    constructor(e, r) {
        this.createdAt = e, this.lastLoginAt = r, this._initializeTime()
    }

    _initializeTime() {
        this.lastSignInTime = RC(this.lastLoginAt), this.creationTime = RC(this.createdAt)
    }

    _copy(e) {
        this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime()
    }

    toJSON() {
        return {createdAt: this.createdAt, lastLoginAt: this.lastLoginAt}
    }
}

async function i8(t) {
    var e;
    const r = t.auth, n = await t.getIdToken(), i = await Wv(t, Qjt(r, {idToken: n}));
    Lt(i == null ? void 0 : i.users.length, r, "internal-error");
    const a = i.users[0];
    t._notifyReloadListener(a);
    const o = !((e = a.providerUserInfo) === null || e === void 0) && e.length ? nzt(a.providerUserInfo) : [],
        s = rzt(t.providerData, o), l = t.isAnonymous, f = !(t.email && a.passwordHash) && !(s != null && s.length),
        d = l ? f : !1, p = {
            uid: a.localId,
            displayName: a.displayName || null,
            photoURL: a.photoUrl || null,
            email: a.email || null,
            emailVerified: a.emailVerified || !1,
            phoneNumber: a.phoneNumber || null,
            tenantId: a.tenantId || null,
            providerData: s,
            metadata: new k8e(a.createdAt, a.lastLoginAt),
            isAnonymous: d
        };
    Object.assign(t, p)
}

async function R8e(t) {
    const e = Tr(t);
    await i8(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e)
}

function rzt(t, e) {
    return [...t.filter(n => !e.some(i => i.providerId === n.providerId)), ...e]
}

function nzt(t) {
    return t.map(e => {
        var {providerId: r} = e, n = cI(e, ["providerId"]);
        return {
            providerId: r,
            uid: n.rawId || "",
            displayName: n.displayName || null,
            email: n.email || null,
            phoneNumber: n.phoneNumber || null,
            photoURL: n.photoUrl || null
        }
    })
}

async function izt(t, e) {
    const r = await C8e(t, {}, async () => {
        const n = s3({grant_type: "refresh_token", refresh_token: e}).slice(1), {tokenApiHost: i, apiKey: a} = t.config,
            o = A8e(t, i, "/v1/token", `key=${a}`), s = await t._getAdditionalHeaders();
        return s["Content-Type"] = "application/x-www-form-urlencoded", T8e.fetch()(o, {
            method: "POST",
            headers: s,
            body: n
        })
    });
    return {accessToken: r.access_token, expiresIn: r.expires_in, refreshToken: r.refresh_token}
}

class a8 {
    constructor() {
        this.refreshToken = null, this.accessToken = null, this.expirationTime = null
    }

    get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
    }

    updateFromServerResponse(e) {
        Lt(e.idToken, "internal-error"), Lt(typeof e.idToken < "u", "internal-error"), Lt(typeof e.refreshToken < "u", "internal-error");
        const r = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : Jjt(e.idToken);
        this.updateTokensAndExpiration(e.idToken, e.refreshToken, r)
    }

    async getToken(e, r = !1) {
        return Lt(!this.accessToken || this.refreshToken, e, "user-token-expired"), !r && this.accessToken && !this.isExpired ? this.accessToken : this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null
    }

    clearRefreshToken() {
        this.refreshToken = null
    }

    async refresh(e, r) {
        const {accessToken: n, refreshToken: i, expiresIn: a} = await izt(e, r);
        this.updateTokensAndExpiration(n, i, Number(a))
    }

    updateTokensAndExpiration(e, r, n) {
        this.refreshToken = r || null, this.accessToken = e || null, this.expirationTime = Date.now() + n * 1e3
    }

    static fromJSON(e, r) {
        const {refreshToken: n, accessToken: i, expirationTime: a} = r, o = new a8;
        return n && (Lt(typeof n == "string", "internal-error", {appName: e}), o.refreshToken = n), i && (Lt(typeof i == "string", "internal-error", {appName: e}), o.accessToken = i), a && (Lt(typeof a == "number", "internal-error", {appName: e}), o.expirationTime = a), o
    }

    toJSON() {
        return {refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime}
    }

    _assign(e) {
        this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime
    }

    _clone() {
        return Object.assign(new a8, this.toJSON())
    }

    _performRefresh() {
        return I0("not implemented")
    }
}

function hy(t, e) {
    Lt(typeof t == "string" || typeof t > "u", "internal-error", {appName: e})
}

class Zw {
    constructor(e) {
        var {uid: r, auth: n, stsTokenManager: i} = e, a = cI(e, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase", this.proactiveRefresh = new tzt(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = r, this.auth = n, this.stsTokenManager = i, this.accessToken = i.accessToken, this.displayName = a.displayName || null, this.email = a.email || null, this.emailVerified = a.emailVerified || !1, this.phoneNumber = a.phoneNumber || null, this.photoURL = a.photoURL || null, this.isAnonymous = a.isAnonymous || !1, this.tenantId = a.tenantId || null, this.providerData = a.providerData ? [...a.providerData] : [], this.metadata = new k8e(a.createdAt || void 0, a.lastLoginAt || void 0)
    }

    async getIdToken(e) {
        const r = await Wv(this, this.stsTokenManager.getToken(this.auth, e));
        return Lt(r, this.auth, "internal-error"), this.accessToken !== r && (this.accessToken = r, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), r
    }

    getIdTokenResult(e) {
        return I8e(this, e)
    }

    reload() {
        return R8e(this)
    }

    _assign(e) {
        this !== e && (Lt(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map(r => Object.assign({}, r)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager))
    }

    _clone(e) {
        return new Zw(Object.assign(Object.assign({}, this), {auth: e, stsTokenManager: this.stsTokenManager._clone()}))
    }

    _onReload(e) {
        Lt(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null)
    }

    _notifyReloadListener(e) {
        this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e
    }

    _startProactiveRefresh() {
        this.proactiveRefresh._start()
    }

    _stopProactiveRefresh() {
        this.proactiveRefresh._stop()
    }

    async _updateTokensIfNecessary(e, r = !1) {
        let n = !1;
        e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), n = !0), r && await i8(this), await this.auth._persistUserIfCurrent(this), n && this.auth._notifyListenersIfCurrent(this)
    }

    async delete() {
        const e = await this.getIdToken();
        return await Wv(this, Yjt(this.auth, {idToken: e})), this.stsTokenManager.clearRefreshToken(), this.auth.signOut()
    }

    toJSON() {
        return Object.assign(Object.assign({
            uid: this.uid,
            email: this.email || void 0,
            emailVerified: this.emailVerified,
            displayName: this.displayName || void 0,
            isAnonymous: this.isAnonymous,
            photoURL: this.photoURL || void 0,
            phoneNumber: this.phoneNumber || void 0,
            tenantId: this.tenantId || void 0,
            providerData: this.providerData.map(e => Object.assign({}, e)),
            stsTokenManager: this.stsTokenManager.toJSON(),
            _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {apiKey: this.auth.config.apiKey, appName: this.auth.name})
    }

    get refreshToken() {
        return this.stsTokenManager.refreshToken || ""
    }

    static _fromJSON(e, r) {
        var n, i, a, o, s, l, f, d;
        const p = (n = r.displayName) !== null && n !== void 0 ? n : void 0,
            g = (i = r.email) !== null && i !== void 0 ? i : void 0,
            b = (a = r.phoneNumber) !== null && a !== void 0 ? a : void 0,
            S = (o = r.photoURL) !== null && o !== void 0 ? o : void 0,
            T = (s = r.tenantId) !== null && s !== void 0 ? s : void 0,
            I = (l = r._redirectEventId) !== null && l !== void 0 ? l : void 0,
            N = (f = r.createdAt) !== null && f !== void 0 ? f : void 0,
            P = (d = r.lastLoginAt) !== null && d !== void 0 ? d : void 0, {
                uid: F,
                emailVerified: V,
                isAnonymous: Y,
                providerData: ee,
                stsTokenManager: oe
            } = r;
        Lt(F && oe, e, "internal-error");
        const G = a8.fromJSON(this.name, oe);
        Lt(typeof F == "string", e, "internal-error"), hy(p, e.name), hy(g, e.name), Lt(typeof V == "boolean", e, "internal-error"), Lt(typeof Y == "boolean", e, "internal-error"), hy(b, e.name), hy(S, e.name), hy(T, e.name), hy(I, e.name), hy(N, e.name), hy(P, e.name);
        const J = new Zw({
            uid: F,
            auth: e,
            email: g,
            emailVerified: V,
            displayName: p,
            isAnonymous: Y,
            photoURL: S,
            phoneNumber: b,
            tenantId: T,
            stsTokenManager: G,
            createdAt: N,
            lastLoginAt: P
        });
        return ee && Array.isArray(ee) && (J.providerData = ee.map(ce => Object.assign({}, ce))), I && (J._redirectEventId = I), J
    }

    static async _fromIdTokenResponse(e, r, n = !1) {
        const i = new a8;
        i.updateFromServerResponse(r);
        const a = new Zw({uid: r.localId, auth: e, stsTokenManager: i, isAnonymous: n});
        return await i8(a), a
    }
}

class D8e {
    constructor() {
        this.type = "NONE", this.storage = {}
    }

    async _isAvailable() {
        return !0
    }

    async _set(e, r) {
        this.storage[e] = r
    }

    async _get(e) {
        const r = this.storage[e];
        return r === void 0 ? null : r
    }

    async _remove(e) {
        delete this.storage[e]
    }

    _addListener(e, r) {
    }

    _removeListener(e, r) {
    }
}

D8e.type = "NONE";
const RY = D8e;

function mM(t, e, r) {
    return `firebase:${t}:${e}:${r}`
}

class b4 {
    constructor(e, r, n) {
        this.persistence = e, this.auth = r, this.userKey = n;
        const {config: i, name: a} = this.auth;
        this.fullUserKey = mM(this.userKey, i.apiKey, a), this.fullPersistenceKey = mM("persistence", i.apiKey, a), this.boundEventHandler = r._onStorageEvent.bind(r), this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
    }

    setCurrentUser(e) {
        return this.persistence._set(this.fullUserKey, e.toJSON())
    }

    async getCurrentUser() {
        const e = await this.persistence._get(this.fullUserKey);
        return e ? Zw._fromJSON(this.auth, e) : null
    }

    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey)
    }

    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
    }

    async setPersistence(e) {
        if (this.persistence === e) return;
        const r = await this.getCurrentUser();
        if (await this.removeCurrentUser(), this.persistence = e, r) return this.setCurrentUser(r)
    }

    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
    }

    static async create(e, r, n = "authUser") {
        if (!r.length) return new b4(vv(RY), e, n);
        const i = (await Promise.all(r.map(async f => {
            if (await f._isAvailable()) return f
        }))).filter(f => f);
        let a = i[0] || vv(RY);
        const o = mM(n, e.config.apiKey, e.name);
        let s = null;
        for (const f of r) try {
            const d = await f._get(o);
            if (d) {
                const p = Zw._fromJSON(e, d);
                f !== a && (s = p), a = f;
                break
            }
        } catch {
        }
        const l = i.filter(f => f._shouldAllowMigration);
        return !a._shouldAllowMigration || !l.length ? new b4(a, e, n) : (a = l[0], s && await a._set(o, s.toJSON()), await Promise.all(r.map(async f => {
            if (f !== a) try {
                await f._remove(o)
            } catch {
            }
        })), new b4(a, e, n))
    }
}

function _me(t) {
    const e = t.toLowerCase();
    if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/")) return "Opera";
    if (P8e(e)) return "IEMobile";
    if (e.includes("msie") || e.includes("trident/")) return "IE";
    if (e.includes("edge/")) return "Edge";
    if (M8e(e)) return "Firefox";
    if (e.includes("silk/")) return "Silk";
    if (L8e(e)) return "Blackberry";
    if (B8e(e)) return "Webos";
    if (Lte(e)) return "Safari";
    if ((e.includes("chrome/") || O8e(e)) && !e.includes("edge/")) return "Chrome";
    if (N8e(e)) return "Android";
    {
        const r = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/, n = t.match(r);
        if ((n == null ? void 0 : n.length) === 2) return n[1]
    }
    return "Other"
}

function M8e(t = $s()) {
    return /firefox\//i.test(t)
}

function Lte(t = $s()) {
    const e = t.toLowerCase();
    return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android")
}

function O8e(t = $s()) {
    return /crios\//i.test(t)
}

function P8e(t = $s()) {
    return /iemobile/i.test(t)
}

function N8e(t = $s()) {
    return /android/i.test(t)
}

function L8e(t = $s()) {
    return /blackberry/i.test(t)
}

function B8e(t = $s()) {
    return /webos/i.test(t)
}

function cB(t = $s()) {
    return /iphone|ipad|ipod/i.test(t) || /macintosh/i.test(t) && /mobile/i.test(t)
}

function azt(t = $s()) {
    var e;
    return cB(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone)
}

function ozt() {
    return uNt() && document.documentMode === 10
}

function $8e(t = $s()) {
    return cB(t) || N8e(t) || B8e(t) || L8e(t) || /windows phone/i.test(t) || P8e(t)
}

function szt() {
    try {
        return !!(window && window !== window.top)
    } catch {
        return !1
    }
}

function F8e(t, e = []) {
    let r;
    switch (t) {
        case"Browser":
            r = _me($s());
            break;
        case"Worker":
            r = `${_me($s())}-${t}`;
            break;
        default:
            r = t
    }
    const n = e.length ? e.join(",") : "FirebaseCore-web";
    return `${r}/JsCore/${_I}/${n}`
}

class czt {
    constructor(e) {
        this.auth = e, this.queue = []
    }

    pushCallback(e, r) {
        const n = a => new Promise((o, s) => {
            try {
                const l = e(a);
                o(l)
            } catch (l) {
                s(l)
            }
        });
        n.onAbort = r, this.queue.push(n);
        const i = this.queue.length - 1;
        return () => {
            this.queue[i] = () => Promise.resolve()
        }
    }

    async runMiddleware(e) {
        if (this.auth.currentUser === e) return;
        const r = [];
        try {
            for (const n of this.queue) await n(e), n.onAbort && r.push(n.onAbort)
        } catch (n) {
            r.reverse();
            for (const i of r) try {
                i()
            } catch {
            }
            throw this.auth._errorFactory.create("login-blocked", {originalMessage: n == null ? void 0 : n.message})
        }
    }
}

class lzt {
    constructor(e, r, n) {
        this.app = e, this.heartbeatServiceProvider = r, this.config = n, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new xme(this), this.idTokenSubscription = new xme(this), this.beforeStateQueue = new czt(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = _8e, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = {appVerificationDisabledForTesting: !1}, this.frameworks = [], this.name = e.name, this.clientVersion = n.sdkClientVersion
    }

    _initializeWithPersistence(e, r) {
        return r && (this._popupRedirectResolver = vv(r)), this._initializationPromise = this.queue(async () => {
            var n, i;
            if (!this._deleted && (this.persistenceManager = await b4.create(this, e), !this._deleted)) {
                if (!((n = this._popupRedirectResolver) === null || n === void 0) && n._shouldInitProactively) try {
                    await this._popupRedirectResolver._initialize(this)
                } catch {
                }
                await this.initializeCurrentUser(r), this.lastNotifiedUid = ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null, !this._deleted && (this._isInitialized = !0)
            }
        }), this._initializationPromise
    }

    async _onStorageEvent() {
        if (this._deleted) return;
        const e = await this.assertedPersistence.getCurrentUser();
        if (!(!this.currentUser && !e)) {
            if (this.currentUser && e && this.currentUser.uid === e.uid) {
                this._currentUser._assign(e), await this.currentUser.getIdToken();
                return
            }
            await this._updateCurrentUser(e, !0)
        }
    }

    async initializeCurrentUser(e) {
        var r;
        const n = await this.assertedPersistence.getCurrentUser();
        let i = n, a = !1;
        if (e && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const o = (r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId,
                s = i == null ? void 0 : i._redirectEventId, l = await this.tryRedirectSignIn(e);
            (!o || o === s) && (l != null && l.user) && (i = l.user, a = !0)
        }
        if (!i) return this.directlySetCurrentUser(null);
        if (!i._redirectEventId) {
            if (a) try {
                await this.beforeStateQueue.runMiddleware(i)
            } catch (o) {
                i = n, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o))
            }
            return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null)
        }
        return Lt(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId ? this.directlySetCurrentUser(i) : this.reloadAndSetCurrentUserOrClear(i)
    }

    async tryRedirectSignIn(e) {
        let r = null;
        try {
            r = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
        } catch {
            await this._setRedirectUser(null)
        }
        return r
    }

    async reloadAndSetCurrentUserOrClear(e) {
        try {
            await i8(e)
        } catch (r) {
            if ((r == null ? void 0 : r.code) !== "auth/network-request-failed") return this.directlySetCurrentUser(null)
        }
        return this.directlySetCurrentUser(e)
    }

    useDeviceLanguage() {
        this.languageCode = Wjt()
    }

    async _delete() {
        this._deleted = !0
    }

    async updateCurrentUser(e) {
        const r = e ? Tr(e) : null;
        return r && Lt(r.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(r && r._clone(this))
    }

    async _updateCurrentUser(e, r = !1) {
        if (!this._deleted) return e && Lt(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), r || await this.beforeStateQueue.runMiddleware(e), this.queue(async () => {
            await this.directlySetCurrentUser(e), this.notifyAuthListeners()
        })
    }

    async signOut() {
        return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0)
    }

    setPersistence(e) {
        return this.queue(async () => {
            await this.assertedPersistence.setPersistence(vv(e))
        })
    }

    _getPersistence() {
        return this.assertedPersistence.persistence.type
    }

    _updateErrorMap(e) {
        this._errorFactory = new wI("auth", "Firebase", e())
    }

    onAuthStateChanged(e, r, n) {
        return this.registerStateListener(this.authStateSubscription, e, r, n)
    }

    beforeAuthStateChanged(e, r) {
        return this.beforeStateQueue.pushCallback(e, r)
    }

    onIdTokenChanged(e, r, n) {
        return this.registerStateListener(this.idTokenSubscription, e, r, n)
    }

    toJSON() {
        var e;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
        }
    }

    async _setRedirectUser(e, r) {
        const n = await this.getOrInitRedirectPersistenceManager(r);
        return e === null ? n.removeCurrentUser() : n.setCurrentUser(e)
    }

    async getOrInitRedirectPersistenceManager(e) {
        if (!this.redirectPersistenceManager) {
            const r = e && vv(e) || this._popupRedirectResolver;
            Lt(r, this, "argument-error"), this.redirectPersistenceManager = await b4.create(this, [vv(r._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
        }
        return this.redirectPersistenceManager
    }

    async _redirectUserForId(e) {
        var r, n;
        return this._isInitialized && await this.queue(async () => {
        }), ((r = this._currentUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e ? this._currentUser : ((n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e ? this.redirectUser : null
    }

    async _persistUserIfCurrent(e) {
        if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e))
    }

    _notifyListenersIfCurrent(e) {
        e === this.currentUser && this.notifyAuthListeners()
    }

    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
    }

    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh()
    }

    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh()
    }

    get _currentUser() {
        return this.currentUser
    }

    notifyAuthListeners() {
        var e, r;
        if (!this._isInitialized) return;
        this.idTokenSubscription.next(this.currentUser);
        const n = (r = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && r !== void 0 ? r : null;
        this.lastNotifiedUid !== n && (this.lastNotifiedUid = n, this.authStateSubscription.next(this.currentUser))
    }

    registerStateListener(e, r, n, i) {
        if (this._deleted) return () => {
        };
        const a = typeof r == "function" ? r : r.next.bind(r),
            o = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        return Lt(o, this, "internal-error"), o.then(() => a(this.currentUser)), typeof r == "function" ? e.addObserver(r, n, i) : e.addObserver(r)
    }

    async directlySetCurrentUser(e) {
        this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser()
    }

    queue(e) {
        return this.operations = this.operations.then(e, e), this.operations
    }

    get assertedPersistence() {
        return Lt(this.persistenceManager, this, "internal-error"), this.persistenceManager
    }

    _logFramework(e) {
        !e || this.frameworks.includes(e) || (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = F8e(this.config.clientPlatform, this._getFrameworks()))
    }

    _getFrameworks() {
        return this.frameworks
    }

    async _getAdditionalHeaders() {
        var e;
        const r = {"X-Client-Version": this.clientVersion};
        this.app.options.appId && (r["X-Firebase-gmpid"] = this.app.options.appId);
        const n = await ((e = this.heartbeatServiceProvider.getImmediate({optional: !0})) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader());
        return n && (r["X-Firebase-Client"] = n), r
    }
}

function xu(t) {
    return Tr(t)
}

class xme {
    constructor(e) {
        this.auth = e, this.observer = null, this.addObserver = yNt(r => this.observer = r)
    }

    get next() {
        return Lt(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer)
    }
}

function U8e(t, e, r) {
    const n = xu(t);
    Lt(n._canInitEmulator, n, "emulator-config-failed"), Lt(/^https?:\/\//.test(e), n, "invalid-emulator-scheme");
    const i = !!(r != null && r.disableWarnings), a = j8e(e), {host: o, port: s} = uzt(e),
        l = s === null ? "" : `:${s}`;
    n.config.emulator = {url: `${a}//${o}${l}/`}, n.settings.appVerificationDisabledForTesting = !0, n.emulatorConfig = Object.freeze({
        host: o,
        port: s,
        protocol: a.replace(":", ""),
        options: Object.freeze({disableWarnings: i})
    }), i || fzt()
}

function j8e(t) {
    const e = t.indexOf(":");
    return e < 0 ? "" : t.substr(0, e + 1)
}

function uzt(t) {
    const e = j8e(t), r = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length));
    if (!r) return {host: "", port: null};
    const n = r[2].split("@").pop() || "", i = /^(\[[^\]]+\])(:|$)/.exec(n);
    if (i) {
        const a = i[1];
        return {host: a, port: Eme(n.substr(a.length + 1))}
    } else {
        const [a, o] = n.split(":");
        return {host: a, port: Eme(o)}
    }
}

function Eme(t) {
    if (!t) return null;
    const e = Number(t);
    return isNaN(e) ? null : e
}

function fzt() {
    function t() {
        const e = document.createElement("p"), r = e.style;
        e.innerText = "Running in emulator mode. Do not use with production credentials.", r.position = "fixed", r.width = "100%", r.backgroundColor = "#ffffff", r.border = ".1em solid #000000", r.color = "#b50000", r.bottom = "0px", r.left = "0px", r.margin = "0px", r.zIndex = "10000", r.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e)
    }

    typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t())
}

class x3 {
    constructor(e, r) {
        this.providerId = e, this.signInMethod = r
    }

    toJSON() {
        return I0("not implemented")
    }

    _getIdTokenResponse(e) {
        return I0("not implemented")
    }

    _linkToIdToken(e, r) {
        return I0("not implemented")
    }

    _getReauthenticationResolver(e) {
        return I0("not implemented")
    }
}

async function z8e(t, e) {
    return uc(t, "POST", "/v1/accounts:resetPassword", zs(t, e))
}

async function V8e(t, e) {
    return uc(t, "POST", "/v1/accounts:update", e)
}

async function dzt(t, e) {
    return uc(t, "POST", "/v1/accounts:update", zs(t, e))
}

async function hzt(t, e) {
    return og(t, "POST", "/v1/accounts:signInWithPassword", zs(t, e))
}

async function lB(t, e) {
    return uc(t, "POST", "/v1/accounts:sendOobCode", zs(t, e))
}

async function pzt(t, e) {
    return lB(t, e)
}

async function mzt(t, e) {
    return lB(t, e)
}

async function vzt(t, e) {
    return lB(t, e)
}

async function gzt(t, e) {
    return lB(t, e)
}

async function yzt(t, e) {
    return og(t, "POST", "/v1/accounts:signInWithEmailLink", zs(t, e))
}

async function bzt(t, e) {
    return og(t, "POST", "/v1/accounts:signInWithEmailLink", zs(t, e))
}

class CE extends x3 {
    constructor(e, r, n, i = null) {
        super("password", n), this._email = e, this._password = r, this._tenantId = i
    }

    static _fromEmailAndPassword(e, r) {
        return new CE(e, r, "password")
    }

    static _fromEmailAndCode(e, r, n = null) {
        return new CE(e, r, "emailLink", n)
    }

    toJSON() {
        return {email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId}
    }

    static fromJSON(e) {
        const r = typeof e == "string" ? JSON.parse(e) : e;
        if (r != null && r.email && (r != null && r.password)) {
            if (r.signInMethod === "password") return this._fromEmailAndPassword(r.email, r.password);
            if (r.signInMethod === "emailLink") return this._fromEmailAndCode(r.email, r.password, r.tenantId)
        }
        return null
    }

    async _getIdTokenResponse(e) {
        switch (this.signInMethod) {
            case"password":
                return hzt(e, {returnSecureToken: !0, email: this._email, password: this._password});
            case"emailLink":
                return yzt(e, {email: this._email, oobCode: this._password});
            default:
                ff(e, "internal-error")
        }
    }

    async _linkToIdToken(e, r) {
        switch (this.signInMethod) {
            case"password":
                return V8e(e, {idToken: r, returnSecureToken: !0, email: this._email, password: this._password});
            case"emailLink":
                return bzt(e, {idToken: r, email: this._email, oobCode: this._password});
            default:
                ff(e, "internal-error")
        }
    }

    _getReauthenticationResolver(e) {
        return this._getIdTokenResponse(e)
    }
}

async function Av(t, e) {
    return og(t, "POST", "/v1/accounts:signInWithIdp", zs(t, e))
}

const wzt = "http://localhost";

class Y0 extends x3 {
    constructor() {
        super(...arguments), this.pendingToken = null
    }

    static _fromParams(e) {
        const r = new Y0(e.providerId, e.signInMethod);
        return e.idToken || e.accessToken ? (e.idToken && (r.idToken = e.idToken), e.accessToken && (r.accessToken = e.accessToken), e.nonce && !e.pendingToken && (r.nonce = e.nonce), e.pendingToken && (r.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (r.accessToken = e.oauthToken, r.secret = e.oauthTokenSecret) : ff("argument-error"), r
    }

    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        }
    }

    static fromJSON(e) {
        const r = typeof e == "string" ? JSON.parse(e) : e, {providerId: n, signInMethod: i} = r,
            a = cI(r, ["providerId", "signInMethod"]);
        if (!n || !i) return null;
        const o = new Y0(n, i);
        return o.idToken = a.idToken || void 0, o.accessToken = a.accessToken || void 0, o.secret = a.secret, o.nonce = a.nonce, o.pendingToken = a.pendingToken || null, o
    }

    _getIdTokenResponse(e) {
        const r = this.buildRequest();
        return Av(e, r)
    }

    _linkToIdToken(e, r) {
        const n = this.buildRequest();
        return n.idToken = r, Av(e, n)
    }

    _getReauthenticationResolver(e) {
        const r = this.buildRequest();
        return r.autoCreate = !1, Av(e, r)
    }

    buildRequest() {
        const e = {requestUri: wzt, returnSecureToken: !0};
        if (this.pendingToken) e.pendingToken = this.pendingToken; else {
            const r = {};
            this.idToken && (r.id_token = this.idToken), this.accessToken && (r.access_token = this.accessToken), this.secret && (r.oauth_token_secret = this.secret), r.providerId = this.providerId, this.nonce && !this.pendingToken && (r.nonce = this.nonce), e.postBody = s3(r)
        }
        return e
    }
}

async function Szt(t, e) {
    return uc(t, "POST", "/v1/accounts:sendVerificationCode", zs(t, e))
}

async function _zt(t, e) {
    return og(t, "POST", "/v1/accounts:signInWithPhoneNumber", zs(t, e))
}

async function xzt(t, e) {
    const r = await og(t, "POST", "/v1/accounts:signInWithPhoneNumber", zs(t, e));
    if (r.temporaryProof) throw qT(t, "account-exists-with-different-credential", r);
    return r
}

const Ezt = {USER_NOT_FOUND: "user-not-found"};

async function Tzt(t, e) {
    const r = Object.assign(Object.assign({}, e), {operation: "REAUTH"});
    return og(t, "POST", "/v1/accounts:signInWithPhoneNumber", zs(t, r), Ezt)
}

class qy extends x3 {
    constructor(e) {
        super("phone", "phone"), this.params = e
    }

    static _fromVerification(e, r) {
        return new qy({verificationId: e, verificationCode: r})
    }

    static _fromTokenResponse(e, r) {
        return new qy({phoneNumber: e, temporaryProof: r})
    }

    _getIdTokenResponse(e) {
        return _zt(e, this._makeVerificationRequest())
    }

    _linkToIdToken(e, r) {
        return xzt(e, Object.assign({idToken: r}, this._makeVerificationRequest()))
    }

    _getReauthenticationResolver(e) {
        return Tzt(e, this._makeVerificationRequest())
    }

    _makeVerificationRequest() {
        const {temporaryProof: e, phoneNumber: r, verificationId: n, verificationCode: i} = this.params;
        return e && r ? {temporaryProof: e, phoneNumber: r} : {sessionInfo: n, code: i}
    }

    toJSON() {
        const e = {providerId: this.providerId};
        return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (e.verificationCode = this.params.verificationCode), this.params.verificationId && (e.verificationId = this.params.verificationId), e
    }

    static fromJSON(e) {
        typeof e == "string" && (e = JSON.parse(e));
        const {verificationId: r, verificationCode: n, phoneNumber: i, temporaryProof: a} = e;
        return !n && !r && !i && !a ? null : new qy({
            verificationId: r,
            verificationCode: n,
            phoneNumber: i,
            temporaryProof: a
        })
    }
}

function Czt(t) {
    switch (t) {
        case"recoverEmail":
            return "RECOVER_EMAIL";
        case"resetPassword":
            return "PASSWORD_RESET";
        case"signIn":
            return "EMAIL_SIGNIN";
        case"verifyEmail":
            return "VERIFY_EMAIL";
        case"verifyAndChangeEmail":
            return "VERIFY_AND_CHANGE_EMAIL";
        case"revertSecondFactorAddition":
            return "REVERT_SECOND_FACTOR_ADDITION";
        default:
            return null
    }
}

function Azt(t) {
    const e = UT(jT(t)).link, r = e ? UT(jT(e)).deep_link_id : null, n = UT(jT(t)).deep_link_id;
    return (n ? UT(jT(n)).link : null) || n || r || e || t
}

class E3 {
    constructor(e) {
        var r, n, i, a, o, s;
        const l = UT(jT(e)), f = (r = l.apiKey) !== null && r !== void 0 ? r : null,
            d = (n = l.oobCode) !== null && n !== void 0 ? n : null,
            p = Czt((i = l.mode) !== null && i !== void 0 ? i : null);
        Lt(f && d && p, "argument-error"), this.apiKey = f, this.operation = p, this.code = d, this.continueUrl = (a = l.continueUrl) !== null && a !== void 0 ? a : null, this.languageCode = (o = l.languageCode) !== null && o !== void 0 ? o : null, this.tenantId = (s = l.tenantId) !== null && s !== void 0 ? s : null
    }

    static parseLink(e) {
        const r = Azt(e);
        try {
            return new E3(r)
        } catch {
            return null
        }
    }
}

function Izt(t) {
    return E3.parseLink(t)
}

class N1 {
    constructor() {
        this.providerId = N1.PROVIDER_ID
    }

    static credential(e, r) {
        return CE._fromEmailAndPassword(e, r)
    }

    static credentialWithLink(e, r) {
        const n = E3.parseLink(r);
        return Lt(n, "argument-error"), CE._fromEmailAndCode(e, n.code, n.tenantId)
    }
}

N1.PROVIDER_ID = "password";
N1.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
N1.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";

class sg {
    constructor(e) {
        this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {}
    }

    setDefaultLanguage(e) {
        this.defaultLanguageCode = e
    }

    setCustomParameters(e) {
        return this.customParameters = e, this
    }

    getCustomParameters() {
        return this.customParameters
    }
}

class T3 extends sg {
    constructor() {
        super(...arguments), this.scopes = []
    }

    addScope(e) {
        return this.scopes.includes(e) || this.scopes.push(e), this
    }

    getScopes() {
        return [...this.scopes]
    }
}

class DC extends T3 {
    static credentialFromJSON(e) {
        const r = typeof e == "string" ? JSON.parse(e) : e;
        return Lt("providerId" in r && "signInMethod" in r, "argument-error"), Y0._fromParams(r)
    }

    credential(e) {
        return this._credential(Object.assign(Object.assign({}, e), {nonce: e.rawNonce}))
    }

    _credential(e) {
        return Lt(e.idToken || e.accessToken, "argument-error"), Y0._fromParams(Object.assign(Object.assign({}, e), {
            providerId: this.providerId,
            signInMethod: this.providerId
        }))
    }

    static credentialFromResult(e) {
        return DC.oauthCredentialFromTaggedObject(e)
    }

    static credentialFromError(e) {
        return DC.oauthCredentialFromTaggedObject(e.customData || {})
    }

    static oauthCredentialFromTaggedObject({_tokenResponse: e}) {
        if (!e) return null;
        const {oauthIdToken: r, oauthAccessToken: n, oauthTokenSecret: i, pendingToken: a, nonce: o, providerId: s} = e;
        if (!n && !i && !r && !a || !s) return null;
        try {
            return new DC(s)._credential({idToken: r, accessToken: n, nonce: o, pendingToken: a})
        } catch {
            return null
        }
    }
}

class sv extends T3 {
    constructor() {
        super("facebook.com")
    }

    static credential(e) {
        return Y0._fromParams({providerId: sv.PROVIDER_ID, signInMethod: sv.FACEBOOK_SIGN_IN_METHOD, accessToken: e})
    }

    static credentialFromResult(e) {
        return sv.credentialFromTaggedObject(e)
    }

    static credentialFromError(e) {
        return sv.credentialFromTaggedObject(e.customData || {})
    }

    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null;
        try {
            return sv.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}

sv.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
sv.PROVIDER_ID = "facebook.com";

class cv extends T3 {
    constructor() {
        super("google.com"), this.addScope("profile")
    }

    static credential(e, r) {
        return Y0._fromParams({
            providerId: cv.PROVIDER_ID,
            signInMethod: cv.GOOGLE_SIGN_IN_METHOD,
            idToken: e,
            accessToken: r
        })
    }

    static credentialFromResult(e) {
        return cv.credentialFromTaggedObject(e)
    }

    static credentialFromError(e) {
        return cv.credentialFromTaggedObject(e.customData || {})
    }

    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e) return null;
        const {oauthIdToken: r, oauthAccessToken: n} = e;
        if (!r && !n) return null;
        try {
            return cv.credential(r, n)
        } catch {
            return null
        }
    }
}

cv.GOOGLE_SIGN_IN_METHOD = "google.com";
cv.PROVIDER_ID = "google.com";

class lv extends T3 {
    constructor() {
        super("github.com")
    }

    static credential(e) {
        return Y0._fromParams({providerId: lv.PROVIDER_ID, signInMethod: lv.GITHUB_SIGN_IN_METHOD, accessToken: e})
    }

    static credentialFromResult(e) {
        return lv.credentialFromTaggedObject(e)
    }

    static credentialFromError(e) {
        return lv.credentialFromTaggedObject(e.customData || {})
    }

    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken) return null;
        try {
            return lv.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}

lv.GITHUB_SIGN_IN_METHOD = "github.com";
lv.PROVIDER_ID = "github.com";
const kzt = "http://localhost";

class o8 extends x3 {
    constructor(e, r) {
        super(e, e), this.pendingToken = r
    }

    _getIdTokenResponse(e) {
        const r = this.buildRequest();
        return Av(e, r)
    }

    _linkToIdToken(e, r) {
        const n = this.buildRequest();
        return n.idToken = r, Av(e, n)
    }

    _getReauthenticationResolver(e) {
        const r = this.buildRequest();
        return r.autoCreate = !1, Av(e, r)
    }

    toJSON() {
        return {signInMethod: this.signInMethod, providerId: this.providerId, pendingToken: this.pendingToken}
    }

    static fromJSON(e) {
        const r = typeof e == "string" ? JSON.parse(e) : e, {providerId: n, signInMethod: i, pendingToken: a} = r;
        return !n || !i || !a || n !== i ? null : new o8(n, a)
    }

    static _create(e, r) {
        return new o8(e, r)
    }

    buildRequest() {
        return {requestUri: kzt, returnSecureToken: !0, pendingToken: this.pendingToken}
    }
}

const Rzt = "saml.";

class SP extends sg {
    constructor(e) {
        Lt(e.startsWith(Rzt), "argument-error"), super(e)
    }

    static credentialFromResult(e) {
        return SP.samlCredentialFromTaggedObject(e)
    }

    static credentialFromError(e) {
        return SP.samlCredentialFromTaggedObject(e.customData || {})
    }

    static credentialFromJSON(e) {
        const r = o8.fromJSON(e);
        return Lt(r, "argument-error"), r
    }

    static samlCredentialFromTaggedObject({_tokenResponse: e}) {
        if (!e) return null;
        const {pendingToken: r, providerId: n} = e;
        if (!r || !n) return null;
        try {
            return o8._create(n, r)
        } catch {
            return null
        }
    }
}

class uv extends T3 {
    constructor() {
        super("twitter.com")
    }

    static credential(e, r) {
        return Y0._fromParams({
            providerId: uv.PROVIDER_ID,
            signInMethod: uv.TWITTER_SIGN_IN_METHOD,
            oauthToken: e,
            oauthTokenSecret: r
        })
    }

    static credentialFromResult(e) {
        return uv.credentialFromTaggedObject(e)
    }

    static credentialFromError(e) {
        return uv.credentialFromTaggedObject(e.customData || {})
    }

    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e) return null;
        const {oauthAccessToken: r, oauthTokenSecret: n} = e;
        if (!r || !n) return null;
        try {
            return uv.credential(r, n)
        } catch {
            return null
        }
    }
}

uv.TWITTER_SIGN_IN_METHOD = "twitter.com";
uv.PROVIDER_ID = "twitter.com";

async function H8e(t, e) {
    return og(t, "POST", "/v1/accounts:signUp", zs(t, e))
}

class eh {
    constructor(e) {
        this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType
    }

    static async _fromIdTokenResponse(e, r, n, i = !1) {
        const a = await Zw._fromIdTokenResponse(e, n, i), o = Tme(n);
        return new eh({user: a, providerId: o, _tokenResponse: n, operationType: r})
    }

    static async _forOperation(e, r, n) {
        await e._updateTokensIfNecessary(n, !0);
        const i = Tme(n);
        return new eh({user: e, providerId: i, _tokenResponse: n, operationType: r})
    }
}

function Tme(t) {
    return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null
}

async function W8e(t) {
    var e;
    const r = xu(t);
    if (await r._initializationPromise, !((e = r.currentUser) === null || e === void 0) && e.isAnonymous) return new eh({
        user: r.currentUser,
        providerId: null,
        operationType: "signIn"
    });
    const n = await H8e(r, {returnSecureToken: !0}), i = await eh._fromIdTokenResponse(r, "signIn", n, !0);
    return await r._updateCurrentUser(i.user), i
}

class _P extends tg {
    constructor(e, r, n, i) {
        var a;
        super(r.code, r.message), this.operationType = n, this.user = i, Object.setPrototypeOf(this, _P.prototype), this.customData = {
            appName: e.name,
            tenantId: (a = e.tenantId) !== null && a !== void 0 ? a : void 0,
            _serverResponse: r.customData._serverResponse,
            operationType: n
        }
    }

    static _fromErrorAndOperation(e, r, n, i) {
        return new _P(e, r, n, i)
    }
}

function q8e(t, e, r, n) {
    return (e === "reauthenticate" ? r._getReauthenticationResolver(t) : r._getIdTokenResponse(t)).catch(a => {
        throw a.code === "auth/multi-factor-auth-required" ? _P._fromErrorAndOperation(t, a, e, n) : a
    })
}

function G8e(t) {
    return new Set(t.map(({providerId: e}) => e).filter(e => !!e))
}

async function Dzt(t, e) {
    const r = Tr(t);
    await uB(!0, r, e);
    const {providerUserInfo: n} = await Xjt(r.auth, {idToken: await r.getIdToken(), deleteProvider: [e]}),
        i = G8e(n || []);
    return r.providerData = r.providerData.filter(a => i.has(a.providerId)), i.has("phone") || (r.phoneNumber = null), await r.auth._persistUserIfCurrent(r), r
}

async function Bte(t, e, r = !1) {
    const n = await Wv(t, e._linkToIdToken(t.auth, await t.getIdToken()), r);
    return eh._forOperation(t, "link", n)
}

async function uB(t, e, r) {
    await i8(e);
    const n = G8e(e.providerData), i = t === !1 ? "provider-already-linked" : "no-such-provider";
    Lt(n.has(r) === t, e.auth, i)
}

async function K8e(t, e, r = !1) {
    const {auth: n} = t, i = "reauthenticate";
    try {
        const a = await Wv(t, q8e(n, i, e, t), r);
        Lt(a.idToken, n, "internal-error");
        const o = sB(a.idToken);
        Lt(o, n, "internal-error");
        const {sub: s} = o;
        return Lt(t.uid === s, n, "user-mismatch"), eh._forOperation(t, i, a)
    } catch (a) {
        throw (a == null ? void 0 : a.code) === "auth/user-not-found" && ff(n, "user-mismatch"), a
    }
}

async function Y8e(t, e, r = !1) {
    const n = "signIn", i = await q8e(t, n, e), a = await eh._fromIdTokenResponse(t, n, i);
    return r || await t._updateCurrentUser(a.user), a
}

async function fB(t, e) {
    return Y8e(xu(t), e)
}

async function X8e(t, e) {
    const r = Tr(t);
    return await uB(!1, r, e.providerId), Bte(r, e)
}

async function Q8e(t, e) {
    return K8e(Tr(t), e)
}

async function Mzt(t, e) {
    return og(t, "POST", "/v1/accounts:signInWithCustomToken", zs(t, e))
}

async function Z8e(t, e) {
    const r = xu(t), n = await Mzt(r, {token: e, returnSecureToken: !0}),
        i = await eh._fromIdTokenResponse(r, "signIn", n);
    return await r._updateCurrentUser(i.user), i
}

class dB {
    constructor(e, r) {
        this.factorId = e, this.uid = r.mfaEnrollmentId, this.enrollmentTime = new Date(r.enrolledAt).toUTCString(), this.displayName = r.displayName
    }

    static _fromServerResponse(e, r) {
        return "phoneInfo" in r ? $te._fromServerResponse(e, r) : ff(e, "internal-error")
    }
}

class $te extends dB {
    constructor(e) {
        super("phone", e), this.phoneNumber = e.phoneInfo
    }

    static _fromServerResponse(e, r) {
        return new $te(r)
    }
}

function hB(t, e, r) {
    var n;
    Lt(((n = r.url) === null || n === void 0 ? void 0 : n.length) > 0, t, "invalid-continue-uri"), Lt(typeof r.dynamicLinkDomain > "u" || r.dynamicLinkDomain.length > 0, t, "invalid-dynamic-link-domain"), e.continueUrl = r.url, e.dynamicLinkDomain = r.dynamicLinkDomain, e.canHandleCodeInApp = r.handleCodeInApp, r.iOS && (Lt(r.iOS.bundleId.length > 0, t, "missing-ios-bundle-id"), e.iOSBundleId = r.iOS.bundleId), r.android && (Lt(r.android.packageName.length > 0, t, "missing-android-pkg-name"), e.androidInstallApp = r.android.installApp, e.androidMinimumVersionCode = r.android.minimumVersion, e.androidPackageName = r.android.packageName)
}

async function Ozt(t, e, r) {
    const n = Tr(t), i = {requestType: "PASSWORD_RESET", email: e};
    r && hB(n, i, r), await mzt(n, i)
}

async function Pzt(t, e, r) {
    await z8e(Tr(t), {oobCode: e, newPassword: r})
}

async function Nzt(t, e) {
    await dzt(Tr(t), {oobCode: e})
}

async function J8e(t, e) {
    const r = Tr(t), n = await z8e(r, {oobCode: e}), i = n.requestType;
    switch (Lt(i, r, "internal-error"), i) {
        case"EMAIL_SIGNIN":
            break;
        case"VERIFY_AND_CHANGE_EMAIL":
            Lt(n.newEmail, r, "internal-error");
            break;
        case"REVERT_SECOND_FACTOR_ADDITION":
            Lt(n.mfaInfo, r, "internal-error");
        default:
            Lt(n.email, r, "internal-error")
    }
    let a = null;
    return n.mfaInfo && (a = dB._fromServerResponse(xu(r), n.mfaInfo)), {
        data: {
            email: (n.requestType === "VERIFY_AND_CHANGE_EMAIL" ? n.newEmail : n.email) || null,
            previousEmail: (n.requestType === "VERIFY_AND_CHANGE_EMAIL" ? n.email : n.newEmail) || null,
            multiFactorInfo: a
        }, operation: i
    }
}

async function Lzt(t, e) {
    const {data: r} = await J8e(Tr(t), e);
    return r.email
}

async function Bzt(t, e, r) {
    const n = xu(t), i = await H8e(n, {returnSecureToken: !0, email: e, password: r}),
        a = await eh._fromIdTokenResponse(n, "signIn", i);
    return await n._updateCurrentUser(a.user), a
}

function $zt(t, e, r) {
    return fB(Tr(t), N1.credential(e, r))
}

async function Fzt(t, e, r) {
    const n = Tr(t), i = {requestType: "EMAIL_SIGNIN", email: e};
    Lt(r.handleCodeInApp, n, "argument-error"), r && hB(n, i, r), await vzt(n, i)
}

function Uzt(t, e) {
    const r = E3.parseLink(e);
    return (r == null ? void 0 : r.operation) === "EMAIL_SIGNIN"
}

async function jzt(t, e, r) {
    const n = Tr(t), i = N1.credentialWithLink(e, r || n8());
    return Lt(i._tenantId === (n.tenantId || null), n, "tenant-id-mismatch"), fB(n, i)
}

async function zzt(t, e) {
    return uc(t, "POST", "/v1/accounts:createAuthUri", zs(t, e))
}

async function Vzt(t, e) {
    const r = Pte() ? n8() : "http://localhost",
        n = {identifier: e, continueUri: r}, {signinMethods: i} = await zzt(Tr(t), n);
    return i || []
}

async function Hzt(t, e) {
    const r = Tr(t), i = {requestType: "VERIFY_EMAIL", idToken: await t.getIdToken()};
    e && hB(r.auth, i, e);
    const {email: a} = await pzt(r.auth, i);
    a !== t.email && await t.reload()
}

async function Wzt(t, e, r) {
    const n = Tr(t), a = {requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: await t.getIdToken(), newEmail: e};
    r && hB(n.auth, a, r);
    const {email: o} = await gzt(n.auth, a);
    o !== t.email && await t.reload()
}

async function qzt(t, e) {
    return uc(t, "POST", "/v1/accounts:update", e)
}

async function Gzt(t, {displayName: e, photoURL: r}) {
    if (e === void 0 && r === void 0) return;
    const n = Tr(t), a = {idToken: await n.getIdToken(), displayName: e, photoUrl: r, returnSecureToken: !0},
        o = await Wv(n, qzt(n.auth, a));
    n.displayName = o.displayName || null, n.photoURL = o.photoUrl || null;
    const s = n.providerData.find(({providerId: l}) => l === "password");
    s && (s.displayName = n.displayName, s.photoURL = n.photoURL), await n._updateTokensIfNecessary(o)
}

function Kzt(t, e) {
    return eIe(Tr(t), e, null)
}

function Yzt(t, e) {
    return eIe(Tr(t), null, e)
}

async function eIe(t, e, r) {
    const {auth: n} = t, a = {idToken: await t.getIdToken(), returnSecureToken: !0};
    e && (a.email = e), r && (a.password = r);
    const o = await Wv(t, V8e(n, a));
    await t._updateTokensIfNecessary(o, !0)
}

function Xzt(t) {
    var e, r;
    if (!t) return null;
    const {providerId: n} = t, i = t.rawUserInfo ? JSON.parse(t.rawUserInfo) : {},
        a = t.isNewUser || t.kind === "identitytoolkit#SignupNewUserResponse";
    if (!n && (t != null && t.idToken)) {
        const o = (r = (e = sB(t.idToken)) === null || e === void 0 ? void 0 : e.firebase) === null || r === void 0 ? void 0 : r.sign_in_provider;
        if (o) {
            const s = o !== "anonymous" && o !== "custom" ? o : null;
            return new w4(a, s)
        }
    }
    if (!n) return null;
    switch (n) {
        case"facebook.com":
            return new Qzt(a, i);
        case"github.com":
            return new Zzt(a, i);
        case"google.com":
            return new Jzt(a, i);
        case"twitter.com":
            return new eVt(a, i, t.screenName || null);
        case"custom":
        case"anonymous":
            return new w4(a, null);
        default:
            return new w4(a, n, i)
    }
}

class w4 {
    constructor(e, r, n = {}) {
        this.isNewUser = e, this.providerId = r, this.profile = n
    }
}

class tIe extends w4 {
    constructor(e, r, n, i) {
        super(e, r, n), this.username = i
    }
}

class Qzt extends w4 {
    constructor(e, r) {
        super(e, "facebook.com", r)
    }
}

class Zzt extends tIe {
    constructor(e, r) {
        super(e, "github.com", r, typeof (r == null ? void 0 : r.login) == "string" ? r == null ? void 0 : r.login : null)
    }
}

class Jzt extends w4 {
    constructor(e, r) {
        super(e, "google.com", r)
    }
}

class eVt extends tIe {
    constructor(e, r, n) {
        super(e, "twitter.com", r, n)
    }
}

function tVt(t) {
    const {user: e, _tokenResponse: r} = t;
    return e.isAnonymous && !r ? {providerId: null, isNewUser: !1, profile: null} : Xzt(r)
}

function rVt(t, e) {
    return Tr(t).setPersistence(e)
}

function rIe(t, e, r, n) {
    return Tr(t).onIdTokenChanged(e, r, n)
}

function nIe(t, e, r) {
    return Tr(t).beforeAuthStateChanged(e, r)
}

function nVt(t, e, r, n) {
    return Tr(t).onAuthStateChanged(e, r, n)
}

function iVt(t) {
    Tr(t).useDeviceLanguage()
}

function aVt(t, e) {
    return Tr(t).updateCurrentUser(e)
}

function iIe(t) {
    return Tr(t).signOut()
}

async function oVt(t) {
    return Tr(t).delete()
}

class Pw {
    constructor(e, r, n) {
        this.type = e, this.credential = r, this.auth = n
    }

    static _fromIdtoken(e, r) {
        return new Pw("enroll", e, r)
    }

    static _fromMfaPendingCredential(e) {
        return new Pw("signin", e)
    }

    toJSON() {
        return {multiFactorSession: {[this.type === "enroll" ? "idToken" : "pendingCredential"]: this.credential}}
    }

    static fromJSON(e) {
        var r, n;
        if (e != null && e.multiFactorSession) {
            if (!((r = e.multiFactorSession) === null || r === void 0) && r.pendingCredential) return Pw._fromMfaPendingCredential(e.multiFactorSession.pendingCredential);
            if (!((n = e.multiFactorSession) === null || n === void 0) && n.idToken) return Pw._fromIdtoken(e.multiFactorSession.idToken)
        }
        return null
    }
}

class Fte {
    constructor(e, r, n) {
        this.session = e, this.hints = r, this.signInResolver = n
    }

    static _fromError(e, r) {
        const n = xu(e), i = r.customData._serverResponse, a = (i.mfaInfo || []).map(s => dB._fromServerResponse(n, s));
        Lt(i.mfaPendingCredential, n, "internal-error");
        const o = Pw._fromMfaPendingCredential(i.mfaPendingCredential);
        return new Fte(o, a, async s => {
            const l = await s._process(n, o);
            delete i.mfaInfo, delete i.mfaPendingCredential;
            const f = Object.assign(Object.assign({}, i), {idToken: l.idToken, refreshToken: l.refreshToken});
            switch (r.operationType) {
                case"signIn":
                    const d = await eh._fromIdTokenResponse(n, r.operationType, f);
                    return await n._updateCurrentUser(d.user), d;
                case"reauthenticate":
                    return Lt(r.user, n, "internal-error"), eh._forOperation(r.user, r.operationType, f);
                default:
                    ff(n, "internal-error")
            }
        })
    }

    async resolveSignIn(e) {
        const r = e;
        return this.signInResolver(r)
    }
}

function sVt(t, e) {
    var r;
    const n = Tr(t), i = e;
    return Lt(e.customData.operationType, n, "argument-error"), Lt((r = i.customData._serverResponse) === null || r === void 0 ? void 0 : r.mfaPendingCredential, n, "argument-error"), Fte._fromError(n, i)
}

function cVt(t, e) {
    return uc(t, "POST", "/v2/accounts/mfaEnrollment:start", zs(t, e))
}

function lVt(t, e) {
    return uc(t, "POST", "/v2/accounts/mfaEnrollment:finalize", zs(t, e))
}

function uVt(t, e) {
    return uc(t, "POST", "/v2/accounts/mfaEnrollment:withdraw", zs(t, e))
}

class Ute {
    constructor(e) {
        this.user = e, this.enrolledFactors = [], e._onReload(r => {
            r.mfaInfo && (this.enrolledFactors = r.mfaInfo.map(n => dB._fromServerResponse(e.auth, n)))
        })
    }

    static _fromUser(e) {
        return new Ute(e)
    }

    async getSession() {
        return Pw._fromIdtoken(await this.user.getIdToken(), this.user.auth)
    }

    async enroll(e, r) {
        const n = e, i = await this.getSession(), a = await Wv(this.user, n._process(this.user.auth, i, r));
        return await this.user._updateTokensIfNecessary(a), this.user.reload()
    }

    async unenroll(e) {
        const r = typeof e == "string" ? e : e.uid, n = await this.user.getIdToken();
        try {
            const i = await Wv(this.user, uVt(this.user.auth, {idToken: n, mfaEnrollmentId: r}));
            this.enrolledFactors = this.enrolledFactors.filter(({uid: a}) => a !== r), await this.user._updateTokensIfNecessary(i), await this.user.reload()
        } catch (i) {
            throw i
        }
    }
}

const XH = new WeakMap;

function fVt(t) {
    const e = Tr(t);
    return XH.has(e) || XH.set(e, Ute._fromUser(e)), XH.get(e)
}

const xP = "__sak";

class aIe {
    constructor(e, r) {
        this.storageRetriever = e, this.type = r
    }

    _isAvailable() {
        try {
            return this.storage ? (this.storage.setItem(xP, "1"), this.storage.removeItem(xP), Promise.resolve(!0)) : Promise.resolve(!1)
        } catch {
            return Promise.resolve(!1)
        }
    }

    _set(e, r) {
        return this.storage.setItem(e, JSON.stringify(r)), Promise.resolve()
    }

    _get(e) {
        const r = this.storage.getItem(e);
        return Promise.resolve(r ? JSON.parse(r) : null)
    }

    _remove(e) {
        return this.storage.removeItem(e), Promise.resolve()
    }

    get storage() {
        return this.storageRetriever()
    }
}

function dVt() {
    const t = $s();
    return Lte(t) || cB(t)
}

const hVt = 1e3, pVt = 10;

class oIe extends aIe {
    constructor() {
        super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (e, r) => this.onStorageEvent(e, r), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = dVt() && szt(), this.fallbackToPolling = $8e(), this._shouldAllowMigration = !0
    }

    forAllChangedKeys(e) {
        for (const r of Object.keys(this.listeners)) {
            const n = this.storage.getItem(r), i = this.localCache[r];
            n !== i && e(r, i, n)
        }
    }

    onStorageEvent(e, r = !1) {
        if (!e.key) {
            this.forAllChangedKeys((o, s, l) => {
                this.notifyListeners(o, l)
            });
            return
        }
        const n = e.key;
        if (r ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
            const o = this.storage.getItem(n);
            if (e.newValue !== o) e.newValue !== null ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n); else if (this.localCache[n] === e.newValue && !r) return
        }
        const i = () => {
            const o = this.storage.getItem(n);
            !r && this.localCache[n] === o || this.notifyListeners(n, o)
        }, a = this.storage.getItem(n);
        ozt() && a !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, pVt) : i()
    }

    notifyListeners(e, r) {
        this.localCache[e] = r;
        const n = this.listeners[e];
        if (n) for (const i of Array.from(n)) i(r && JSON.parse(r))
    }

    startPolling() {
        this.stopPolling(), this.pollTimer = setInterval(() => {
            this.forAllChangedKeys((e, r, n) => {
                this.onStorageEvent(new StorageEvent("storage", {key: e, oldValue: r, newValue: n}), !0)
            })
        }, hVt)
    }

    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
    }

    attachListener() {
        window.addEventListener("storage", this.boundEventHandler)
    }

    detachListener() {
        window.removeEventListener("storage", this.boundEventHandler)
    }

    _addListener(e, r) {
        Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(r)
    }

    _removeListener(e, r) {
        this.listeners[e] && (this.listeners[e].delete(r), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling())
    }

    async _set(e, r) {
        await super._set(e, r), this.localCache[e] = JSON.stringify(r)
    }

    async _get(e) {
        const r = await super._get(e);
        return this.localCache[e] = JSON.stringify(r), r
    }

    async _remove(e) {
        await super._remove(e), delete this.localCache[e]
    }
}

oIe.type = "LOCAL";
const sIe = oIe;

class cIe extends aIe {
    constructor() {
        super(() => window.sessionStorage, "SESSION")
    }

    _addListener(e, r) {
    }

    _removeListener(e, r) {
    }
}

cIe.type = "SESSION";
const jte = cIe;

function mVt(t) {
    return Promise.all(t.map(async e => {
        try {
            return {fulfilled: !0, value: await e}
        } catch (r) {
            return {fulfilled: !1, reason: r}
        }
    }))
}

class pB {
    constructor(e) {
        this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this)
    }

    static _getInstance(e) {
        const r = this.receivers.find(i => i.isListeningto(e));
        if (r) return r;
        const n = new pB(e);
        return this.receivers.push(n), n
    }

    isListeningto(e) {
        return this.eventTarget === e
    }

    async handleEvent(e) {
        const r = e, {eventId: n, eventType: i, data: a} = r.data, o = this.handlersMap[i];
        if (!(o != null && o.size)) return;
        r.ports[0].postMessage({status: "ack", eventId: n, eventType: i});
        const s = Array.from(o).map(async f => f(r.origin, a)), l = await mVt(s);
        r.ports[0].postMessage({status: "done", eventId: n, eventType: i, response: l})
    }

    _subscribe(e, r) {
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(r)
    }

    _unsubscribe(e, r) {
        this.handlersMap[e] && r && this.handlersMap[e].delete(r), (!r || this.handlersMap[e].size === 0) && delete this.handlersMap[e], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler)
    }
}

pB.receivers = [];

function mB(t = "", e = 10) {
    let r = "";
    for (let n = 0; n < e; n++) r += Math.floor(Math.random() * 10);
    return t + r
}

class vVt {
    constructor(e) {
        this.target = e, this.handlers = new Set
    }

    removeMessageHandler(e) {
        e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e)
    }

    async _send(e, r, n = 50) {
        const i = typeof MessageChannel < "u" ? new MessageChannel : null;
        if (!i) throw new Error("connection_unavailable");
        let a, o;
        return new Promise((s, l) => {
            const f = mB("", 20);
            i.port1.start();
            const d = setTimeout(() => {
                l(new Error("unsupported_event"))
            }, n);
            o = {
                messageChannel: i, onMessage(p) {
                    const g = p;
                    if (g.data.eventId === f) switch (g.data.status) {
                        case"ack":
                            clearTimeout(d), a = setTimeout(() => {
                                l(new Error("timeout"))
                            }, 3e3);
                            break;
                        case"done":
                            clearTimeout(a), s(g.data.response);
                            break;
                        default:
                            clearTimeout(d), clearTimeout(a), l(new Error("invalid_response"));
                            break
                    }
                }
            }, this.handlers.add(o), i.port1.addEventListener("message", o.onMessage), this.target.postMessage({
                eventType: e,
                eventId: f,
                data: r
            }, [i.port2])
        }).finally(() => {
            o && this.removeMessageHandler(o)
        })
    }
}

function ks() {
    return window
}

function gVt(t) {
    ks().location.href = t
}

function zte() {
    return typeof ks().WorkerGlobalScope < "u" && typeof ks().importScripts == "function"
}

async function yVt() {
    if (!(navigator != null && navigator.serviceWorker)) return null;
    try {
        return (await navigator.serviceWorker.ready).active
    } catch {
        return null
    }
}

function bVt() {
    var t;
    return ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null
}

function wVt() {
    return zte() ? self : null
}

const lIe = "firebaseLocalStorageDb", SVt = 1, EP = "firebaseLocalStorage", uIe = "fbase_key";

class GI {
    constructor(e) {
        this.request = e
    }

    toPromise() {
        return new Promise((e, r) => {
            this.request.addEventListener("success", () => {
                e(this.request.result)
            }), this.request.addEventListener("error", () => {
                r(this.request.error)
            })
        })
    }
}

function vB(t, e) {
    return t.transaction([EP], e ? "readwrite" : "readonly").objectStore(EP)
}

function _Vt() {
    const t = indexedDB.deleteDatabase(lIe);
    return new GI(t).toPromise()
}

function DY() {
    const t = indexedDB.open(lIe, SVt);
    return new Promise((e, r) => {
        t.addEventListener("error", () => {
            r(t.error)
        }), t.addEventListener("upgradeneeded", () => {
            const n = t.result;
            try {
                n.createObjectStore(EP, {keyPath: uIe})
            } catch (i) {
                r(i)
            }
        }), t.addEventListener("success", async () => {
            const n = t.result;
            n.objectStoreNames.contains(EP) ? e(n) : (n.close(), await _Vt(), e(await DY()))
        })
    })
}

async function Cme(t, e, r) {
    const n = vB(t, !0).put({[uIe]: e, value: r});
    return new GI(n).toPromise()
}

async function xVt(t, e) {
    const r = vB(t, !1).get(e), n = await new GI(r).toPromise();
    return n === void 0 ? null : n.value
}

function Ame(t, e) {
    const r = vB(t, !0).delete(e);
    return new GI(r).toPromise()
}

const EVt = 800, TVt = 3;

class fIe {
    constructor() {
        this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
        }, () => {
        })
    }

    async _openDb() {
        return this.db ? this.db : (this.db = await DY(), this.db)
    }

    async _withRetries(e) {
        let r = 0;
        for (; ;) try {
            const n = await this._openDb();
            return await e(n)
        } catch (n) {
            if (r++ > TVt) throw n;
            this.db && (this.db.close(), this.db = void 0)
        }
    }

    async initializeServiceWorkerMessaging() {
        return zte() ? this.initializeReceiver() : this.initializeSender()
    }

    async initializeReceiver() {
        this.receiver = pB._getInstance(wVt()), this.receiver._subscribe("keyChanged", async (e, r) => ({keyProcessed: (await this._poll()).includes(r.key)})), this.receiver._subscribe("ping", async (e, r) => ["keyChanged"])
    }

    async initializeSender() {
        var e, r;
        if (this.activeServiceWorker = await yVt(), !this.activeServiceWorker) return;
        this.sender = new vVt(this.activeServiceWorker);
        const n = await this.sender._send("ping", {}, 800);
        n && !((e = n[0]) === null || e === void 0) && e.fulfilled && !((r = n[0]) === null || r === void 0) && r.value.includes("keyChanged") && (this.serviceWorkerReceiverAvailable = !0)
    }

    async notifyServiceWorker(e) {
        if (!(!this.sender || !this.activeServiceWorker || bVt() !== this.activeServiceWorker)) try {
            await this.sender._send("keyChanged", {key: e}, this.serviceWorkerReceiverAvailable ? 800 : 50)
        } catch {
        }
    }

    async _isAvailable() {
        try {
            if (!indexedDB) return !1;
            const e = await DY();
            return await Cme(e, xP, "1"), await Ame(e, xP), !0
        } catch {
        }
        return !1
    }

    async _withPendingWrite(e) {
        this.pendingWrites++;
        try {
            await e()
        } finally {
            this.pendingWrites--
        }
    }

    async _set(e, r) {
        return this._withPendingWrite(async () => (await this._withRetries(n => Cme(n, e, r)), this.localCache[e] = r, this.notifyServiceWorker(e)))
    }

    async _get(e) {
        const r = await this._withRetries(n => xVt(n, e));
        return this.localCache[e] = r, r
    }

    async _remove(e) {
        return this._withPendingWrite(async () => (await this._withRetries(r => Ame(r, e)), delete this.localCache[e], this.notifyServiceWorker(e)))
    }

    async _poll() {
        const e = await this._withRetries(i => {
            const a = vB(i, !1).getAll();
            return new GI(a).toPromise()
        });
        if (!e) return [];
        if (this.pendingWrites !== 0) return [];
        const r = [], n = new Set;
        for (const {
            fbase_key: i,
            value: a
        } of e) n.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(a) && (this.notifyListeners(i, a), r.push(i));
        for (const i of Object.keys(this.localCache)) this.localCache[i] && !n.has(i) && (this.notifyListeners(i, null), r.push(i));
        return r
    }

    notifyListeners(e, r) {
        this.localCache[e] = r;
        const n = this.listeners[e];
        if (n) for (const i of Array.from(n)) i(r)
    }

    startPolling() {
        this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), EVt)
    }

    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
    }

    _addListener(e, r) {
        Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(r)
    }

    _removeListener(e, r) {
        this.listeners[e] && (this.listeners[e].delete(r), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && this.stopPolling()
    }
}

fIe.type = "LOCAL";
const dIe = fIe;

function CVt(t, e) {
    return uc(t, "POST", "/v2/accounts/mfaSignIn:start", zs(t, e))
}

function AVt(t, e) {
    return uc(t, "POST", "/v2/accounts/mfaSignIn:finalize", zs(t, e))
}

async function IVt(t) {
    return (await uc(t, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || ""
}

function kVt() {
    var t, e;
    return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null && e !== void 0 ? e : document
}

function hIe(t) {
    return new Promise((e, r) => {
        const n = document.createElement("script");
        n.setAttribute("src", t), n.onload = e, n.onerror = i => {
            const a = Vf("internal-error");
            a.customData = i, r(a)
        }, n.type = "text/javascript", n.charset = "UTF-8", kVt().appendChild(n)
    })
}

function pIe(t) {
    return `__${t}${Math.floor(Math.random() * 1e6)}`
}

const RVt = 500, DVt = 6e4, Q7 = 1e12;

class MVt {
    constructor(e) {
        this.auth = e, this.counter = Q7, this._widgets = new Map
    }

    render(e, r) {
        const n = this.counter;
        return this._widgets.set(n, new OVt(e, this.auth.name, r || {})), this.counter++, n
    }

    reset(e) {
        var r;
        const n = e || Q7;
        (r = this._widgets.get(n)) === null || r === void 0 || r.delete(), this._widgets.delete(n)
    }

    getResponse(e) {
        var r;
        const n = e || Q7;
        return ((r = this._widgets.get(n)) === null || r === void 0 ? void 0 : r.getResponse()) || ""
    }

    async execute(e) {
        var r;
        const n = e || Q7;
        return (r = this._widgets.get(n)) === null || r === void 0 || r.execute(), ""
    }
}

class OVt {
    constructor(e, r, n) {
        this.params = n, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => {
            this.execute()
        };
        const i = typeof e == "string" ? document.getElementById(e) : e;
        Lt(i, "argument-error", {appName: r}), this.container = i, this.isVisible = this.params.size !== "invisible", this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler)
    }

    getResponse() {
        return this.checkIfDeleted(), this.responseToken
    }

    delete() {
        this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler)
    }

    execute() {
        this.checkIfDeleted(), !this.timerId && (this.timerId = window.setTimeout(() => {
            this.responseToken = PVt(50);
            const {callback: e, "expired-callback": r} = this.params;
            if (e) try {
                e(this.responseToken)
            } catch {
            }
            this.timerId = window.setTimeout(() => {
                if (this.timerId = null, this.responseToken = null, r) try {
                    r()
                } catch {
                }
                this.isVisible && this.execute()
            }, DVt)
        }, RVt))
    }

    checkIfDeleted() {
        if (this.deleted) throw new Error("reCAPTCHA mock was already deleted!")
    }
}

function PVt(t) {
    const e = [], r = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (let n = 0; n < t; n++) e.push(r.charAt(Math.floor(Math.random() * r.length)));
    return e.join("")
}

const QH = pIe("rcb"), NVt = new qI(3e4, 6e4), LVt = "https://www.google.com/recaptcha/api.js?";

class BVt {
    constructor() {
        var e;
        this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !!(!((e = ks().grecaptcha) === null || e === void 0) && e.render)
    }

    load(e, r = "") {
        return Lt($Vt(r), e, "argument-error"), this.shouldResolveImmediately(r) ? Promise.resolve(ks().grecaptcha) : new Promise((n, i) => {
            const a = ks().setTimeout(() => {
                i(Vf(e, "network-request-failed"))
            }, NVt.get());
            ks()[QH] = () => {
                ks().clearTimeout(a), delete ks()[QH];
                const s = ks().grecaptcha;
                if (!s) {
                    i(Vf(e, "internal-error"));
                    return
                }
                const l = s.render;
                s.render = (f, d) => {
                    const p = l(f, d);
                    return this.counter++, p
                }, this.hostLanguage = r, n(s)
            };
            const o = `${LVt}?${s3({onload: QH, render: "explicit", hl: r})}`;
            hIe(o).catch(() => {
                clearTimeout(a), i(Vf(e, "internal-error"))
            })
        })
    }

    clearedOneInstance() {
        this.counter--
    }

    shouldResolveImmediately(e) {
        var r;
        return !!(!((r = ks().grecaptcha) === null || r === void 0) && r.render) && (e === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded)
    }
}

function $Vt(t) {
    return t.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(t)
}

class FVt {
    async load(e) {
        return new MVt(e)
    }

    clearedOneInstance() {
    }
}

const mIe = "recaptcha", UVt = {theme: "light", type: "image"};

class jVt {
    constructor(e, r = Object.assign({}, UVt), n) {
        this.parameters = r, this.type = mIe, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = new Set, this.renderPromise = null, this.recaptcha = null, this.auth = xu(n), this.isInvisible = this.parameters.size === "invisible", Lt(typeof document < "u", this.auth, "operation-not-supported-in-this-environment");
        const i = typeof e == "string" ? document.getElementById(e) : e;
        Lt(i, this.auth, "argument-error"), this.container = i, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new FVt : new BVt, this.validateStartingState()
    }

    async verify() {
        this.assertNotDestroyed();
        const e = await this.render(), r = this.getAssertedRecaptcha(), n = r.getResponse(e);
        return n || new Promise(i => {
            const a = o => {
                o && (this.tokenChangeListeners.delete(a), i(o))
            };
            this.tokenChangeListeners.add(a), this.isInvisible && r.execute(e)
        })
    }

    render() {
        try {
            this.assertNotDestroyed()
        } catch (e) {
            return Promise.reject(e)
        }
        return this.renderPromise ? this.renderPromise : (this.renderPromise = this.makeRenderPromise().catch(e => {
            throw this.renderPromise = null, e
        }), this.renderPromise)
    }

    _reset() {
        this.assertNotDestroyed(), this.widgetId !== null && this.getAssertedRecaptcha().reset(this.widgetId)
    }

    clear() {
        this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach(e => {
            this.container.removeChild(e)
        })
    }

    validateStartingState() {
        Lt(!this.parameters.sitekey, this.auth, "argument-error"), Lt(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"), Lt(typeof document < "u", this.auth, "operation-not-supported-in-this-environment")
    }

    makeTokenCallback(e) {
        return r => {
            if (this.tokenChangeListeners.forEach(n => n(r)), typeof e == "function") e(r); else if (typeof e == "string") {
                const n = ks()[e];
                typeof n == "function" && n(r)
            }
        }
    }

    assertNotDestroyed() {
        Lt(!this.destroyed, this.auth, "internal-error")
    }

    async makeRenderPromise() {
        if (await this.init(), !this.widgetId) {
            let e = this.container;
            if (!this.isInvisible) {
                const r = document.createElement("div");
                e.appendChild(r), e = r
            }
            this.widgetId = this.getAssertedRecaptcha().render(e, this.parameters)
        }
        return this.widgetId
    }

    async init() {
        Lt(Pte() && !zte(), this.auth, "internal-error"), await zVt(), this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0);
        const e = await IVt(this.auth);
        Lt(e, this.auth, "internal-error"), this.parameters.sitekey = e
    }

    getAssertedRecaptcha() {
        return Lt(this.recaptcha, this.auth, "internal-error"), this.recaptcha
    }
}

function zVt() {
    let t = null;
    return new Promise(e => {
        if (document.readyState === "complete") {
            e();
            return
        }
        t = () => e(), window.addEventListener("load", t)
    }).catch(e => {
        throw t && window.removeEventListener("load", t), e
    })
}

class Vte {
    constructor(e, r) {
        this.verificationId = e, this.onConfirmation = r
    }

    confirm(e) {
        const r = qy._fromVerification(this.verificationId, e);
        return this.onConfirmation(r)
    }
}

async function VVt(t, e, r) {
    const n = xu(t), i = await gB(n, e, Tr(r));
    return new Vte(i, a => fB(n, a))
}

async function HVt(t, e, r) {
    const n = Tr(t);
    await uB(!1, n, "phone");
    const i = await gB(n.auth, e, Tr(r));
    return new Vte(i, a => X8e(n, a))
}

async function WVt(t, e, r) {
    const n = Tr(t), i = await gB(n.auth, e, Tr(r));
    return new Vte(i, a => Q8e(n, a))
}

async function gB(t, e, r) {
    var n;
    const i = await r.verify();
    try {
        Lt(typeof i == "string", t, "argument-error"), Lt(r.type === mIe, t, "argument-error");
        let a;
        if (typeof e == "string" ? a = {phoneNumber: e} : a = e, "session" in a) {
            const o = a.session;
            if ("phoneNumber" in a) return Lt(o.type === "enroll", t, "internal-error"), (await cVt(t, {
                idToken: o.credential,
                phoneEnrollmentInfo: {phoneNumber: a.phoneNumber, recaptchaToken: i}
            })).phoneSessionInfo.sessionInfo;
            {
                Lt(o.type === "signin", t, "internal-error");
                const s = ((n = a.multiFactorHint) === null || n === void 0 ? void 0 : n.uid) || a.multiFactorUid;
                return Lt(s, t, "missing-multi-factor-info"), (await CVt(t, {
                    mfaPendingCredential: o.credential,
                    mfaEnrollmentId: s,
                    phoneSignInInfo: {recaptchaToken: i}
                })).phoneResponseInfo.sessionInfo
            }
        } else {
            const {sessionInfo: o} = await Szt(t, {phoneNumber: a.phoneNumber, recaptchaToken: i});
            return o
        }
    } finally {
        r._reset()
    }
}

async function qVt(t, e) {
    await Bte(Tr(t), e)
}

class Jw {
    constructor(e) {
        this.providerId = Jw.PROVIDER_ID, this.auth = xu(e)
    }

    verifyPhoneNumber(e, r) {
        return gB(this.auth, e, Tr(r))
    }

    static credential(e, r) {
        return qy._fromVerification(e, r)
    }

    static credentialFromResult(e) {
        const r = e;
        return Jw.credentialFromTaggedObject(r)
    }

    static credentialFromError(e) {
        return Jw.credentialFromTaggedObject(e.customData || {})
    }

    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e) return null;
        const {phoneNumber: r, temporaryProof: n} = e;
        return r && n ? qy._fromTokenResponse(r, n) : null
    }
}

Jw.PROVIDER_ID = "phone";
Jw.PHONE_SIGN_IN_METHOD = "phone";

function r2(t, e) {
    return e ? vv(e) : (Lt(t._popupRedirectResolver, t, "argument-error"), t._popupRedirectResolver)
}

class Hte extends x3 {
    constructor(e) {
        super("custom", "custom"), this.params = e
    }

    _getIdTokenResponse(e) {
        return Av(e, this._buildIdpRequest())
    }

    _linkToIdToken(e, r) {
        return Av(e, this._buildIdpRequest(r))
    }

    _getReauthenticationResolver(e) {
        return Av(e, this._buildIdpRequest())
    }

    _buildIdpRequest(e) {
        const r = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: !0,
            returnIdpCredential: !0
        };
        return e && (r.idToken = e), r
    }
}

function GVt(t) {
    return Y8e(t.auth, new Hte(t), t.bypassAuthState)
}

function KVt(t) {
    const {auth: e, user: r} = t;
    return Lt(r, e, "internal-error"), K8e(r, new Hte(t), t.bypassAuthState)
}

async function YVt(t) {
    const {auth: e, user: r} = t;
    return Lt(r, e, "internal-error"), Bte(r, new Hte(t), t.bypassAuthState)
}

class vIe {
    constructor(e, r, n, i, a = !1) {
        this.auth = e, this.resolver = n, this.user = i, this.bypassAuthState = a, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(r) ? r : [r]
    }

    execute() {
        return new Promise(async (e, r) => {
            this.pendingPromise = {resolve: e, reject: r};
            try {
                this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this)
            } catch (n) {
                this.reject(n)
            }
        })
    }

    async onAuthEvent(e) {
        const {urlResponse: r, sessionId: n, postBody: i, tenantId: a, error: o, type: s} = e;
        if (o) {
            this.reject(o);
            return
        }
        const l = {
            auth: this.auth,
            requestUri: r,
            sessionId: n,
            tenantId: a || void 0,
            postBody: i || void 0,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(s)(l))
        } catch (f) {
            this.reject(f)
        }
    }

    onError(e) {
        this.reject(e)
    }

    getIdpTask(e) {
        switch (e) {
            case"signInViaPopup":
            case"signInViaRedirect":
                return GVt;
            case"linkViaPopup":
            case"linkViaRedirect":
                return YVt;
            case"reauthViaPopup":
            case"reauthViaRedirect":
                return KVt;
            default:
                ff(this.auth, "internal-error")
        }
    }

    resolve(e) {
        Hv(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp()
    }

    reject(e) {
        Hv(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp()
    }

    unregisterAndCleanUp() {
        this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp()
    }
}

const XVt = new qI(2e3, 1e4);

async function QVt(t, e, r) {
    const n = xu(t);
    _3(t, e, sg);
    const i = r2(n, r);
    return new gv(n, "signInViaPopup", e, i).executeNotNull()
}

async function ZVt(t, e, r) {
    const n = Tr(t);
    _3(n.auth, e, sg);
    const i = r2(n.auth, r);
    return new gv(n.auth, "reauthViaPopup", e, i, n).executeNotNull()
}

async function JVt(t, e, r) {
    const n = Tr(t);
    _3(n.auth, e, sg);
    const i = r2(n.auth, r);
    return new gv(n.auth, "linkViaPopup", e, i, n).executeNotNull()
}

class gv extends vIe {
    constructor(e, r, n, i, a) {
        super(e, r, i, a), this.provider = n, this.authWindow = null, this.pollId = null, gv.currentPopupAction && gv.currentPopupAction.cancel(), gv.currentPopupAction = this
    }

    async executeNotNull() {
        const e = await this.execute();
        return Lt(e, this.auth, "internal-error"), e
    }

    async onExecution() {
        Hv(this.filter.length === 1, "Popup operations only handle one event");
        const e = mB();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch(r => {
            this.reject(r)
        }), this.resolver._isIframeWebStorageSupported(this.auth, r => {
            r || this.reject(Vf(this.auth, "web-storage-unsupported"))
        }), this.pollUserCancellation()
    }

    get eventId() {
        var e;
        return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null
    }

    cancel() {
        this.reject(Vf(this.auth, "cancelled-popup-request"))
    }

    cleanUp() {
        this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, gv.currentPopupAction = null
    }

    pollUserCancellation() {
        const e = () => {
            var r, n;
            if (!((n = (r = this.authWindow) === null || r === void 0 ? void 0 : r.window) === null || n === void 0) && n.closed) {
                this.pollId = window.setTimeout(() => {
                    this.pollId = null, this.reject(Vf(this.auth, "popup-closed-by-user"))
                }, 2e3);
                return
            }
            this.pollId = window.setTimeout(e, XVt.get())
        };
        e()
    }
}

gv.currentPopupAction = null;
const eHt = "pendingRedirect", vM = new Map;

class tHt extends vIe {
    constructor(e, r, n = !1) {
        super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], r, void 0, n), this.eventId = null
    }

    async execute() {
        let e = vM.get(this.auth._key());
        if (!e) {
            try {
                const n = await rHt(this.resolver, this.auth) ? await super.execute() : null;
                e = () => Promise.resolve(n)
            } catch (r) {
                e = () => Promise.reject(r)
            }
            vM.set(this.auth._key(), e)
        }
        return this.bypassAuthState || vM.set(this.auth._key(), () => Promise.resolve(null)), e()
    }

    async onAuthEvent(e) {
        if (e.type === "signInViaRedirect") return super.onAuthEvent(e);
        if (e.type === "unknown") {
            this.resolve(null);
            return
        }
        if (e.eventId) {
            const r = await this.auth._redirectUserForId(e.eventId);
            if (r) return this.user = r, super.onAuthEvent(e);
            this.resolve(null)
        }
    }

    async onExecution() {
    }

    cleanUp() {
    }
}

async function rHt(t, e) {
    const r = yIe(e), n = gIe(t);
    if (!await n._isAvailable()) return !1;
    const i = await n._get(r) === "true";
    return await n._remove(r), i
}

async function Wte(t, e) {
    return gIe(t)._set(yIe(e), "true")
}

function nHt(t, e) {
    vM.set(t._key(), e)
}

function gIe(t) {
    return vv(t._redirectPersistence)
}

function yIe(t) {
    return mM(eHt, t.config.apiKey, t.name)
}

function iHt(t, e, r) {
    return aHt(t, e, r)
}

async function aHt(t, e, r) {
    const n = xu(t);
    _3(t, e, sg), await n._initializationPromise;
    const i = r2(n, r);
    return await Wte(i, n), i._openRedirect(n, e, "signInViaRedirect")
}

function oHt(t, e, r) {
    return sHt(t, e, r)
}

async function sHt(t, e, r) {
    const n = Tr(t);
    _3(n.auth, e, sg), await n.auth._initializationPromise;
    const i = r2(n.auth, r);
    await Wte(i, n.auth);
    const a = await wIe(n);
    return i._openRedirect(n.auth, e, "reauthViaRedirect", a)
}

function cHt(t, e, r) {
    return lHt(t, e, r)
}

async function lHt(t, e, r) {
    const n = Tr(t);
    _3(n.auth, e, sg), await n.auth._initializationPromise;
    const i = r2(n.auth, r);
    await uB(!1, n, e.providerId), await Wte(i, n.auth);
    const a = await wIe(n);
    return i._openRedirect(n.auth, e, "linkViaRedirect", a)
}

async function uHt(t, e) {
    return await xu(t)._initializationPromise, bIe(t, e, !1)
}

async function bIe(t, e, r = !1) {
    const n = xu(t), i = r2(n, e), o = await new tHt(n, i, r).execute();
    return o && !r && (delete o.user._redirectEventId, await n._persistUserIfCurrent(o.user), await n._setRedirectUser(null, e)), o
}

async function wIe(t) {
    const e = mB(`${t.uid}:::`);
    return t._redirectEventId = e, await t.auth._setRedirectUser(t), await t.auth._persistUserIfCurrent(t), e
}

const fHt = 10 * 60 * 1e3;

class dHt {
    constructor(e) {
        this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now()
    }

    registerConsumer(e) {
        this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null)
    }

    unregisterConsumer(e) {
        this.consumers.delete(e)
    }

    onEvent(e) {
        if (this.hasEventBeenHandled(e)) return !1;
        let r = !1;
        return this.consumers.forEach(n => {
            this.isEventForConsumer(e, n) && (r = !0, this.sendToConsumer(e, n), this.saveEventToCache(e))
        }), this.hasHandledPotentialRedirect || !hHt(e) || (this.hasHandledPotentialRedirect = !0, r || (this.queuedRedirectEvent = e, r = !0)), r
    }

    sendToConsumer(e, r) {
        var n;
        if (e.error && !SIe(e)) {
            const i = ((n = e.error.code) === null || n === void 0 ? void 0 : n.split("auth/")[1]) || "internal-error";
            r.onError(Vf(this.auth, i))
        } else r.onAuthEvent(e)
    }

    isEventForConsumer(e, r) {
        const n = r.eventId === null || !!e.eventId && e.eventId === r.eventId;
        return r.filter.includes(e.type) && n
    }

    hasEventBeenHandled(e) {
        return Date.now() - this.lastProcessedEventTime >= fHt && this.cachedEventUids.clear(), this.cachedEventUids.has(Ime(e))
    }

    saveEventToCache(e) {
        this.cachedEventUids.add(Ime(e)), this.lastProcessedEventTime = Date.now()
    }
}

function Ime(t) {
    return [t.type, t.eventId, t.sessionId, t.tenantId].filter(e => e).join("-")
}

function SIe({type: t, error: e}) {
    return t === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event"
}

function hHt(t) {
    switch (t.type) {
        case"signInViaRedirect":
        case"linkViaRedirect":
        case"reauthViaRedirect":
            return !0;
        case"unknown":
            return SIe(t);
        default:
            return !1
    }
}

async function pHt(t, e = {}) {
    return uc(t, "GET", "/v1/projects", e)
}

const mHt = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, vHt = /^https?/;

async function gHt(t) {
    if (t.config.emulator) return;
    const {authorizedDomains: e} = await pHt(t);
    for (const r of e) try {
        if (yHt(r)) return
    } catch {
    }
    ff(t, "unauthorized-domain")
}

function yHt(t) {
    const e = n8(), {protocol: r, hostname: n} = new URL(e);
    if (t.startsWith("chrome-extension://")) {
        const o = new URL(t);
        return o.hostname === "" && n === "" ? r === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : r === "chrome-extension:" && o.hostname === n
    }
    if (!vHt.test(r)) return !1;
    if (mHt.test(t)) return n === t;
    const i = t.replace(/\./g, "\\.");
    return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(n)
}

const bHt = new qI(3e4, 6e4);

function kme() {
    const t = ks().___jsl;
    if (t != null && t.H) {
        for (const e of Object.keys(t.H)) if (t.H[e].r = t.H[e].r || [], t.H[e].L = t.H[e].L || [], t.H[e].r = [...t.H[e].L], t.CP) for (let r = 0; r < t.CP.length; r++) t.CP[r] = null
    }
}

function wHt(t) {
    return new Promise((e, r) => {
        var n, i, a;

        function o() {
            kme(), gapi.load("gapi.iframes", {
                callback: () => {
                    e(gapi.iframes.getContext())
                }, ontimeout: () => {
                    kme(), r(Vf(t, "network-request-failed"))
                }, timeout: bHt.get()
            })
        }

        if (!((i = (n = ks().gapi) === null || n === void 0 ? void 0 : n.iframes) === null || i === void 0) && i.Iframe) e(gapi.iframes.getContext()); else if (!((a = ks().gapi) === null || a === void 0) && a.load) o(); else {
            const s = pIe("iframefcb");
            return ks()[s] = () => {
                gapi.load ? o() : r(Vf(t, "network-request-failed"))
            }, hIe(`https://apis.google.com/js/api.js?onload=${s}`).catch(l => r(l))
        }
    }).catch(e => {
        throw gM = null, e
    })
}

let gM = null;

function SHt(t) {
    return gM = gM || wHt(t), gM
}

const _Ht = new qI(5e3, 15e3), xHt = "__/auth/iframe", EHt = "emulator/auth/iframe", THt = {
        style: {position: "absolute", top: "-100px", width: "1px", height: "1px"},
        "aria-hidden": "true",
        tabindex: "-1"
    },
    CHt = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]);

function AHt(t) {
    const e = t.config;
    Lt(e.authDomain, t, "auth-domain-config-required");
    const r = e.emulator ? Nte(e, EHt) : `https://${t.config.authDomain}/${xHt}`,
        n = {apiKey: e.apiKey, appName: t.name, v: _I}, i = CHt.get(t.config.apiHost);
    i && (n.eid = i);
    const a = t._getFrameworks();
    return a.length && (n.fw = a.join(",")), `${r}?${s3(n).slice(1)}`
}

async function IHt(t) {
    const e = await SHt(t), r = ks().gapi;
    return Lt(r, t, "internal-error"), e.open({
        where: document.body,
        url: AHt(t),
        messageHandlersFilter: r.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: THt,
        dontclear: !0
    }, n => new Promise(async (i, a) => {
        await n.restyle({setHideOnLeave: !1});
        const o = Vf(t, "network-request-failed"), s = ks().setTimeout(() => {
            a(o)
        }, _Ht.get());

        function l() {
            ks().clearTimeout(s), i(n)
        }

        n.ping(l).then(l, () => {
            a(o)
        })
    }))
}

const kHt = {location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no"}, RHt = 500, DHt = 600, MHt = "_blank",
    OHt = "http://localhost";

class Rme {
    constructor(e) {
        this.window = e, this.associatedEvent = null
    }

    close() {
        if (this.window) try {
            this.window.close()
        } catch {
        }
    }
}

function PHt(t, e, r, n = RHt, i = DHt) {
    const a = Math.max((window.screen.availHeight - i) / 2, 0).toString(),
        o = Math.max((window.screen.availWidth - n) / 2, 0).toString();
    let s = "";
    const l = Object.assign(Object.assign({}, kHt), {width: n.toString(), height: i.toString(), top: a, left: o}),
        f = $s().toLowerCase();
    r && (s = O8e(f) ? MHt : r), M8e(f) && (e = e || OHt, l.scrollbars = "yes");
    const d = Object.entries(l).reduce((g, [b, S]) => `${g}${b}=${S},`, "");
    if (azt(f) && s !== "_self") return NHt(e || "", s), new Rme(null);
    const p = window.open(e || "", s, d);
    Lt(p, t, "popup-blocked");
    try {
        p.focus()
    } catch {
    }
    return new Rme(p)
}

function NHt(t, e) {
    const r = document.createElement("a");
    r.href = t, r.target = e;
    const n = document.createEvent("MouseEvent");
    n.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), r.dispatchEvent(n)
}

const LHt = "__/auth/handler", BHt = "emulator/auth/handler";

function Dme(t, e, r, n, i, a) {
    Lt(t.config.authDomain, t, "auth-domain-config-required"), Lt(t.config.apiKey, t, "invalid-api-key");
    const o = {apiKey: t.config.apiKey, appName: t.name, authType: r, redirectUrl: n, v: _I, eventId: i};
    if (e instanceof sg) {
        e.setDefaultLanguage(t.languageCode), o.providerId = e.providerId || "", gNt(e.getCustomParameters()) || (o.customParameters = JSON.stringify(e.getCustomParameters()));
        for (const [l, f] of Object.entries(a || {})) o[l] = f
    }
    if (e instanceof T3) {
        const l = e.getScopes().filter(f => f !== "");
        l.length > 0 && (o.scopes = l.join(","))
    }
    t.tenantId && (o.tid = t.tenantId);
    const s = o;
    for (const l of Object.keys(s)) s[l] === void 0 && delete s[l];
    return `${$Ht(t)}?${s3(s).slice(1)}`
}

function $Ht({config: t}) {
    return t.emulator ? Nte(t, BHt) : `https://${t.authDomain}/${LHt}`
}

const ZH = "webStorageSupport";

class FHt {
    constructor() {
        this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = jte, this._completeRedirectFn = bIe, this._overrideRedirectResult = nHt
    }

    async _openPopup(e, r, n, i) {
        var a;
        Hv((a = this.eventManagers[e._key()]) === null || a === void 0 ? void 0 : a.manager, "_initialize() not called before _openPopup()");
        const o = Dme(e, r, n, n8(), i);
        return PHt(e, o, mB())
    }

    async _openRedirect(e, r, n, i) {
        return await this._originValidation(e), gVt(Dme(e, r, n, n8(), i)), new Promise(() => {
        })
    }

    _initialize(e) {
        const r = e._key();
        if (this.eventManagers[r]) {
            const {manager: i, promise: a} = this.eventManagers[r];
            return i ? Promise.resolve(i) : (Hv(a, "If manager is not set, promise should be"), a)
        }
        const n = this.initAndGetManager(e);
        return this.eventManagers[r] = {promise: n}, n.catch(() => {
            delete this.eventManagers[r]
        }), n
    }

    async initAndGetManager(e) {
        const r = await IHt(e), n = new dHt(e);
        return r.register("authEvent", i => (Lt(i == null ? void 0 : i.authEvent, e, "invalid-auth-event"), {status: n.onEvent(i.authEvent) ? "ACK" : "ERROR"}), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = {manager: n}, this.iframes[e._key()] = r, n
    }

    _isIframeWebStorageSupported(e, r) {
        this.iframes[e._key()].send(ZH, {type: ZH}, i => {
            var a;
            const o = (a = i == null ? void 0 : i[0]) === null || a === void 0 ? void 0 : a[ZH];
            o !== void 0 && r(!!o), ff(e, "internal-error")
        }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
    }

    _originValidation(e) {
        const r = e._key();
        return this.originValidationPromises[r] || (this.originValidationPromises[r] = gHt(e)), this.originValidationPromises[r]
    }

    get _shouldInitProactively() {
        return $8e() || Lte() || cB()
    }
}

const _Ie = FHt;

class UHt {
    constructor(e) {
        this.factorId = e
    }

    _process(e, r, n) {
        switch (r.type) {
            case"enroll":
                return this._finalizeEnroll(e, r.credential, n);
            case"signin":
                return this._finalizeSignIn(e, r.credential);
            default:
                return I0("unexpected MultiFactorSessionType")
        }
    }
}

class qte extends UHt {
    constructor(e) {
        super("phone"), this.credential = e
    }

    static _fromCredential(e) {
        return new qte(e)
    }

    _finalizeEnroll(e, r, n) {
        return lVt(e, {idToken: r, displayName: n, phoneVerificationInfo: this.credential._makeVerificationRequest()})
    }

    _finalizeSignIn(e, r) {
        return AVt(e, {mfaPendingCredential: r, phoneVerificationInfo: this.credential._makeVerificationRequest()})
    }
}

class xIe {
    constructor() {
    }

    static assertion(e) {
        return qte._fromCredential(e)
    }
}

xIe.FACTOR_ID = "phone";
var Mme = "@firebase/auth", Ome = "0.21.3";

class jHt {
    constructor(e) {
        this.auth = e, this.internalListeners = new Map
    }

    getUid() {
        var e;
        return this.assertAuthConfigured(), ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null
    }

    async getToken(e) {
        return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? {accessToken: await this.auth.currentUser.getIdToken(e)} : null
    }

    addAuthTokenListener(e) {
        if (this.assertAuthConfigured(), this.internalListeners.has(e)) return;
        const r = this.auth.onIdTokenChanged(n => {
            e((n == null ? void 0 : n.stsTokenManager.accessToken) || null)
        });
        this.internalListeners.set(e, r), this.updateProactiveRefresh()
    }

    removeAuthTokenListener(e) {
        this.assertAuthConfigured();
        const r = this.internalListeners.get(e);
        r && (this.internalListeners.delete(e), r(), this.updateProactiveRefresh())
    }

    assertAuthConfigured() {
        Lt(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
    }

    updateProactiveRefresh() {
        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
    }
}

function zHt(t) {
    switch (t) {
        case"Node":
            return "node";
        case"ReactNative":
            return "rn";
        case"Worker":
            return "webworker";
        case"Cordova":
            return "cordova";
        default:
            return
    }
}

function VHt(t) {
    dE(new vS("auth", (e, {options: r}) => {
        const n = e.getProvider("app").getImmediate(), i = e.getProvider("heartbeat"), {
            apiKey: a,
            authDomain: o
        } = n.options;
        return ((s, l) => {
            Lt(a && !a.includes(":"), "invalid-api-key", {appName: s.name}), Lt(!(o != null && o.includes(":")), "argument-error", {appName: s.name});
            const f = {
                apiKey: a,
                authDomain: o,
                clientPlatform: t,
                apiHost: "identitytoolkit.googleapis.com",
                tokenApiHost: "securetoken.googleapis.com",
                apiScheme: "https",
                sdkClientVersion: F8e(t)
            }, d = new lzt(s, l, f);
            return Vjt(d, r), d
        })(n, i)
    }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, r, n) => {
        e.getProvider("auth-internal").initialize()
    })), dE(new vS("auth-internal", e => {
        const r = xu(e.getProvider("auth").getImmediate());
        return (n => new jHt(n))(r)
    }, "PRIVATE").setInstantiationMode("EXPLICIT")), Kw(Mme, Ome, zHt(t)), Kw(Mme, Ome, "esm2017")
}

const HHt = 5 * 60, WHt = J5e("authIdTokenMaxAge") || HHt;
let Pme = null;
const qHt = t => async e => {
    const r = e && await e.getIdTokenResult(), n = r && (new Date().getTime() - Date.parse(r.issuedAtTime)) / 1e3;
    if (n && n > WHt) return;
    const i = r == null ? void 0 : r.token;
    Pme !== i && (Pme = i, await fetch(t, {
        method: i ? "POST" : "DELETE",
        headers: i ? {Authorization: `Bearer ${i}`} : {}
    }))
};

function GHt(t = iTe()) {
    const e = SI(t, "auth");
    if (e.isInitialized()) return e.getImmediate();
    const r = E8e(t, {popupRedirectResolver: _Ie, persistence: [dIe, sIe, jte]}), n = J5e("authTokenSyncURL");
    if (n) {
        const a = qHt(n);
        nIe(r, a, () => a(r.currentUser)), rIe(r, o => a(o))
    }
    const i = Z5e("auth");
    return i && U8e(r, `http://${i}`), r
}

VHt("Browser");
const KHt = Object.freeze(Object.defineProperty({
    __proto__: null,
    ActionCodeOperation: Fjt,
    ActionCodeURL: E3,
    AuthCredential: x3,
    AuthErrorCodes: zjt,
    EmailAuthCredential: CE,
    EmailAuthProvider: N1,
    FacebookAuthProvider: sv,
    FactorId: Njt,
    GithubAuthProvider: lv,
    GoogleAuthProvider: cv,
    OAuthCredential: Y0,
    OAuthProvider: DC,
    OperationType: $jt,
    PhoneAuthCredential: qy,
    PhoneAuthProvider: Jw,
    PhoneMultiFactorGenerator: xIe,
    ProviderId: Ljt,
    RecaptchaVerifier: jVt,
    SAMLAuthProvider: SP,
    SignInMethod: Bjt,
    TwitterAuthProvider: uv,
    applyActionCode: Nzt,
    beforeAuthStateChanged: nIe,
    browserLocalPersistence: sIe,
    browserPopupRedirectResolver: _Ie,
    browserSessionPersistence: jte,
    checkActionCode: J8e,
    confirmPasswordReset: Pzt,
    connectAuthEmulator: U8e,
    createUserWithEmailAndPassword: Bzt,
    debugErrorMap: jjt,
    deleteUser: oVt,
    fetchSignInMethodsForEmail: Vzt,
    getAdditionalUserInfo: tVt,
    getAuth: GHt,
    getIdToken: Zjt,
    getIdTokenResult: I8e,
    getMultiFactorResolver: sVt,
    getRedirectResult: uHt,
    inMemoryPersistence: RY,
    indexedDBLocalPersistence: dIe,
    initializeAuth: E8e,
    isSignInWithEmailLink: Uzt,
    linkWithCredential: X8e,
    linkWithPhoneNumber: HVt,
    linkWithPopup: JVt,
    linkWithRedirect: cHt,
    multiFactor: fVt,
    onAuthStateChanged: nVt,
    onIdTokenChanged: rIe,
    parseActionCodeURL: Izt,
    prodErrorMap: S8e,
    reauthenticateWithCredential: Q8e,
    reauthenticateWithPhoneNumber: WVt,
    reauthenticateWithPopup: ZVt,
    reauthenticateWithRedirect: oHt,
    reload: R8e,
    sendEmailVerification: Hzt,
    sendPasswordResetEmail: Ozt,
    sendSignInLinkToEmail: Fzt,
    setPersistence: rVt,
    signInAnonymously: W8e,
    signInWithCredential: fB,
    signInWithCustomToken: Z8e,
    signInWithEmailAndPassword: $zt,
    signInWithEmailLink: jzt,
    signInWithPhoneNumber: VVt,
    signInWithPopup: QVt,
    signInWithRedirect: iHt,
    signOut: iIe,
    unlink: Dzt,
    updateCurrentUser: aVt,
    updateEmail: Kzt,
    updatePassword: Yzt,
    updatePhoneNumber: qVt,
    updateProfile: Gzt,
    useDeviceLanguage: iVt,
    verifyBeforeUpdateEmail: Wzt,
    verifyPasswordResetCode: Lzt
}, Symbol.toStringTag, {value: "Module"})), YHt = pt(Y5e, sr, (t, e) => ({
    currentUser: new ia(n => t.onAuthStateChanged({
        next: i => n.next(i), error: i => {
            e.error({event: {id: "failedOnQueryingAuthenticatedUser", data: {error: i}}}), n.error(i)
        }, complete: () => n.complete()
    })).pipe(PE(), zn(n => n ? {id: n.uid, email: n.email ?? void 0} : void 0), Xa),
    signInAnonymously: () => Ly(() => W8e(t)).pipe(zn(n => ({id: n.user.uid, email: n.user.email ?? void 0}))),
    signWithCustomToken: n => Ly(async () => {
        await Z8e(t, n).catch(i => {
            throw e.error({event: {id: "failedOnSigningWithCustomToken", data: {error: i}}}), i
        })
    }),
    signOut: () => Ly(() => iIe(t).catch(n => {
        throw e.error({event: {id: "failedOnSigningOut", data: {error: n}}}), n
    })),
    deleteUser: () => Dye
})), XHt = pt(Ra, sr, (t, e) => {
    const r = id(t, aOt);
    return {
        async findByUserId(n) {
            const i = [], a = Qa(r, Li("userId", "==", n)), o = await gu(a).catch(s => {
                e.error({event: {id: "failedOnFindingChartStudyTemplatesByUserId", data: {userId: n, error: s}}})
            });
            return o ? (o.forEach(s => {
                const l = s.data({serverTimestamps: "estimate"}), f = pMt.safeParse({...l, id: s.id});
                f.success ? i.push(f.data) : e.error({
                    event: {
                        id: "failedOnParsingChartStudyTemplateEntity",
                        data: {error: f.error}
                    }
                })
            }), i) : []
        }, async create(n, i) {
            await im(r, {
                schemaVersion: i.schemaVersion,
                userId: n,
                name: i.name,
                content: i.content,
                createdAt: Ti(),
                updatedAt: Ti()
            }).catch(a => {
                e.error({event: {id: "failedOnCreatingChartStudyTemplates", data: {userId: n, error: a, input: i}}})
            })
        }, async update(n) {
            await zf(ua(r, n.id), {...n.input, updatedAt: Ti()}).catch(i => {
                e.error({
                    event: {
                        id: "failedOnUpdatingChartStudyTemplates",
                        data: {error: i, userId: n.userId, input: n.input}
                    }
                })
            })
        }, async delete(n) {
            await ic(ua(r, n)).catch(i => {
                e.error({event: {id: "failedOnDeletingAChartStudyTemplate", data: {id: n, error: i}}})
            })
        }, async deleteAllByUserId(n) {
            const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                e.error({event: {id: "failedGettingChartStudyTemplates", data: {userId: n, error: o}}})
            });
            if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                e.error({event: {id: "failedDeletingChartStudyTemplates", data: {id: o.id, userId: n, error: s}}})
            })
        }
    }
}), QHt = pt(Ra, sr, (t, e) => {
    const r = id(t, oOt);
    return {
        findByUserIdSnapshot(n) {
            const i = Qa(r, Li("userId", "==", n.userId), Qw("updatedAt", "desc"), w3(1));
            return Ip(i, a => {
                const o = [];
                for (const s of a.docs) {
                    const l = s.data({serverTimestamps: "estimate"}), f = gMt.safeParse({...l, id: s.id});
                    f.success ? o.push(f.data) : e.error({
                        event: {
                            id: "failedOnParsingGlobalChartSettingsEntity",
                            data: {userId: n.userId, error: f.error}
                        }
                    })
                }
                n.onResult(o[0])
            }, a => {
                a.code !== "permission-denied" && (e.error({
                    event: {
                        id: "failedOnQueryingGlobalChartSettings",
                        data: {userId: n.userId, error: a}
                    }
                }), n.onError(a))
            })
        }, async create(n, i) {
            await kY(ua(r, n), {
                schemaVersion: i.schemaVersion,
                userId: n,
                settings: i.settings,
                createdAt: Ti(),
                updatedAt: Ti()
            }).catch(a => {
                e.error({event: {id: "failedOnCreatingGlobalChartSettings", data: {userId: n, error: a, input: i}}})
            })
        }, async update(n) {
            await kY(ua(r, n.userId), {
                schemaVersion: n.input.schemaVersion,
                userId: n.userId,
                settings: n.input.settings,
                createdAt: n.input.createdAt,
                updatedAt: Ti()
            }).catch(i => {
                e.error({
                    event: {
                        id: "failedOnUpdatingGlobalChartSettings",
                        data: {id: n.id, userId: n.userId, input: n.input, error: i}
                    }
                })
            })
        }, async deleteAllByUserId(n) {
            const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                e.error({event: {id: "failedGettingGlobalChartSettings", data: {userId: n, error: o}}})
            });
            if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                e.error({event: {id: "failedDeletingGlobalChartSettings", data: {id: o.id, userId: n, error: s}}})
            })
        }
    }
});
var ZHt = s8;
s8.flatten = s8;
s8.unflatten = CIe;

function EIe(t) {
    return t && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t)
}

function TIe(t) {
    return t
}

function s8(t, e) {
    e = e || {};
    const r = e.delimiter || ".", n = e.maxDepth, i = e.transformKey || TIe, a = {};

    function o(s, l, f) {
        f = f || 1, Object.keys(s).forEach(function (d) {
            const p = s[d], g = e.safe && Array.isArray(p), b = Object.prototype.toString.call(p), S = EIe(p),
                T = b === "[object Object]" || b === "[object Array]", I = l ? l + r + i(d) : i(d);
            if (!g && !S && T && Object.keys(p).length && (!e.maxDepth || f < n)) return o(p, I, f + 1);
            a[I] = p
        })
    }

    return o(t), a
}

function CIe(t, e) {
    e = e || {};
    const r = e.delimiter || ".", n = e.overwrite || !1, i = e.transformKey || TIe, a = {};
    if (EIe(t) || Object.prototype.toString.call(t) !== "[object Object]") return t;

    function s(d) {
        const p = Number(d);
        return isNaN(p) || d.indexOf(".") !== -1 || e.object ? d : p
    }

    function l(d, p, g) {
        return Object.keys(g).reduce(function (b, S) {
            return b[d + r + S] = g[S], b
        }, p)
    }

    function f(d) {
        const p = Object.prototype.toString.call(d), g = p === "[object Array]", b = p === "[object Object]";
        if (d) {
            if (g) return !d.length;
            if (b) return !Object.keys(d).length
        } else return !0
    }

    return t = Object.keys(t).reduce(function (d, p) {
        const g = Object.prototype.toString.call(t[p]);
        return !(g === "[object Object]" || g === "[object Array]") || f(t[p]) ? (d[p] = t[p], d) : l(p, d, s8(t[p], e))
    }, {}), Object.keys(t).forEach(function (d) {
        const p = d.split(r).map(i);
        let g = s(p.shift()), b = s(p[0]), S = a;
        for (; b !== void 0;) {
            if (g === "__proto__") return;
            const T = Object.prototype.toString.call(S[g]), I = T === "[object Object]" || T === "[object Array]";
            if (!n && !I && typeof S[g] < "u") return;
            (n && !I || !n && S[g] == null) && (S[g] = typeof b == "number" && !e.object ? [] : {}), S = S[g], p.length > 0 && (g = s(p.shift()), b = s(p[0]))
        }
        S[g] = CIe(t[d], e)
    }), a
}

const JHt = pt(Ra, sr, (t, e) => {
    const r = id(t, sOt);
    return {
        findByUserIdSnapshot(n) {
            const i = Qa(r, Li("userId", "==", n.userId));
            return Ip(i, a => {
                const o = [];
                for (const s of a.docs) {
                    const l = s.data({serverTimestamps: "estimate"}), f = _Mt.safeParse({...l, id: s.id});
                    f.success ? o.push(f.data) : e.error({
                        event: {
                            id: "failedOnParsingMultichartEntity",
                            data: {error: f.error}
                        }
                    })
                }
                n.onResult(o)
            }, a => {
                a.code !== "permission-denied" && (e.error({
                    event: {
                        id: "failedOnQueryingMulticharts",
                        data: {error: a}
                    }
                }), n.onError(a))
            })
        }, async create(n, i) {
            await im(r, {
                schemaVersion: i.schemaVersion,
                userId: n,
                name: i.name,
                order: i.order,
                default: i.default,
                pairs: i.pairs,
                settings: i.settings,
                createdAt: Ti(),
                updatedAt: Ti()
            }).catch(a => {
                e.error({event: {id: "failedOnCreatingAMultichart", data: {userId: n, error: a, input: i}}})
            })
        }, async update(n, i) {
            const a = ZHt.flatten(i, {safe: !0});
            await zf(ua(r, n), {...a, updatedAt: Ti()}).catch(o => {
                e.error({event: {id: "failedOnUpdatingAMultichart", data: {id: n, error: o, input: i}}})
            })
        }, async delete(n) {
            await ic(ua(r, n)).catch(i => {
                e.error({event: {id: "failedOnDeletingAMultichart", data: {id: n, error: i}}})
            })
        }, async addPair(n, i) {
            await zf(ua(r, n), {updatedAt: Ti(), pairs: Dte(i)}).catch(a => {
                e.error({event: {id: "failedOnAddingAPairToAMultichart", data: {id: n, error: a, pair: i}}})
            })
        }, async removePair(n, i) {
            await zf(ua(r, n), {updatedAt: Ti(), pairs: Mte(i)}).catch(a => {
                e.error({event: {id: "failedOnRemovingAPairFromAMultichart", data: {id: n, error: a, pair: i}}})
            })
        }, async deleteAllByUserId(n) {
            const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                e.error({event: {id: "failedGettingMulticharts", data: {userId: n, error: o}}})
            });
            if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                e.error({event: {id: "failedDeletingMulticharts", data: {id: o.id, userId: n, error: s}}})
            })
        }
    }
});

class JH extends Error {
}

const eWt = pt(Ra, sr, (t, e) => {
        const r = id(t, cOt);
        return {
            async create() {
                throw new JH("notificationSettingsWebRepository.create")
            }, async update() {
                throw new JH("notificationSettingsWebRepository.update")
            }, async delete() {
                throw new JH("notificationSettingsWebRepository.delete")
            }, async findBy(n, i) {
                const a = [Li("userId", "==", n)];
                i.active !== void 0 && a.push(Li("active", "==", i.active)), i.channelType && a.push(Li("channelType", "==", i.channelType)), i.token && a.push(Li("token", "==", i.token));
                const o = Qa(r, ...a), s = await gu(o).catch(f => {
                    e.error({event: {id: "failedOnFindingNotificationSettings", data: {userId: n, query: i, error: f}}})
                });
                if (!s || s.docs.length === 0) return null;
                const l = [];
                for (const f of s.docs) {
                    const d = zMt.safeParse({...f.data(), id: f.id});
                    d.success ? l.push(d.data) : e.error({
                        event: {
                            id: "failedOnParsingNotificationSettings",
                            data: {id: f.id, userId: n, error: d.error}
                        }
                    })
                }
                return l
            }, async deleteAllByUserId(n) {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingNotificationSettings", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingNotificationSettings", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    }), tWt = pt(Ra, sr, (t, e) => {
        const r = id(t, lOt);
        return {
            async findById(n) {
                const i = await TE(ua(r, n)), a = i.data({serverTimestamps: "estimate"}),
                    o = Dpe.safeParse({...a, id: i.id});
                if (!o.success) {
                    e.error({event: {id: "failedGettingPairChartSettingsById", data: {id: i.id, error: o.error}}});
                    return
                }
                return o.data
            }, async findByPairId(n) {
                const i = [],
                    a = Qa(r, Li("userId", "==", n.userId), Li("pair.pairId", "==", n.pairId), Li("pair.chainId", "==", n.chainId), Qw("updatedAt", "desc"), w3(1)),
                    o = await gu(a).catch(s => {
                        e.error({
                            event: {
                                id: "failedOnFindingPairChartSettingsEntityByPairId",
                                data: {userId: n.userId, chainId: n.chainId, pairId: n.pairId, error: s}
                            }
                        })
                    });
                if (o) return o.forEach(s => {
                    const l = s.data({serverTimestamps: "estimate"}), f = Dpe.safeParse({...l, id: s.id});
                    f.success ? i.push(f.data) : e.error({
                        event: {
                            id: "failedOnParsingPairChartSettingsEntity",
                            data: {userId: n.userId, error: f.error}
                        }
                    })
                }), i[0]
            }, create: async (n, i) => {
                const a = zK({pair: i.pair, isInverted: i.isInverted, chartType: i.chartType});
                await im(r, {
                    schemaVersion: i.schemaVersion,
                    userId: n,
                    pair: {type: "dexPair", chainId: i.pair.chainId, pairId: i.pair.pairId},
                    settings: {[a]: {[i.quotePricingMode]: i.chartData}},
                    createdAt: Ti(),
                    updatedAt: Ti()
                }).catch(o => {
                    e.error({event: {id: "failedOnCreatingAPairChartSettings", data: {userId: n, error: o, pair: i.pair}}})
                })
            }, async update(n) {
                const i = zK({pair: n.input.pair, isInverted: n.input.isInverted, chartType: n.input.chartType}),
                    a = `settings.${i}`;
                await zf(ua(r, n.pairChartSettings.id), {
                    [a]: {
                        ...n.pairChartSettings.settings[i],
                        [n.input.quotePricingMode]: n.input.chartData
                    }, updatedAt: Ti()
                }).catch(o => {
                    e.error({
                        event: {
                            id: "failedOnUpdatingAPairChartSettings",
                            data: {
                                error: o,
                                userId: n.userId,
                                pairChartSettingsId: n.pairChartSettings.id,
                                pair: n.input.pair
                            }
                        }
                    })
                })
            }, async deleteAllByUserId(n) {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingPairChartSettings", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingPairChartSettings", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    }), rWt = pt(Ra, sr, (t, e) => {
        const r = id(t, uOt), n = (o, s) => {
            const l = im(r, kf({schemaVersion: "1.0.0", ...s, userId: o, createdAt: Ti(), updatedAt: Ti()})).catch(f => {
                e.error({event: {id: "failedOnCreatingPairSettings", data: {userId: o, error: f, input: s}}})
            });
            return Ju(l).pipe(zn(() => {
            }))
        }, i = (o, s) => {
            const l = zf(ua(r, o), kf({...s, updatedAt: Ti()})).catch(f => {
                e.error({event: {id: "failedOnUpdatingPairSettings", data: {id: o, error: f, input: s}}})
            });
            return Ju(l).pipe(zn(() => {
            }))
        };
        return {
            findByUserIdAndPairIdentity: (o, s) => new ia(l => {
                const f = Qa(r, Li("userId", "==", o), Li("pair.pairId", "==", s.pairId), Li("pair.chainId", "==", s.chainId), Qw("updatedAt", "desc"), w3(1)),
                    d = Ip(f, {
                        next: p => {
                            const g = p.docs[0];
                            if (!g) return l.next(void 0);
                            const b = {...g.data({serverTimestamps: "estimate"}), id: g.id}, S = IMt.safeParse(b);
                            if (!S.success) {
                                e.error({
                                    event: {
                                        id: "failedOnParsingPairSettingsEntity",
                                        data: {userId: o, docId: g.id, error: S.error}
                                    }
                                });
                                return
                            }
                            l.next(S.data)
                        }, error: p => {
                            e.error({
                                event: {
                                    id: "failedOnFindingPairSettingsEntityByUserId",
                                    data: {userId: o, chainId: s.chainId, pairId: s.pairId, error: p}
                                }
                            })
                        }, complete: () => l.complete()
                    });
                return () => d()
            }), update: (o, s) => i(o, s), create: (o, s) => n(o, s), deleteAllByUserId: async o => {
                const s = Qa(r, Li("userId", "==", o)), l = await gu(s).catch(f => {
                    e.error({event: {id: "failedGettingPairSettings", data: {userId: o, error: f}}})
                });
                if (l) for (const f of l.docs) await ic(f.ref).catch(d => {
                    e.error({event: {id: "failedDeletingPairSettings", data: {id: f.id, userId: o, error: d}}})
                })
            }
        }
    }), nWt = pt(Ra, sr, (t, e) => {
        const r = id(t, dOt);
        return {
            findByUserIdSnapshot(n) {
                const i = Qa(r, Li("userId", "==", n.userId), w3(1));
                return Ip(i, a => {
                    const o = [];
                    for (const s of a.docs) {
                        const l = s.data({serverTimestamps: "estimate"}), f = FMt.safeParse({...l, id: s.id});
                        f.success ? o.push(f.data) : e.error({
                            event: {
                                id: "failedOnParsingUISettingsEntity",
                                data: {error: f.error}
                            }
                        })
                    }
                    n.onResult(o[0])
                }, a => {
                    a.code !== "permission-denied" && (e.error({
                        event: {
                            id: "failedOnQueryingUISettings",
                            data: {error: a}
                        }
                    }), n.onError(a))
                })
            }, async create(n, i) {
                await im(r, kf({
                    schemaVersion: i.schemaVersion,
                    userId: n,
                    value: kf({
                        ...i.value,
                        mobile: i.value.mobile ? kf(i.value.mobile) : void 0,
                        desktop: i.value.desktop ? kf(i.value.desktop) : void 0
                    }),
                    createdAt: Ti(),
                    updatedAt: Ti()
                })).catch(a => {
                    e.error({event: {id: "failedOnCreatingAUISettings", data: {userId: n, error: a, input: i}}})
                })
            }, async update(n, i) {
                await zf(ua(r, n), kf({
                    ...i,
                    value: i.value ? kf({
                        ...i.value,
                        mobile: i.value.mobile ? kf(i.value.mobile) : void 0,
                        desktop: i.value.desktop ? kf(i.value.desktop) : void 0
                    }) : void 0,
                    updatedAt: Ti()
                })).catch(a => {
                    e.error({event: {id: "failedOnUpdatingAUISettings", data: {id: n, error: a, input: i}}})
                })
            }, async deleteAllByUserId(n) {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingUISettings", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingUISettings", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    }), iWt = t => ({
        visibility: "public",
        schemaVersion: t.schemaVersion,
        id: t.id,
        userId: void 0,
        name: t.name,
        pairs: t.pairs
    }), aWt = pt(Ra, sr, (t, e) => {
        const r = id(t, hOt);
        return {
            findByUserIdSnapshot(n) {
                const i = Qa(r, Li("userId", "==", n.userId));
                return Ip(i, a => {
                    const o = [];
                    for (const s of a.docs) {
                        const l = s.data({serverTimestamps: "estimate"}), f = CH(s.id, l), d = TH.safeParse(f);
                        d.success ? o.push(d.data) : e.error({
                            event: {
                                id: "failedOnParsingWatchlistEntity",
                                data: {userId: n.userId, error: d.error}
                            }
                        })
                    }
                    n.onResult(o)
                }, a => {
                    a.code !== "permission-denied" && (e.error({
                        event: {
                            id: "failedOnQueryingWatchlists",
                            data: {userId: n.userId, error: a}
                        }
                    }), n.onError(a))
                })
            }, async findById(n, i) {
                const a = ua(r, n), o = await TE(a).catch(d => {
                    e.error({event: {id: "failedOnGettingWatchlistById", data: {id: n, error: d}}})
                });
                if (!o) return;
                const s = o.data();
                if (!s) return;
                const l = CH(n, s), f = TH.safeParse(l);
                if (!f.success) {
                    e.error({event: {id: "failedOnParsingWatchlistById", data: {id: n, error: f.error}}});
                    return
                }
                return i && f.data.userId === i ? f.data : iWt(f.data)
            }, async create(n, i) {
                const a = await im(r, {
                    visibility: i.visibility,
                    schemaVersion: i.schemaVersion,
                    userId: n,
                    name: i.name,
                    default: i.default,
                    pairs: i.pairs,
                    createdAt: Ti(),
                    updatedAt: Ti()
                }).catch(o => {
                    e.error({event: {id: "failedOnCreatingAWatchlist", data: {userId: n, error: o, input: i}}})
                });
                return a ? a.id : ""
            }, async update(n, i) {
                await zf(ua(r, n), {...i, updatedAt: Ti()}).catch(a => {
                    e.error({event: {id: "failedOnUpdatingAWatchlist", data: {id: n, error: a, input: i}}})
                })
            }, async delete(n) {
                await ic(ua(r, n)).catch(i => {
                    e.error({event: {id: "failedOnDeletingAWatchlist", data: {id: n, error: i}}})
                })
            }, async addPair(n, i) {
                const o = (await TE(ua(r, n))).data({serverTimestamps: "estimate"});
                if (!o) return;
                const s = CH(n, o), l = TH.parse(s);
                E5e(l);
                const f = {...i, type: "dexPair"};
                await zf(ua(r, n), {updatedAt: Ti(), pairs: Dte(f)}).catch(d => {
                    e.error({event: {id: "failedOnAddingAPairToAWatchlist", data: {id: n, error: d, pair: i}}})
                })
            }, async removePair(n, i) {
                const a = {...i, type: "dexPair"};
                await zf(ua(r, n), {updatedAt: Ti(), pairs: Mte(a)}).catch(o => {
                    e.error({event: {id: "failedOnRemovingAPairToAWatchlist", data: {id: n, error: o, pair: i}}})
                })
            }, async deleteAllByUserId(n) {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingWatchlists", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingWatchlists", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    }), oWt = t => ({
        schemaVersion: t.schemaVersion,
        id: t.id,
        userId: t.userId,
        name: t.name,
        order: t.order,
        createdAt: t.createdAt,
        updatedAt: t.updatedAt,
        hiddenPairs: t.hiddenPairs,
        address: t.address
    }), sWt = pt(Ra, sr, (t, e) => {
        const r = id(t, fOt);
        return {
            findByUserIdSnapshot(n) {
                const i = Qa(r, Li("userId", "==", n.userId));
                return Ip(i, a => {
                    const o = [];
                    for (const s of a.docs) {
                        const f = {...s.data({serverTimestamps: "estimate"}), id: s.id}, d = Mpe.safeParse(f);
                        d.success ? o.push(d.data) : e.error({
                            event: {
                                id: "failedOnParsingPortfolioEntity",
                                data: {userId: n.userId, error: d.error}
                            }
                        })
                    }
                    n.onResult(o)
                }, a => {
                    a.code !== "permission-denied" && (e.error({
                        event: {
                            id: "failedOnQueryingPortfolios",
                            data: {userId: n.userId, error: a}
                        }
                    }), n.onError(a))
                })
            }, async findById(n, i) {
                const a = ua(r, n), o = await TE(a).catch(d => {
                    e.error({event: {id: "failedOnGettingPortfolioById", data: {id: n, error: d}}})
                });
                if (!o) return;
                const s = o.data();
                if (!s) return;
                const l = {...s}, f = Mpe.safeParse(l);
                if (!f.success) {
                    e.error({event: {id: "failedOnParsingPortfolioById", data: {id: n, error: f.error}}});
                    return
                }
                return i && f.data.userId === i ? f.data : oWt(f.data)
            }, async create(n, i) {
                const a = await im(r, {
                    schemaVersion: i.schemaVersion,
                    userId: n,
                    name: i.name,
                    order: i.order,
                    hiddenPairs: i.hiddenPairs,
                    address: i.address,
                    createdAt: Ti(),
                    updatedAt: Ti()
                }).catch(o => {
                    e.error({event: {id: "failedOnCreatingAPortfolio", data: {userId: n, error: o, input: i}}})
                });
                return a ? a.id : ""
            }, async update(n, i) {
                await zf(ua(r, n), {...i, updatedAt: Ti()}).catch(a => {
                    e.error({event: {id: "failedOnUpdatingAPortfolio", data: {id: n, error: a, input: i}}})
                })
            }, async delete(n) {
                await ic(ua(r, n)).catch(i => {
                    e.error({event: {id: "failedOnDeletingAPortfolio", data: {id: n, error: i}}})
                })
            }, async deleteAllByUserId(n) {
                const i = Qa(r, Li("userId", "==", n)), a = await gu(i).catch(o => {
                    e.error({event: {id: "failedGettingPortfolios", data: {userId: n, error: o}}})
                });
                if (a) for (const o of a.docs) await ic(o.ref).catch(s => {
                    e.error({event: {id: "failedDeletingPortfolios", data: {id: o.id, userId: n, error: s}}})
                })
            }
        }
    }),
    cWt = Ppe.omit({timestamp: !0}).extend({timestamp: VQ(Ca).transform(t => t.toDate(), t => Ca.fromDate(t), Ppe.fields.timestamp)}),
    lWt = pt(Ra, sr, xL, EL, (t, e, r, n) => {
        const i = a => {
            const o = [];
            for (const s of a.docs) {
                const l = {...s.data({serverTimestamps: "estimate"}), id: s.id}, f = cWt.safeDecode(l);
                f.ok ? o.push(f.value) : e.error({
                    event: {
                        id: "failedDecodingChatMessage",
                        data: {payload: l, error: f.error}
                    }
                })
            }
            return o
        };
        return {
            getHistory: a => {
                const o = [Li("chainId", "==", a.chainId), Li("tokenAddress", "==", a.tokenAddress)];
                switch (a.ordering) {
                    case"top": {
                        o.push(Qw("votes", "desc"), Qw("timestamp", "desc"));
                        break
                    }
                    case"new": {
                        o.push(Qw("timestamp", "desc"));
                        break
                    }
                }
                return o.push(w3(a.limit)), new ia(s => Ip(Qa(id(t, "chatMessages"), ...o), s)).pipe(zn(i))
            }, sendMessage: async ({chainId: a, tokenAddress: o, content: s}) => {
                await n(r, "sendChatMessage")(EOt.encode({chainId: a, tokenAddress: o, content: s}))
            }, reportMessage: async ({messageId: a}) => {
                await n(r, "reportChatMessage")(TOt.encode({messageId: a}))
            }, voteMessage: async a => {
                await n(r, "voteChatMessage")(AOt.encode(a))
            }
        }
    }), uWt = pt(xL, EL, Ra, (t, e, r) => {
        const n = i => {
            if (i.exists()) return qMt.json.decode(i.data())
        };
        return {
            setPublicUserName: async i => {
                await e(t, "setPublicUserName")(xOt.encode({name: i.userName, captchaValue: i.captchaValue}))
            }, getPublicUserData: async i => {
                const a = ua(r, "publicUserData", i.userId), o = await TE(a);
                return n(o)
            }, listenToPublicUserData: i => new ia(a => Ip(ua(r, "publicUserData", i.userId), a)).pipe(zn(n))
        }
    }), fWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => Ojt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdSnapshot: n => {
                let i, a = !1;
                return r().then(o => {
                    a || (i = o.findByUserIdSnapshot(n))
                }), () => {
                    a = !0, i && (i(), i = void 0)
                }
            },
            create: async (n, i) => (await r()).create(n, i),
            delete: async n => (await r()).delete(n),
            update: async (n, i) => (await r()).update(n, i),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), dWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => Pjt({[sr.key]: t, [Ra.key]: await e()})), n = Ly(() => r()).pipe(Xa);
        return {
            create: async (i, a) => (await r()).create(i, a),
            findByUserId: i => n.pipe(uo(a => a.findByUserId(i))),
            delete: async i => (await r()).delete(i),
            deleteAllByUserId: async i => (await r()).deleteAllByUserId(i)
        }
    }), hWt = pt(LPt, sr, (t, e) => {
        const r = ls(async () => YHt({[sr.key]: e, [Y5e.key]: await t()})), n = Ly(() => r()).pipe(Xa);
        return {
            currentUser: n.pipe(uo(i => i.currentUser), Xa),
            signOut: () => n.pipe(uo(i => i.signOut())),
            signWithCustomToken: i => n.pipe(uo(a => a.signWithCustomToken(i))),
            signInAnonymously: () => n.pipe(uo(i => i.signInAnonymously())),
            deleteUser: () => Dye
        }
    }), pWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => XHt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserId: async n => (await r()).findByUserId(n),
            create: async (n, i) => (await r()).create(n, i),
            update: async n => (await r()).update(n),
            delete: async n => (await r()).delete(n),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), mWt = pt(o3, nd, sr, (t, e, r) => {
        const n = ls(async () => {
            const {
                httpsCallable: i,
                getFunctions: a
            } = await na(() => import("../chunks/index.esm-P1WENdMj.js"), __vite__mapDeps([4, 1]));
            return lWt({[xL.key]: a(await t()), [EL.key]: i, [sr.key]: r, [Ra.key]: await e()})
        });
        return {
            getHistory: i => Ly(n).pipe(uo(a => a.getHistory(i))),
            sendMessage: async i => (await n()).sendMessage(i),
            reportMessage: async i => (await n()).reportMessage(i),
            voteMessage: async i => (await n()).voteMessage(i)
        }
    }), vWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => QHt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdSnapshot: n => {
                let i, a = !1;
                return r().then(o => {
                    a || (i = o.findByUserIdSnapshot(n))
                }), () => {
                    a = !0, i && (i(), i = void 0)
                }
            },
            create: async (n, i) => (await r()).create(n, i),
            update: async n => (await r()).update(n),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), gWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => JHt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdSnapshot: n => {
                let i, a = !1;
                return r().then(o => {
                    a || (i = o.findByUserIdSnapshot(n))
                }), () => {
                    a = !0, i && (i(), i = void 0)
                }
            },
            create: async (n, i) => (await r()).create(n, i),
            delete: async n => (await r()).delete(n),
            update: async (n, i) => (await r()).update(n, i),
            addPair: async (n, i) => (await r()).addPair(n, i),
            removePair: async (n, i) => (await r()).removePair(n, i),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), yWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => eWt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            create: async (n, i) => (await r()).create(n, i),
            update: async (n, i) => (await r()).update(n, i),
            delete: async n => (await r()).delete(n),
            findBy: async (n, i) => (await r()).findBy(n, i),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), bWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => tWt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findById: async n => (await r()).findById(n),
            findByPairId: async n => (await r()).findByPairId(n),
            create: async (n, i) => (await r()).create(n, i),
            update: async n => (await r()).update(n),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), wWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => rWt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdAndPairIdentity: (n, i) => Ju(r()).pipe(uo(a => a.findByUserIdAndPairIdentity(n, i))),
            create: (n, i) => Ju(r()).pipe(uo(a => a.create(n, i))),
            update: (n, i) => Ju(r()).pipe(uo(a => a.update(n, i))),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), SWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => sWt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdSnapshot: n => {
                let i, a = !1;
                return r().then(o => {
                    a || (i = o.findByUserIdSnapshot(n))
                }), () => {
                    a = !0, i && (i(), i = void 0)
                }
            },
            findById: async (n, i) => (await r()).findById(n, i),
            create: async (n, i) => (await r()).create(n, i),
            delete: async n => (await r()).delete(n),
            update: async (n, i) => (await r()).update(n, i),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), _Wt = pt(o3, nd, (t, e) => {
        const r = ls(async () => {
            const {
                httpsCallable: n,
                getFunctions: i
            } = await na(() => import("../chunks/index.esm-P1WENdMj.js"), __vite__mapDeps([4, 1]));
            return uWt({[xL.key]: i(await t()), [EL.key]: n, [Ra.key]: await e()})
        });
        return {
            setPublicUserName: async n => (await r()).setPublicUserName(n),
            getPublicUserData: async n => (await r()).getPublicUserData(n),
            listenToPublicUserData: n => Ly(async () => r()).pipe(uo(i => i.listenToPublicUserData(n)))
        }
    }), xWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => nWt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdSnapshot: n => {
                let i, a = !1;
                return r().then(o => {
                    a || (i = o.findByUserIdSnapshot(n))
                }), () => {
                    a = !0, i && (i(), i = void 0)
                }
            },
            create: async (n, i) => (await r()).create(n, i),
            update: async (n, i) => (await r()).update(n, i),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), EWt = pt(sr, nd, (t, e) => {
        const r = ls(async () => aWt({[Ra.key]: await e(), [sr.key]: t}));
        return {
            findByUserIdSnapshot: n => {
                let i, a = !1;
                return r().then(o => {
                    a || (i = o.findByUserIdSnapshot(n))
                }), () => {
                    a = !0, i && (i(), i = void 0)
                }
            },
            findById: async (n, i) => (await r()).findById(n, i),
            create: async (n, i) => (await r()).create(n, i),
            delete: async n => (await r()).delete(n),
            update: async (n, i) => (await r()).update(n, i),
            addPair: async (n, i) => (await r()).addPair(n, i),
            removePair: async (n, i) => (await r()).removePair(n, i),
            deleteAllByUserId: async n => (await r()).deleteAllByUserId(n)
        }
    }), TWt = mn("@dexscreener/web/chartWindowLike")(), If = t => t ? "1" : "0", CWt = pt(() => ({
        getSettingsFromSearchParams({searchParams: t, branding: e, dsApp: r}) {
            const n = t.get("embed") === "1";
            if (!n) return {isEmbed: !1};
            const i = t.get("nav") === "1";
            let a = t.get("trades") !== "0", o = t.get("chart") !== "0", s = t.get("info") !== "0",
                l = t.get("chartStudyTemplates") !== "0", f = t.get("chartLeftTollbar") !== "0",
                d = t.get("chartSaveDrawings") !== "0", p = t.get("chartComparePairs") !== "0";
            const g = t.get("chartTimeframesToolbar") !== "0", b = t.get("inverted") === "1", S = t.get("tabs") !== "0",
                T = O_e.safeParse(t.get("interval")), I = T.success ? T.data : void 0,
                N = i0t.safeParse(t.get("chartStyle")), P = N.success ? N.data : void 0, F = hZ.safeParse(t.get("theme")),
                V = F.success ? F.data : void 0;
            return !a && !o && !s && !l && !f && !d && !p && (a = !0, o = !0, s = !0, l = !0, f = !0, d = !0, p = !0), {
                isEmbed: n,
                chart: o,
                nav: i,
                trades: a,
                info: s,
                branding: e,
                dsApp: r,
                inverted: b,
                chartStudyTemplates: l,
                chartLeftTollbar: f,
                chartSaveDrawings: d,
                chartComparePairs: p,
                chartTimeframesToolbar: g,
                interval: I,
                chartStyle: P,
                theme: V,
                tabs: S
            }
        }, buildSettingsSearchParams(t) {
            const e = new URLSearchParams({embed: "1"});
            return t.chart !== void 0 && e.set("chart", If(t.chart)), t.nav !== void 0 && e.set("nav", If(t.nav)), t.trades !== void 0 && e.set("trades", If(t.trades)), t.info !== void 0 && e.set("info", If(t.info)), t.branding !== void 0 && e.set("branding", If(t.branding)), t.dsApp !== void 0 && e.set("dsApp", If(t.dsApp)), t.inverted !== void 0 && e.set("inverted", If(t.inverted)), t.chartStudyTemplates !== void 0 && e.set("chartStudyTemplates", If(t.chartStudyTemplates)), t.chartLeftTollbar !== void 0 && e.set("chartLeftTollbar", If(t.chartLeftTollbar)), t.chartSaveDrawings !== void 0 && e.set("chartSaveDrawings", If(t.chartSaveDrawings)), t.chartComparePairs !== void 0 && e.set("chartComparePairs", If(t.chartComparePairs)), t.chartTimeframesToolbar !== void 0 && e.set("chartTimeframesToolbar", If(t.chartTimeframesToolbar)), t.interval !== void 0 && e.set("interval", t.interval), t.chartStyle !== void 0 && e.set("chartStyle", t.chartStyle.toString()), t.theme !== void 0 && e.set("theme", t.theme), t.tabs !== void 0 && e.set("tabs", If(t.tabs)), e
        }
    }));
var AWt = {BASE_SERVER: "/", BASE_ASSETS: "/", BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1};
const Nme = t => {
    let e;
    const r = new Set, n = (l, f) => {
        const d = typeof l == "function" ? l(e) : l;
        if (!Object.is(d, e)) {
            const p = e;
            e = f ?? typeof d != "object" ? d : Object.assign({}, e, d), r.forEach(g => g(e, p))
        }
    }, i = () => e, s = {
        setState: n, getState: i, subscribe: l => (r.add(l), () => r.delete(l)), destroy: () => {
            (AWt && "production") !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), r.clear()
        }
    };
    return e = t(n, i, s), s
}, IWt = t => t ? Nme(t) : Nme;
var MY = {exports: {}}, eW = {}, Z7 = {exports: {}}, tW = {};
var Lme;

function kWt() {
    if (Lme) return tW;
    Lme = 1;
    var t = Kv();

    function e(p, g) {
        return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g
    }

    var r = typeof Object.is == "function" ? Object.is : e, n = t.useState, i = t.useEffect, a = t.useLayoutEffect,
        o = t.useDebugValue;

    function s(p, g) {
        var b = g(), S = n({inst: {value: b, getSnapshot: g}}), T = S[0].inst, I = S[1];
        return a(function () {
            T.value = b, T.getSnapshot = g, l(T) && I({inst: T})
        }, [p, b, g]), i(function () {
            return l(T) && I({inst: T}), p(function () {
                l(T) && I({inst: T})
            })
        }, [p]), o(b), b
    }

    function l(p) {
        var g = p.getSnapshot;
        p = p.value;
        try {
            var b = g();
            return !r(p, b)
        } catch {
            return !0
        }
    }

    function f(p, g) {
        return g()
    }

    var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : s;
    return tW.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : d, tW
}

var rW = {}, Bme;

function RWt() {
    return Bme || (Bme = 1, Ve.env.NODE_ENV !== "production" && function () {
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
        var t = Kv(), e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

        function r(F) {
            {
                for (var V = arguments.length, Y = new Array(V > 1 ? V - 1 : 0), ee = 1; ee < V; ee++) Y[ee - 1] = arguments[ee];
                n("error", F, Y)
            }
        }

        function n(F, V, Y) {
            {
                var ee = e.ReactDebugCurrentFrame, oe = ee.getStackAddendum();
                oe !== "" && (V += "%s", Y = Y.concat([oe]));
                var G = Y.map(function (J) {
                    return String(J)
                });
                G.unshift("Warning: " + V), Function.prototype.apply.call(console[F], console, G)
            }
        }

        function i(F, V) {
            return F === V && (F !== 0 || 1 / F === 1 / V) || F !== F && V !== V
        }

        var a = typeof Object.is == "function" ? Object.is : i, o = t.useState, s = t.useEffect, l = t.useLayoutEffect,
            f = t.useDebugValue, d = !1, p = !1;

        function g(F, V, Y) {
            d || t.startTransition !== void 0 && (d = !0, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
            var ee = V();
            if (!p) {
                var oe = V();
                a(ee, oe) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), p = !0)
            }
            var G = o({inst: {value: ee, getSnapshot: V}}), J = G[0].inst, ce = G[1];
            return l(function () {
                J.value = ee, J.getSnapshot = V, b(J) && ce({inst: J})
            }, [F, ee, V]), s(function () {
                b(J) && ce({inst: J});
                var re = function () {
                    b(J) && ce({inst: J})
                };
                return F(re)
            }, [F]), f(ee), ee
        }

        function b(F) {
            var V = F.getSnapshot, Y = F.value;
            try {
                var ee = V();
                return !a(Y, ee)
            } catch {
                return !0
            }
        }

        function S(F, V, Y) {
            return V()
        }

        var T = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
            I = !T, N = I ? S : g, P = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : N;
        rW.useSyncExternalStore = P, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)
    }()), rW
}

var $me;

function AIe() {
    return $me || ($me = 1, Ve.env.NODE_ENV === "production" ? Z7.exports = kWt() : Z7.exports = RWt()), Z7.exports
}

var Fme;

function DWt() {
    if (Fme) return eW;
    Fme = 1;
    var t = Kv(), e = AIe();

    function r(f, d) {
        return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d
    }

    var n = typeof Object.is == "function" ? Object.is : r, i = e.useSyncExternalStore, a = t.useRef, o = t.useEffect,
        s = t.useMemo, l = t.useDebugValue;
    return eW.useSyncExternalStoreWithSelector = function (f, d, p, g, b) {
        var S = a(null);
        if (S.current === null) {
            var T = {hasValue: !1, value: null};
            S.current = T
        } else T = S.current;
        S = s(function () {
            function N(ee) {
                if (!P) {
                    if (P = !0, F = ee, ee = g(ee), b !== void 0 && T.hasValue) {
                        var oe = T.value;
                        if (b(oe, ee)) return V = oe
                    }
                    return V = ee
                }
                if (oe = V, n(F, ee)) return oe;
                var G = g(ee);
                return b !== void 0 && b(oe, G) ? oe : (F = ee, V = G)
            }

            var P = !1, F, V, Y = p === void 0 ? null : p;
            return [function () {
                return N(d())
            }, Y === null ? void 0 : function () {
                return N(Y())
            }]
        }, [d, p, g, b]);
        var I = i(f, S[0], S[1]);
        return o(function () {
            T.hasValue = !0, T.value = I
        }, [I]), l(I), I
    }, eW
}

var nW = {}, Ume;

function MWt() {
    return Ume || (Ume = 1, Ve.env.NODE_ENV !== "production" && function () {
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
        var t = Kv(), e = AIe();

        function r(d, p) {
            return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p
        }

        var n = typeof Object.is == "function" ? Object.is : r, i = e.useSyncExternalStore, a = t.useRef,
            o = t.useEffect, s = t.useMemo, l = t.useDebugValue;

        function f(d, p, g, b, S) {
            var T = a(null), I;
            T.current === null ? (I = {hasValue: !1, value: null}, T.current = I) : I = T.current;
            var N = s(function () {
                var Y = !1, ee, oe, G = function (M) {
                    if (!Y) {
                        Y = !0, ee = M;
                        var D = b(M);
                        if (S !== void 0 && I.hasValue) {
                            var x = I.value;
                            if (S(x, D)) return oe = x, x
                        }
                        return oe = D, D
                    }
                    var A = ee, B = oe;
                    if (n(A, M)) return B;
                    var z = b(M);
                    return S !== void 0 && S(B, z) ? B : (ee = M, oe = z, z)
                }, J = g === void 0 ? null : g, ce = function () {
                    return G(p())
                }, re = J === null ? void 0 : function () {
                    return G(J())
                };
                return [ce, re]
            }, [p, g, b, S]), P = N[0], F = N[1], V = i(d, P, F);
            return o(function () {
                I.hasValue = !0, I.value = V
            }, [V]), l(V), V
        }

        nW.useSyncExternalStoreWithSelector = f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)
    }()), nW
}

Ve.env.NODE_ENV === "production" ? MY.exports = DWt() : MY.exports = MWt();
var OWt = MY.exports;
const PWt = za(OWt), {useSyncExternalStoreWithSelector: NWt} = PWt;

function jme(t, e = t.getState, r) {
    const n = NWt(t.subscribe, t.getState, t.getServerState || t.getState, e, r);
    return W.useDebugValue(n), n
}

const zme = "dexscreener.pairTradingWindowSettings", IIe = W.createContext(void 0), LWt = t => {
    const {isBrandingEnabled: e, isDsApp: r, children: n, initialSearch: i} = t, a = aa(CWt), o = () => {
        const l = typeof window < "u" && window !== window.top, f = new URLSearchParams(i);
        return l && f.set("embed", "1"), f.get("branding"), a.getSettingsFromSearchParams({
            searchParams: f,
            branding: e,
            dsApp: r
        })
    }, s = W.useMemo(() => IWt(l => ({
        isMobileNavOpen: !1,
        embedSettings: o(),
        pairDetailTimeframeKey: "h24",
        actions: {
            setIsMobileNavOpen: f => l(d => ({...d, isMobileNavOpen: f})),
            setEmbedSettings: f => l(d => ({...d, embedSettings: f})),
            setPairDetailTimeframeKey: f => l(d => ({...d, pairDetailTimeframeKey: f})),
            setPairTradingWindowSettings: f => {
                try {
                    localStorage.setItem(zme, JSON.stringify(f))
                } catch {
                }
                l(d => ({...d, pairTradingWindowSettings: f}))
            },
            initializeState: () => {
                let f;
                try {
                    const d = localStorage.getItem(zme);
                    d && (f = JSON.parse(d))
                } catch {
                    f = void 0
                }
                l({pairTradingWindowSettings: f})
            }
        }
    })), []);
    return ie.jsx(IIe.Provider, {value: s, children: n})
};

function BWt() {
    const t = W.useContext(IIe);
    if (!t) throw new Error("useAppStore must be called within AppStoreProvider");
    return t
}

function AE(t, e) {
    const r = BWt();
    return t === void 0 ? jme(r) : jme(r, t, e)
}

const kIe = W.createContext({current: void 0}), RIe = t => {
    const e = W.useRef(t.value ?? $Wt());
    return W.useEffect(() => {
        e.current = void 0
    }, []), ie.jsx(kIe.Provider, {value: e, children: t.children})
}, n2 = () => W.useContext(kIe);

function $Wt() {
    return window.__SERVER_DATA
}

const Us = t => W.lazy(async () => {
    const {default: e} = await t(), r = n => (n2(), ie.jsx(RIe, {value: void 0, children: ie.jsx(e, {...n})}));
    return r.displayName = `LazyWithServerData(${e.displayName})`, {default: r}
}), [am, FWt] = T0t("DSData"), DIe = $i(), UWt = W.memo(t => {
    var F, V, Y, ee, oe;
    const {children: e} = t,
        r = n2(), [n] = W.useState((F = r.current) == null ? void 0 : F.chains), [i] = W.useState((V = r.current) == null ? void 0 : V.dexes), [a, o] = W.useState(((Y = r.current) == null ? void 0 : Y.activePairDetailsAds) ?? Wd), [s, l] = W.useState(() => {
            if (!r.current) return Wd;
            const {activePairDetailsAds: G, thresholdedPairDetailsAdIds: J} = r.current;
            return G.filter(ce => J.includes(ce.id))
        }), [f, d] = W.useState(((ee = r.current) == null ? void 0 : ee.activeTrendingBarAds) ?? Wd), [p, g] = W.useState(((oe = r.current) == null ? void 0 : oe.recentAds) ?? Wd),
        b = W.useMemo(() => n == null ? void 0 : n.map(G => G.slug), [n]),
        S = W.useMemo(() => i == null ? void 0 : i.map(G => G.slug), [i]), T = aa(Odt), I = aa(DIe),
        N = W.useMemo(() => {
            if (n) return Pft(n)
        }, [n]);
    W.useEffect(() => {
        const G = m2e({
            intervalInMs: I.DS_DATA_TIME_TO_STALE_IN_MS, callback: async () => {
                const [J, ce, re, M] = await Promise.all([T.getActivePairDetailsAds(), T.getThresholdedPairDetailsAds(), T.getActiveTrendingBarAds(), T.getRecentAds()]);
                o(J), l(ce), d(re), g(M)
            }, delayInMs: I.DS_DATA_TIME_TO_STALE_IN_MS
        });
        return G.start(), () => {
            G.stop()
        }
    }, [T, I.DS_DATA_TIME_TO_STALE_IN_MS]);
    const P = W.useMemo(() => {
        if (n && N && i && b && S) return {
            chains: n,
            discoverableChains: N,
            dexes: i,
            chainSlugs: b,
            dexSlugs: S,
            activePairDetailsAds: a,
            thresholdedPairDetailsAds: s,
            activeTrendingBarAds: f,
            recentAds: p
        };
        throw new Error("Cannot build DSDataProvider value. useServerData() is empty")
    }, [n, i, N, b, S, a, s, f, p]);
    return ie.jsx(FWt, {value: P, children: e})
});

function Gte(t, e) {
    if (e !== void 0) return t.find(r => r.slug === e)
}

function Kte(t) {
    const {chains: e} = am();
    return W.useMemo(() => Gte(e, t), [e, t])
}

function Ker(t) {
    const e = Kte(t);
    return W.useMemo(() => {
        if (e) return Bft(e)
    }, [e])
}

const OY = "Unknown Platform";

function jWt(t) {
    var e;
    return ((e = Kte(t)) == null ? void 0 : e.name) ?? OY
}

function Yer(t, e) {
    var r;
    return e === void 0 ? OY : ((r = Gte(t, e)) == null ? void 0 : r.name) ?? OY
}

function Yte(t, e) {
    if (e !== void 0) return t.find(r => r.slug === e)
}

const PY = "Unknown DEX";

function zWt(t) {
    const {dexes: e} = am();
    return W.useMemo(() => Yte(e, t), [e, t])
}

function Xer(t) {
    var r;
    const e = (r = zWt(t)) == null ? void 0 : r.name;
    return t === "moonshot" ? "Moonshot" : e ?? PY
}

function Qer(t, e) {
    var r;
    return e === "moonshot" ? "Moonshot" : e === void 0 ? PY : ((r = Yte(t, e)) == null ? void 0 : r.name) ?? PY
}

function Zer(t) {
    const e = Kte(t), {dexes: r} = am();
    if (!e) return;
    const n = [];
    for (const i of e.dexes) {
        const a = r.find(o => o.slug === i);
        a && n.push(a)
    }
    return n
}

function MIe(t) {
    const e = ss(t.serverRandom), {random: r} = W.useMemo(() => ({
        random: e.current ?? Math.random(),
        chainId: t.chainId,
        tokenAddress: t.tokenAddress
    }), [t.chainId, t.tokenAddress, e]);
    return r
}

function Jer(t) {
    var d;
    const [e] = W5e(), r = n2(), {activePairDetailsAds: n, thresholdedPairDetailsAds: i} = am(), a = ss(n), o = ss(i),
        s = MIe({
            serverRandom: (d = r.current) == null ? void 0 : d.activePairDetailsAdsRandom,
            chainId: t.chainId,
            tokenAddress: t.tokenAddress
        }), l = e.get("ad-id") ?? void 0;
    return W.useMemo(() => l ? a.current.find(p => p.id === l) : yft({
        ads: o.current,
        chainId: t.chainId,
        tokenAddress: t.tokenAddress,
        random: s
    }), [l, a, o, t.chainId, t.tokenAddress, s])
}

const VWt = [{
    kind: "hardcoded",
    source: "image",
    url: "https://a1.adform.net/C/?bn=72017121",
    imageUrl: {
        dark: "https://static.dexscreen.com/finixio/tg-casino-trending-dark-v4.svg",
        light: "https://static.dexscreen.com/finixio/tg-casino-trending-light-v4.svg"
    },
    impressionURLs: ["https://a1.adform.net/adfserve/?CC=1&bn=72017121;1x1inv=1;srctype=3", "https://cfw.dexscreener.com/a/direct/pair/trending-bar/tg-casino"],
    clickCountURLs: [],
    weight: 1
}, {
    kind: "hardcoded",
    source: "image",
    url: "https://metawin.com/t/dexscreener-2",
    imageUrl: {
        dark: "https://static.dexscreen.com/metawin/trending-bar-dark.svg",
        light: "https://static.dexscreen.com/metawin/trending-bar-light.svg"
    },
    impressionURLs: ["https://cfw.dexscreener.com/a/direct/pair/trending-bar/metawin", "https://metawin.com/t/dexscreener-2"],
    clickCountURLs: [],
    weight: 1
}];

function etr(t) {
    var f;
    const [e] = W5e(), r = n2(), {activeTrendingBarAds: n} = am(), i = ss(n), a = aa(DIe), o = MIe({
        serverRandom: (f = r.current) == null ? void 0 : f.activeTrendingBarAdsRandom,
        chainId: t.chainId,
        tokenAddress: t.tokenAddress
    }), s = e.get("ad-id") ?? void 0;
    return W.useMemo(() => {
        if (s) return i.current.find(b => b.id === s);
        if (t.isMoonshotPair) return;
        const d = i.current.filter(b => b.chainId === t.chainId);
        if (d.length > 0 && t.fullfillRemainingAds !== !0) return uw({items: d, random: o});
        if (a.DS_WEB_MAX_TRENDING_BAR_ADS_AMOUNT - d.length <= 0) return uw({items: d, random: o});
        const g = VWt.filter(b => b.kind !== "hardcoded" ? !1 : b.source === "image" ? !0 : b.chainId === t.chainId);
        if (t.fullfillRemainingAds) {
            const b = a.DS_WEB_MAX_TRENDING_BAR_ADS_AMOUNT - d.length;
            if (b <= 0) return uw({items: d, random: o});
            const S = pze({items: g, random: o, numberOfItems: b});
            return uw({items: [...d, ...S], random: o})
        } else return uw({items: [...d, ...g], random: o})
    }, [s, t.isMoonshotPair, t.fullfillRemainingAds, t.chainId, i, a.DS_WEB_MAX_TRENDING_BAR_ADS_AMOUNT, o])
}

function ttr(t) {
    const {recentAds: e} = am();
    return G2e({recentAds: e, chainId: t.chainId, tokenAddress: t.tokenAddress})
}

const [rtr, HWt] = LN("Time"), WWt = ({children: t}) => {
    const [e, r] = W.useState(() => new Date);
    return W.useEffect(() => {
        const n = m2e({intervalInMs: 1e3, callback: async () => r(new Date)});
        return n.start(), () => n.stop()
    }, []), ie.jsx(HWt, {value: {second: e}, children: t})
}, bT = t => new WW(t), OIe = t => {
    let e = t.replace(",", "."), r = !1;
    return e = e.replace(/\./g, () => r ? "" : (r = !0, ".")), e = e.replace(/[^0-9.]/g, ""), e === "0" ? e : e === "." ? "0." : e.replace(/^0+(?!\.)/, "")
}, Vme = t => {
    if (t === void 0) return;
    let e;
    return Rv(t) ? e = t[0] !== void 0 ? t[0] : void 0 : e = `${t}`, e !== void 0 ? OIe(e) : void 0
}, ntr = W.forwardRef(({
                           onChange: t,
                           onKeyDown: e,
                           onKeyUp: r,
                           onValueChange: n,
                           min: i,
                           max: a,
                           step: o,
                           value: s,
                           ...l
                       }, f) => {
    const d = W.useMemo(() => i !== void 0 ? bT(i) : void 0, [i]),
        p = W.useMemo(() => o !== void 0 ? bT(o) : void 0, [o]),
        g = W.useMemo(() => a !== void 0 ? bT(a) : void 0, [a]), [b, S] = W.useState(() => Vme(s)), T = ss(p),
        I = ss(d), N = ss(g), P = W.useRef(0), F = W.useCallback(ee => {
            t == null || t(ee);
            const oe = OIe(ee.target.value);
            S(oe), bT(oe).isNaN() === !1 && (n == null || n(oe))
        }, [t, n]), V = W.useCallback(ee => {
            switch (e == null || e(ee), ee.key) {
                case"ArrowUp":
                case"ArrowDown": {
                    if (P.current += 1, T.current === void 0) return;
                    const oe = ee.key === "ArrowDown", G = ee.shiftKey;
                    S(J => {
                        if (J === void 0 || J === "") return I.current === void 0 ? void 0 : I.current.toString();
                        if (T.current === void 0) return J;
                        let ce = bT(J);
                        if (ce.isNaN()) return J;
                        const re = P.current > 100 ? 1e4 : P.current > 50 ? 1e3 : P.current > 30 ? 100 : 10;
                        return I.current !== void 0 && ce.lt(I.current) ? ce = I.current : N.current !== void 0 && ce.gt(N.current) ? ce = N.current : oe ? ce = ce.minus(T.current.times(G ? re : Math.max(Math.round(re / 10), 1))) : ce = ce.plus(T.current.times(G ? re : Math.max(Math.round(re / 10), 1))), I.current !== void 0 && (ce = WW.max(I.current, ce)), N.current !== void 0 && (ce = WW.min(N.current, ce)), n == null || n(ce.toString()), ce.toString()
                    }), ee.preventDefault();
                    break
                }
            }
        }, [N, I, e, n, T]), Y = W.useCallback(ee => {
            switch (r == null || r(ee), ee.key) {
                case"ArrowUp":
                case"ArrowDown": {
                    P.current = 0;
                    break
                }
            }
        }, [r]);
    return W.useEffect(() => S(() => Vme(s)), [s]), ie.jsx(LA, {
        ref: f,
        type: "text",
        inputMode: "decimal",
        onChange: F,
        onKeyDown: V,
        onKeyUp: Y,
        value: b, ...l
    })
}), itr = W.memo(t => {
    const {
        compact: e,
        enableTooltip: r,
        initialNow: n,
        timestamp: i,
        updateInterval: a = 200,
        ...o
    } = t, [s, l] = W.useState(Hle(i, {now: n}));
    W.useEffect(() => {
        const d = setInterval(() => {
            l(Hle(i, {now: Date.now()}))
        }, a);
        return () => clearInterval(d)
    }, [i, a]);
    const f = e ? s == null ? void 0 : s.split(" ").at(0) : s;
    return ie.jsxs(ln, {
        as: "span",
        pos: "relative",
        _hover: {"@media (hover: hover)": {span: {display: "block"}}}, ...o,
        children: [f ?? "0s", !e && " ago", r && ie.jsx(ln, {
            as: "span",
            display: "none",
            pos: "absolute",
            top: "-2px",
            left: "110%",
            bg: "gray.950",
            borderWidth: 1,
            borderColor: "gray.975",
            color: "white",
            fontSize: "2xs",
            px: "6px",
            py: "2px",
            whiteSpace: "nowrap",
            borderRadius: "sm",
            userSelect: "none",
            children: Fut(i, "MMM d hh:mm:ss a")
        })]
    })
});

function xo(t, e) {
    return r => r.colorMode === "dark" ? e : t
}

const qWt = t => W.createElement("svg", {
    viewBox: "0 0 70 70",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg", ...t
}, W.createElement("path", {
    d: "M69.8374 47.9306C70.6307 46.0406 68.3635 44.4306 66.4618 45.2706C62.6606 46.9392 58.5535 47.7974 54.4022 47.7906C38.127 47.7906 24.9358 34.864 24.9358 18.9157C24.9298 13.531 26.4597 8.25619 29.3458 3.71022C30.4503 1.968 29.1242 -0.443102 27.1019 0.0702296C11.5112 4.04855 0 17.9396 0 34.4635C0 54.0906 16.2363 70 36.2681 70C51.435 70 64.424 60.8806 69.8374 47.9306Z",
    fill: "currentColor"
}), W.createElement("path", {
    d: "M62.6526 8.11672C63.4175 5.86247 60.5264 4.19344 58.9554 5.97929L56.155 9.16564C55.0196 10.458 53.5269 11.3853 51.8652 11.8306C50.2035 12.2758 48.4472 12.2191 46.8178 11.6675L42.7993 10.3083C40.5459 9.5472 38.8776 12.4418 40.6671 14.0116L43.8526 16.8081C45.1451 17.9433 46.0724 19.4359 46.5176 21.0974C46.9628 22.759 46.906 24.5152 46.3543 26.1446L44.9948 30.1628C44.23 32.417 47.1211 34.0861 48.6911 32.2966L51.4915 29.1103C52.6269 27.8179 54.1195 26.8906 55.7812 26.4453C57.4429 26.0001 59.1993 26.0568 60.8287 26.6084L64.8472 27.9676C67.1015 28.7323 68.7708 25.8413 66.9803 24.2679L63.7948 21.4714C62.5024 20.3362 61.5751 18.8436 61.1299 17.1821C60.6847 15.5205 60.7415 13.7643 61.2931 12.1349L62.6526 8.11672Z",
    fill: "currentColor"
}));
var KI = t => t.type === "checkbox", Vx = t => t instanceof Date, ru = t => t == null;
const PIe = t => typeof t == "object";
var ac = t => !ru(t) && !Array.isArray(t) && PIe(t) && !Vx(t),
    NIe = t => ac(t) && t.target ? KI(t.target) ? t.target.checked : t.target.value : t,
    GWt = t => t.substring(0, t.search(/\.\d+(\.|$)/)) || t, LIe = (t, e) => t.has(GWt(e)),
    YI = t => Array.isArray(t) ? t.filter(Boolean) : [], jo = t => t === void 0, ir = (t, e, r) => {
        if (!e || !ac(t)) return r;
        const n = YI(e.split(/[,[\].]+?/)).reduce((i, a) => ru(i) ? i : i[a], t);
        return jo(n) || n === t ? jo(t[e]) ? r : t[e] : n
    };
const TP = {BLUR: "blur", FOCUS_OUT: "focusout", CHANGE: "change"},
    Qh = {onBlur: "onBlur", onChange: "onChange", onSubmit: "onSubmit", onTouched: "onTouched", all: "all"}, tv = {
        max: "max",
        min: "min",
        maxLength: "maxLength",
        minLength: "minLength",
        pattern: "pattern",
        required: "required",
        validate: "validate"
    }, BIe = ar.createContext(null), yB = () => ar.useContext(BIe), KWt = t => {
        const {children: e, ...r} = t;
        return ar.createElement(BIe.Provider, {value: r}, e)
    };
var $Ie = (t, e, r, n = !0) => {
        const i = {defaultValues: e._defaultValues};
        for (const a in t) Object.defineProperty(i, a, {
            get: () => {
                const o = a;
                return e._proxyFormState[o] !== Qh.all && (e._proxyFormState[o] = !n || Qh.all), r && (r[o] = !0), t[o]
            }
        });
        return i
    }, Fd = t => ac(t) && !Object.keys(t).length, FIe = (t, e, r) => {
        const {name: n, ...i} = t;
        return Fd(i) || Object.keys(i).length >= Object.keys(e).length || Object.keys(i).find(a => e[a] === (!r || Qh.all))
    }, yM = t => Array.isArray(t) ? t : [t],
    UIe = (t, e, r) => r && e ? t === e : !t || !e || t === e || yM(t).some(n => n && (n.startsWith(e) || e.startsWith(n)));

function Xte(t) {
    const e = ar.useRef(t);
    e.current = t, ar.useEffect(() => {
        const r = !t.disabled && e.current.subject.subscribe({next: e.current.callback});
        return () => {
            r && r.unsubscribe()
        }
    }, [t.disabled])
}

function YWt(t) {
    const e = yB(), {
            control: r = e.control,
            disabled: n,
            name: i,
            exact: a
        } = t || {}, [o, s] = ar.useState(r._formState), l = ar.useRef(!0),
        f = ar.useRef({isDirty: !1, dirtyFields: !1, touchedFields: !1, isValidating: !1, isValid: !1, errors: !1}),
        d = ar.useRef(i);
    return d.current = i, Xte({
        disabled: n,
        callback: ar.useCallback(p => l.current && UIe(d.current, p.name, a) && FIe(p, f.current) && s({...r._formState, ...p}), [r, a]),
        subject: r._subjects.state
    }), ar.useEffect(() => (l.current = !0, () => {
        l.current = !1
    }), []), $Ie(o, r, f.current, !1)
}

var Zh = t => typeof t == "string", jIe = (t, e, r, n) => {
    const i = Array.isArray(t);
    return Zh(t) ? (n && e.watch.add(t), ir(r, t)) : i ? t.map(a => (n && e.watch.add(a), ir(r, a))) : (n && (e.watchAll = !0), r)
}, CP = t => typeof t == "function", Qte = t => {
    for (const e in t) if (CP(t[e])) return !0;
    return !1
};

function XWt(t) {
    const e = yB(), {control: r = e.control, name: n, defaultValue: i, disabled: a, exact: o} = t || {},
        s = ar.useRef(n);
    s.current = n, Xte({
        disabled: a, subject: r._subjects.watch, callback: ar.useCallback(d => {
            if (UIe(s.current, d.name, o)) {
                const p = jIe(s.current, r._names, d.values || r._formValues);
                f(jo(s.current) || ac(p) && !Qte(p) ? {...p} : Array.isArray(p) ? [...p] : jo(p) ? i : p)
            }
        }, [r, o, i])
    });
    const [l, f] = ar.useState(jo(i) ? r._getWatch(n) : i);
    return ar.useEffect(() => r._removeUnmounted()), l
}

function QWt(t) {
    const e = yB(), {name: r, control: n = e.control, shouldUnregister: i} = t, a = LIe(n._names.array, r), o = XWt({
        control: n,
        name: r,
        defaultValue: ir(n._formValues, r, ir(n._defaultValues, r, t.defaultValue)),
        exact: !0
    }), s = YWt({control: n, name: r}), l = ar.useRef(n.register(r, {...t.rules, value: o})), f = ir(n._fields, r);
    return f && (f._f._c = !0), ar.useEffect(() => {
        const d = (p, g) => {
            const b = ir(n._fields, p);
            b && (b._f.mount = g)
        };
        return d(r, !0), () => {
            const p = n._options.shouldUnregister || i;
            (a ? p && !n._stateFlags.action : p) ? n.unregister(r) : d(r, !1)
        }
    }, [r, n, a, i]), {
        field: {
            name: r,
            value: o,
            onChange: ar.useCallback(d => l.current.onChange({target: {value: NIe(d), name: r}, type: TP.CHANGE}), [r]),
            onBlur: ar.useCallback(() => l.current.onBlur({
                target: {value: ir(n._formValues, r), name: r},
                type: TP.BLUR
            }), [r, n]),
            ref: d => {
                f && d && (f._f.ref = d)
            }
        },
        formState: s,
        fieldState: Object.defineProperties({}, {
            invalid: {enumerable: !0, get: () => !!ir(s.errors, r)},
            isDirty: {enumerable: !0, get: () => !!ir(s.dirtyFields, r)},
            isTouched: {enumerable: !0, get: () => !!ir(s.touchedFields, r)},
            error: {enumerable: !0, get: () => ir(s.errors, r)}
        })
    }
}

const ZWt = t => t.render(QWt(t));
var JWt = (t, e, r, n, i) => e ? {...r[t], types: {...r[t] && r[t].types ? r[t].types : {}, [n]: i || !0}} : {},
    Zte = t => /^\w*$/.test(t), zIe = t => YI(t.replace(/["|']|\]/g, "").split(/\.|\[/));

function qa(t, e, r) {
    let n = -1;
    const i = Zte(e) ? [e] : zIe(e), a = i.length, o = a - 1;
    for (; ++n < a;) {
        const s = i[n];
        let l = r;
        if (n !== o) {
            const f = t[s];
            l = ac(f) || Array.isArray(f) ? f : isNaN(+i[n + 1]) ? {} : []
        }
        t[s] = l, t = t[s]
    }
    return t
}

const NY = (t, e, r) => {
    for (const n of r || Object.keys(t)) {
        const i = ir(t, n);
        if (i) {
            const {_f: a, ...o} = i;
            if (a && e(a.name)) {
                if (a.ref.focus) {
                    a.ref.focus();
                    break
                } else if (a.refs && a.refs[0].focus) {
                    a.refs[0].focus();
                    break
                }
            } else ac(o) && NY(o, e)
        }
    }
};
var Hme = (t, e, r) => !r && (e.watchAll || e.watch.has(t) || [...e.watch].some(n => t.startsWith(n) && /^\.\w+/.test(t.slice(n.length)))),
    eqt = (t, e, r) => {
        const n = YI(ir(t, r));
        return qa(n, "root", e[r]), qa(t, r, n), t
    }, MC = t => typeof t == "boolean", Jte = t => t.type === "file", bM = t => Zh(t) || ar.isValidElement(t),
    ere = t => t.type === "radio", AP = t => t instanceof RegExp;
const Wme = {value: !1, isValid: !1}, qme = {value: !0, isValid: !0};
var VIe = t => {
    if (Array.isArray(t)) {
        if (t.length > 1) {
            const e = t.filter(r => r && r.checked && !r.disabled).map(r => r.value);
            return {value: e, isValid: !!e.length}
        }
        return t[0].checked && !t[0].disabled ? t[0].attributes && !jo(t[0].attributes.value) ? jo(t[0].value) || t[0].value === "" ? qme : {
            value: t[0].value,
            isValid: !0
        } : qme : Wme
    }
    return Wme
};
const Gme = {isValid: !1, value: null};
var HIe = t => Array.isArray(t) ? t.reduce((e, r) => r && r.checked && !r.disabled ? {
    isValid: !0,
    value: r.value
} : e, Gme) : Gme;

function Kme(t, e, r = "validate") {
    if (bM(t) || Array.isArray(t) && t.every(bM) || MC(t) && !t) return {type: r, message: bM(t) ? t : "", ref: e}
}

var ux = t => ac(t) && !AP(t) ? t : {value: t, message: ""}, Yme = async (t, e, r, n, i) => {
    const {
        ref: a,
        refs: o,
        required: s,
        maxLength: l,
        minLength: f,
        min: d,
        max: p,
        pattern: g,
        validate: b,
        name: S,
        valueAsNumber: T,
        mount: I,
        disabled: N
    } = t._f;
    if (!I || N) return {};
    const P = o ? o[0] : a, F = re => {
            n && Zh(re) && (P.setCustomValidity(re), P.reportValidity())
        }, V = {}, Y = ere(a), ee = KI(a), oe = Y || ee,
        G = (T || Jte(a)) && !a.value || e === "" || Array.isArray(e) && !e.length, J = JWt.bind(null, S, r, V),
        ce = (re, M, D, x = tv.maxLength, A = tv.minLength) => {
            const B = re ? M : D;
            V[S] = {type: re ? x : A, message: B, ref: a, ...J(re ? x : A, B)}
        };
    if (i ? !Array.isArray(e) || !e.length : s && (!oe && (G || ru(e)) || MC(e) && !e || ee && !VIe(o).isValid || Y && !HIe(o).isValid)) {
        const {value: re, message: M} = bM(s) ? {value: !!s, message: s} : ux(s);
        if (re && (V[S] = {type: tv.required, message: M, ref: P, ...J(tv.required, M)}, !r)) return F(M), V
    }
    if (!G && (!ru(d) || !ru(p))) {
        let re, M;
        const D = ux(p), x = ux(d);
        if (!ru(e) && !isNaN(e)) {
            const A = a.valueAsNumber || e && +e;
            ru(D.value) || (re = A > D.value), ru(x.value) || (M = A < x.value)
        } else {
            const A = a.valueAsDate || new Date(e), B = $ => new Date(new Date().toDateString() + " " + $),
                z = a.type == "time", j = a.type == "week";
            Zh(D.value) && e && (re = z ? B(e) > B(D.value) : j ? e > D.value : A > new Date(D.value)), Zh(x.value) && e && (M = z ? B(e) < B(x.value) : j ? e < x.value : A < new Date(x.value))
        }
        if ((re || M) && (ce(!!re, D.message, x.message, tv.max, tv.min), !r)) return F(V[S].message), V
    }
    if ((l || f) && !G && (Zh(e) || i && Array.isArray(e))) {
        const re = ux(l), M = ux(f), D = !ru(re.value) && e.length > re.value, x = !ru(M.value) && e.length < M.value;
        if ((D || x) && (ce(D, re.message, M.message), !r)) return F(V[S].message), V
    }
    if (g && !G && Zh(e)) {
        const {value: re, message: M} = ux(g);
        if (AP(re) && !e.match(re) && (V[S] = {
            type: tv.pattern,
            message: M,
            ref: a, ...J(tv.pattern, M)
        }, !r)) return F(M), V
    }
    if (b) {
        if (CP(b)) {
            const re = await b(e), M = Kme(re, P);
            if (M && (V[S] = {...M, ...J(tv.validate, M.message)}, !r)) return F(M.message), V
        } else if (ac(b)) {
            let re = {};
            for (const M in b) {
                if (!Fd(re) && !r) break;
                const D = Kme(await b[M](e), P, M);
                D && (re = {...D, ...J(M, D.message)}, F(D.message), r && (V[S] = re))
            }
            if (!Fd(re) && (V[S] = {ref: P, ...re}, !r)) return V
        }
    }
    return F(!0), V
}, tqt = t => {
    const e = t.constructor && t.constructor.prototype;
    return ac(e) && e.hasOwnProperty("isPrototypeOf")
}, LY = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";

function cw(t) {
    let e;
    const r = Array.isArray(t);
    if (t instanceof Date) e = new Date(t); else if (t instanceof Set) e = new Set(t); else if (!(LY && (t instanceof Blob || t instanceof FileList)) && (r || ac(t))) if (e = r ? [] : {}, !Array.isArray(t) && !tqt(t)) e = t; else for (const n in t) e[n] = cw(t[n]); else return t;
    return e
}

var Xme = t => ({
    isOnSubmit: !t || t === Qh.onSubmit,
    isOnBlur: t === Qh.onBlur,
    isOnChange: t === Qh.onChange,
    isOnAll: t === Qh.all,
    isOnTouch: t === Qh.onTouched
});

function rqt(t, e) {
    const r = e.slice(0, -1).length;
    let n = 0;
    for (; n < r;) t = jo(t) ? n++ : t[e[n++]];
    return t
}

function nqt(t) {
    for (const e in t) if (!jo(t[e])) return !1;
    return !0
}

function Zl(t, e) {
    const r = Zte(e) ? [e] : zIe(e), n = r.length == 1 ? t : rqt(t, r), i = r[r.length - 1];
    let a;
    n && delete n[i];
    for (let o = 0; o < r.slice(0, -1).length; o++) {
        let s = -1, l;
        const f = r.slice(0, -(o + 1)), d = f.length - 1;
        for (o > 0 && (a = t); ++s < f.length;) {
            const p = f[s];
            l = l ? l[p] : t[p], d === s && (ac(l) && Fd(l) || Array.isArray(l) && nqt(l)) && (a ? delete a[p] : delete t[p]), a = l
        }
    }
    return t
}

function iW() {
    let t = [];
    return {
        get observers() {
            return t
        }, next: i => {
            for (const a of t) a.next(i)
        }, subscribe: i => (t.push(i), {
            unsubscribe: () => {
                t = t.filter(a => a !== i)
            }
        }), unsubscribe: () => {
            t = []
        }
    }
}

var IP = t => ru(t) || !PIe(t);

function Hx(t, e) {
    if (IP(t) || IP(e)) return t === e;
    if (Vx(t) && Vx(e)) return t.getTime() === e.getTime();
    const r = Object.keys(t), n = Object.keys(e);
    if (r.length !== n.length) return !1;
    for (const i of r) {
        const a = t[i];
        if (!n.includes(i)) return !1;
        if (i !== "ref") {
            const o = e[i];
            if (Vx(a) && Vx(o) || ac(a) && ac(o) || Array.isArray(a) && Array.isArray(o) ? !Hx(a, o) : a !== o) return !1
        }
    }
    return !0
}

var BY = t => {
    const e = t ? t.ownerDocument : 0, r = e && e.defaultView ? e.defaultView.HTMLElement : HTMLElement;
    return t instanceof r
}, WIe = t => t.type === "select-multiple", iqt = t => ere(t) || KI(t), aW = t => BY(t) && t.isConnected;

function kP(t, e = {}) {
    const r = Array.isArray(t);
    if (ac(t) || r) for (const n in t) Array.isArray(t[n]) || ac(t[n]) && !Qte(t[n]) ? (e[n] = Array.isArray(t[n]) ? [] : {}, kP(t[n], e[n])) : ru(t[n]) || (e[n] = !0);
    return e
}

function qIe(t, e, r) {
    const n = Array.isArray(t);
    if (ac(t) || n) for (const i in t) Array.isArray(t[i]) || ac(t[i]) && !Qte(t[i]) ? jo(e) || IP(r[i]) ? r[i] = Array.isArray(t[i]) ? kP(t[i], []) : {...kP(t[i])} : qIe(t[i], ru(e) ? {} : e[i], r[i]) : Hx(t[i], e[i]) ? delete r[i] : r[i] = !0;
    return r
}

var oW = (t, e) => qIe(t, e, kP(e)), GIe = (t, {
    valueAsNumber: e,
    valueAsDate: r,
    setValueAs: n
}) => jo(t) ? t : e ? t === "" ? NaN : t && +t : r && Zh(t) ? new Date(t) : n ? n(t) : t;

function sW(t) {
    const e = t.ref;
    if (!(t.refs ? t.refs.every(r => r.disabled) : e.disabled)) return Jte(e) ? e.files : ere(e) ? HIe(t.refs).value : WIe(e) ? [...e.selectedOptions].map(({value: r}) => r) : KI(e) ? VIe(t.refs).value : GIe(jo(e.value) ? t.ref.value : e.value, t)
}

var aqt = (t, e, r, n) => {
        const i = {};
        for (const a of t) {
            const o = ir(e, a);
            o && qa(i, a, o._f)
        }
        return {criteriaMode: r, names: [...t], fields: i, shouldUseNativeValidation: n}
    }, wT = t => jo(t) ? void 0 : AP(t) ? t.source : ac(t) ? AP(t.value) ? t.value.source : t.value : t,
    oqt = t => t.mount && (t.required || t.min || t.max || t.maxLength || t.minLength || t.pattern || t.validate);

function Qme(t, e, r) {
    const n = ir(t, r);
    if (n || Zte(r)) return {error: n, name: r};
    const i = r.split(".");
    for (; i.length;) {
        const a = i.join("."), o = ir(e, a), s = ir(t, a);
        if (o && !Array.isArray(o) && r !== a) return {name: r};
        if (s && s.type) return {name: a, error: s};
        i.pop()
    }
    return {name: r}
}

var sqt = (t, e, r, n, i) => i.isOnAll ? !1 : !r && i.isOnTouch ? !(e || t) : (r ? n.isOnBlur : i.isOnBlur) ? !t : (r ? n.isOnChange : i.isOnChange) ? t : !0,
    cqt = (t, e) => !YI(ir(t, e)).length && Zl(t, e);
const lqt = {mode: Qh.onSubmit, reValidateMode: Qh.onChange, shouldFocusError: !0};

function uqt(t = {}) {
    let e = {...lqt, ...t}, r = {
            submitCount: 0,
            isDirty: !1,
            isValidating: !1,
            isSubmitted: !1,
            isSubmitting: !1,
            isSubmitSuccessful: !1,
            isValid: !1,
            touchedFields: {},
            dirtyFields: {},
            errors: {}
        }, n = {}, i = cw(e.defaultValues) || {}, a = e.shouldUnregister ? {} : cw(i),
        o = {action: !1, mount: !1, watch: !1}, s = {mount: new Set, unMount: new Set, array: new Set, watch: new Set},
        l, f = 0, d = {};
    const p = {isDirty: !1, dirtyFields: !1, touchedFields: !1, isValidating: !1, isValid: !1, errors: !1},
        g = {watch: iW(), array: iW(), state: iW()}, b = Xme(e.mode), S = Xme(e.reValidateMode),
        T = e.criteriaMode === Qh.all, I = ne => be => {
            clearTimeout(f), f = window.setTimeout(ne, be)
        }, N = async () => {
            let ne = !1;
            return p.isValid && (ne = e.resolver ? Fd((await oe()).errors) : await J(n, !0), ne !== r.isValid && (r.isValid = ne, g.state.next({isValid: ne}))), ne
        }, P = (ne, be = [], Ee, Oe, ze = !0, Be = !0) => {
            if (Oe && Ee) {
                if (o.action = !0, Be && Array.isArray(ir(n, ne))) {
                    const it = Ee(ir(n, ne), Oe.argA, Oe.argB);
                    ze && qa(n, ne, it)
                }
                if (p.errors && Be && Array.isArray(ir(r.errors, ne))) {
                    const it = Ee(ir(r.errors, ne), Oe.argA, Oe.argB);
                    ze && qa(r.errors, ne, it), cqt(r.errors, ne)
                }
                if (p.touchedFields && Be && Array.isArray(ir(r.touchedFields, ne))) {
                    const it = Ee(ir(r.touchedFields, ne), Oe.argA, Oe.argB);
                    ze && qa(r.touchedFields, ne, it)
                }
                p.dirtyFields && (r.dirtyFields = oW(i, a)), g.state.next({
                    isDirty: re(ne, be),
                    dirtyFields: r.dirtyFields,
                    errors: r.errors,
                    isValid: r.isValid
                })
            } else qa(a, ne, be)
        }, F = (ne, be) => {
            qa(r.errors, ne, be), g.state.next({errors: r.errors})
        }, V = (ne, be, Ee, Oe) => {
            const ze = ir(n, ne);
            if (ze) {
                const Be = ir(a, ne, jo(Ee) ? ir(i, ne) : Ee);
                jo(Be) || Oe && Oe.defaultChecked || be ? qa(a, ne, be ? Be : sW(ze._f)) : x(ne, Be), o.mount && N()
            }
        }, Y = (ne, be, Ee, Oe, ze) => {
            let Be = !1;
            const it = {name: ne}, Ue = ir(r.touchedFields, ne);
            if (p.isDirty) {
                const bt = r.isDirty;
                r.isDirty = it.isDirty = re(), Be = bt !== it.isDirty
            }
            if (p.dirtyFields && (!Ee || Oe)) {
                const bt = ir(r.dirtyFields, ne);
                Hx(ir(i, ne), be) ? Zl(r.dirtyFields, ne) : qa(r.dirtyFields, ne, !0), it.dirtyFields = r.dirtyFields, Be = Be || bt !== ir(r.dirtyFields, ne)
            }
            return Ee && !Ue && (qa(r.touchedFields, ne, Ee), it.touchedFields = r.touchedFields, Be = Be || p.touchedFields && Ue !== Ee), Be && ze && g.state.next(it), Be ? it : {}
        }, ee = (ne, be, Ee, Oe) => {
            const ze = ir(r.errors, ne), Be = p.isValid && MC(be) && r.isValid !== be;
            if (t.delayError && Ee ? (l = I(() => F(ne, Ee)), l(t.delayError)) : (clearTimeout(f), l = null, Ee ? qa(r.errors, ne, Ee) : Zl(r.errors, ne)), (Ee ? !Hx(ze, Ee) : ze) || !Fd(Oe) || Be) {
                const it = {...Oe, ...Be && MC(be) ? {isValid: be} : {}, errors: r.errors, name: ne};
                r = {...r, ...it}, g.state.next(it)
            }
            d[ne]--, p.isValidating && !Object.values(d).some(it => it) && (g.state.next({isValidating: !1}), d = {})
        },
        oe = async ne => e.resolver ? await e.resolver({...a}, e.context, aqt(ne || s.mount, n, e.criteriaMode, e.shouldUseNativeValidation)) : {},
        G = async ne => {
            const {errors: be} = await oe();
            if (ne) for (const Ee of ne) {
                const Oe = ir(be, Ee);
                Oe ? qa(r.errors, Ee, Oe) : Zl(r.errors, Ee)
            } else r.errors = be;
            return be
        }, J = async (ne, be, Ee = {valid: !0}) => {
            for (const Oe in ne) {
                const ze = ne[Oe];
                if (ze) {
                    const {_f: Be, ...it} = ze;
                    if (Be) {
                        const Ue = s.array.has(Be.name),
                            bt = await Yme(ze, ir(a, Be.name), T, e.shouldUseNativeValidation, Ue);
                        if (bt[Be.name] && (Ee.valid = !1, be)) break;
                        !be && (ir(bt, Be.name) ? Ue ? eqt(r.errors, bt, Be.name) : qa(r.errors, Be.name, bt[Be.name]) : Zl(r.errors, Be.name))
                    }
                    it && await J(it, be, Ee)
                }
            }
            return Ee.valid
        }, ce = () => {
            for (const ne of s.unMount) {
                const be = ir(n, ne);
                be && (be._f.refs ? be._f.refs.every(Ee => !aW(Ee)) : !aW(be._f.ref)) && fe(ne)
            }
            s.unMount = new Set
        }, re = (ne, be) => (ne && be && qa(a, ne, be), !Hx($(), i)), M = (ne, be, Ee) => {
            const Oe = {...o.mount ? a : jo(be) ? i : Zh(ne) ? {[ne]: be} : be};
            return jIe(ne, s, Oe, Ee)
        }, D = ne => YI(ir(o.mount ? a : i, ne, t.shouldUnregister ? ir(i, ne, []) : [])), x = (ne, be, Ee = {}) => {
            const Oe = ir(n, ne);
            let ze = be;
            if (Oe) {
                const Be = Oe._f;
                Be && (!Be.disabled && qa(a, ne, GIe(be, Be)), ze = LY && BY(Be.ref) && ru(be) ? "" : be, WIe(Be.ref) ? [...Be.ref.options].forEach(it => it.selected = ze.includes(it.value)) : Be.refs ? KI(Be.ref) ? Be.refs.length > 1 ? Be.refs.forEach(it => (!it.defaultChecked || !it.disabled) && (it.checked = Array.isArray(ze) ? !!ze.find(Ue => Ue === it.value) : ze === it.value)) : Be.refs[0] && (Be.refs[0].checked = !!ze) : Be.refs.forEach(it => it.checked = it.value === ze) : Jte(Be.ref) ? Be.ref.value = "" : (Be.ref.value = ze, Be._c && g.watch.next({name: ne})))
            }
            (Ee.shouldDirty || Ee.shouldTouch) && Y(ne, ze, Ee.shouldTouch, Ee.shouldDirty, !0), Ee.shouldValidate && j(ne)
        }, A = (ne, be, Ee) => {
            for (const Oe in be) {
                const ze = be[Oe], Be = `${ne}.${Oe}`, it = ir(n, Be);
                (s.array.has(ne) || !IP(ze) || it && !it._f) && !Vx(ze) ? A(Be, ze, Ee) : x(Be, ze, Ee)
            }
        }, B = (ne, be, Ee = {}) => {
            const Oe = ir(n, ne), ze = s.array.has(ne), Be = cw(be);
            qa(a, ne, Be), ze ? (g.array.next({
                name: ne,
                values: a
            }), (p.isDirty || p.dirtyFields) && Ee.shouldDirty && (r.dirtyFields = oW(i, a), g.state.next({
                name: ne,
                dirtyFields: r.dirtyFields,
                isDirty: re(ne, Be)
            }))) : Oe && !Oe._f && !ru(Be) ? A(ne, Be, Ee) : x(ne, Be, Ee), Hme(ne, s) && g.state.next({}), g.watch.next({name: ne})
        }, z = async ne => {
            const be = ne.target;
            let Ee = be.name;
            const Oe = ir(n, Ee);
            if (Oe) {
                let ze, Be;
                const it = be.type ? sW(Oe._f) : NIe(ne), Ue = ne.type === TP.BLUR || ne.type === TP.FOCUS_OUT,
                    bt = !oqt(Oe._f) && !e.resolver && !ir(r.errors, Ee) && !Oe._f.deps || sqt(Ue, ir(r.touchedFields, Ee), r.isSubmitted, S, b),
                    gt = Hme(Ee, s, Ue);
                qa(a, Ee, it), Ue ? (Oe._f.onBlur && Oe._f.onBlur(ne), l && l(0)) : Oe._f.onChange && Oe._f.onChange(ne);
                const Ot = Y(Ee, it, Ue, !1), zt = !Fd(Ot) || gt;
                if (!Ue && g.watch.next({
                    name: Ee,
                    type: ne.type
                }), bt) return p.isValid && N(), zt && g.state.next({name: Ee, ...gt ? {} : Ot});
                if (!Ue && gt && g.state.next({}), d[Ee] = d[Ee] ? d[Ee] + 1 : 1, g.state.next({isValidating: !0}), e.resolver) {
                    const {errors: _t} = await oe([Ee]), Dt = Qme(r.errors, n, Ee), rr = Qme(_t, n, Dt.name || Ee);
                    ze = rr.error, Ee = rr.name, Be = Fd(_t)
                } else ze = (await Yme(Oe, ir(a, Ee), T, e.shouldUseNativeValidation))[Ee], N();
                Oe._f.deps && j(Oe._f.deps), ee(Ee, Be, ze, Ot)
            }
        }, j = async (ne, be = {}) => {
            let Ee, Oe;
            const ze = yM(ne);
            if (g.state.next({isValidating: !0}), e.resolver) {
                const Be = await G(jo(ne) ? ne : ze);
                Ee = Fd(Be), Oe = ne ? !ze.some(it => ir(Be, it)) : Ee
            } else ne ? (Oe = (await Promise.all(ze.map(async Be => {
                const it = ir(n, Be);
                return await J(it && it._f ? {[Be]: it} : it)
            }))).every(Boolean), !(!Oe && !r.isValid) && N()) : Oe = Ee = await J(n);
            return g.state.next({
                ...!Zh(ne) || p.isValid && Ee !== r.isValid ? {} : {name: ne}, ...e.resolver || !ne ? {isValid: Ee} : {},
                errors: r.errors,
                isValidating: !1
            }), be.shouldFocus && !Oe && NY(n, Be => Be && ir(r.errors, Be), ne ? ze : s.mount), Oe
        }, $ = ne => {
            const be = {...i, ...o.mount ? a : {}};
            return jo(ne) ? be : Zh(ne) ? ir(be, ne) : ne.map(Ee => ir(be, Ee))
        }, C = (ne, be) => ({
            invalid: !!ir((be || r).errors, ne),
            isDirty: !!ir((be || r).dirtyFields, ne),
            isTouched: !!ir((be || r).touchedFields, ne),
            error: ir((be || r).errors, ne)
        }), R = ne => {
            ne ? yM(ne).forEach(be => Zl(r.errors, be)) : r.errors = {}, g.state.next({errors: r.errors})
        }, k = (ne, be, Ee) => {
            const Oe = (ir(n, ne, {_f: {}})._f || {}).ref;
            qa(r.errors, ne, {...be, ref: Oe}), g.state.next({
                name: ne,
                errors: r.errors,
                isValid: !1
            }), Ee && Ee.shouldFocus && Oe && Oe.focus && Oe.focus()
        }, Q = (ne, be) => CP(ne) ? g.watch.subscribe({next: Ee => ne(M(void 0, be), Ee)}) : M(ne, be, !0),
        fe = (ne, be = {}) => {
            for (const Ee of ne ? yM(ne) : s.mount) s.mount.delete(Ee), s.array.delete(Ee), ir(n, Ee) && (be.keepValue || (Zl(n, Ee), Zl(a, Ee)), !be.keepError && Zl(r.errors, Ee), !be.keepDirty && Zl(r.dirtyFields, Ee), !be.keepTouched && Zl(r.touchedFields, Ee), !e.shouldUnregister && !be.keepDefaultValue && Zl(i, Ee));
            g.watch.next({}), g.state.next({...r, ...be.keepDirty ? {isDirty: re()} : {}}), !be.keepIsValid && N()
        }, ye = (ne, be = {}) => {
            let Ee = ir(n, ne);
            const Oe = MC(be.disabled);
            return qa(n, ne, {
                ...Ee || {},
                _f: {...Ee && Ee._f ? Ee._f : {ref: {name: ne}}, name: ne, mount: !0, ...be}
            }), s.mount.add(ne), Ee ? Oe && qa(a, ne, be.disabled ? void 0 : ir(a, ne, sW(Ee._f))) : V(ne, !0, be.value), {
                ...Oe ? {disabled: be.disabled} : {}, ...e.shouldUseNativeValidation ? {
                    required: !!be.required,
                    min: wT(be.min),
                    max: wT(be.max),
                    minLength: wT(be.minLength),
                    maxLength: wT(be.maxLength),
                    pattern: wT(be.pattern)
                } : {}, name: ne, onChange: z, onBlur: z, ref: ze => {
                    if (ze) {
                        ye(ne, be), Ee = ir(n, ne);
                        const Be = jo(ze.value) && ze.querySelectorAll && ze.querySelectorAll("input,select,textarea")[0] || ze,
                            it = iqt(Be), Ue = Ee._f.refs || [];
                        if (it ? Ue.find(bt => bt === Be) : Be === Ee._f.ref) return;
                        qa(n, ne, {
                            _f: {
                                ...Ee._f, ...it ? {
                                    refs: [...Ue.filter(aW), Be, ...Array.isArray(ir(i, ne)) ? [{}] : []],
                                    ref: {type: Be.type, name: ne}
                                } : {ref: Be}
                            }
                        }), V(ne, !1, void 0, Be)
                    } else Ee = ir(n, ne, {}), Ee._f && (Ee._f.mount = !1), (e.shouldUnregister || be.shouldUnregister) && !(LIe(s.array, ne) && o.action) && s.unMount.add(ne)
                }
            }
        }, ue = () => e.shouldFocusError && NY(n, ne => ne && ir(r.errors, ne), s.mount), me = (ne, be) => async Ee => {
            Ee && (Ee.preventDefault && Ee.preventDefault(), Ee.persist && Ee.persist());
            let Oe = !0, ze = cw(a);
            g.state.next({isSubmitting: !0});
            try {
                if (e.resolver) {
                    const {errors: Be, values: it} = await oe();
                    r.errors = Be, ze = it
                } else await J(n);
                Fd(r.errors) ? (g.state.next({
                    errors: {},
                    isSubmitting: !0
                }), await ne(ze, Ee)) : (be && await be({...r.errors}, Ee), ue())
            } catch (Be) {
                throw Oe = !1, Be
            } finally {
                r.isSubmitted = !0, g.state.next({
                    isSubmitted: !0,
                    isSubmitting: !1,
                    isSubmitSuccessful: Fd(r.errors) && Oe,
                    submitCount: r.submitCount + 1,
                    errors: r.errors
                })
            }
        }, Se = (ne, be = {}) => {
            ir(n, ne) && (jo(be.defaultValue) ? B(ne, ir(i, ne)) : (B(ne, be.defaultValue), qa(i, ne, be.defaultValue)), be.keepTouched || Zl(r.touchedFields, ne), be.keepDirty || (Zl(r.dirtyFields, ne), r.isDirty = be.defaultValue ? re(ne, ir(i, ne)) : re()), be.keepError || (Zl(r.errors, ne), p.isValid && N()), g.state.next({...r}))
        }, Ce = (ne, be = {}) => {
            const Ee = ne || i, Oe = cw(Ee), ze = ne && !Fd(ne) ? Oe : i;
            if (be.keepDefaultValues || (i = Ee), !be.keepValues) {
                if (be.keepDirtyValues) for (const Be of s.mount) ir(r.dirtyFields, Be) ? qa(ze, Be, ir(a, Be)) : B(Be, ir(ze, Be)); else {
                    if (LY && jo(ne)) for (const Be of s.mount) {
                        const it = ir(n, Be);
                        if (it && it._f) {
                            const Ue = Array.isArray(it._f.refs) ? it._f.refs[0] : it._f.ref;
                            if (BY(Ue)) {
                                const bt = Ue.closest("form");
                                if (bt) {
                                    bt.reset();
                                    break
                                }
                            }
                        }
                    }
                    n = {}
                }
                a = t.shouldUnregister ? be.keepDefaultValues ? cw(i) : {} : Oe, g.array.next({values: ze}), g.watch.next({values: ze})
            }
            s = {
                mount: new Set,
                unMount: new Set,
                array: new Set,
                watch: new Set,
                watchAll: !1,
                focus: ""
            }, o.mount = !p.isValid || !!be.keepIsValid, o.watch = !!t.shouldUnregister, g.state.next({
                submitCount: be.keepSubmitCount ? r.submitCount : 0,
                isDirty: be.keepDirty || be.keepDirtyValues ? r.isDirty : !!(be.keepDefaultValues && !Hx(ne, i)),
                isSubmitted: be.keepIsSubmitted ? r.isSubmitted : !1,
                dirtyFields: be.keepDirty || be.keepDirtyValues ? r.dirtyFields : be.keepDefaultValues && ne ? oW(i, ne) : {},
                touchedFields: be.keepTouched ? r.touchedFields : {},
                errors: be.keepErrors ? r.errors : {},
                isSubmitting: !1,
                isSubmitSuccessful: !1
            })
        };
    return {
        control: {
            register: ye,
            unregister: fe,
            getFieldState: C,
            _executeSchema: oe,
            _focusError: ue,
            _getWatch: M,
            _getDirty: re,
            _updateValid: N,
            _removeUnmounted: ce,
            _updateFieldArray: P,
            _getFieldArray: D,
            _subjects: g,
            _proxyFormState: p,
            get _fields() {
                return n
            },
            get _formValues() {
                return a
            },
            get _stateFlags() {
                return o
            },
            set _stateFlags(ne) {
                o = ne
            },
            get _defaultValues() {
                return i
            },
            get _names() {
                return s
            },
            set _names(ne) {
                s = ne
            },
            get _formState() {
                return r
            },
            set _formState(ne) {
                r = ne
            },
            get _options() {
                return e
            },
            set _options(ne) {
                e = {...e, ...ne}
            }
        },
        trigger: j,
        register: ye,
        handleSubmit: me,
        watch: Q,
        setValue: B,
        getValues: $,
        reset: (ne, be) => Ce(CP(ne) ? ne(a) : ne, be),
        resetField: Se,
        clearErrors: R,
        unregister: fe,
        setError: k,
        setFocus: (ne, be = {}) => {
            const Ee = ir(n, ne), Oe = Ee && Ee._f;
            if (Oe) {
                const ze = Oe.refs ? Oe.refs[0] : Oe.ref;
                ze.focus && (ze.focus(), be.shouldSelect && ze.select())
            }
        },
        getFieldState: C
    }
}

function atr(t = {}) {
    const e = ar.useRef(), [r, n] = ar.useState({
        isDirty: !1,
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        errors: {},
        defaultValues: t.defaultValues
    });
    e.current || (e.current = {...uqt(t), formState: r});
    const i = e.current.control;
    return i._options = t, Xte({
        subject: i._subjects.state, callback: ar.useCallback(a => {
            FIe(a, i._proxyFormState, !0) && (i._formState = {...i._formState, ...a}, n({...i._formState}))
        }, [i])
    }), ar.useEffect(() => {
        i._stateFlags.mount || (i._proxyFormState.isValid && i._updateValid(), i._stateFlags.mount = !0), i._stateFlags.watch && (i._stateFlags.watch = !1, i._subjects.state.next({})), i._removeUnmounted()
    }), ar.useEffect(() => {
        r.submitCount && i._focusError()
    }, [i, r.submitCount]), e.current.formState = $Ie(r, i), e.current
}

const otr = KWt, KIe = ar.createContext(void 0),
    str = ({...t}) => ie.jsx(KIe.Provider, {value: {name: t.name}, children: ie.jsx(ZWt, {...t})}),
    YIe = ar.createContext(void 0), fqt = () => {
        const t = ar.useContext(KIe), e = ar.useContext(YIe), {getFieldState: r, formState: n} = yB();
        if (!t || !e) throw new Error("useFormField should be used within <FormField>");
        const i = r(t.name, n), {id: a} = e;
        return {
            id: a,
            name: t.name,
            formItemId: `${a}-form-item`,
            formDescriptionId: `${a}-form-item-description`,
            formMessageId: `${a}-form-item-message`, ...i
        }
    }, ctr = ({children: t}) => {
        const e = ar.useId();
        return ie.jsx(YIe.Provider, {value: {id: e}, children: t})
    }, ltr = () => {
        const {error: t} = fqt();
        return t
    }, ST = {
        black: "#000000",
        white: "#FFFFFF",
        whiteAlpha: {
            25: "rgba(255, 255, 255, 0.02)",
            50: "rgba(255, 255, 255, 0.04)",
            100: "rgba(255, 255, 255, 0.06)",
            150: "rgba(255, 255, 255, 0.07)",
            200: "rgba(255, 255, 255, 0.08)",
            250: "rgba(255, 255, 255, 0.12)",
            300: "rgba(255, 255, 255, 0.16)",
            350: "rgba(255, 255, 255, 0.20)",
            400: "rgba(255, 255, 255, 0.24)",
            450: "rgba(255, 255, 255, 0.30)",
            500: "rgba(255, 255, 255, 0.36)",
            550: "rgba(255, 255, 255, 0.42)",
            600: "rgba(255, 255, 255, 0.48)",
            650: "rgba(255, 255, 255, 0.56)",
            700: "rgba(255, 255, 255, 0.64)",
            750: "rgba(255, 255, 255, 0.72)",
            800: "rgba(255, 255, 255, 0.80)",
            850: "rgba(255, 255, 255, 0.86)",
            900: "rgba(255, 255, 255, 0.92)",
            950: "rgba(255, 255, 255, 0.96)"
        },
        blackAlpha: {
            25: "rgba(0, 0, 0, 0.02)",
            50: "rgba(0, 0, 0, 0.04)",
            100: "rgba(0, 0, 0, 0.06)",
            150: "rgba(0, 0, 0, 0.07)",
            200: "rgba(0, 0, 0, 0.08)",
            250: "rgba(0, 0, 0, 0.12)",
            300: "rgba(0, 0, 0, 0.16)",
            350: "rgba(0, 0, 0, 0.20)",
            400: "rgba(0, 0, 0, 0.24)",
            450: "rgba(0, 0, 0, 0.30)",
            500: "rgba(0, 0, 0, 0.36)",
            550: "rgba(0, 0, 0, 0.42)",
            600: "rgba(0, 0, 0, 0.48)",
            650: "rgba(0, 0, 0, 0.56)",
            700: "rgba(0, 0, 0, 0.64)",
            750: "rgba(0, 0, 0, 0.72)",
            800: "rgba(0, 0, 0, 0.80)",
            850: "rgba(0, 0, 0, 0.86)",
            900: "rgba(0, 0, 0, 0.92)",
            950: "rgba(0, 0, 0, 0.96)"
        },
        orange: {
            50: "#FFFAF0",
            100: "#FEEBC8",
            200: "#FBD38D",
            300: "#F6AD55",
            400: "#ED8936",
            500: "#DD6B20",
            600: "#C05621",
            700: "#9C4221",
            800: "#7B341E",
            900: "#652B19"
        },
        teal: {
            50: "#E6FFFA",
            100: "#B2F5EA",
            200: "#81E6D9",
            300: "#4FD1C5",
            400: "#38B2AC",
            500: "#319795",
            600: "#2C7A7B",
            700: "#285E61",
            800: "#234E52",
            900: "#1D4044"
        },
        cyan: {
            50: "#EDFDFD",
            100: "#C4F1F9",
            200: "#9DECF9",
            300: "#76E4F7",
            400: "#0BC5EA",
            500: "#00B5D8",
            600: "#00A3C4",
            700: "#0987A0",
            800: "#086F83",
            900: "#065666"
        },
        purple: {
            50: "#FAF5FF",
            100: "#E9D8FD",
            200: "#D6BCFA",
            300: "#B794F4",
            400: "#9F7AEA",
            500: "#805AD5",
            600: "#6B46C1",
            700: "#553C9A",
            800: "#44337A",
            900: "#322659"
        },
        pink: {
            50: "#FFF5F7",
            100: "#FED7E2",
            200: "#FBB6CE",
            300: "#F687B3",
            400: "#ED64A6",
            500: "#D53F8C",
            600: "#B83280",
            700: "#97266D",
            800: "#702459",
            900: "#521B41"
        },
        linkedin: {
            50: "#E8F4F9",
            100: "#CFEDFB",
            200: "#9BDAF3",
            300: "#68C7EC",
            400: "#34B3E4",
            500: "#00A0DC",
            600: "#008CC9",
            700: "#0077B5",
            800: "#005E93",
            900: "#004471"
        },
        facebook: {
            50: "#E8F4F9",
            100: "#D9DEE9",
            200: "#B7C2DA",
            300: "#6482C0",
            400: "#4267B2",
            500: "#385898",
            600: "#314E89",
            700: "#29487D",
            800: "#223B67",
            900: "#1E355B"
        },
        messenger: {
            50: "#D0E6FF",
            100: "#B9DAFF",
            200: "#A2CDFF",
            300: "#7AB8FF",
            400: "#2E90FF",
            500: "#0078FF",
            600: "#0063D1",
            700: "#0052AC",
            800: "#003C7E",
            900: "#002C5C"
        },
        whatsapp: {
            50: "#dffeec",
            100: "#b9f5d0",
            200: "#90edb3",
            300: "#65e495",
            400: "#3cdd78",
            500: "#22c35e",
            600: "#179848",
            700: "#0c6c33",
            800: "#01421c",
            900: "#001803"
        },
        twitter: {
            50: "#E5F4FD",
            100: "#C8E9FB",
            200: "#A8DCFA",
            300: "#83CDF7",
            400: "#57BBF5",
            500: "#1DA1F2",
            600: "#1A94DA",
            700: "#1681BF",
            800: "#136B9E",
            900: "#0D4D71"
        },
        telegram: {
            50: "#E3F2F9",
            100: "#C5E4F3",
            200: "#A2D4EC",
            300: "#7AC1E4",
            400: "#47A9DA",
            500: "#0088CC",
            600: "#007AB8",
            700: "#006BA1",
            800: "#005885",
            900: "#003F5E"
        },
        gray: {
            0: "#ffffff",
            25: "#f9f9f9",
            50: "#f2f2f2",
            75: "#ececec",
            100: "#e6e6e6",
            125: "#dfdfdf",
            150: "#d9d9d9",
            175: "#d2d2d2",
            200: "#cccccc",
            225: "#c6c6c6",
            250: "#bfbfbf",
            275: "#b9b9b9",
            300: "#b3b3b3",
            325: "#acacac",
            350: "#a6a6a6",
            375: "#9f9f9f",
            400: "#999999",
            425: "#939393",
            450: "#8c8c8c",
            475: "#868686",
            500: "#808080",
            525: "#797979",
            550: "#737373",
            575: "#6c6c6c",
            600: "#666666",
            625: "#606060",
            650: "#595959",
            675: "#535353",
            700: "#4d4d4d",
            725: "#464646",
            750: "#404040",
            775: "#393939",
            800: "#333333",
            825: "#2d2d2d",
            850: "#262626",
            875: "#202020",
            900: "#191919",
            925: "#131313",
            950: "#0d0d0d",
            975: "#060606",
            1e3: "#000000"
        },
        blue: {
            0: "#f7f7fc",
            25: "#f1f1f6",
            50: "#ebebf1",
            75: "#e6e6eb",
            100: "#e0e0e5",
            125: "#dadadf",
            150: "#d5d5da",
            175: "#cfcfd4",
            200: "#c9c9ce",
            225: "#c3c3c8",
            250: "#bebec3",
            275: "#b8b8bd",
            300: "#b2b2b7",
            325: "#acacb1",
            350: "#a7a7ac",
            375: "#a1a1a6",
            400: "#9b9ba0",
            425: "#95959a",
            450: "#909095",
            475: "#8a8a8f",
            500: "#848489",
            525: "#7e7e83",
            550: "#79797e",
            575: "#737378",
            600: "#6d6d72",
            625: "#67676c",
            650: "#626267",
            675: "#5c5c61",
            700: "#56565b",
            725: "#505055",
            750: "#4b4b50",
            775: "#45454a",
            800: "#3f3f44",
            825: "#39393e",
            850: "#343439",
            875: "#2e2e33",
            900: "#28282d",
            925: "#222227",
            950: "#1d1d22",
            975: "#17171c",
            1e3: "#111116"
        },
        nativeBlue: {
            50: "#ebf8ff",
            100: "#bee3f8",
            200: "#90cdf4",
            300: "#63b3ed",
            400: "#4299e1",
            500: "#3182ce",
            600: "#2b6cb0",
            700: "#2c5282",
            800: "#2a4365",
            900: "#1A365D"
        },
        green: {
            50: "#F0FFF4",
            100: "#C6F6D5",
            200: "#9AE6B4",
            300: "#68D391",
            400: "#48BB78",
            500: "#38A169",
            600: "#2F855A",
            700: "#276749",
            800: "#22543D",
            900: "#1C4532"
        },
        yellow: {
            0: "#ffffff",
            25: "#fffbf2",
            50: "#fff7e6",
            75: "#fff3d9",
            100: "#ffefcc",
            125: "#ffecbf",
            150: "#ffe8b3",
            175: "#ffe4a6",
            200: "#ffe099",
            225: "#ffdc8c",
            250: "#ffd880",
            275: "#ffd473",
            300: "#ffd066",
            325: "#ffcc59",
            350: "#ffc84d",
            375: "#ffc440",
            400: "#ffc133",
            425: "#ffbd26",
            450: "#ffb919",
            475: "#ffb50d",
            500: "#ffb100",
            525: "#f4a900",
            550: "#e8a100",
            575: "#dd9900",
            600: "#d29100",
            625: "#c68a00",
            650: "#bb8200",
            675: "#b07a00",
            700: "#a47200",
            725: "#996a00",
            750: "#8e6200",
            775: "#825a00",
            800: "#775200",
            825: "#6b4a00",
            850: "#604200",
            875: "#553b00",
            900: "#493300",
            925: "#3e2b00",
            950: "#332300",
            975: "#271b00",
            1e3: "#1c1300"
        },
        red: {
            50: "#FFF5F5",
            100: "#FED7D7",
            200: "#FEB2B2",
            300: "#FC8181",
            400: "#F56565",
            450: "#ff5a5a",
            500: "#E53E3E",
            600: "#C53030",
            700: "#9B2C2C",
            800: "#822727",
            900: "#63171B"
        },
        accent: {
            0: "#ffffff",
            25: "#f7f8fe",
            50: "#eef1fe",
            75: "#e6eafd",
            100: "#dee3fc",
            125: "#d6dcfb",
            150: "#cdd5fb",
            175: "#c5cefa",
            200: "#bdc7f9",
            225: "#b4c0f8",
            250: "#acbaf8",
            275: "#a4b3f7",
            300: "#9bacf6",
            325: "#93a5f5",
            350: "#8b9ef5",
            375: "#8397f4",
            400: "#7a90f3",
            425: "#7289f2",
            450: "#6a82f2",
            475: "#617bf1",
            500: "#5974f0",
            525: "#556ee4",
            550: "#5068d8",
            575: "#4c63cc",
            600: "#475dc0",
            625: "#4357b4",
            650: "#3e51a8",
            675: "#3a4b9c",
            700: "#354690",
            725: "#314084",
            750: "#2d3a78",
            775: "#28346c",
            800: "#242e60",
            825: "#1f2954",
            850: "#1b2348",
            875: "#161d3c",
            900: "#121730",
            925: "#0d1124",
            950: "#090c18",
            975: "#04060c",
            1e3: "#000000",
            lightGreen: "#a4cf5e",
            darkGreen: "#678838",
            red: "#f45b5b",
            orangeLight: "#ff9900",
            orange: "#ff6600",
            orangeDark: "#ff3300"
        },
        moonshot: {
            0: "#ffffff",
            25: "#fdfff3",
            50: "#fcffe8",
            75: "#faffdc",
            100: "#f9ffd0",
            125: "#f7ffc5",
            150: "#f5ffb9",
            175: "#f4ffad",
            200: "#f2ffa2",
            225: "#f1ff96",
            250: "#efff8b",
            275: "#edff7f",
            300: "#ecff73",
            325: "#eaff68",
            350: "#e9ff5c",
            375: "#e7ff50",
            400: "#e5ff45",
            425: "#e4ff39",
            450: "#e2ff2d",
            475: "#e1ff22",
            500: "#dfff16",
            525: "#d4f215",
            550: "#c9e514",
            575: "#bed913",
            600: "#b2cc12",
            625: "#a7bf10",
            650: "#9cb30f",
            675: "#91a60e",
            700: "#86990d",
            725: "#7b8c0c",
            750: "#70800b",
            775: "#64730a",
            800: "#596609",
            825: "#4e5908",
            850: "#434d07",
            875: "#384006",
            900: "#2d3304",
            925: "#212603",
            950: "#161a02",
            975: "#0b0d01",
            1e3: "#000000"
        }
    }, Ql = {
        "3xs": 10,
        "2xs": 11,
        xs: 12,
        sm: 13,
        md: 14,
        lg: 15,
        xl: 16,
        "2xl": 17,
        "3xl": 18,
        "4xl": 19,
        "5xl": 20,
        "6xl": 21,
        "7xl": 22,
        "8xl": 28,
        "9xl": 34
    }, J7 = {
        fonts: {heading: "Space Grotesk", body: "Poppins", mono: "Fira Mono"},
        fontSizes: {
            "2xs": `${Ql["2xs"]}px`,
            xs: `${Ql.xs}px`,
            sm: `${Ql.sm}px`,
            md: `${Ql.md}px`,
            lg: `${Ql.lg}px`,
            xl: `${Ql.xl}px`,
            "2xl": `${Ql["2xl"]}px`,
            "3xl": `${Ql["3xl"]}px`,
            "4xl": `${Ql["4xl"]}px`,
            "5xl": `${Ql["5xl"]}px`,
            "6xl": `${Ql["6xl"]}px`,
            "7xl": `${Ql["7xl"]}px`,
            "8xl": `${Ql["8xl"]}px`,
            "9xl": `${Ql["9xl"]}px`
        },
        fontSizesPX: Ql,
        fontWeights: {
            hairline: "100",
            thin: "200",
            light: "300",
            normal: "400",
            medium: "500",
            semibold: "600",
            bold: "700",
            extrabold: "800",
            black: "900"
        }
    }, Ms = (t, e, r) => r === "light" ? t : e, XIe = t => ({
        scrollbarWidth: t.scrollbarWidthFirefox,
        scrollbarColor: `${t.thumbColor} ${t.trackBg}`,
        "&::-webkit-scrollbar": {width: t.scrollbarWidth, height: t.scrollBarHeight ?? t.scrollbarWidth},
        "&::-webkit-scrollbar-track": {background: t.trackBg},
        "&::-webkit-scrollbar-corner": {background: t.cornerBg},
        "&::-webkit-scrollbar-thumb": {
            background: t.thumbColor,
            borderRadius: t.thumbBorderRadius,
            borderWidth: t.thumbBorderWidth,
            borderStyle: "solid",
            borderColor: t.thumbBorderColor
        },
        "&::-webkit-scrollbar-thumb:hover": {background: t.thumbHoverColor}
    }), QIe = t => {
        const e = zfe("colors", t.thumbColor), r = zfe("colors", t.trackBg);
        return {...XIe(t), scrollbarColor: `${e} ${r}`}
    }, dqt = t => XIe({
        thumbColor: Ms("gray.200", "gray.700", t.colorMode),
        thumbHoverColor: Ms("gray.275", "gray.625", t.colorMode),
        thumbBorderRadius: "10px",
        thumbBorderWidth: "5px",
        thumbBorderColor: Ms("gray.25", "blue.900", t.colorMode),
        trackBg: Ms("gray.25", "blue.900", t.colorMode),
        cornerBg: Ms("gray.75", "blue.875", t.colorMode),
        scrollbarWidth: "20px",
        scrollbarWidthFirefox: "auto", ...t.overrides
    }), utr = t => QIe({
        thumbColor: Ms("gray.200", "gray.700", t.colorMode),
        thumbHoverColor: Ms("gray.275", "gray.625", t.colorMode),
        thumbBorderRadius: "10px",
        thumbBorderWidth: "5px",
        thumbBorderColor: Ms("gray.25", "blue.900", t.colorMode),
        trackBg: Ms("gray.25", "blue.900", t.colorMode),
        cornerBg: Ms("gray.75", "blue.875", t.colorMode),
        scrollbarWidth: "20px",
        scrollbarWidthFirefox: "auto", ...t.overrides
    }), Zme = Q6t({
        config: {initialColorMode: "dark", useSystemColorMode: !1},
        styles: {
            global: t => ({
                body: {
                    bg: t.colorMode === "light" ? "gray.25" : "blue.975",
                    color: t.colorMode === "light" ? "gray.750" : "white",
                    fontSize: "md",
                    "*": {WebkitTapHighlightColor: "transparent"}
                }
            })
        },
        semanticTokens: {
            colors: {
                "chakra-body-text": {_light: "gray.750", _dark: "white"},
                "chakra-body-bg": {_light: "gray.25", _dark: "blue.975"},
                "chakra-border-color": {_light: "gray.200", _dark: "whiteAlpha.300"},
                "chakra-subtle-bg": {_light: "gray.100", _dark: "gray.700"},
                "chakra-placeholder-color": {_light: "gray.500", _dark: "whiteAlpha.400"},
                "trading-view.background": "#131722",
                "trading-view.background-hover": "#2A2E39",
                "trading-view.border-color": "#2A2E39",
                "trading-view.text-color": "#CFD2DC",
                "moonshot.accent.text": {_light: "moonshot.700", _dark: "moonshot.550"},
                "moonshot.progress": {_light: "moonshot.600", _dark: "moonshot.550"}
            }
        },
        fonts: {
            body: `"${J7.fonts.body}",${pC.fonts.body}`,
            heading: `"${J7.fonts.heading}",${pC.fonts.heading}`,
            mono: `"${J7.fonts.mono}",${pC.fonts.mono}`
        },
        fontSizes: {...J7.fontSizes, "8xl": "23px", "9xl": "24px"},
        colors: ST,
        shadows: {
            outline: "0 0 0 3px rgba(48, 93, 255, 0.6)",
            outlineSm: "0 0 0 2px rgba(48, 93, 255, 0.6)",
            sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
            md: "0 1px 3px 0 rgba(0, 0, 0, 0.08)"
        },
        components: {
            Button: {
                sizes: {md: {h: "37px"}}, variants: {
                    solid: t => {
                        if (t.colorScheme === "accent") return {
                            bg: "accent.500",
                            color: "white",
                            _hover: {bg: "accent.600", _disabled: {bg: "accent.500"}},
                            _active: {bg: "accent.700"}
                        };
                        if (t.colorScheme === "moonshot") return {
                            bg: xo("moonshot.550", "moonshot.500")(t),
                            color: "black",
                            _hover: {bg: "moonshot.600", _disabled: {bg: "moonshot.500"}},
                            _active: {bg: "moonshot.700"}
                        }
                    }, link: t => {
                        if (t.colorScheme === "accent") return {color: "accent.500", _active: {color: "accent.700"}}
                    }
                }
            },
            Badge: {
                baseStyle: {fontWeight: "normal"},
                variants: {
                    subtle: t => ({
                        bg: "transparent",
                        borderWidth: "1px",
                        borderColor: xo("gray.75", "gray.875")(t),
                        color: xo("gray.400", "gray.500")(t)
                    })
                }
            },
            Modal: {
                baseStyle: t => ({
                    overlay: {bg: xo("rgba(0, 0, 0, 0.5)", "rgba(0, 0, 0, 0.7)")(t)},
                    header: {
                        bg: xo("gray.25", "blue.900")(t),
                        px: 4,
                        py: 4,
                        borderBottomWidth: 1,
                        borderBottomColor: xo("gray.75", "blue.850")(t)
                    },
                    body: {
                        bg: xo("white", "blue.950")(t), ...dqt({
                            colorMode: t.colorMode,
                            overrides: {
                                thumbColor: xo(ST.gray[200], ST.gray[700])(t),
                                trackBg: xo(ST.gray[25], ST.blue[900])(t)
                            }
                        })
                    },
                    footer: {
                        flexShrink: 0,
                        bg: xo("white", "blue.900")(t),
                        borderTopWidth: 1,
                        borderTopColor: xo("gray.75", "blue.850")(t),
                        justifyContent: "center",
                        py: 3
                    }
                })
            },
            CloseButton: {baseStyle: () => ({borderWidth: 1})},
            Menu: {
                baseStyle: t => {
                    const e = Kr("menu-bg");
                    return {
                        list: {
                            [e.variable]: "white",
                            _dark: {[e.variable]: "colors.blue.950"},
                            bg: e.reference,
                            borderColor: xo("inherit", "blue.900")(t)
                        },
                        item: {
                            _focus: {[e.variable]: "colors.gray.100", _dark: {[e.variable]: "colors.blue.900"}},
                            _active: {[e.variable]: "colors.gray.200", _dark: {[e.variable]: "colors.blue.900"}},
                            _expanded: {[e.variable]: "colors.gray.100", _dark: {[e.variable]: "colors.blue.900"}},
                            bg: e.reference
                        }
                    }
                }
            },
            Input: {
                baseStyle: t => ({field: {_placeholder: {color: xo("gray.400", "gray.500")(t)}}}),
                variants: {
                    filled: t => ({
                        field: {
                            bg: xo("blackAlpha.50", "whiteAlpha.50")(t),
                            _hover: {bg: xo("blackAlpha.100", "whiteAlpha.100")(t)},
                            _focusVisible: {borderColor: xo("blackAlpha.500", "whiteAlpha.700")(t)}
                        }
                    }),
                    outline: t => ({addon: {bg: xo("gray.25", "gray.800")(t), color: xo("gray.400", "gray.500")(t), px: 3}})
                }
            },
            Progress: {baseStyle: t => t.colorScheme === "moonshot" ? {filledTrack: {bg: xo("moonshot.550", "moonshot.500")(t)}} : {}},
            Textarea: {
                variants: {
                    filled: t => ({
                        bg: xo("blackAlpha.50", "whiteAlpha.50")(t),
                        _hover: {bg: xo("blackAlpha.100", "whiteAlpha.100")(t)},
                        _focusVisible: {borderColor: xo("blackAlpha.500", "whiteAlpha.700")(t)}
                    })
                }
            }
        }
    });

function hqt(t) {
    return t && typeof t.then == "function"
}

Promise.resolve(!1);
var pqt = Promise.resolve(!0), Iv = Promise.resolve();

function Nw(t, e) {
    return t || (t = 0), new Promise(function (r) {
        return setTimeout(function () {
            return r(e)
        }, t)
    })
}

function mqt(t, e) {
    return Math.floor(Math.random() * (e - t + 1) + t)
}

function XI() {
    return Math.random().toString(36).substring(2)
}

var Jme = 0, cW = 0;

function bB() {
    var t = Date.now();
    return t === Jme ? (cW++, t * 1e3 + cW) : (Jme = t, cW = 0, t * 1e3)
}

function vqt() {
    return typeof navigator < "u" && typeof navigator.locks < "u" && typeof navigator.locks.request == "function"
}

var gqt = bB, yqt = "native";

function bqt(t) {
    var e = {messagesCallback: null, bc: new BroadcastChannel(t), subFns: []};
    return e.bc.onmessage = function (r) {
        e.messagesCallback && e.messagesCallback(r.data)
    }, e
}

function wqt(t) {
    t.bc.close(), t.subFns = []
}

function Sqt(t, e) {
    try {
        return t.bc.postMessage(e, !1), Iv
    } catch (r) {
        return Promise.reject(r)
    }
}

function _qt(t, e) {
    t.messagesCallback = e
}

function xqt() {
    if (typeof globalThis < "u" && globalThis.Deno && globalThis.Deno.args) return !0;
    if ((typeof window < "u" || typeof self < "u") && typeof BroadcastChannel == "function") {
        if (BroadcastChannel._pubkey) throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
        return !0
    } else return !1
}

function Eqt() {
    return 150
}

var Tqt = {
    create: bqt,
    close: wqt,
    onMessage: _qt,
    postMessage: Sqt,
    canBeUsed: xqt,
    type: yqt,
    averageResponseTime: Eqt,
    microSeconds: gqt
};

class ZIe {
    constructor(e) {
        Ft(this, "ttl");
        Ft(this, "map", new Map);
        Ft(this, "_to", !1);
        this.ttl = e
    }

    has(e) {
        return this.map.has(e)
    }

    add(e) {
        this.map.set(e, JIe()), this._to || (this._to = !0, setTimeout(() => {
            this._to = !1, Cqt(this)
        }, 0))
    }

    clear() {
        this.map.clear()
    }
}

function Cqt(t) {
    const e = JIe() - t.ttl, r = t.map[Symbol.iterator]();
    for (; ;) {
        const n = r.next().value;
        if (!n) return;
        const i = n[0];
        if (n[1] < e) t.map.delete(i); else return
    }
}

function JIe() {
    return Date.now()
}

function tre() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = JSON.parse(JSON.stringify(t));
    return typeof e.webWorkerSupport > "u" && (e.webWorkerSupport = !0), e.idb || (e.idb = {}), e.idb.ttl || (e.idb.ttl = 1e3 * 45), e.idb.fallbackInterval || (e.idb.fallbackInterval = 150), t.idb && typeof t.idb.onclose == "function" && (e.idb.onclose = t.idb.onclose), e.localstorage || (e.localstorage = {}), e.localstorage.removeTimeout || (e.localstorage.removeTimeout = 1e3 * 60), t.methods && (e.methods = t.methods), e.node || (e.node = {}), e.node.ttl || (e.node.ttl = 1e3 * 60 * 2), e.node.maxParallelWrites || (e.node.maxParallelWrites = 2048), typeof e.node.useFastPath > "u" && (e.node.useFastPath = !0), e
}

var Aqt = bB, Iqt = "pubkey.broadcast-channel-0-", qv = "messages", wB = {durability: "relaxed"}, kqt = "idb";

function eke() {
    if (typeof indexedDB < "u") return indexedDB;
    if (typeof window < "u") {
        if (typeof window.mozIndexedDB < "u") return window.mozIndexedDB;
        if (typeof window.webkitIndexedDB < "u") return window.webkitIndexedDB;
        if (typeof window.msIndexedDB < "u") return window.msIndexedDB
    }
    return !1
}

function rre(t) {
    t.commit && t.commit()
}

function Rqt(t) {
    var e = eke(), r = Iqt + t, n = e.open(r);
    return n.onupgradeneeded = function (i) {
        var a = i.target.result;
        a.createObjectStore(qv, {keyPath: "id", autoIncrement: !0})
    }, new Promise(function (i, a) {
        n.onerror = function (o) {
            return a(o)
        }, n.onsuccess = function () {
            i(n.result)
        }
    })
}

function Dqt(t, e, r) {
    var n = Date.now(), i = {uuid: e, time: n, data: r}, a = t.transaction([qv], "readwrite", wB);
    return new Promise(function (o, s) {
        a.oncomplete = function () {
            return o()
        }, a.onerror = function (f) {
            return s(f)
        };
        var l = a.objectStore(qv);
        l.add(i), rre(a)
    })
}

function Mqt(t, e) {
    var r = t.transaction(qv, "readonly", wB), n = r.objectStore(qv), i = [], a = IDBKeyRange.bound(e + 1, 1 / 0);
    if (n.getAll) {
        var o = n.getAll(a);
        return new Promise(function (l, f) {
            o.onerror = function (d) {
                return f(d)
            }, o.onsuccess = function (d) {
                l(d.target.result)
            }
        })
    }

    function s() {
        try {
            return a = IDBKeyRange.bound(e + 1, 1 / 0), n.openCursor(a)
        } catch {
            return n.openCursor()
        }
    }

    return new Promise(function (l, f) {
        var d = s();
        d.onerror = function (p) {
            return f(p)
        }, d.onsuccess = function (p) {
            var g = p.target.result;
            g ? g.value.id < e + 1 ? g.continue(e + 1) : (i.push(g.value), g.continue()) : (rre(r), l(i))
        }
    })
}

function Oqt(t, e) {
    if (t.closed) return Promise.resolve([]);
    var r = t.db.transaction(qv, "readwrite", wB), n = r.objectStore(qv);
    return Promise.all(e.map(function (i) {
        var a = n.delete(i);
        return new Promise(function (o) {
            a.onsuccess = function () {
                return o()
            }
        })
    }))
}

function Pqt(t, e) {
    var r = Date.now() - e, n = t.transaction(qv, "readonly", wB), i = n.objectStore(qv), a = [];
    return new Promise(function (o) {
        i.openCursor().onsuccess = function (s) {
            var l = s.target.result;
            if (l) {
                var f = l.value;
                f.time < r ? (a.push(f), l.continue()) : (rre(n), o(a))
            } else o(a)
        }
    })
}

function Nqt(t) {
    return Pqt(t.db, t.options.idb.ttl).then(function (e) {
        return Oqt(t, e.map(function (r) {
            return r.id
        }))
    })
}

function Lqt(t, e) {
    return e = tre(e), Rqt(t).then(function (r) {
        var n = {
            closed: !1,
            lastCursorId: 0,
            channelName: t,
            options: e,
            uuid: XI(),
            eMIs: new ZIe(e.idb.ttl * 2),
            writeBlockPromise: Iv,
            messagesCallback: null,
            readQueuePromises: [],
            db: r
        };
        return r.onclose = function () {
            n.closed = !0, e.idb.onclose && e.idb.onclose()
        }, tke(n), n
    })
}

function tke(t) {
    t.closed || rke(t).then(function () {
        return Nw(t.options.idb.fallbackInterval)
    }).then(function () {
        return tke(t)
    })
}

function Bqt(t, e) {
    return !(t.uuid === e.uuid || e.eMIs.has(t.id) || t.data.time < e.messagesCallbackTime)
}

function rke(t) {
    return t.closed || !t.messagesCallback ? Iv : Mqt(t.db, t.lastCursorId).then(function (e) {
        var r = e.filter(function (n) {
            return !!n
        }).map(function (n) {
            return n.id > t.lastCursorId && (t.lastCursorId = n.id), n
        }).filter(function (n) {
            return Bqt(n, t)
        }).sort(function (n, i) {
            return n.time - i.time
        });
        return r.forEach(function (n) {
            t.messagesCallback && (t.eMIs.add(n.id), t.messagesCallback(n.data))
        }), Iv
    })
}

function $qt(t) {
    t.closed = !0, t.db.close()
}

function Fqt(t, e) {
    return t.writeBlockPromise = t.writeBlockPromise.then(function () {
        return Dqt(t.db, t.uuid, e)
    }).then(function () {
        mqt(0, 10) === 0 && Nqt(t)
    }), t.writeBlockPromise
}

function Uqt(t, e, r) {
    t.messagesCallbackTime = r, t.messagesCallback = e, rke(t)
}

function jqt() {
    return !!eke()
}

function zqt(t) {
    return t.idb.fallbackInterval * 2
}

var Vqt = {
    create: Lqt,
    close: $qt,
    onMessage: Uqt,
    postMessage: Fqt,
    canBeUsed: jqt,
    type: kqt,
    averageResponseTime: zqt,
    microSeconds: Aqt
}, Hqt = bB, Wqt = "pubkey.broadcastChannel-", qqt = "localstorage";

function nke() {
    var t;
    if (typeof window > "u") return null;
    try {
        t = window.localStorage, t = window["ie8-eventlistener/storage"] || window.localStorage
    } catch {
    }
    return t
}

function ike(t) {
    return Wqt + t
}

function Gqt(t, e) {
    return new Promise(function (r) {
        Nw().then(function () {
            var n = ike(t.channelName), i = {token: XI(), time: Date.now(), data: e, uuid: t.uuid},
                a = JSON.stringify(i);
            nke().setItem(n, a);
            var o = document.createEvent("Event");
            o.initEvent("storage", !0, !0), o.key = n, o.newValue = a, window.dispatchEvent(o), r()
        })
    })
}

function Kqt(t, e) {
    var r = ike(t), n = function (a) {
        a.key === r && e(JSON.parse(a.newValue))
    };
    return window.addEventListener("storage", n), n
}

function Yqt(t) {
    window.removeEventListener("storage", t)
}

function Xqt(t, e) {
    if (e = tre(e), !ake()) throw new Error("BroadcastChannel: localstorage cannot be used");
    var r = XI(), n = new ZIe(e.localstorage.removeTimeout), i = {channelName: t, uuid: r, eMIs: n};
    return i.listener = Kqt(t, function (a) {
        i.messagesCallback && a.uuid !== r && (!a.token || n.has(a.token) || a.data.time && a.data.time < i.messagesCallbackTime || (n.add(a.token), i.messagesCallback(a.data)))
    }), i
}

function Qqt(t) {
    Yqt(t.listener)
}

function Zqt(t, e, r) {
    t.messagesCallbackTime = r, t.messagesCallback = e
}

function ake() {
    var t = nke();
    if (!t) return !1;
    try {
        var e = "__broadcastchannel_check";
        t.setItem(e, "works"), t.removeItem(e)
    } catch {
        return !1
    }
    return !0
}

function Jqt() {
    var t = 120, e = navigator.userAgent.toLowerCase();
    return e.includes("safari") && !e.includes("chrome") ? t * 2 : t
}

var eGt = {
    create: Xqt,
    close: Qqt,
    onMessage: Zqt,
    postMessage: Gqt,
    canBeUsed: ake,
    type: qqt,
    averageResponseTime: Jqt,
    microSeconds: Hqt
}, tGt = bB, rGt = "simulate", nre = new Set;

function nGt(t) {
    var e = {name: t, messagesCallback: null};
    return nre.add(e), e
}

function iGt(t) {
    nre.delete(t)
}

function aGt(t, e) {
    return new Promise(function (r) {
        return setTimeout(function () {
            var n = Array.from(nre);
            n.filter(function (i) {
                return i.name === t.name
            }).filter(function (i) {
                return i !== t
            }).filter(function (i) {
                return !!i.messagesCallback
            }).forEach(function (i) {
                return i.messagesCallback(e)
            }), r()
        }, 5)
    })
}

function oGt(t, e) {
    t.messagesCallback = e
}

function sGt() {
    return !0
}

function cGt() {
    return 5
}

var lGt = {
    create: nGt,
    close: iGt,
    onMessage: oGt,
    postMessage: aGt,
    canBeUsed: sGt,
    type: rGt,
    averageResponseTime: cGt,
    microSeconds: tGt
}, eve = [Tqt, Vqt, eGt];

function uGt(t) {
    var e = [].concat(t.methods, eve).filter(Boolean);
    if (t.type) {
        if (t.type === "simulate") return lGt;
        var r = e.find(function (i) {
            return i.type === t.type
        });
        if (r) return r;
        throw new Error("method-type " + t.type + " not found")
    }
    t.webWorkerSupport || (e = e.filter(function (i) {
        return i.type !== "idb"
    }));
    var n = e.find(function (i) {
        return i.canBeUsed()
    });
    if (n) return n;
    throw new Error("No usable method found in " + JSON.stringify(eve.map(function (i) {
        return i.type
    })))
}

var oke = new Set, fGt = 0, ire = function (e, r) {
    this.id = fGt++, oke.add(this), this.name = e, tve && (r = tve), this.options = tre(r), this.method = uGt(this.options), this._iL = !1, this._onML = null, this._addEL = {
        message: [],
        internal: []
    }, this._uMP = new Set, this._befC = [], this._prepP = null, dGt(this)
};
ire._pubkey = !0;
var tve;
ire.prototype = {
    postMessage: function (e) {
        if (this.closed) throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + JSON.stringify(e));
        return rve(this, "message", e)
    }, postInternal: function (e) {
        return rve(this, "internal", e)
    }, set onmessage(t) {
        var e = this.method.microSeconds(), r = {time: e, fn: t};
        ive(this, "message", this._onML), t && typeof t == "function" ? (this._onML = r, nve(this, "message", r)) : this._onML = null
    }, addEventListener: function (e, r) {
        var n = this.method.microSeconds(), i = {time: n, fn: r};
        nve(this, e, i)
    }, removeEventListener: function (e, r) {
        var n = this._addEL[e].find(function (i) {
            return i.fn === r
        });
        ive(this, e, n)
    }, close: function () {
        var e = this;
        if (!this.closed) {
            oke.delete(this), this.closed = !0;
            var r = this._prepP ? this._prepP : Iv;
            return this._onML = null, this._addEL.message = [], r.then(function () {
                return Promise.all(Array.from(e._uMP))
            }).then(function () {
                return Promise.all(e._befC.map(function (n) {
                    return n()
                }))
            }).then(function () {
                return e.method.close(e._state)
            })
        }
    }, get type() {
        return this.method.type
    }, get isClosed() {
        return this.closed
    }
};

function rve(t, e, r) {
    var n = t.method.microSeconds(), i = {time: n, type: e, data: r}, a = t._prepP ? t._prepP : Iv;
    return a.then(function () {
        var o = t.method.postMessage(t._state, i);
        return t._uMP.add(o), o.catch().then(function () {
            return t._uMP.delete(o)
        }), o
    })
}

function dGt(t) {
    var e = t.method.create(t.name, t.options);
    hqt(e) ? (t._prepP = e, e.then(function (r) {
        t._state = r
    })) : t._state = e
}

function ske(t) {
    return t._addEL.message.length > 0 || t._addEL.internal.length > 0
}

function nve(t, e, r) {
    t._addEL[e].push(r), hGt(t)
}

function ive(t, e, r) {
    t._addEL[e] = t._addEL[e].filter(function (n) {
        return n !== r
    }), pGt(t)
}

function hGt(t) {
    if (!t._iL && ske(t)) {
        var e = function (i) {
            t._addEL[i.type].forEach(function (a) {
                var o = 1e5, s = a.time - o;
                i.time >= s && a.fn(i.data)
            })
        }, r = t.method.microSeconds();
        t._prepP ? t._prepP.then(function () {
            t._iL = !0, t.method.onMessage(t._state, e, r)
        }) : (t._iL = !0, t.method.onMessage(t._state, e, r))
    }
}

function pGt(t) {
    if (t._iL && !ske(t)) {
        t._iL = !1;
        var e = t.method.microSeconds();
        t.method.onMessage(t._state, null, e)
    }
}

function mGt(t) {
    if (typeof WorkerGlobalScope == "function" && self instanceof WorkerGlobalScope) {
        var e = self.close.bind(self);
        self.close = function () {
            return t(), e()
        }
    } else {
        if (typeof window.addEventListener != "function") return;
        window.addEventListener("beforeunload", function () {
            t()
        }, !0), window.addEventListener("unload", function () {
            t()
        }, !0)
    }
}

function vGt(t) {
    Ve.on("exit", function () {
        return t()
    }), Ve.on("beforeExit", function () {
        return t().then(function () {
            return Ve.exit()
        })
    }), Ve.on("SIGINT", function () {
        return t().then(function () {
            return Ve.exit()
        })
    }), Ve.on("uncaughtException", function (e) {
        return t().then(function () {
            console.trace(e), Ve.exit(101)
        })
    })
}

var gGt = Object.prototype.toString.call(typeof Ve < "u" ? Ve : 0) === "[object process]", yGt = gGt ? vGt : mGt,
    OC = new Set, ave = !1;

function bGt() {
    ave || (ave = !0, yGt(SGt))
}

function wGt(t) {
    if (bGt(), typeof t != "function") throw new Error("Listener is no function");
    OC.add(t);
    var e = {
        remove: function () {
            return OC.delete(t)
        }, run: function () {
            return OC.delete(t), t()
        }
    };
    return e
}

function SGt() {
    var t = [];
    return OC.forEach(function (e) {
        t.push(e()), OC.delete(e)
    }), Promise.all(t)
}

function eS(t, e) {
    var r = {context: "leader", action: e, token: t.token};
    return t.broadcastChannel.postInternal(r)
}

function cke(t) {
    t.isLeader = !0, t._hasLeader = !0;
    var e = wGt(function () {
        return t.die()
    });
    t._unl.push(e);
    var r = function (i) {
        i.context === "leader" && i.action === "apply" && eS(t, "tell"), i.context === "leader" && i.action === "tell" && !t._dpLC && (t._dpLC = !0, t._dpL(), eS(t, "tell"))
    };
    return t.broadcastChannel.addEventListener("internal", r), t._lstns.push(r), eS(t, "tell")
}

var lke = function (e, r) {
    var n = this;
    this.broadcastChannel = e, e._befC.push(function () {
        return n.die()
    }), this._options = r, this.isLeader = !1, this.isDead = !1, this.token = XI(), this._lstns = [], this._unl = [], this._dpL = function () {
    }, this._dpLC = !1, this._wKMC = {}, this.lN = "pubkey-bc||" + e.method.type + "||" + e.name
};
lke.prototype = {
    hasLeader: function () {
        var e = this;
        return navigator.locks.query().then(function (r) {
            var n = r.held ? r.held.filter(function (i) {
                return i.name === e.lN
            }) : [];
            return !!(n && n.length > 0)
        })
    }, awaitLeadership: function () {
        var e = this;
        if (!this._wLMP) {
            this._wKMC.c = new AbortController;
            var r = new Promise(function (n, i) {
                e._wKMC.res = n, e._wKMC.rej = i
            });
            this._wLMP = new Promise(function (n) {
                navigator.locks.request(e.lN, {signal: e._wKMC.c.signal}, function () {
                    return e._wKMC.c = void 0, cke(e), n(), r
                }).catch(function () {
                })
            })
        }
        return this._wLMP
    }, set onduplicate(t) {
    }, die: function () {
        var e = this;
        return this._lstns.forEach(function (r) {
            return e.broadcastChannel.removeEventListener("internal", r)
        }), this._lstns = [], this._unl.forEach(function (r) {
            return r.remove()
        }), this._unl = [], this.isLeader && (this.isLeader = !1), this.isDead = !0, this._wKMC.res && this._wKMC.res(), this._wKMC.c && this._wKMC.c.abort("LeaderElectionWebLock.die() called"), eS(this, "death")
    }
};
var uke = function (e, r) {
    var n = this;
    this.broadcastChannel = e, this._options = r, this.isLeader = !1, this._hasLeader = !1, this.isDead = !1, this.token = XI(), this._aplQ = Iv, this._aplQC = 0, this._unl = [], this._lstns = [], this._dpL = function () {
    }, this._dpLC = !1;
    var i = function (o) {
        o.context === "leader" && (o.action === "death" && (n._hasLeader = !1), o.action === "tell" && (n._hasLeader = !0))
    };
    this.broadcastChannel.addEventListener("internal", i), this._lstns.push(i)
};
uke.prototype = {
    hasLeader: function () {
        return Promise.resolve(this._hasLeader)
    }, applyOnce: function (e) {
        var r = this;
        if (this.isLeader) return Nw(0, !0);
        if (this.isDead) return Nw(0, !1);
        if (this._aplQC > 1) return this._aplQ;
        var n = function () {
            if (r.isLeader) return pqt;
            var a = !1, o, s = new Promise(function (d) {
                o = function () {
                    a = !0, d()
                }
            }), l = function (p) {
                p.context === "leader" && p.token != r.token && (p.action === "apply" && p.token > r.token && o(), p.action === "tell" && (o(), r._hasLeader = !0))
            };
            r.broadcastChannel.addEventListener("internal", l);
            var f = e ? r._options.responseTime * 4 : r._options.responseTime;
            return eS(r, "apply").then(function () {
                return Promise.race([Nw(f), s.then(function () {
                    return Promise.reject(new Error)
                })])
            }).then(function () {
                return eS(r, "apply")
            }).then(function () {
                return Promise.race([Nw(f), s.then(function () {
                    return Promise.reject(new Error)
                })])
            }).catch(function () {
            }).then(function () {
                return r.broadcastChannel.removeEventListener("internal", l), a ? !1 : cke(r).then(function () {
                    return !0
                })
            })
        };
        return this._aplQC = this._aplQC + 1, this._aplQ = this._aplQ.then(function () {
            return n()
        }).then(function () {
            r._aplQC = r._aplQC - 1
        }), this._aplQ.then(function () {
            return r.isLeader
        })
    }, awaitLeadership: function () {
        return this._aLP || (this._aLP = _Gt(this)), this._aLP
    }, set onduplicate(t) {
        this._dpL = t
    }, die: function () {
        var e = this;
        return this._lstns.forEach(function (r) {
            return e.broadcastChannel.removeEventListener("internal", r)
        }), this._lstns = [], this._unl.forEach(function (r) {
            return r.remove()
        }), this._unl = [], this.isLeader && (this._hasLeader = !1, this.isLeader = !1), this.isDead = !0, eS(this, "death")
    }
};

function _Gt(t) {
    return t.isLeader ? Iv : new Promise(function (e) {
        var r = !1;

        function n() {
            r || (r = !0, t.broadcastChannel.removeEventListener("internal", a), e(!0))
        }

        t.applyOnce().then(function () {
            t.isLeader && n()
        });
        var i = function o() {
            return Nw(t._options.fallbackInterval).then(function () {
                if (!(t.isDead || r)) if (t.isLeader) n(); else return t.applyOnce(!0).then(function () {
                    t.isLeader ? n() : o()
                })
            })
        };
        i();
        var a = function (s) {
            s.context === "leader" && s.action === "death" && (t._hasLeader = !1, t.applyOnce().then(function () {
                t.isLeader && n()
            }))
        };
        t.broadcastChannel.addEventListener("internal", a), t._lstns.push(a)
    })
}

function xGt(t, e) {
    return t || (t = {}), t = JSON.parse(JSON.stringify(t)), t.fallbackInterval || (t.fallbackInterval = 3e3), t.responseTime || (t.responseTime = e.method.averageResponseTime(e.options)), t
}

function EGt(t, e) {
    if (t._leaderElector) throw new Error("BroadcastChannel already has a leader-elector");
    e = xGt(e, t);
    var r = vqt() ? new lke(t, e) : new uke(t, e);
    return t._befC.push(function () {
        return r.die()
    }), t._leaderElector = r, r
}

const om = {DEFAULT: 3, HIGH: 4, LOW: 2, MIN: 1, NONE: 0}, PC = {id: "alert", title: "Trade"},
    TGt = {id: "alert", actions: [{id: PC.id, title: PC.title, foreground: !0}]},
    oc = {id: "alert-v1.0.0", name: "Alerts Channel", importance: om.HIGH, sound: "default"}, CGt = t => {
        if (t.alert.trigger.type !== "priceUsd" || !t.pair.priceUsd) return !1;
        const e = Js(t.alert.trigger.priceUsd.replace(/,/g, "")), r = Js(t.pair.priceUsd.replace(/,/g, ""));
        return t.alert.trigger.direction === "over" ? r.gt(e) : r.lt(e)
    }, AGt = t => {
        if (t.alert.trigger.type !== "priceUsdInverted" || !t.pair.priceUsd) return !1;
        const e = Js(t.alert.trigger.priceUsd.replace(/,/g, "")), r = Js(t.pair.priceUsd.replace(/,/g, "")),
            n = Js(t.pair.price.replace(/,/g, "")), i = r.dividedBy(n);
        return t.alert.trigger.direction === "over" ? i.gt(e) : i.lt(e)
    }, IGt = t => {
        if (t.alert.trigger.type !== "priceNative") return !1;
        const e = Js(t.alert.trigger.price.replace(/,/g, "")), r = Js(t.pair.price.replace(/,/g, ""));
        return t.alert.trigger.direction === "over" ? r.gt(e) : r.lt(e)
    }, kGt = t => {
        if (t.alert.trigger.type !== "priceNativeInverted") return !1;
        const e = Js(t.alert.trigger.price.replace(/,/g, "")), r = Js(t.pair.price.replace(/,/g, "")),
            n = Js(1).dividedBy(r);
        return t.alert.trigger.direction === "over" ? n.gt(e) : n.lt(e)
    }, RGt = t => {
        if (t.alert.trigger.type !== "priceUsdPercentage") return !1;
        const e = t.pair.priceChange[t.alert.trigger.timeframeKey];
        return e ? t.alert.trigger.direction === "over" ? e > t.alert.trigger.percentage : e < -t.alert.trigger.percentage : !1
    }, DGt = t => {
        if (t.alert.trigger.type !== "moonshotProgress" || !PN(t.pair)) return !1;
        const e = t.pair.moonshot.progress;
        return e ? t.alert.trigger.direction === "over" ? e > t.alert.trigger.percentage : e < t.alert.trigger.percentage : !1
    },
    MGt = t => t.alert.trigger.type !== "marketCap" || !t.pair.marketCap ? !1 : t.alert.trigger.direction === "over" ? t.pair.marketCap > t.alert.trigger.marketCap : t.pair.marketCap < t.alert.trigger.marketCap,
    eD = "ds://", OGt = pt(W2e, q2e, (t, e) => {
        const r = {
            linkingScheme: eD,
            linkingSchemes: ["ds://", "dexscreener://", "https://dexscreener.com", "https://dexscreener.dev", "https://*.dexscreener.com", "https://*.dexscreener.dev"],
            rootUrl: `${eD}/`,
            pairDetailsUrl: (n, i) => `${eD}${n}/${i}`.toLowerCase(),
            pairTradeUrl: async n => {
                const {pair: i, utm: a} = n, o = await t.findBySlug(i.chainId), s = await e.findBySlug(i.dexId);
                if (!o || !s) return;
                const l = Qft({
                    chain: o,
                    dex: s,
                    pairAddress: i.pairAddress,
                    baseTokenAddress: i.baseToken.address,
                    labels: i.labels
                });
                if (!l) return;
                const f = new URL(l);
                return f.searchParams.append("utm_source", (a == null ? void 0 : a.source) ?? "dexscreener"), f.searchParams.append("utm_medium", (a == null ? void 0 : a.medium) ?? "app"), a != null && a.content && f.searchParams.append("utm_medium", a.content), f.toString().toLowerCase()
            },
            pairTradeAggregatorUrl: async n => {
                var d;
                const {pair: i, utm: a} = n, o = await t.findBySlug(i.chainId), s = await e.findBySlug(i.dexId);
                if (!o || !s) return;
                const l = Zft({
                    dex: s,
                    chain: o,
                    pairAddress: i.pairAddress,
                    baseTokenAddress: i.baseToken.address,
                    labels: i.labels,
                    inputCurrency: (d = i.quoteToken) == null ? void 0 : d.address
                });
                if (!l) return r.pairTradeUrl(n);
                if (l[0] === void 0) return;
                const f = new URL(l[0].url);
                return a != null && a.content && f.searchParams.append("utm_medium", a.content), f.toString()
            },
            watchlistUrl: n => `${eD}watchlist/${n}`
        };
        return r
    }), PGt = {pairPath: (t, e) => `/${t}/${e}`.toLowerCase(), watchlistPath: t => `/watchlist/${t}`},
    cg = pt(OGt, t => async e => {
        const r = {id: "default", type: "urlNavigation", url: t.pairDetailsUrl(e.chainId, e.pairAddress)},
            n = PGt.pairPath(e.chainId, e.pairAddress), i = await t.pairTradeUrl({pair: e, utm: {content: "alert"}});
        if (i) {
            const a = {id: PC.id, type: "inAppBrowserNavigation", url: i},
                o = [{title: PC.title, pressAction: {id: PC.id, launchActivity: "default"}}];
            return {data: [r, a], ios: {categoryId: TGt.id}, android: {actions: o}, web: {url: n}}
        }
        return {data: [r], web: {url: n}}
    }), RP = (t, e) => Jv({
        number: t,
        suffix: ` ${e}`,
        significantDigits: {gte1: 4, lt1: 4},
        maxDecimalPrecision: {gte1: 4, lt1: 12},
        addCommas: !0,
        maxZeroes: 5
    }), X0 = t => Jv({
        number: t,
        prefix: "$",
        significantDigits: {lt1: 4, gte1: 2},
        maxDecimalPrecision: {gte1: 2},
        addCommas: !0,
        maxZeroes: 5
    }), ove = (t, e) => Jv({
        number: t,
        prefix: e == null ? void 0 : e.prefix,
        suffix: "%",
        significantDigits: r => r.lt(1e3) ? 2 : 0,
        maxDecimalPrecision: 2,
        addCommas: !0
    }), sve = t => Jv({
        number: t,
        suffix: "%",
        significantDigits: e => e.eq(0) ? 0 : e.abs().lt(100) ? 2 : 0,
        maxDecimalPrecision: 2,
        addCommas: !0,
        largeNumberSuffix: {threshold: "hundred-thousand", significantDigits: 0}
    }), NGt = pt(cg, t => async ({pair: e, alert: r}) => {
        var d, p;
        if (r.trigger.type !== "priceNativeInverted") return;
        const n = RP(r.trigger.price, e.baseToken.symbol), i = Js(e.price.replace(/,/g, "")), a = Js(1).dividedBy(i),
            o = RP(a, e.baseToken.symbol);
        let l = `${e.quoteToken.symbol} went ${r.trigger.direction} ${n}, currently at ${o}`;
        r.note && r.note.length > 0 && (l += `

🗒️ ${r.note}`);
        const f = await t(e);
        return {
            id: r.id,
            body: l,
            ios: {categoryId: (d = f.ios) == null ? void 0 : d.categoryId, foreground: !0, sound: "default"},
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (p = f.android) == null ? void 0 : p.actions,
                importance: om.HIGH,
                sound: oc.sound
            },
            web: {
                message: l,
                icon: "direction" in r.trigger && r.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: f.web.url
            },
            data: {actions: f.data}
        }
    }), LGt = pt(cg, t => async ({alert: e, pair: r}) => {
        var l, f;
        if (e.trigger.type !== "priceNative") return;
        const n = RP(e.trigger.price, r.quoteToken.symbol), i = RP(r.price, r.quoteToken.symbol);
        let o = `${r.baseToken.symbol} went ${e.trigger.direction} ${n}, currently at ${i}`;
        e.note && e.note.length > 0 && (o += `

🗒️ ${e.note}`);
        const s = await t(r);
        return {
            id: e.id,
            body: o,
            ios: {categoryId: (l = s.ios) == null ? void 0 : l.categoryId, foreground: !0, sound: "default"},
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (f = s.android) == null ? void 0 : f.actions,
                importance: om.HIGH,
                sound: oc.sound
            },
            web: {
                message: o,
                icon: "direction" in e.trigger && e.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: s.web.url
            },
            data: {actions: s.data}
        }
    }), BGt = pt(V8, cg, (t, e) => async ({alert: r, pair: n}) => {
        var d, p;
        if (r.trigger.type !== "priceUsdCross" || !n.priceUsd) return;
        const i = X0(r.trigger.priceUsd), a = X0(n.priceUsd);
        let s = `${`${n.baseToken.symbol}/${n.quoteToken.symbol}`} has crossed ${i} and is currently at ${a}`;
        r.note && r.note.length > 0 && (s += `

🗒️ ${r.note}`);
        const l = await e(n), f = t.buildChartScreenshotUrl({
            chainId: n.chainId,
            pairId: n.pairAddress,
            width: 512,
            height: 512,
            interval: z8[1],
            timestamp: Date.now()
        }).toString();
        return {
            id: r.id,
            body: s,
            ios: {
                categoryId: (d = l.ios) == null ? void 0 : d.categoryId,
                foreground: !0,
                sound: "default",
                attachments: [{url: f}]
            },
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (p = l.android) == null ? void 0 : p.actions,
                importance: om.HIGH,
                sound: oc.sound,
                style: {type: 0, picture: f}
            },
            web: {
                message: s,
                icon: "direction" in r.trigger && r.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: l.web.url
            },
            data: {actions: l.data}
        }
    }), $Gt = pt(cg, t => async ({alert: e, pair: r}) => {
        var p, g;
        if (e.trigger.type !== "priceUsdInvertedCross" || !r.priceUsd) return;
        const n = X0(e.trigger.priceUsd), i = Js(r.priceUsd.replace(/,/g, "")), a = Js(r.price.replace(/,/g, "")),
            o = i.dividedBy(a), s = X0(o);
        let f = `${`${r.quoteToken.symbol}/${r.baseToken.symbol}`} has crossed ${n} and is currently at ${s}`;
        e.note && e.note.length > 0 && (f += `

🗒️ ${e.note}`);
        const d = await t(r);
        return {
            id: e.id,
            body: f,
            ios: {categoryId: (p = d.ios) == null ? void 0 : p.categoryId, foreground: !0, sound: "default"},
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (g = d.android) == null ? void 0 : g.actions,
                importance: om.HIGH,
                sound: oc.sound
            },
            web: {
                message: f,
                icon: "direction" in e.trigger && e.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: d.web.url
            },
            data: {actions: d.data}
        }
    }), FGt = pt(cg, t => async ({alert: e, pair: r}) => {
        var p, g;
        if (e.trigger.type !== "priceUsdInverted" || !r.priceUsd) return;
        const n = X0(e.trigger.priceUsd), i = Js(r.priceUsd.replace(/,/g, "")), a = Js(r.price.replace(/,/g, "")),
            o = i.dividedBy(a), s = X0(o);
        let f = `${`${r.quoteToken.symbol}/${r.baseToken.symbol}`} went ${e.trigger.direction} ${n}, currently at ${s}`;
        e.note && e.note.length > 0 && (f += `

🗒️ ${e.note}`);
        const d = await t(r);
        return {
            id: e.id,
            body: f,
            ios: {categoryId: (p = d.ios) == null ? void 0 : p.categoryId, foreground: !0, sound: "default"},
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (g = d.android) == null ? void 0 : g.actions,
                importance: om.HIGH,
                sound: oc.sound
            },
            web: {
                message: f,
                icon: "direction" in e.trigger && e.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: d.web.url
            },
            data: {actions: d.data}
        }
    }), UGt = pt(V8, cg, (t, e) => async ({alert: r, pair: n}) => {
        var d, p;
        if (r.trigger.type !== "priceUsd" || !n.priceUsd) return;
        const i = X0(r.trigger.priceUsd), a = X0(n.priceUsd);
        let s = `${`${n.baseToken.symbol}/${n.quoteToken.symbol}`} went ${r.trigger.direction} ${i}, currently at ${a}`;
        r.note && r.note.length > 0 && (s += `

🗒️ ${r.note}`);
        const l = await e(n), f = t.buildChartScreenshotUrl({
            chainId: n.chainId,
            pairId: n.pairAddress,
            width: 512,
            height: 512,
            interval: z8[1],
            timestamp: Date.now()
        }).toString();
        return {
            id: r.id,
            body: s,
            ios: {
                categoryId: (d = l.ios) == null ? void 0 : d.categoryId,
                foreground: !0,
                sound: "default",
                attachments: [{url: f}]
            },
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (p = l.android) == null ? void 0 : p.actions,
                importance: om.HIGH,
                sound: oc.sound,
                style: {type: 0, picture: f}
            },
            web: {
                message: s,
                icon: "direction" in r.trigger && r.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: l.web.url
            },
            data: {actions: l.data}
        }
    }), jGt = pt(V8, cg, (t, e) => async ({alert: r, pair: n}) => {
        var g, b;
        if (r.trigger.type !== "priceUsdPercentage") return;
        const i = i_e[r.trigger.timeframeKey].label.toLowerCase(), a = n.priceChange[r.trigger.timeframeKey];
        if (!a) return;
        const o = ove(Math.abs(r.trigger.percentage)), s = ove(Math.abs(a)),
            l = `${n.baseToken.symbol}/${n.quoteToken.symbol}`;
        let f;
        r.trigger.direction === "over" ? f = `${l} is up over ${o} in the ${i}, currently up ${s}` : f = `${l} is down over ${o} in the ${i}, currently down ${s}`, r.note && r.note.length > 0 && (f += `

🗒️ ${r.note}`);
        const d = await e(n), p = t.buildChartScreenshotUrl({
            chainId: n.chainId,
            pairId: n.pairAddress,
            width: 512,
            height: 512,
            interval: z8[1],
            timestamp: Date.now()
        }).toString();
        return {
            id: r.id,
            body: f,
            imageUrl: p,
            ios: {
                categoryId: (g = d.ios) == null ? void 0 : g.categoryId,
                foreground: !0,
                sound: "default",
                attachments: [{url: p}]
            },
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (b = d.android) == null ? void 0 : b.actions,
                importance: om.HIGH,
                sound: oc.sound,
                style: {type: 0, picture: p}
            },
            web: {
                message: f,
                icon: "direction" in r.trigger && r.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: d.web.url
            },
            data: {actions: d.data}
        }
    }), zGt = pt(V8, cg, (t, e) => async ({alert: r, pair: n}) => {
        var d, p;
        if (r.trigger.type !== "moonshotProgress" || !PN(n)) return;
        const i = sve(Math.abs(r.trigger.percentage)), a = sve(n.moonshot.progress),
            o = `${n.baseToken.symbol}/${n.quoteToken.symbol}`;
        let s;
        r.trigger.direction === "over" ? s = `🌙 ${o} progress reached ${i}, currently at ${a}.` : s = `🌙 ${o} progress slipped under ${i}, currently at ${a}.`, r.note && r.note.length > 0 && (s += `

🗒️ ${r.note}`);
        const l = await e(n), f = t.buildChartScreenshotUrl({
            chainId: n.chainId,
            pairId: n.pairAddress,
            width: 512,
            height: 512,
            interval: z8[1],
            timestamp: Date.now()
        }).toString();
        return {
            id: r.id,
            body: s,
            imageUrl: f,
            ios: {
                categoryId: (d = l.ios) == null ? void 0 : d.categoryId,
                foreground: !0,
                sound: "default",
                attachments: [{url: f}]
            },
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (p = l.android) == null ? void 0 : p.actions,
                importance: om.HIGH,
                sound: oc.sound,
                style: {type: 0, picture: f}
            },
            web: {
                message: s,
                icon: "direction" in r.trigger && r.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: l.web.url
            },
            data: {actions: l.data}
        }
    }), VGt = pt(V8, cg, (t, e) => async ({alert: r, pair: n}) => {
        var d, p;
        if (r.trigger.type !== "marketCap" || !n.marketCap) return;
        const i = X0(r.trigger.marketCap), a = X0(n.marketCap), o = `${n.baseToken.symbol}/${n.quoteToken.symbol}`;
        let s;
        r.trigger.direction === "over" ? s = `${o} market cap reached ${i}, currently at ${a}.` : s = `${o} market cap slipped under ${i}, currently at ${a}.`, r.note && r.note.length > 0 && (s += `

🗒️ ${r.note}`);
        const l = await e(n), f = t.buildChartScreenshotUrl({
            chainId: n.chainId,
            pairId: n.pairAddress,
            width: 512,
            height: 512,
            interval: z8[1],
            timestamp: Date.now()
        }).toString();
        return {
            id: r.id,
            body: s,
            ios: {
                categoryId: (d = l.ios) == null ? void 0 : d.categoryId,
                foreground: !0,
                sound: "default",
                attachments: [{url: f}]
            },
            android: {
                channelId: oc.id,
                pressAction: {id: "default"},
                actions: (p = l.android) == null ? void 0 : p.actions,
                importance: om.HIGH,
                sound: oc.sound,
                style: {type: 0, picture: f}
            },
            web: {
                message: s,
                icon: "direction" in r.trigger && r.trigger.direction === "under" ? "/img/notification-red.png" : "/img/notification-green.png",
                interactable: !0,
                url: l.web.url
            },
            data: {actions: l.data}
        }
    }), HGt = pt(UGt, FGt, LGt, NGt, jGt, BGt, $Gt, zGt, VGt, (t, e, r, n, i, a, o, s, l) => async f => {
        switch (f.alert.trigger.type) {
            case"priceUsd":
                return t(f);
            case"priceUsdInverted":
                return e(f);
            case"priceNative":
                return r(f);
            case"priceNativeInverted":
                return n(f);
            case"priceUsdPercentage":
                return i(f);
            case"priceUsdCross":
                return a(f);
            case"priceUsdInvertedCross":
                return o(f);
            case"moonshotProgress":
                return s(f);
            case"marketCap":
                return l(f);
            default:
                return
        }
    }), fke = pt(sr, XO, G5e, (t, e, r) => () => {
        const n = new I4(1), i = WGt(e), a = ZQ(5e3, 1 / 0), o = lee({
                url: i,
                reconnectionStrategy: a,
                logger: t,
                transport: r,
                serializer: v2e(K5e),
                beforeUnloadTarget: typeof document < "u" ? window : void 0
            }), s = p => n.next(p), l = (p, g) => {
                p.send({type: "subscribe", payload: {timeframe: "h24", page: 1, ...g}})
            }, f = new ia(p => {
                const g = o.connect();
                p.next(o);
                const b = o.status.pipe(j0(S => S === "connected"), TWe(1), uo(() => n.pipe(Mye(1))), j0(aHe), Zy(S => l(o, S))).subscribe(ZC);
                return () => {
                    b.unsubscribe(), g()
                }
            }).pipe(IX({connector: () => new I4(1), resetOnRefCountZero: () => QW(1e3)})),
            d = n.pipe(uo(p => p ? f.pipe(Zy(g => l(g, p)), uo(g => g.message.pipe(zn(b => b.pairs)))) : Hd([])));
        return {subscribe: s, data: d, status: o.status}
    });

function WGt(t) {
    const e = new URL(t);
    return e.pathname = "/dex/screener/v3/pairs-search", e
}

const qGt = pt(fke, vL, (t, e) => {
    const r = t(), n = e.active.pipe(zn(a => {
        const o = [];
        return a.forEach(s => {
            s.trigger.subject.type !== "dexPair" && s.trigger.subject.type !== "dexToken" || (s.trigger.subject.type === "dexPair" && o.push({
                chainId: s.trigger.subject.chainId.toLowerCase(),
                pairId: s.trigger.subject.pairId.toLowerCase()
            }), s.trigger.subject.type === "dexToken" && o.push({
                chainId: s.trigger.subject.chainId.toLowerCase(),
                tokenAddress: s.trigger.subject.tokenId.toLowerCase()
            }))
        }), {pairs: zZe(o, X1e)}
    }), op(), Xa), i = () => {
        const a = n.subscribe({
            next: ({pairs: o}) => {
                if (o.length === 0) {
                    r.subscribe(void 0);
                    return
                }
                const s = o.map(l => ({id: "pairId" in l ? l.pairId : l.tokenAddress, chainId: l.chainId}));
                r.subscribe({ids: s, filters: {excludedDexIds: []}})
            }
        });
        return () => a.unsubscribe()
    };
    return {status: r.status, data: r.data, connect: i}
}), are = pt("@dexscreener/web/notifications/notifications-manager", uee, t => ({
    dispose: t.dispose,
    isSupported: t.isSupported,
    requestPermission: t.requestPermission,
    hasPermission: t.hasPermission,
    send: t.send
}));

function GGt(t, e) {
    const r = [];
    for (const n of e) {
        const i = t.filter(({
                                trigger: a,
                                enabled: o
                            }) => o === !0 && (a.subject.type === "dexPair" && a.subject.chainId === n.chainId && a.subject.pairId === n.pairAddress || a.subject.type === "dexToken" && a.subject.chainId === n.chainId && a.subject.tokenId === n.baseToken.address));
        for (const a of i) {
            if (!n.priceUsd && !n.marketCap && !(PN(n) && n.moonshot.progress)) continue;
            const o = {pair: n, alert: a};
            switch (a.trigger.type) {
                case"priceUsd":
                    CGt(o) && r.push([a, n]);
                    break;
                case"priceUsdInverted":
                    AGt(o) && r.push([a, n]);
                    break;
                case"priceUsdPercentage":
                    RGt(o) && r.push([a, n]);
                    break;
                case"priceNative":
                    IGt(o) && r.push([a, n]);
                    break;
                case"priceNativeInverted":
                    kGt(o) && r.push([a, n]);
                    break;
                case"marketCap":
                    MGt(o) && r.push([a, n]);
                    break;
                case"moonshotProgress":
                    DGt(o) && r.push([a, n])
            }
        }
    }
    return r
}

const KGt = "@dexscreener/web/alerts/new-alerts-observer", YGt = pt(KGt, vL, are, qGt, HGt, uee, (t, e, r, n) => i => {
        let a, o;

        function s() {
            o = r.connect();
            const f = t.active, d = r.data, p = Qy([f, d]).pipe(AX(([g, b]) => GGt(g, b)));
            a == null || a.unsubscribe(), a = p.subscribe(async g => {
                var I;
                if (!g) return;
                const [b, S] = g, T = await n({alert: b, pair: S});
                T != null && T.web && ((I = i.onAlertTriggered) == null || I.call(i, b, S), e.send(T.web))
            })
        }

        function l() {
            a == null || a.unsubscribe(), o == null || o()
        }

        return {dispose: l, observe: s}
    }), XGt = {
        observe: () => {
        }, dispose: () => {
        }
    }, dke = W.createContext(void 0), QGt = () => {
        const t = W.useContext(dke);
        if (!t) throw new Error("Manager not provided!");
        return t
    }, ZGt = ({children: t}) => {
        const e = aa(are);
        return W.useEffect(() => () => e.dispose(), [e]), ie.jsx(dke.Provider, {value: e, children: t})
    }, JGt = new ire("alertsObserverChannel"), eKt = EGt(JGt), tKt = ({children: t}) => {
        const e = aa(vL), {actions: r} = e, n = QGt(), i = aa(YGt), a = W.useCallback(s => r.setAlertTriggered(s.id), [r]),
            o = W.useMemo(() => n.hasPermission() ? i({onAlertTriggered: a}) : XGt, [n, i, a]);
        return W.useEffect(() => (eKt.awaitLeadership().then(() => o.observe()), () => o.dispose()), [o]), ie.jsx(ie.Fragment, {children: t})
    }, rKt = ({key: t, defaultState: e, schema: r, onError: n, localKeys: i}) => {
        const a = aa(ROt);
        return W.useMemo(() => a({key: t, defaultState: e, schema: r, onError: n, localKeys: i}), [a, t, e, r, n, i])
    }, nKt = _.object({
        sidebarPosition: _.enum(["left", "right"]),
        transactionsHeight: _.number().optional(),
        sidebar: _.boolean().optional().default(!0),
        trendingBar: _.boolean().optional().default(!0),
        tokenHeaderImage: _.boolean().optional().default(!0),
        mobileTxnsLayout: _.enum(["wide", "compact"]).optional().default("compact"),
        txnsDateFormat: _.enum(["full", "timeAgo"]).optional().default("timeAgo"),
        usePriceUsd: _.boolean().optional().default(!0)
    }), hke = {
        sidebarPosition: "right",
        transactionsHeight: void 0,
        sidebar: !0,
        trendingBar: !0,
        tokenHeaderImage: !0,
        mobileTxnsLayout: "compact",
        txnsDateFormat: "timeAgo",
        usePriceUsd: !0
    }, iKt = {chart: !0, trades: !0, menu: !0, chatState: "minimized"}, aKt = {...hke, ...iKt},
    oKt = "@dexscreener/pair-details-layout", [ftr, sKt] = LN("DEXPairDetailsLayoutSettingsContext"),
    cKt = ["sidebar", "transactionsHeight"], lKt = ({children: t}) => {
        const {state: e, setState: r} = rKt({
                key: oKt,
                schema: nKt,
                defaultState: hke,
                localKeys: cKt
            }), [n, i] = W.useState(aKt), a = AE(b => b.embedSettings), o = ss(a.isEmbed), s = ss(a.dsApp),
            l = W.useMemo(() => a.isEmbed && (a.chart === !0 && !a.info || a.trades && !a.info), [a.isEmbed, a.info, a.chart, a.trades]), {
                toggle: f,
                value: d
            } = V_e(l ?? !1);
        yZ(() => e.pipe(Zy(b => i(S => ({...S, ...b})))), [e, i]);
        const p = v0t(b => b.pipe(uo(S => e.pipe(_We(), zn(T => ({...T, ...S})))), Zy(S => i(T => {
                const I = {...T, ...S};
                return (s.current || o.current === !1) && r(I), I
            }))), [e, s, o, r]),
            g = {settings: n, setSettings: p, isMobileChartOrTxnsVisible: d, toggleMobileChartOrTxnsVisible: f};
        return ie.jsx(sKt, {value: g, children: t})
    }, tD = {}, fx = {
        get(t, e) {
            var r;
            try {
                return (r = tD[t]) !== null && r !== void 0 ? r : uKt(localStorage.getItem(t))
            } catch {
                return e
            }
        }, set(t, e) {
            try {
                return localStorage.setItem(t, JSON.stringify(e)), tD[t] = void 0, !0
            } catch {
                return tD[t] = e, !1
            }
        }, remove(t) {
            tD[t] = void 0, localStorage.removeItem(t)
        }
    };

function uKt(t) {
    return t === "undefined" ? void 0 : JSON.parse(t ?? "")
}

function fKt(t, e) {
    const r = W.useMemo(() => (d => typeof d == "function")(e) ? e() : e, [t]), n = W.useMemo(() => ({
        value: fx.get(t, r), isPersistent: (() => {
            if (typeof window > "u") return !0;
            try {
                return localStorage.setItem("__ulss", "#"), localStorage.removeItem("__ulss"), !0
            } catch {
                return !1
            }
        })()
    }), [t, r]), [{value: i, isPersistent: a}, o] = W.useState(n), s = W.useMemo(() => f => {
        (p => typeof p == "function")(f) ? o(p => ({
            value: f(p.value),
            isPersistent: fx.set(t, f(p.value))
        })) : o({value: f, isPersistent: fx.set(t, f)})
    }, [t]);
    W.useEffect(() => {
        const f = d => {
            d.storageArea === localStorage && d.key === t && o({value: fx.get(t, r), isPersistent: !0})
        };
        return window.addEventListener("storage", f), () => window.removeEventListener("storage", f)
    }, [t, r]);
    const l = W.useRef(!0);
    return W.useEffect(() => {
        if (!(l.current && n.value === void 0)) {
            if (fx.set(t, n.value), l.current) {
                l.current = !1;
                return
            }
            o(n)
        }
    }, [t, n]), W.useMemo(() => [i, s, {
        isPersistent: a, removeItem() {
            fx.remove(t), o(f => ({value: r, isPersistent: f.isPersistent}))
        }
    }], [i, s, a, t, r])
}

function dKt(t, e) {
    const r = [], n = [];
    return function () {
        const [a, o, {isPersistent: s, removeItem: l}] = fKt(t, e), f = W.useCallback(d => {
            Jh.unstable_batchedUpdates(() => {
                for (const p of r) p(d)
            })
        }, []);
        return W.useEffect(() => (r.push(o), n.push(l), () => {
            r.splice(r.indexOf(o), 1), n.splice(n.indexOf(l), 1)
        }), [o, l]), W.useMemo(() => [a, f, {
            isPersistent: s, removeItem() {
                for (const d of n) d()
            }
        }], [a, f, s])
    }
}

const hKt = _.object({
    schemaVersion: _.number(),
    updatedAtTimestamp: _.number(),
    ui: _.object({collapseNav: _.boolean(), pairDetailSide: _.literal("left").or(_.literal("right"))})
}), pke = 1, pKt = {
    schemaVersion: pke,
    updatedAtTimestamp: new Date().getTime(),
    ui: {collapseNav: !1, pairDetailSide: "right"}
}, mKt = dKt("dexscreener.settings"), lg = t => {
    const [e, r] = mKt(), [n, i] = W.useState(pKt);
    return W.useEffect(() => {
        const o = hKt.safeParse(e);
        o.success ? i(o.data) : t != null && t.onParseError && t.onParseError()
    }, [e == null ? void 0 : e.updatedAtTimestamp]), {
        settings: n, setUiSettings: o => {
            try {
                return r({schemaVersion: pke, updatedAtTimestamp: new Date().getTime(), ui: {...n.ui, ...o}}), !0
            } catch {
                return !1
            }
        }
    }
}, QI = () => {
    const {settings: t} = lg(), e = AE(o => o.embedSettings);
    let r = t.ui.collapseNav ? 50 : 210;
    e.isEmbed && !e.nav && (r = 0);
    const n = !e.isEmbed || e.nav ? 50 : 0, i = 46;
    let a = 0;
    return e.isEmbed && !e.nav && e.branding ? a = 38 : a = 0, {
        navWidth: r,
        headerHeight: n,
        subnavHeight: i,
        footerHeight: a
    }
}, mke = t => ie.jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "100%",
    height: "100%",
    fill: "#fff",
    fillRule: "evenodd",
    viewBox: "0 0 252 300", ...t,
    children: [ie.jsx("path", {d: "M151.818 106.866c9.177-4.576 20.854-11.312 32.545-20.541 2.465 5.119 2.735 9.586 1.465 13.193-.9 2.542-2.596 4.753-4.826 6.512-2.415 1.901-5.431 3.285-8.765 4.033-6.326 1.425-13.712.593-20.419-3.197m1.591 46.886l12.148 7.017c-24.804 13.902-31.547 39.716-39.557 64.859-8.009-25.143-14.753-50.957-39.556-64.859l12.148-7.017a5.95 5.95 0 003.84-5.845c-1.113-23.547 5.245-33.96 13.821-40.498 3.076-2.342 6.434-3.518 9.747-3.518s6.671 1.176 9.748 3.518c8.576 6.538 14.934 16.951 13.821 40.498a5.95 5.95 0 003.84 5.845zM126 0c14.042.377 28.119 3.103 40.336 8.406 8.46 3.677 16.354 8.534 23.502 14.342 3.228 2.622 5.886 5.155 8.814 8.071 7.897.273 19.438-8.5 24.796-16.709-9.221 30.23-51.299 65.929-80.43 79.589-.012-.005-.02-.012-.029-.018-5.228-3.992-11.108-5.988-16.989-5.988s-11.76 1.996-16.988 5.988c-.009.005-.017.014-.029.018-29.132-13.66-71.209-49.359-80.43-79.589 5.357 8.209 16.898 16.982 24.795 16.709 2.929-2.915 5.587-5.449 8.814-8.071C69.31 16.94 77.204 12.083 85.664 8.406 97.882 3.103 111.959.377 126 0m-25.818 106.866c-9.176-4.576-20.854-11.312-32.544-20.541-2.465 5.119-2.735 9.586-1.466 13.193.901 2.542 2.597 4.753 4.826 6.512 2.416 1.901 5.432 3.285 8.766 4.033 6.326 1.425 13.711.593 20.418-3.197"}), ie.jsx("path", {d: "M197.167 75.016c6.436-6.495 12.107-13.684 16.667-20.099l2.316 4.359c7.456 14.917 11.33 29.774 11.33 46.494l-.016 26.532.14 13.754c.54 33.766 7.846 67.929 24.396 99.193l-34.627-27.922-24.501 39.759-25.74-24.231L126 299.604l-41.132-66.748-25.739 24.231-24.501-39.759L0 245.25c16.55-31.264 23.856-65.427 24.397-99.193l.14-13.754-.016-26.532c0-16.721 3.873-31.578 11.331-46.494l2.315-4.359c4.56 6.415 10.23 13.603 16.667 20.099l-2.01 4.175c-3.905 8.109-5.198 17.176-2.156 25.799 1.961 5.554 5.54 10.317 10.154 13.953 4.48 3.531 9.782 5.911 15.333 7.161 3.616.814 7.3 1.149 10.96 1.035-.854 4.841-1.227 9.862-1.251 14.978L53.2 160.984l25.206 14.129a41.926 41.926 0 015.734 3.869c20.781 18.658 33.275 73.855 41.861 100.816 8.587-26.961 21.08-82.158 41.862-100.816a41.865 41.865 0 015.734-3.869l25.206-14.129-32.665-18.866c-.024-5.116-.397-10.137-1.251-14.978 3.66.114 7.344-.221 10.96-1.035 5.551-1.25 10.854-3.63 15.333-7.161 4.613-3.636 8.193-8.399 10.153-13.953 3.043-8.623 1.749-17.689-2.155-25.799l-2.01-4.175z"})]
}), vKt = () => {
    const {footerHeight: t} = QI(), {pathname: e} = Oo();
    return ie.jsxs(Bf, {
        href: e,
        target: "_blank",
        bg: "black",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        h: `${t}px`,
        px: 2,
        _hover: {textDecor: "none", bg: "gray.950"},
        _focus: {boxShadow: "none"},
        children: [ie.jsx(ln, {
            as: "span",
            color: "gray.500",
            fontSize: "xs",
            fontStyle: "italic",
            mr: 2,
            children: "Tracked by"
        }), ie.jsx(Gn, {
            children: ie.jsxs(i1, {
                as: "h1",
                display: "flex",
                alignItems: "center",
                color: "white",
                fontSize: "16px",
                children: [ie.jsx(Wi, {
                    as: mke,
                    pos: "relative",
                    top: "1px",
                    mr: "3px",
                    color: "white",
                    boxSize: "26px"
                }), ie.jsxs(ln, {
                    as: "span",
                    children: [ie.jsx(ln, {as: "span", fontWeight: "semibold", children: "DEX"}), ie.jsx(ln, {
                        ml: "2px",
                        as: "span",
                        fontWeight: "normal",
                        children: "SCREENER"
                    })]
                })]
            })
        })]
    })
};

function gKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 384 512"},
        child: [{
            tag: "path",
            attr: {d: "M318.7 268.7c-.2-36.7 16.4-64.4 50-84.8-18.8-26.9-47.2-41.7-84.7-44.6-35.5-2.8-74.3 20.7-88.5 20.7-15 0-49.4-19.7-76.4-19.7C63.3 141.2 4 184.8 4 273.5q0 39.3 14.4 81.2c12.8 36.7 59 126.7 107.2 125.2 25.2-.6 43-17.9 75.8-17.9 31.8 0 48.3 17.9 76.4 17.9 48.6-.7 90.4-82.5 102.6-119.3-65.2-30.7-61.7-90-61.7-91.9zm-56.6-164.2c27.3-32.4 24.8-61.9 24-72.5-24.1 1.4-52 16.4-67.9 34.9-17.5 19.8-27.8 44.3-25.6 71.9 26.1 2 49.9-11.4 69.5-34.3z"}
        }]
    })(t)
}

function yKt(t) {
    return ct({
        tag: "svg", attr: {viewBox: "0 0 640 512"}, child: [{
            tag: "path",
            attr: {d: "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"}
        }]
    })(t)
}

function dtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"}
        }]
    })(t)
}

function htr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 488 512"},
        child: [{
            tag: "path",
            attr: {d: "M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"}
        }]
    })(t)
}

function bKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z"}
        }]
    })(t)
}

function ptr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M448,209.91a210.06,210.06,0,0,1-122.77-39.25V349.38A162.55,162.55,0,1,1,185,188.31V278.2a74.62,74.62,0,1,0,52.23,71.18V0l88,0a121.18,121.18,0,0,0,1.86,22.17h0A122.18,122.18,0,0,0,381,102.39a121.43,121.43,0,0,0,67,20.14Z"}
        }]
    })(t)
}

function wKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"}
        }]
    })(t)
}

function SKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"}
        }]
    })(t)
}

function _Kt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z"}
        }]
    })(t)
}

function xKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"}
        }]
    })(t)
}

function EKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z"}
        }]
    })(t)
}

function TKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M177 159.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 329.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"}
        }]
    })(t)
}

function mtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z"}
        }]
    })(t)
}

function vtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"}
        }]
    })(t)
}

function gtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"}
        }]
    })(t)
}

function ytr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"}
        }]
    })(t)
}

function btr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M377.941 169.941V216H134.059v-46.059c0-21.382-25.851-32.09-40.971-16.971L7.029 239.029c-9.373 9.373-9.373 24.568 0 33.941l86.059 86.059c15.119 15.119 40.971 4.411 40.971-16.971V296h243.882v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.568 0-33.941l-86.059-86.059c-15.119-15.12-40.971-4.412-40.971 16.97z"}
        }]
    })(t)
}

function CKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"}
        }]
    })(t)
}

function wtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 640 512"},
        child: [{
            tag: "path",
            attr: {d: "M633.82 458.1l-90.62-70.05c.19-1.38.8-2.66.8-4.06.05-7.55-2.61-15.27-8.61-21.71-19.32-20.76-55.47-51.99-55.47-154.29 0-77.7-54.48-139.9-127.94-155.16V32c0-17.67-14.32-32-31.98-32s-31.98 14.33-31.98 32v20.84c-40.33 8.38-74.66 31.07-97.59 62.57L45.47 3.37C38.49-2.05 28.43-.8 23.01 6.18L3.37 31.45C-2.05 38.42-.8 48.47 6.18 53.9l588.35 454.73c6.98 5.43 17.03 4.17 22.46-2.81l19.64-25.27c5.42-6.97 4.17-17.02-2.81-22.45zM157.23 251.54c-8.61 67.96-36.41 93.33-52.62 110.75-6 6.45-8.66 14.16-8.61 21.71.11 16.4 12.98 32 32.1 32h241.92L157.23 251.54zM320 512c35.32 0 63.97-28.65 63.97-64H256.03c0 35.35 28.65 64 63.97 64z"}
        }]
    })(t)
}

function AKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M224 512c35.32 0 63.97-28.65 63.97-64H160.03c0 35.35 28.65 64 63.97 64zm215.39-149.71c-19.32-20.76-55.47-51.99-55.47-154.29 0-77.7-54.48-139.9-127.94-155.16V32c0-17.67-14.32-32-31.98-32s-31.98 14.33-31.98 32v20.84C118.56 68.1 64.08 130.3 64.08 208c0 102.3-36.15 133.53-55.47 154.29-6 6.45-8.66 14.16-8.61 21.71.11 16.4 12.98 32 32.1 32h383.8c19.12 0 32-15.6 32.1-32 .05-7.55-2.61-15.27-8.61-21.71z"}
        }]
    })(t)
}

function Str(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M0 464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V192H0v272zm320-196c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM192 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM64 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM400 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H48C21.5 64 0 85.5 0 112v48h448v-48c0-26.5-21.5-48-48-48z"}
        }]
    })(t)
}

function IKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z"}
        }]
    })(t)
}

function kKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M288.662 352H31.338c-17.818 0-26.741-21.543-14.142-34.142l128.662-128.662c7.81-7.81 20.474-7.81 28.284 0l128.662 128.662c12.6 12.599 3.676 34.142-14.142 34.142z"}
        }]
    })(t)
}

function _tr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M496 384H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v336c0 17.67 14.33 32 32 32h464c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16zM464 96H345.94c-21.38 0-32.09 25.85-16.97 40.97l32.4 32.4L288 242.75l-73.37-73.37c-12.5-12.5-32.76-12.5-45.25 0l-68.69 68.69c-6.25 6.25-6.25 16.38 0 22.63l22.62 22.62c6.25 6.25 16.38 6.25 22.63 0L192 237.25l73.37 73.37c12.5 12.5 32.76 12.5 45.25 0l96-96 32.4 32.4c15.12 15.12 40.97 4.41 40.97-16.97V112c.01-8.84-7.15-16-15.99-16z"}
        }]
    })(t)
}

function xtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"}
        }]
    })(t)
}

function RKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"}
        }]
    })(t)
}

function DKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"}
        }]
    })(t)
}

function Etr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"}
        }]
    })(t)
}

function Ttr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"}
        }]
    })(t)
}

function Ctr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"}
        }]
    })(t)
}

function Atr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"}
        }]
    })(t)
}

function MKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 640 512"},
        child: [{
            tag: "path",
            attr: {d: "M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"}
        }]
    })(t)
}

function OKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"}
        }]
    })(t)
}

function Itr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z"}
        }]
    })(t)
}

function ktr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 192 512"},
        child: [{
            tag: "path",
            attr: {d: "M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z"}
        }]
    })(t)
}

function Rtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M497.941 273.941c18.745-18.745 18.745-49.137 0-67.882l-160-160c-18.745-18.745-49.136-18.746-67.883 0l-256 256c-18.745 18.745-18.745 49.137 0 67.882l96 96A48.004 48.004 0 0 0 144 480h356c6.627 0 12-5.373 12-12v-40c0-6.627-5.373-12-12-12H355.883l142.058-142.059zm-302.627-62.627l137.373 137.373L265.373 416H150.628l-80-80 124.686-124.686z"}
        }]
    })(t)
}

function Dtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M0 168v-16c0-13.255 10.745-24 24-24h360V80c0-21.367 25.899-32.042 40.971-16.971l80 80c9.372 9.373 9.372 24.569 0 33.941l-80 80C409.956 271.982 384 261.456 384 240v-48H24c-13.255 0-24-10.745-24-24zm488 152H128v-48c0-21.314-25.862-32.08-40.971-16.971l-80 80c-9.372 9.373-9.372 24.569 0 33.941l80 80C102.057 463.997 128 453.437 128 432v-48h360c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24z"}
        }]
    })(t)
}

function Mtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 576 512"},
        child: [{
            tag: "path",
            attr: {d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"}
        }]
    })(t)
}

function Otr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M448 344v112a23.94 23.94 0 0 1-24 24H312c-21.39 0-32.09-25.9-17-41l36.2-36.2L224 295.6 116.77 402.9 153 439c15.09 15.1 4.39 41-17 41H24a23.94 23.94 0 0 1-24-24V344c0-21.4 25.89-32.1 41-17l36.19 36.2L184.46 256 77.18 148.7 41 185c-15.1 15.1-41 4.4-41-17V56a23.94 23.94 0 0 1 24-24h112c21.39 0 32.09 25.9 17 41l-36.2 36.2L224 216.4l107.23-107.3L295 73c-15.09-15.1-4.39-41 17-41h112a23.94 23.94 0 0 1 24 24v112c0 21.4-25.89 32.1-41 17l-36.19-36.2L263.54 256l107.28 107.3L407 327.1c15.1-15.2 41-4.5 41 16.9z"}
        }]
    })(t)
}

function Ptr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM488,0h-128c-21.37,0-32.05,25.91-17,41l35.73,35.73L135,320.37a24,24,0,0,0,0,34L157.67,377a24,24,0,0,0,34,0L435.28,133.32,471,169c15,15,41,4.5,41-17V24A24,24,0,0,0,488,0Z"}
        }]
    })(t)
}

function Ntr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 640 512"},
        child: [{
            tag: "path",
            attr: {d: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z"}
        }]
    })(t)
}

function Ltr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 576 512"},
        child: [{
            tag: "path",
            attr: {d: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"}
        }]
    })(t)
}

function Btr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z"}
        }]
    })(t)
}

function $tr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M323.56 51.2c-20.8 19.3-39.58 39.59-56.22 59.97C240.08 73.62 206.28 35.53 168 0 69.74 91.17 0 209.96 0 281.6 0 408.85 100.29 512 224 512s224-103.15 224-230.4c0-53.27-51.98-163.14-124.44-230.4zm-19.47 340.65C282.43 407.01 255.72 416 226.86 416 154.71 416 96 368.26 96 290.75c0-38.61 24.31-72.63 72.79-130.75 6.93 7.98 98.83 125.34 98.83 125.34l58.63-66.88c4.14 6.85 7.91 13.55 11.27 19.97 27.35 52.19 15.81 118.97-33.43 153.42z"}
        }]
    })(t)
}

function Ftr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 384 512"},
        child: [{
            tag: "path",
            attr: {d: "M216 23.86c0-23.8-30.65-32.77-44.15-13.04C48 191.85 224 200 224 288c0 35.63-29.11 64.46-64.85 63.99-35.17-.45-63.15-29.77-63.15-64.94v-85.51c0-21.7-26.47-32.23-41.43-16.5C27.8 213.16 0 261.33 0 320c0 105.87 86.13 192 192 192s192-86.13 192-192c0-170.29-168-193-168-296.14z"}
        }]
    })(t)
}

function Utr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 496 512"},
        child: [{
            tag: "path",
            attr: {d: "M336.5 160C322 70.7 287.8 8 248 8s-74 62.7-88.5 152h177zM152 256c0 22.2 1.2 43.5 3.3 64h185.3c2.1-20.5 3.3-41.8 3.3-64s-1.2-43.5-3.3-64H155.3c-2.1 20.5-3.3 41.8-3.3 64zm324.7-96c-28.6-67.9-86.5-120.4-158-141.6 24.4 33.8 41.2 84.7 50 141.6h108zM177.2 18.4C105.8 39.6 47.8 92.1 19.3 160h108c8.7-56.9 25.5-107.8 49.9-141.6zM487.4 192H372.7c2.1 21 3.3 42.5 3.3 64s-1.2 43-3.3 64h114.6c5.5-20.5 8.6-41.8 8.6-64s-3.1-43.5-8.5-64zM120 256c0-21.5 1.2-43 3.3-64H8.6C3.2 212.5 0 233.8 0 256s3.2 43.5 8.6 64h114.6c-2-21-3.2-42.5-3.2-64zm39.5 96c14.5 89.3 48.7 152 88.5 152s74-62.7 88.5-152h-177zm159.3 141.6c71.4-21.2 129.4-73.7 158-141.6h-108c-8.8 56.9-25.6 107.8-50 141.6zM19.3 352c28.6 67.9 86.5 120.4 158 141.6-24.4-33.8-41.2-84.7-50-141.6h-108z"}
        }]
    })(t)
}

function PKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M96 32H32C14.33 32 0 46.33 0 64v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zm0 160H32c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zm0 160H32c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zM288 32h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zm0 160h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32zm0 160h-64c-17.67 0-32 14.33-32 32v64c0 17.67 14.33 32 32 32h64c17.67 0 32-14.33 32-32v-64c0-17.67-14.33-32-32-32z"}
        }]
    })(t)
}

function jtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M504 255.531c.253 136.64-111.18 248.372-247.82 248.468-59.015.042-113.223-20.53-155.822-54.911-11.077-8.94-11.905-25.541-1.839-35.607l11.267-11.267c8.609-8.609 22.353-9.551 31.891-1.984C173.062 425.135 212.781 440 256 440c101.705 0 184-82.311 184-184 0-101.705-82.311-184-184-184-48.814 0-93.149 18.969-126.068 49.932l50.754 50.754c10.08 10.08 2.941 27.314-11.313 27.314H24c-8.837 0-16-7.163-16-16V38.627c0-14.254 17.234-21.393 27.314-11.314l49.372 49.372C129.209 34.136 189.552 8 256 8c136.81 0 247.747 110.78 248 247.531zm-180.912 78.784l9.823-12.63c8.138-10.463 6.253-25.542-4.21-33.679L288 256.349V152c0-13.255-10.745-24-24-24h-16c-13.255 0-24 10.745-24 24v135.651l65.409 50.874c10.463 8.137 25.541 6.253 33.679-4.21z"}
        }]
    })(t)
}

function ztr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 384 512"},
        child: [{
            tag: "path",
            attr: {d: "M360 0H24C10.745 0 0 10.745 0 24v16c0 13.255 10.745 24 24 24 0 90.965 51.016 167.734 120.842 192C75.016 280.266 24 357.035 24 448c-13.255 0-24 10.745-24 24v16c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24 0-90.965-51.016-167.734-120.842-192C308.984 231.734 360 154.965 360 64c13.255 0 24-10.745 24-24V24c0-13.255-10.745-24-24-24zm-75.078 384H99.08c17.059-46.797 52.096-80 92.92-80 40.821 0 75.862 33.196 92.922 80zm.019-256H99.078C91.988 108.548 88 86.748 88 64h208c0 22.805-3.987 44.587-11.059 64z"}
        }]
    })(t)
}

function Vtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 384 512"},
        child: [{
            tag: "path",
            attr: {d: "M360 64c13.255 0 24-10.745 24-24V24c0-13.255-10.745-24-24-24H24C10.745 0 0 10.745 0 24v16c0 13.255 10.745 24 24 24 0 90.965 51.016 167.734 120.842 192C75.016 280.266 24 357.035 24 448c-13.255 0-24 10.745-24 24v16c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24v-16c0-13.255-10.745-24-24-24 0-90.965-51.016-167.734-120.842-192C308.984 231.734 360 154.965 360 64z"}
        }]
    })(t)
}

function Htr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"}
        }]
    })(t)
}

function Wtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"}
        }]
    })(t)
}

function qtr(t) {
    return ct({
        tag: "svg", attr: {viewBox: "0 0 512 512"}, child: [{
            tag: "path",
            attr: {d: "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"}
        }]
    })(t)
}

function Gtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M80 368H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm0-320H16A16 16 0 0 0 0 64v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16V64a16 16 0 0 0-16-16zm0 160H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm416 176H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"}
        }]
    })(t)
}

function Ktr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M223.75 130.75L154.62 15.54A31.997 31.997 0 0 0 127.18 0H16.03C3.08 0-4.5 14.57 2.92 25.18l111.27 158.96c29.72-27.77 67.52-46.83 109.56-53.39zM495.97 0H384.82c-11.24 0-21.66 5.9-27.44 15.54l-69.13 115.21c42.04 6.56 79.84 25.62 109.56 53.38L509.08 25.18C516.5 14.57 508.92 0 495.97 0zM256 160c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm92.52 157.26l-37.93 36.96 8.97 52.22c1.6 9.36-8.26 16.51-16.65 12.09L256 393.88l-46.9 24.65c-8.4 4.45-18.25-2.74-16.65-12.09l8.97-52.22-37.93-36.96c-6.82-6.64-3.05-18.23 6.35-19.59l52.43-7.64 23.43-47.52c2.11-4.28 6.19-6.39 10.28-6.39 4.11 0 8.22 2.14 10.33 6.39l23.43 47.52 52.43 7.64c9.4 1.36 13.17 12.95 6.35 19.59z"}
        }]
    })(t)
}

function Ytr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"}
        }]
    })(t)
}

function NKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"}
        }]
    })(t)
}

function LKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"}
        }]
    })(t)
}

function Xtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z"}
        }]
    })(t)
}

function BKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"}
        }]
    })(t)
}

function $Kt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"}
        }]
    })(t)
}

function Qtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z"}
        }]
    })(t)
}

function Ztr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"}
        }]
    })(t)
}

function FKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M500.33 0h-47.41a12 12 0 0 0-12 12.57l4 82.76A247.42 247.42 0 0 0 256 8C119.34 8 7.9 119.53 8 256.19 8.1 393.07 119.1 504 256 504a247.1 247.1 0 0 0 166.18-63.91 12 12 0 0 0 .48-17.43l-34-34a12 12 0 0 0-16.38-.55A176 176 0 1 1 402.1 157.8l-101.53-4.87a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12h200.33a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12z"}
        }]
    })(t)
}

function Jtr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M505.12019,19.09375c-1.18945-5.53125-6.65819-11-12.207-12.1875C460.716,0,435.507,0,410.40747,0,307.17523,0,245.26909,55.20312,199.05238,128H94.83772c-16.34763.01562-35.55658,11.875-42.88664,26.48438L2.51562,253.29688A28.4,28.4,0,0,0,0,264a24.00867,24.00867,0,0,0,24.00582,24H127.81618l-22.47457,22.46875c-11.36521,11.36133-12.99607,32.25781,0,45.25L156.24582,406.625c11.15623,11.1875,32.15619,13.15625,45.27726,0l22.47457-22.46875V488a24.00867,24.00867,0,0,0,24.00581,24,28.55934,28.55934,0,0,0,10.707-2.51562l98.72834-49.39063c14.62888-7.29687,26.50776-26.5,26.50776-42.85937V312.79688c72.59753-46.3125,128.03493-108.40626,128.03493-211.09376C512.07526,76.5,512.07526,51.29688,505.12019,19.09375ZM384.04033,168A40,40,0,1,1,424.05,128,40.02322,40.02322,0,0,1,384.04033,168Z"}
        }]
    })(t)
}

function vke(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"}
        }]
    })(t)
}

function gke(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M64 96H0c0 123.7 100.3 224 224 224v144c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V320C288 196.3 187.7 96 64 96zm384-64c-84.2 0-157.4 46.5-195.7 115.2 27.7 30.2 48.2 66.9 59 107.6C424 243.1 512 147.9 512 32h-64z"}
        }]
    })(t)
}

function err(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"}
        }]
    })(t)
}

function trr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M496 384H160v-16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v16H16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h80v16c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-16h336c8.8 0 16-7.2 16-16v-32c0-8.8-7.2-16-16-16zm0-160h-80v-16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v16H16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h336v16c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-16h80c8.8 0 16-7.2 16-16v-32c0-8.8-7.2-16-16-16zm0-160H288V48c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v16H16C7.2 64 0 71.2 0 80v32c0 8.8 7.2 16 16 16h208v16c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-16h208c8.8 0 16-7.2 16-16V80c0-8.8-7.2-16-16-16z"}
        }]
    })(t)
}

function rrr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 320 512"},
        child: [{
            tag: "path",
            attr: {d: "M41 288h238c21.4 0 32.1 25.9 17 41L177 448c-9.4 9.4-24.6 9.4-33.9 0L24 329c-15.1-15.1-4.4-41 17-41zm255-105L177 64c-9.4-9.4-24.6-9.4-33.9 0L24 183c-15.1 15.1-4.4 41 17 41h238c21.4 0 32.1-25.9 17-41z"}
        }]
    })(t)
}

function yke(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 576 512"},
        child: [{
            tag: "path",
            attr: {d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z"}
        }]
    })(t)
}

function nrr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M312 320h136V56c0-13.3-10.7-24-24-24H24C10.7 32 0 42.7 0 56v400c0 13.3 10.7 24 24 24h264V344c0-13.2 10.8-24 24-24zm129 55l-98 98c-4.5 4.5-10.6 7-17 7h-6V352h128v6.1c0 6.3-2.5 12.4-7 16.9z"}
        }]
    })(t)
}

function irr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M432 304c0 114.9-93.1 208-208 208S16 418.9 16 304c0-104 76.3-190.2 176-205.5V64h-28c-6.6 0-12-5.4-12-12V12c0-6.6 5.4-12 12-12h120c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-28v34.5c37.5 5.8 71.7 21.6 99.7 44.6l27.5-27.5c4.7-4.7 12.3-4.7 17 0l28.3 28.3c4.7 4.7 4.7 12.3 0 17l-29.4 29.4-.6.6C419.7 223.3 432 262.2 432 304zm-176 36V188.5c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12V340c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12z"}
        }]
    })(t)
}

function arr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M16 128h416c8.84 0 16-7.16 16-16V48c0-8.84-7.16-16-16-16H16C7.16 32 0 39.16 0 48v64c0 8.84 7.16 16 16 16zm480 80H80c-8.84 0-16 7.16-16 16v64c0 8.84 7.16 16 16 16h416c8.84 0 16-7.16 16-16v-64c0-8.84-7.16-16-16-16zm-64 176H16c-8.84 0-16 7.16-16 16v64c0 8.84 7.16 16 16 16h416c8.84 0 16-7.16 16-16v-64c0-8.84-7.16-16-16-16z"}
        }]
    })(t)
}

function UKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"}
        }]
    })(t)
}

function orr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M440.65 12.57l4 82.77A247.16 247.16 0 0 0 255.83 8C134.73 8 33.91 94.92 12.29 209.82A12 12 0 0 0 24.09 224h49.05a12 12 0 0 0 11.67-9.26 175.91 175.91 0 0 1 317-56.94l-101.46-4.86a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12H500a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12h-47.37a12 12 0 0 0-11.98 12.57zM255.83 432a175.61 175.61 0 0 1-146-77.8l101.8 4.87a12 12 0 0 0 12.57-12v-47.4a12 12 0 0 0-12-12H12a12 12 0 0 0-12 12V500a12 12 0 0 0 12 12h47.35a12 12 0 0 0 12-12.6l-4.15-82.57A247.17 247.17 0 0 0 255.83 504c121.11 0 221.93-86.92 243.55-201.82a12 12 0 0 0-11.8-14.18h-49.05a12 12 0 0 0-11.67 9.26A175.86 175.86 0 0 1 255.83 432z"}
        }]
    })(t)
}

function srr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"}
        }]
    })(t)
}

function bke(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 352 512"},
        child: [{
            tag: "path",
            attr: {d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"}
        }]
    })(t)
}

function jKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z"}
        }]
    })(t)
}

function crr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 576 512"},
        child: [{
            tag: "path",
            attr: {d: "M552 64H448V24c0-13.3-10.7-24-24-24H152c-13.3 0-24 10.7-24 24v40H24C10.7 64 0 74.7 0 88v56c0 35.7 22.5 72.4 61.9 100.7 31.5 22.7 69.8 37.1 110 41.7C203.3 338.5 240 360 240 360v72h-48c-35.3 0-64 20.7-64 56v12c0 6.6 5.4 12 12 12h296c6.6 0 12-5.4 12-12v-12c0-35.3-28.7-56-64-56h-48v-72s36.7-21.5 68.1-73.6c40.3-4.6 78.6-19 110-41.7 39.3-28.3 61.9-65 61.9-100.7V88c0-13.3-10.7-24-24-24zM99.3 192.8C74.9 175.2 64 155.6 64 144v-16h64.2c1 32.6 5.8 61.2 12.8 86.2-15.1-5.2-29.2-12.4-41.7-21.4zM512 144c0 16.1-17.7 36.1-35.3 48.8-12.5 9-26.7 16.2-41.8 21.4 7-25 11.8-53.6 12.8-86.2H512v16z"}
        }]
    })(t)
}

function lrr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 496 512"},
        child: [{
            tag: "path",
            attr: {d: "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"}
        }]
    })(t)
}

function urr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"}
        }]
    })(t)
}

function frr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 640 512"},
        child: [{
            tag: "path",
            attr: {d: "M96 224c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm448 0c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm32 32h-64c-17.6 0-33.5 7.1-45.1 18.6 40.3 22.1 68.9 62 75.1 109.4h66c17.7 0 32-14.3 32-32v-32c0-35.3-28.7-64-64-64zm-256 0c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C179.6 288 128 339.6 128 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zm-223.7-13.4C161.5 263.1 145.6 256 128 256H64c-35.3 0-64 28.7-64 64v32c0 17.7 14.3 32 32 32h65.9c6.3-47.4 34.9-87.3 75.2-109.4z"}
        }]
    })(t)
}

function zKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 512 512"},
        child: [{
            tag: "path",
            attr: {d: "M461.2 128H80c-8.84 0-16-7.16-16-16s7.16-16 16-16h384c8.84 0 16-7.16 16-16 0-26.51-21.49-48-48-48H64C28.65 32 0 60.65 0 96v320c0 35.35 28.65 64 64 64h397.2c28.02 0 50.8-21.53 50.8-48V176c0-26.47-22.78-48-50.8-48zM416 336c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"}
        }]
    })(t)
}

function drr(t) {
    return ct({
        tag: "svg", attr: {viewBox: "0 0 576 512"}, child: [{
            tag: "path",
            attr: {d: "M562.1 383.9c-21.5-2.4-42.1-10.5-57.9-22.9-14.1-11.1-34.2-11.3-48.2 0-37.9 30.4-107.2 30.4-145.7-1.5-13.5-11.2-33-9.1-46.7 1.8-38 30.1-106.9 30-145.2-1.7-13.5-11.2-33.3-8.9-47.1 2-15.5 12.2-36 20.1-57.7 22.4-7.9.8-13.6 7.8-13.6 15.7v32.2c0 9.1 7.6 16.8 16.7 16 28.8-2.5 56.1-11.4 79.4-25.9 56.5 34.6 137 34.1 192 0 56.5 34.6 137 34.1 192 0 23.3 14.2 50.9 23.3 79.1 25.8 9.1.8 16.7-6.9 16.7-16v-31.6c.1-8-5.7-15.4-13.8-16.3zm0-144c-21.5-2.4-42.1-10.5-57.9-22.9-14.1-11.1-34.2-11.3-48.2 0-37.9 30.4-107.2 30.4-145.7-1.5-13.5-11.2-33-9.1-46.7 1.8-38 30.1-106.9 30-145.2-1.7-13.5-11.2-33.3-8.9-47.1 2-15.5 12.2-36 20.1-57.7 22.4-7.9.8-13.6 7.8-13.6 15.7v32.2c0 9.1 7.6 16.8 16.7 16 28.8-2.5 56.1-11.4 79.4-25.9 56.5 34.6 137 34.1 192 0 56.5 34.6 137 34.1 192 0 23.3 14.2 50.9 23.3 79.1 25.8 9.1.8 16.7-6.9 16.7-16v-31.6c.1-8-5.7-15.4-13.8-16.3zm0-144C540.6 93.4 520 85.4 504.2 73 490.1 61.9 470 61.7 456 73c-37.9 30.4-107.2 30.4-145.7-1.5-13.5-11.2-33-9.1-46.7 1.8-38 30.1-106.9 30-145.2-1.7-13.5-11.2-33.3-8.9-47.1 2-15.5 12.2-36 20.1-57.7 22.4-7.9.8-13.6 7.8-13.6 15.7v32.2c0 9.1 7.6 16.8 16.7 16 28.8-2.5 56.1-11.4 79.4-25.9 56.5 34.6 137 34.1 192 0 56.5 34.6 137 34.1 192 0 23.3 14.2 50.9 23.3 79.1 25.8 9.1.8 16.7-6.9 16.7-16v-31.6c.1-8-5.7-15.4-13.8-16.3z"}
        }]
    })(t)
}

function hrr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M439.39 362.29c-19.32-20.76-55.47-51.99-55.47-154.29 0-77.7-54.48-139.9-127.94-155.16V32c0-17.67-14.32-32-31.98-32s-31.98 14.33-31.98 32v20.84C118.56 68.1 64.08 130.3 64.08 208c0 102.3-36.15 133.53-55.47 154.29-6 6.45-8.66 14.16-8.61 21.71.11 16.4 12.98 32 32.1 32h383.8c19.12 0 32-15.6 32.1-32 .05-7.55-2.61-15.27-8.61-21.71zM67.53 368c21.22-27.97 44.42-74.33 44.53-159.42 0-.2-.06-.38-.06-.58 0-61.86 50.14-112 112-112s112 50.14 112 112c0 .2-.06.38-.06.58.11 85.1 23.31 131.46 44.53 159.42H67.53zM224 512c35.32 0 63.97-28.65 63.97-64H160.03c0 35.35 28.65 64 63.97 64z"}
        }]
    })(t)
}

function prr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 448 512"},
        child: [{
            tag: "path",
            attr: {d: "M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"}
        }]
    })(t)
}

function mrr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 576 512"},
        child: [{
            tag: "path",
            attr: {d: "M288 144a110.94 110.94 0 0 0-31.24 5 55.4 55.4 0 0 1 7.24 27 56 56 0 0 1-56 56 55.4 55.4 0 0 1-27-7.24A111.71 111.71 0 1 0 288 144zm284.52 97.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400c-98.65 0-189.09-55-237.93-144C98.91 167 189.34 112 288 112s189.09 55 237.93 144C477.1 345 386.66 400 288 400z"}
        }]
    })(t)
}

const wke = "https://discord.gg/ARbh55A472", VKt = "https://telegram.me/dexscreenerchat",
    vrr = "https://telegram.me/moonshotcabal", grr = "https://x.com/moonshotdotcc",
    ZI = t => ie.jsx(Bf, {...t, as: bI}), yrr = W.forwardRef((t, e) => ie.jsx(Hc, {...t, ref: e, as: bI})),
    HKt = t => ({
        boxShadow: Ms("md", "none", t),
        bg: Ms("white", "blue.900", t),
        borderColor: Ms("gray.100", "transparent", t),
        textDecoration: "none"
    }), WKt = (t, e) => ({
        bg: Ms("white", "blue.950", t),
        boxShadow: "sm",
        boxSizing: "border-box", ...e ? {
            cursor: "pointer",
            borderWidth: 1,
            borderColor: "transparent",
            _hover: HKt(t)
        } : void 0
    }), ore = ({children: t, isHoverable: e, _hover: r, ...n}) => {
        const {colorMode: i} = S1(), a = WKt(i, e);
        return ie.jsx(Gn, {
            ...a,
            transition: "background-color 0.3s", ...e && (r || a._hover) ? {sx: {"@media (hover: hover)": {_hover: rZe({}, a._hover, r)}}} : void 0, ...n,
            children: t
        })
    }, qKt = t => ie.jsx(ZI, {_hover: {textDecoration: "none"}, ...t}),
    brr = ({children: t, ...e}) => ie.jsx(ore, {as: qKt, ...e, children: t}), dx = {
        sm: {width: "100%", height: "auto", padding: 3, emojiFontSize: "25px", headingSize: "md", headingMargin: 2},
        full: {width: "80vw", height: "100vh", padding: 10, emojiFontSize: "50px", headingSize: "lg", headingMargin: 4}
    }, GKt = ({
                  children: t,
                  topOffset: e,
                  containerProps: r,
                  size: n = "full",
                  emoji: i,
                  title: a
              }) => ie.jsx(KJ, {
        w: "100%",
        h: `calc(${dx[n].height} - ${e ?? 0}px)`,
        overflowY: "auto", ...r,
        children: ie.jsxs(ore, {
            pos: "relative",
            w: dx[n].width,
            maxW: "500px",
            flexDir: "column",
            p: dx[n].padding,
            textAlign: "center",
            children: [ie.jsx(ln, {fontSize: dx[n].emojiFontSize, mb: 3, children: i ?? "😕"}), a && ie.jsx(i1, {
                as: "h3",
                size: dx[n].headingSize,
                mb: dx[n].headingMargin,
                children: a
            }), t]
        })
    }), KKt = W.memo(({error: t, hideRefresh: e, size: r}) => ie.jsxs(GKt, {
        emoji: "💣",
        title: "An unexpected error occured",
        size: r,
        children: [ie.jsx(ln, {children: "This error has been logged and we'll look into it ASAP."}), ie.jsx(ln, {
            mt: 3,
            children: ie.jsx(ln, {
                as: "span",
                fontWeight: "semibold",
                children: "A common cause for this error is a browser extension trying to modify the contents of this page."
            })
        }), ie.jsxs(ln, {
            mt: 2,
            children: [ie.jsx(ln, {
                as: "span",
                fontWeight: "semibold",
                color: "red.500",
                children: "Auto Refresh Plus"
            }), " ", "and", " ", ie.jsx(ln, {
                as: "span",
                fontWeight: "semibold",
                color: "red.500",
                children: "Poper Blocker"
            }), " ", "are examples of extensions known to cause issues. If you're using either one of those extensions try disabling them to see if the problem goes away, or try opening this window in a different browser profile or in incognito mode."]
        }), ie.jsxs(ln, {
            mt: 2,
            children: ["If you still have issues, join us on", " ", ie.jsx(Bf, {
                href: wke,
                target: "_blank",
                color: hS("accent.500", "accent.300"),
                fontWeight: "semibold",
                children: "Discord"
            }), " ", "and let us help out!"]
        }), !e && ie.jsx(Hc, {
            onClick: () => window.location.reload(),
            size: {base: "sm", md: "lg"},
            leftIcon: ie.jsx(Wi, {as: FKt}),
            colorScheme: "accent",
            mt: 5,
            whiteSpace: "normal",
            h: "auto",
            py: {base: 3, md: 4},
            children: "Refresh this page to try again"
        }), (t == null ? void 0 : t.message) && ie.jsxs(Gn, {
            mt: 6,
            opacity: .5,
            children: [ie.jsx(ln, {as: "span", children: "Error message:"}), ie.jsx(ln, {
                fontSize: "sm",
                fontFamily: "mono",
                mt: 1,
                wordBreak: "break-all",
                children: t.message
            })]
        })]
    }));
var NC = function () {
    return NC = Object.assign || function (t) {
        for (var e, r = 1, n = arguments.length; r < n; r++) {
            e = arguments[r];
            for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
        }
        return t
    }, NC.apply(this, arguments)
}, YKt = function (t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
}, cve = !1, XKt = W.forwardRef(function (t, e) {
    var r = t.style, n = YKt(t, ["style"]), i = Ske();
    !cve && (r != null && r.height) && (cve = !0, console.warn("<Div100vh /> overrides the height property of the style prop"));
    var a = NC(NC({}, r), {height: i ? i + "px" : "100vh"});
    return ar.createElement("div", NC({ref: e, style: a}, n))
});
XKt.displayName = "Div100vh";

function Ske() {
    var t = W.useState(lve), e = t[0], r = t[1], n = QKt();
    return W.useEffect(function () {
        if (!n) return;

        function i() {
            var a = lve();
            r(a)
        }

        return window.addEventListener("resize", i), function () {
            return window.removeEventListener("resize", i)
        }
    }, [n]), n ? e : null
}

function lve() {
    return _ke() ? window.innerHeight : null
}

function QKt() {
    var t = W.useState(!1), e = t[0], r = t[1];
    return W.useEffect(function () {
        _ke() && r(!0)
    }, []), e
}

function _ke() {
    return typeof window < "u" && typeof document < "u"
}

const uve = {watchlistsSize: "default", watchlistsActiveId: "main"}, SB = pt(tOt, t => {
    const e = new I4(1);
    return t.all.subscribe(r => {
        e.next(fve(r))
    }), {
        all: e.pipe(op(), Xa),
        setWatchlistSize: async r => {
            if (r === "expanded") {
                const n = await _l(t.all);
                e.next({...fve(n), watchlistsSize: "expanded"});
                return
            }
            await t.actions.persistUISettingsValue({desktop: {watchlistsSize: r}})
        },
        setActiveWatchlist: async r => t.actions.persistUISettingsValue({desktop: {watchlistsActiveId: r}}),
        setTradingMode: async r => {
            await t.actions.setTradingMode(r)
        }
    }
});

function fve(t) {
    var e, r;
    return {
        watchlistsSize: ((e = t == null ? void 0 : t.value.desktop) == null ? void 0 : e.watchlistsSize) ?? uve.watchlistsSize,
        watchlistsActiveId: ((r = t == null ? void 0 : t.value.desktop) == null ? void 0 : r.watchlistsActiveId) ?? uve.watchlistsActiveId,
        tradingModes: t == null ? void 0 : t.value.tradingModes
    }
}

function xke(t, e) {
    const r = n2(), [n, i] = W.useState(e);
    return W.useEffect(() => {
        i(a => r.current === void 0 ? t : a)
    }, [r, t]), r.current === void 0 ? t : n
}

function DP() {
    return xke(!0, !1)
}

function Eke(t) {
    var e, r, n = "";
    if (typeof t == "string" || typeof t == "number") n += t; else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (r = Eke(t[e])) && (n && (n += " "), n += r); else for (e in t) t[e] && (n && (n += " "), n += e);
    return n
}

function fv() {
    for (var t, e, r = 0, n = ""; r < arguments.length;) (t = arguments[r++]) && (e = Eke(t)) && (n && (n += " "), n += e);
    return n
}

function wrr(t) {
    return ct({
        tag: "svg",
        attr: {fill: "currentColor", viewBox: "0 0 16 16"},
        child: [{
            tag: "path",
            attr: {d: "M8 15c4.418 0 8-3.134 8-7s-3.582-7-8-7-8 3.134-8 7c0 1.76.743 3.37 1.97 4.6-.097 1.016-.417 2.13-.771 2.966-.079.186.074.394.273.362 2.256-.37 3.597-.938 4.18-1.234A9.06 9.06 0 0 0 8 15z"}
        }]
    })(t)
}

function Tke(t) {
    return ct({
        tag: "svg",
        attr: {fill: "currentColor", viewBox: "0 0 16 16"},
        child: [{
            tag: "path",
            attr: {d: "M1 2.5A1.5 1.5 0 0 1 2.5 1h3A1.5 1.5 0 0 1 7 2.5v3A1.5 1.5 0 0 1 5.5 7h-3A1.5 1.5 0 0 1 1 5.5v-3zm8 0A1.5 1.5 0 0 1 10.5 1h3A1.5 1.5 0 0 1 15 2.5v3A1.5 1.5 0 0 1 13.5 7h-3A1.5 1.5 0 0 1 9 5.5v-3zm-8 8A1.5 1.5 0 0 1 2.5 9h3A1.5 1.5 0 0 1 7 10.5v3A1.5 1.5 0 0 1 5.5 15h-3A1.5 1.5 0 0 1 1 13.5v-3zm8 0A1.5 1.5 0 0 1 10.5 9h3a1.5 1.5 0 0 1 1.5 1.5v3a1.5 1.5 0 0 1-1.5 1.5h-3A1.5 1.5 0 0 1 9 13.5v-3z"}
        }]
    })(t)
}

function ZKt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 24 24"},
        child: [{
            tag: "path",
            attr: {d: "M7.55197 13 8.39897 10.8852 9.24398 13H7.55197ZM16 12H17V14H16C15.4477 14 15 13.5523 15 13 15 12.4477 15.4477 12 16 12ZM21 3H3C2.44772 3 2 3.44772 2 4V20C2 20.5523 2.44772 21 3 21H21C21.5523 21 22 20.5523 22 20V4C22 3.44772 21.5523 3 21 3ZM12.598 16H10.443L10.043 15H6.75297L6.35297 16H4.19897L5.39797 13.002 5.39897 13 7.39897 8H9.39897L12.598 16ZM17 8H19V16H16C14.3431 16 13 14.6569 13 13 13 11.3431 14.3431 10 16 10H17V8Z"}
        }]
    })(t)
}

function Srr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 24 24"},
        child: [{
            tag: "path",
            attr: {d: "M2.80864 1.39355L20.4863 19.0712L19.0721 20.4854L15.3894 16.8036L12.001 21.0002L0.69043 6.99686C1.60456 6.25759 2.59253 5.60601 3.64156 5.05491L1.39443 2.80777L2.80864 1.39355ZM3.58046 7.39195L12.0009 17.8171L13.9674 15.3806L5.13212 6.54451C4.60029 6.79768 4.08236 7.08052 3.58046 7.39195ZM12.001 3.00016C16.2854 3.00016 20.2201 4.49699 23.3108 6.99623L17.9044 13.6892L16.4824 12.2672L20.4208 7.39148C17.9231 5.84183 15.0283 5.00016 12.001 5.00016C11.1282 5.00016 10.2664 5.07013 9.42189 5.20686L7.72553 3.511C9.09596 3.17714 10.5278 3.00016 12.001 3.00016Z"}
        }]
    })(t)
}

function _rr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 24 24"},
        child: [{
            tag: "path",
            attr: {d: "M12.0049 22.0029C6.48204 22.0029 2.00488 17.5258 2.00488 12.0029C2.00488 6.48008 6.48204 2.00293 12.0049 2.00293C17.5277 2.00293 22.0049 6.48008 22.0049 12.0029C22.0049 17.5258 17.5277 22.0029 12.0049 22.0029ZM12.0049 20.0029C16.4232 20.0029 20.0049 16.4212 20.0049 12.0029C20.0049 7.58465 16.4232 4.00293 12.0049 4.00293C7.5866 4.00293 4.00488 7.58465 4.00488 12.0029C4.00488 16.4212 7.5866 20.0029 12.0049 20.0029ZM12.0049 7.05318L16.9546 12.0029L12.0049 16.9527L7.05514 12.0029L12.0049 7.05318ZM12.0049 9.88161L9.88356 12.0029L12.0049 14.1243L14.1262 12.0029L12.0049 9.88161Z"}
        }]
    })(t)
}

function xrr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 24 24"},
        child: [{
            tag: "path",
            attr: {d: "M12.0049 22.0029C6.48204 22.0029 2.00488 17.5258 2.00488 12.0029C2.00488 6.48008 6.48204 2.00293 12.0049 2.00293C17.5277 2.00293 22.0049 6.48008 22.0049 12.0029C22.0049 17.5258 17.5277 22.0029 12.0049 22.0029ZM12.0049 20.0029C16.4232 20.0029 20.0049 16.4212 20.0049 12.0029C20.0049 7.58465 16.4232 4.00293 12.0049 4.00293C7.5866 4.00293 4.00488 7.58465 4.00488 12.0029C4.00488 16.4212 7.5866 20.0029 12.0049 20.0029ZM8.50488 14.0029H14.0049C14.281 14.0029 14.5049 13.7791 14.5049 13.5029C14.5049 13.2268 14.281 13.0029 14.0049 13.0029H10.0049C8.62417 13.0029 7.50488 11.8836 7.50488 10.5029C7.50488 9.12222 8.62417 8.00293 10.0049 8.00293H11.0049V6.00293H13.0049V8.00293H15.5049V10.0029H10.0049C9.72874 10.0029 9.50488 10.2268 9.50488 10.5029C9.50488 10.7791 9.72874 11.0029 10.0049 11.0029H14.0049C15.3856 11.0029 16.5049 12.1222 16.5049 13.5029C16.5049 14.8836 15.3856 16.0029 14.0049 16.0029H13.0049V18.0029H11.0049V16.0029H8.50488V14.0029Z"}
        }]
    })(t)
}

function Err(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 24 24"},
        child: [{
            tag: "path",
            attr: {d: "M4.87759 3.00293H19.1319C19.4518 3.00293 19.7524 3.15601 19.9406 3.41476L23.7634 8.67115C23.9037 8.86403 23.8882 9.12913 23.7265 9.30438L12.3721 21.6049C12.1848 21.8078 11.8685 21.8205 11.6656 21.6332C11.6558 21.6241 11.6464 21.6147 11.6373 21.6049L0.282992 9.30438C0.121226 9.12913 0.10575 8.86403 0.246026 8.67115L4.06886 3.41476C4.25704 3.15601 4.55766 3.00293 4.87759 3.00293Z"}
        }]
    })(t)
}

let rD;
const JKt = new Uint8Array(16);

function eYt() {
    if (!rD && (rD = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !rD)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return rD(JKt)
}

const Dc = [];
for (let t = 0; t < 256; ++t) Dc.push((t + 256).toString(16).slice(1));

function tYt(t, e = 0) {
    return (Dc[t[e + 0]] + Dc[t[e + 1]] + Dc[t[e + 2]] + Dc[t[e + 3]] + "-" + Dc[t[e + 4]] + Dc[t[e + 5]] + "-" + Dc[t[e + 6]] + Dc[t[e + 7]] + "-" + Dc[t[e + 8]] + Dc[t[e + 9]] + "-" + Dc[t[e + 10]] + Dc[t[e + 11]] + Dc[t[e + 12]] + Dc[t[e + 13]] + Dc[t[e + 14]] + Dc[t[e + 15]]).toLowerCase()
}

const rYt = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), dve = {randomUUID: rYt};

function py(t, e, r) {
    if (dve.randomUUID && !e && !t) return dve.randomUUID();
    t = t || {};
    const n = t.random || (t.rng || eYt)();
    if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
        r = r || 0;
        for (let i = 0; i < 16; ++i) e[r + i] = n[i];
        return e
    }
    return tYt(n)
}

const lW = ({className: t, children: e, isActive: r, isDisabled: n, ...i}) => {
        const {settings: a} = lg();
        return ie.jsx(bI, {
            className: fv("ds-nav-link", {
                "ds-nav-link-active": r,
                "ds-nav-link-collapsed": a.ui.collapseNav,
                "ds-nav-link-disabled": n
            }, t), ...i, children: e
        })
    }, nYt = ({className: t, children: e, ...r}) => {
        const {settings: n} = lg();
        return ie.jsx("a", {
            className: fv("ds-nav-link", {"ds-nav-link-collapsed": n.ui.collapseNav}, t),
            target: "_blank",
            rel: "noopener noreferrer", ...r,
            children: e
        })
    }, Cke = W.forwardRef((t, e) => {
        const {settings: r} = lg(), {className: n, children: i, isActive: a, isDisabled: o, ...s} = t;
        return ie.jsx("button", {
            ref: e,
            className: fv("ds-nav-link", {
                "ds-nav-link-active": a,
                "ds-nav-link-collapsed": r.ui.collapseNav,
                "ds-nav-link-disabled": o
            }, n), ...s,
            children: i
        })
    }),
    iYt = Us(() => na(() => import("../chunks/price-alerts-overview-modal-9gklq1eR.js"), __vite__mapDeps([5, 6, 7, 8, 9, 1]))),
    aYt = t => {
        const r = z_e(aa(vL).activeCount, 0), i = xke(aa(are).isSupported(), !1), a = i ? t.title : void 0, o = GJ(),
            s = W.useCallback(l => {
                l.preventDefault(), o.onOpen()
            }, [o]);
        return ie.jsxs(ie.Fragment, {
            children: [ie.jsx(aee, {
                isDisabled: i,
                label: "Your device does not support notifications",
                children: ie.jsxs(Cke, {
                    isDisabled: !i,
                    onClick: s,
                    title: a,
                    children: [ie.jsx(AKt, {className: "ds-nav-main-nav-link-icon"}), ie.jsxs(ln, {
                        as: "span",
                        display: {lg: t.isCollapsed ? "none" : "flex"},
                        alignItems: "center",
                        marginLeft: {lg: "2.5"},
                        children: [ie.jsx(ln, {mr: "0.5", children: "Alerts"}), i && r > 0 && ie.jsx(ln, {
                            as: "span",
                            display: {base: "none", lg: "block"},
                            borderRadius: "lg",
                            bg: "blue.875",
                            color: "blue.300",
                            ml: 2,
                            fontSize: "xs",
                            fontWeight: "normal",
                            pl: "4px",
                            pr: "5px",
                            py: "2px",
                            minW: "20px",
                            children: r
                        })]
                    })]
                })
            }), o.isOpen && ie.jsx(W.Suspense, {fallback: null, children: ie.jsx(iYt, {onClose: o.onClose})})]
        })
    };

function oYt(t) {
    return ct({
        tag: "svg", attr: {version: "1.1", viewBox: "0 0 32 32"}, child: [{
            tag: "path",
            attr: {d: "M6.802 20.283c0 1.23-0.857 2.237-1.904 2.237s-1.905-1.006-1.905-2.237v-7.321c0-1.23 0.857-2.237 1.905-2.237s1.904 1.007 1.904 2.237v7.321zM29.007 20.283c0 1.23-0.857 2.237-1.905 2.237s-1.905-1.006-1.905-2.237v-7.321c0-1.23 0.857-2.237 1.905-2.237s1.905 1.007 1.905 2.237v7.321zM20.164 3.649l1.222-2.193c0.1-0.179 0.070-0.388-0.065-0.463s-0.329 0.009-0.428 0.188l-1.25 2.244c-1.115-0.439-2.364-0.684-3.684-0.684-1.33 0-2.588 0.25-3.71 0.695l-1.256-2.254c-0.1-0.179-0.293-0.264-0.428-0.188s-0.165 0.284-0.065 0.463l1.228 2.204c-2.555 1.2-4.276 3.453-4.276 6.035 0 0.262 0.019 0.521 0.053 0.776h16.909c0.035-0.255 0.053-0.513 0.053-0.776 0-2.59-1.732-4.849-4.301-6.046zM12.097 7.477c-0.411 0-0.744-0.333-0.744-0.744s0.333-0.744 0.744-0.744 0.744 0.333 0.744 0.744c0 0.411-0.333 0.744-0.744 0.744zM19.861 7.477c-0.411 0-0.744-0.333-0.744-0.744s0.333-0.744 0.744-0.744 0.744 0.333 0.744 0.744c0 0.411-0.333 0.744-0.744 0.744zM7.45 11.211v12.471h0.007c0.087 1.053 1.056 1.89 2.23 1.89h12.541c1.173 0 2.142-0.837 2.23-1.89h0.007v-12.471h-17.014zM14.74 25.51v3.858c0 1.23-0.857 2.237-1.905 2.237s-1.904-1.007-1.904-2.237v-3.855zM21.088 25.508v3.86c0 1.23-0.857 2.237-1.905 2.237s-1.905-1.007-1.905-2.237v-3.86z"}
        }]
    })(t)
}

const Ake = ({buttonProps: t}) => {
    const e = aa(XE), r = GJ();
    return W.useEffect(() => {
        r.isOpen && e.track({event: "appDownload", data: {context: "modal"}})
    }, [e, r.isOpen]), ie.jsxs(ie.Fragment, {
        children: [ie.jsxs(Hc, {
            onClick: r.onOpen,
            variant: "unstyled",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontSize: "sm",
            fontWeight: "semibold",
            borderRadius: "lg",
            h: "35px",
            bg: "blue.900",
            bgGradient: "linear(to-r, blue.900, blue.800)",
            color: "white",
            sx: {"@media (hover: hover)": {_hover: {bgGradient: "linear(to-r, blue.850, blue.750)"}}},
            _focus: {boxShadow: "none"}, ...t,
            children: [ie.jsx(ln, {as: "span", children: "Get the App!"}), ie.jsx(Wi, {
                ml: "6px",
                boxSize: "19px",
                as: gKt
            }), ie.jsx(Wi, {ml: "3px", boxSize: "18px", as: oYt})]
        }), ie.jsxs(dI, {
            size: BA({base: "sm", md: "lg"}),
            isOpen: r.isOpen,
            onClose: r.onClose,
            motionPreset: "none",
            blockScrollOnMount: !1,
            isCentered: BA({base: !1, md: !0}),
            children: [ie.jsx(pI, {}), ie.jsxs(hI, {
                children: [ie.jsx(vI, {}), ie.jsxs(mI, {
                    py: 5,
                    px: 0,
                    textAlign: "center",
                    children: [ie.jsx(i1, {children: "Get the DEX Screener app"}), ie.jsxs(Gn, {
                        mt: 2,
                        px: 5,
                        children: [ie.jsx(ln, {
                            fontSize: "xl",
                            children: "The best screener experience, now on mobile!"
                        }), ie.jsxs(Dy, {
                            mt: 5,
                            spacing: 4,
                            children: [ie.jsx(Bf, {
                                onClick: () => e.track({
                                    event: "appDownload",
                                    data: {context: "ios"}
                                }),
                                href: "https://apps.apple.com/app/dex-screener/id1631840457",
                                target: "_blank",
                                borderRadius: "lg",
                                bg: "black",
                                _hover: {bg: "blue.1000"},
                                children: ie.jsx(bC, {
                                    src: "/img/badge-ios.svg",
                                    w: "200px",
                                    h: "60px",
                                    loading: "lazy"
                                })
                            }), ie.jsx(Bf, {
                                onClick: () => e.track({event: "appDownload", data: {context: "android"}}),
                                href: "https://play.google.com/store/apps/details?id=com.dexscreener",
                                target: "_blank",
                                borderRadius: "lg",
                                bg: "black",
                                _hover: {bg: "blue.1000"},
                                children: ie.jsx(bC, {
                                    src: "/img/badge-android.svg",
                                    w: "200px",
                                    h: "60px",
                                    loading: "lazy"
                                })
                            }), ie.jsx(Bf, {
                                href: "https://www.producthunt.com/posts/dex-screener-mobile?utm_source=badge-featured&utm_medium=badge&utm_souce=badge-dex-screener-mobile",
                                target: "_blank",
                                children: ie.jsx(bC, {
                                    src: "https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=374720&theme=neutral",
                                    width: "200px",
                                    height: "60px",
                                    loading: "lazy"
                                })
                            })]
                        }), ie.jsxs(ln, {
                            mt: 5,
                            children: ["Questions? Feedback? Bugs? Please join us on", " ", ie.jsx(Bf, {
                                href: "https://discord.gg/4fJMABJ2xB",
                                target: "_blank",
                                fontWeight: "semibold",
                                textDecor: "underline",
                                children: "Discord"
                            }), "!"]
                        })]
                    })]
                })]
            })]
        })]
    })
}, sYt = () => {
    const {pathname: t} = Oo(), {settings: e} = lg(), {isOpen: r, onToggle: n} = GJ(),
        i = !r, {discoverableChains: a} = am();
    return {
        activePathname: t,
        isMenuCollapsed: i,
        toggleMenuCollapse: n,
        isNavigationCollapsed: e.ui.collapseNav,
        chains: a
    }
}, cYt = [{
    id: py(),
    type: "app-link",
    icon: ie.jsx(yke, {className: "ds-nav-main-nav-link-icon"}),
    path: "/watchlist",
    label: "Watchlist"
}, {id: py(), type: "button-alert", className: "ds-nav-main-list-item-alerts"}, {
    id: py(),
    type: "app-link",
    icon: ie.jsx(Tke, {className: "ds-nav-main-nav-link-icon"}),
    path: "/multicharts",
    label: "Multicharts"
}, {
    id: py(),
    type: "app-link",
    icon: ie.jsx(gke, {className: "ds-nav-main-nav-link-icon"}),
    path: "/new-pairs",
    label: "New Pairs"
}, {
    id: py(),
    type: "app-link",
    icon: ie.jsx(p5e, {className: "ds-nav-main-nav-link-icon"}),
    path: "/gainers",
    label: "Gainers & Losers"
}, {
    id: py(),
    type: "app-link",
    icon: ie.jsx(zKt, {className: "ds-nav-main-nav-link-icon"}),
    path: "/portfolio",
    label: "Portfolio"
}, {
    id: py(),
    type: "link",
    icon: ie.jsx(ZKt, {className: "ds-nav-main-nav-link-icon"}),
    url: "https://marketplace.dexscreener.com/product/ad",
    label: "Advertise"
}, {
    id: py(),
    type: "link",
    icon: ie.jsx(MKt, {className: "ds-nav-main-nav-link-icon"}),
    url: "https://docs.dexscreener.com/api/reference",
    label: "API",
    collapsed: !0
}], uW = () => {
    const {activePathname: t, isMenuCollapsed: e, toggleMenuCollapse: r, isNavigationCollapsed: n, chains: i} = sYt(),
        a = aa(k2e);
    return ie.jsxs("div", {
        className: "ds-nav-main",
        children: [ie.jsx(Ake, {
            buttonProps: {
                display: {base: "none", lg: n ? "none" : "flex"},
                flex: 1,
                mx: 3,
                my: 2,
                py: 2
            }
        }), ie.jsxs("ul", {
            className: "ds-nav-main-list ds-nav-main-list-features",
            children: [cYt.map(o => ie.jsxs("li", {
                className: fv("ds-nav-main-list-item", {"ds-nav-main-list-item-hidden": e ? !!o.collapsed : !1}, o.className),
                children: [o.type === "app-link" && ie.jsxs(lW, {
                    to: o.path,
                    isActive: t === o.path || t.startsWith(`${o.path}/`),
                    title: n ? o.label : void 0,
                    children: [o.icon, ie.jsx("span", {
                        className: fv("ds-nav-main-nav-link-text", {"ds-nav-main-nav-link-text-hidden": n}),
                        children: o.label
                    })]
                }), o.type === "link" && ie.jsxs(nYt, {
                    href: o.url,
                    title: n ? o.label : void 0,
                    children: [o.icon, ie.jsx("span", {
                        className: fv("ds-nav-main-nav-link-text", {"ds-nav-main-nav-link-text-hidden": n}),
                        children: o.label
                    })]
                }), o.type === "button-alert" && ie.jsx(aYt, {title: "Alerts", isCollapsed: n})]
            }, o.id)), n === !1 && ie.jsxs(Cke, {
                className: "ds-nav-main-collapse-button",
                onClick: r,
                children: [e ? "more" : "less", e ? ie.jsx(IKt, {}) : ie.jsx(kKt, {})]
            })]
        }), ie.jsx("hr", {className: "ds-nav-main-list-separator"}), ie.jsxs("ul", {
            className: "ds-nav-main-list",
            children: [ie.jsx("li", {
                className: "ds-nav-main-list-item",
                children: ie.jsxs(lW, {
                    to: "/moonshot",
                    isActive: t.startsWith("/moonshot"),
                    title: n ? "Moonshot" : void 0,
                    className: "ds-nav-main-nav-link-moonshot",
                    children: [ie.jsx(qWt, {
                        className: "ds-nav-main-nav-chain-icon",
                        "aria-label": "Moonshot"
                    }), ie.jsx("span", {
                        className: fv("ds-nav-main-nav-link-text", {"ds-nav-main-nav-link-text-hidden": n}),
                        children: "Moonshot"
                    }), ie.jsx("span", {className: "ds-nav-main-moonshot-label", children: "new!"})]
                })
            }), i == null ? void 0 : i.map(o => {
                const s = `/${o.slug}`;
                return ie.jsx("li", {
                    className: "ds-nav-main-list-item",
                    children: ie.jsxs(lW, {
                        to: s,
                        isActive: t === s || t.startsWith(`${s}/`),
                        title: n ? o.name : void 0,
                        children: [ie.jsx(bC, {
                            className: "ds-nav-main-nav-chain-icon",
                            src: a(o.slug),
                            alt: o.name,
                            loading: "lazy"
                        }), ie.jsx("span", {
                            className: fv("ds-nav-main-nav-link-text", {"ds-nav-main-nav-link-text-hidden": n}),
                            children: o.name
                        })]
                    })
                }, s)
            })]
        })]
    })
};

function lYt(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 1024 1024"},
        child: [{
            tag: "path",
            attr: {d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 0 0 .6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0 0 46.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"}
        }]
    })(t)
}

function Trr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 1024 1024"},
        child: [{
            tag: "path",
            attr: {d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 0 0 .6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0 0 46.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3zM664.8 561.6l36.1 210.3L512 672.7 323.1 772l36.1-210.3-152.8-149L417.6 382 512 190.7 606.4 382l211.2 30.7-152.8 148.9z"}
        }]
    })(t)
}

function Crr(t) {
    return ct({
        tag: "svg",
        attr: {viewBox: "0 0 1024 1024"},
        child: [{
            tag: "path",
            attr: {d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"}
        }]
    })(t)
}

const uYt = ({resetErrorBoundary: t}) => ie.jsxs(ln, {
    as: "span",
    display: "block",
    fontSize: "xs",
    m: 3,
    color: "white",
    children: ["Error rendering watchlist.", " ", "Please", " ", ie.jsx(Hc, {
        onClick: t,
        variant: "link",
        size: "xs",
        color: "white",
        fontWeight: "semibold",
        children: "click here to retry"
    }), " ", "or refresh this page."]
}), fW = {
    xs: {container: {fontSize: "xs"}, spinner: {size: "xs"}, text: {ml: 2}},
    sm: {container: {fontSize: "sm"}, spinner: {size: "sm"}, text: {ml: 2}},
    md: {container: {fontSize: "md"}, spinner: {size: "sm"}, text: {ml: 3}},
    lg: {container: {fontSize: "lg"}, spinner: {size: "lg"}, text: {ml: 3}}
}, _B = ({label: t, size: e = "md", color: r, spinnerProps: n, spinnerContainerProps: i, ...a}) => {
    const o = hS("gray.500", "blue.400"), s = hS("gray.500", "blue.600");
    return ie.jsxs(Gn, {
        display: "flex",
        alignItems: "center", ...fW[e].container, ...a,
        children: [ie.jsx(Gn, {
            display: "flex", ...i,
            children: ie.jsx(aE, {thickness: "3px", ...fW[e].spinner, color: r ?? o, ...n})
        }), t !== null && ie.jsx(ln, {as: "span", color: r ?? s, ...fW[e].text, children: t ?? "Loading..."})]
    })
}, fYt = () => ie.jsx(Gn, {
    pos: "relative",
    top: "-1px",
    children: ie.jsx(Gn, {
        pos: {lg: "sticky"},
        top: {lg: 0},
        bg: "black",
        zIndex: {lg: "sticky"},
        children: ie.jsx(Gn, {
            display: "flex",
            _hover: {bg: "gray.950"},
            children: ie.jsxs(ZI, {
                to: "/watchlist",
                bg: "transparent",
                flex: 1,
                display: "flex",
                alignItems: "center",
                fontSize: {base: "lg", lg: "xs"},
                fontWeight: "semibold",
                textTransform: "uppercase",
                color: "white",
                px: 3,
                py: {base: 2, lg: "10px"},
                _hover: {textDecor: "none"},
                children: [ie.jsx(_B, {label: null, size: "xs", mr: 2}), "Watchlist"]
            })
        })
    })
});

function dYt(...t) {
    return W.useMemo(() => e => {
        t.forEach(r => r(e))
    }, t)
}

const xB = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";

function C3(t) {
    const e = Object.prototype.toString.call(t);
    return e === "[object Window]" || e === "[object global]"
}

function sre(t) {
    return "nodeType" in t
}

function L1(t) {
    var e, r;
    return t ? C3(t) ? t : sre(t) && (e = (r = t.ownerDocument) == null ? void 0 : r.defaultView) != null ? e : window : window
}

function cre(t) {
    const {Document: e} = L1(t);
    return t instanceof e
}

function A3(t) {
    return C3(t) ? !1 : t instanceof L1(t).HTMLElement
}

function hYt(t) {
    return t instanceof L1(t).SVGElement
}

function I3(t) {
    return t ? C3(t) ? t.document : sre(t) ? cre(t) ? t : A3(t) ? t.ownerDocument : document : document : document
}

const DS = xB ? W.useLayoutEffect : W.useEffect;

function pYt() {
    const t = W.useRef(null), e = W.useCallback((n, i) => {
        t.current = setInterval(n, i)
    }, []), r = W.useCallback(() => {
        t.current !== null && (clearInterval(t.current), t.current = null)
    }, []);
    return [e, r]
}

function k3(t, e) {
    const r = W.useRef();
    return W.useMemo(() => {
        const n = t(r.current);
        return r.current = n, n
    }, [...e])
}

function lre() {
    const t = W.useRef(null), e = W.useCallback(r => {
        t.current = r
    }, []);
    return [t, e]
}

let dW = {};

function JI(t, e) {
    return W.useMemo(() => {
        if (e) return e;
        const r = dW[t] == null ? 0 : dW[t] + 1;
        return dW[t] = r, `${t}-${r}`
    }, [t, e])
}

function Ike(t) {
    return (e, ...r) => r.reduce((n, i) => {
        const a = Object.entries(i);
        for (const [o, s] of a) {
            const l = n[o];
            l != null && (n[o] = l + t * s)
        }
        return n
    }, {...e})
}

const c8 = Ike(1), kke = Ike(-1);

function mYt(t) {
    return "clientX" in t && "clientY" in t
}

function ure(t) {
    if (!t) return !1;
    const {KeyboardEvent: e} = L1(t.target);
    return e && t instanceof e
}

function vYt(t) {
    if (!t) return !1;
    const {TouchEvent: e} = L1(t.target);
    return e && t instanceof e
}

function MP(t) {
    if (vYt(t)) {
        if (t.touches && t.touches.length) {
            const {clientX: e, clientY: r} = t.touches[0];
            return {x: e, y: r}
        } else if (t.changedTouches && t.changedTouches.length) {
            const {clientX: e, clientY: r} = t.changedTouches[0];
            return {x: e, y: r}
        }
    }
    return mYt(t) ? {x: t.clientX, y: t.clientY} : {x: 0, y: 0}
}

const d1 = Object.freeze({
    Translate: {
        toString(t) {
            if (!t) return;
            const {x: e, y: r} = t;
            return `translate3d(${e ? Math.round(e) : 0}px, ${r ? Math.round(r) : 0}px, 0)`
        }
    }, Scale: {
        toString(t) {
            if (!t) return;
            const {scaleX: e, scaleY: r} = t;
            return `scaleX(${e}) scaleY(${r})`
        }
    }, Transform: {
        toString(t) {
            if (t) return [d1.Translate.toString(t), d1.Scale.toString(t)].join(" ")
        }
    }, Transition: {
        toString({property: t, duration: e, easing: r}) {
            return `${t} ${e}ms ${r}`
        }
    }
}), gYt = {display: "none"};

function yYt({id: t, value: e}) {
    return ar.createElement("div", {id: t, style: gYt}, e)
}

const bYt = {
    position: "absolute",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
};

function wYt({id: t, announcement: e}) {
    return ar.createElement("div", {id: t, style: bYt, role: "status", "aria-live": "assertive", "aria-atomic": !0}, e)
}

function SYt() {
    const [t, e] = W.useState("");
    return {
        announce: W.useCallback(n => {
            n != null && e(n)
        }, []), announcement: t
    }
}

const _Yt = {
    draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
}, xYt = {
    onDragStart(t) {
        return `Picked up draggable item ${t}.`
    }, onDragOver(t, e) {
        return e ? `Draggable item ${t} was moved over droppable area ${e}.` : `Draggable item ${t} is no longer over a droppable area.`
    }, onDragEnd(t, e) {
        return e ? `Draggable item ${t} was dropped over droppable area ${e}` : `Draggable item ${t} was dropped.`
    }, onDragCancel(t) {
        return `Dragging was cancelled. Draggable item ${t} was dropped.`
    }
};
var ga;
(function (t) {
    t.DragStart = "dragStart", t.DragMove = "dragMove", t.DragEnd = "dragEnd", t.DragCancel = "dragCancel", t.DragOver = "dragOver", t.RegisterDroppable = "registerDroppable", t.SetDroppableDisabled = "setDroppableDisabled", t.UnregisterDroppable = "unregisterDroppable"
})(ga || (ga = {}));

function hW(...t) {
}

class LC extends Map {
    get(e) {
        var r;
        return e != null && (r = super.get(e)) != null ? r : void 0
    }

    toArray() {
        return Array.from(this.values())
    }

    getEnabled() {
        return this.toArray().filter(({disabled: e}) => !e)
    }

    getNodeFor(e) {
        var r, n;
        return (r = (n = this.get(e)) == null ? void 0 : n.node.current) != null ? r : void 0
    }
}

const EB = W.createContext({
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    activeNodeClientRect: null,
    activators: [],
    ariaDescribedById: {draggable: ""},
    containerNodeRect: null,
    dispatch: hW,
    draggableNodes: {},
    droppableRects: new Map,
    droppableContainers: new LC,
    over: null,
    dragOverlay: {nodeRef: {current: null}, rect: null, setRef: hW},
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    recomputeLayouts: hW,
    windowRect: null,
    willRecomputeLayouts: !1
});

function EYt() {
    return {
        draggable: {active: null, initialCoordinates: {x: 0, y: 0}, nodes: {}, translate: {x: 0, y: 0}},
        droppable: {containers: new LC}
    }
}

function TYt(t, e) {
    switch (e.type) {
        case ga.DragStart:
            return {...t, draggable: {...t.draggable, initialCoordinates: e.initialCoordinates, active: e.active}};
        case ga.DragMove:
            return t.draggable.active ? {
                ...t,
                draggable: {
                    ...t.draggable,
                    translate: {
                        x: e.coordinates.x - t.draggable.initialCoordinates.x,
                        y: e.coordinates.y - t.draggable.initialCoordinates.y
                    }
                }
            } : t;
        case ga.DragEnd:
        case ga.DragCancel:
            return {
                ...t,
                draggable: {...t.draggable, active: null, initialCoordinates: {x: 0, y: 0}, translate: {x: 0, y: 0}}
            };
        case ga.RegisterDroppable: {
            const {element: r} = e, {id: n} = r, i = new LC(t.droppable.containers);
            return i.set(n, r), {...t, droppable: {...t.droppable, containers: i}}
        }
        case ga.SetDroppableDisabled: {
            const {id: r, key: n, disabled: i} = e, a = t.droppable.containers.get(r);
            if (!a || n !== a.key) return t;
            const o = new LC(t.droppable.containers);
            return o.set(r, {...a, disabled: i}), {...t, droppable: {...t.droppable, containers: o}}
        }
        case ga.UnregisterDroppable: {
            const {id: r, key: n} = e, i = t.droppable.containers.get(r);
            if (!i || n !== i.key) return t;
            const a = new LC(t.droppable.containers);
            return a.delete(r), {...t, droppable: {...t.droppable, containers: a}}
        }
        default:
            return t
    }
}

const Rke = W.createContext({type: null, event: null});

function CYt({onDragStart: t, onDragMove: e, onDragOver: r, onDragEnd: n, onDragCancel: i}) {
    const a = W.useContext(Rke), o = W.useRef(a);
    W.useEffect(() => {
        if (a !== o.current) {
            const {type: s, event: l} = a;
            switch (s) {
                case ga.DragStart:
                    t == null || t(l);
                    break;
                case ga.DragMove:
                    e == null || e(l);
                    break;
                case ga.DragOver:
                    r == null || r(l);
                    break;
                case ga.DragCancel:
                    i == null || i(l);
                    break;
                case ga.DragEnd:
                    n == null || n(l);
                    break
            }
            o.current = a
        }
    }, [a, t, e, r, n, i])
}

function AYt({announcements: t = xYt, hiddenTextDescribedById: e, screenReaderInstructions: r}) {
    const {announce: n, announcement: i} = SYt(), a = JI("DndLiveRegion"), [o, s] = W.useState(!1);
    return W.useEffect(() => {
        s(!0)
    }, []), CYt(W.useMemo(() => ({
        onDragStart({active: l}) {
            n(t.onDragStart(l.id))
        }, onDragMove({active: l, over: f}) {
            t.onDragMove && n(t.onDragMove(l.id, f == null ? void 0 : f.id))
        }, onDragOver({active: l, over: f}) {
            n(t.onDragOver(l.id, f == null ? void 0 : f.id))
        }, onDragEnd({active: l, over: f}) {
            n(t.onDragEnd(l.id, f == null ? void 0 : f.id))
        }, onDragCancel({active: l}) {
            n(t.onDragCancel(l.id))
        }
    }), [n, t])), o ? Jh.createPortal(ar.createElement(ar.Fragment, null, ar.createElement(yYt, {
        id: e,
        value: r.draggable
    }), ar.createElement(wYt, {id: a, announcement: i})), document.body) : null
}

const Gv = Object.freeze({x: 0, y: 0});

function IYt(t, e) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}

function kYt(t, e) {
    if (ure(t)) return "0 0";
    const r = MP(t), n = {x: (r.x - e.left) / e.width * 100, y: (r.y - e.top) / e.height * 100};
    return `${n.x}% ${n.y}%`
}

function RYt(t, e, r) {
    return {...t, scaleX: e && r ? e.width / r.width : 1, scaleY: e && r ? e.height / r.height : 1}
}

function DYt(t, e) {
    return t && e ? {x: t.left - e.left, y: t.top - e.top} : Gv
}

function MYt(t) {
    return function (r, ...n) {
        return n.reduce((i, a) => ({
            ...i,
            top: i.top + t * a.y,
            bottom: i.bottom + t * a.y,
            left: i.left + t * a.x,
            right: i.right + t * a.x,
            offsetLeft: i.offsetLeft + t * a.x,
            offsetTop: i.offsetTop + t * a.y
        }), {...r})
    }
}

const hve = MYt(1);

function OYt(t, e = window.getComputedStyle(t)) {
    return e.position === "fixed"
}

function PYt(t, e = window.getComputedStyle(t)) {
    const r = /(auto|scroll|overlay)/;
    return ["overflow", "overflowX", "overflowY"].find(i => {
        const a = e[i];
        return typeof a == "string" ? r.test(a) : !1
    }) != null
}

function fre(t) {
    const e = [];

    function r(n) {
        if (!n) return e;
        if (cre(n) && n.scrollingElement != null && !e.includes(n.scrollingElement)) return e.push(n.scrollingElement), e;
        if (!A3(n) || hYt(n) || e.includes(n)) return e;
        const i = window.getComputedStyle(n);
        return PYt(n, i) && e.push(n), OYt(n, i) ? e : r(n.parentNode)
    }

    return t ? r(t.parentNode) : e
}

function pW(t) {
    return !xB || !t ? null : C3(t) ? t : sre(t) ? cre(t) || t === I3(t).scrollingElement ? window : A3(t) ? t : null : null
}

function $Y(t) {
    return C3(t) ? {x: t.scrollX, y: t.scrollY} : {x: t.scrollLeft, y: t.scrollTop}
}

var Wx;
(function (t) {
    t[t.Forward = 1] = "Forward", t[t.Backward = -1] = "Backward"
})(Wx || (Wx = {}));

function Dke(t) {
    const e = {x: 0, y: 0}, r = {x: t.scrollWidth - t.clientWidth, y: t.scrollHeight - t.clientHeight},
        n = t.scrollTop <= e.y, i = t.scrollLeft <= e.x, a = t.scrollTop >= r.y, o = t.scrollLeft >= r.x;
    return {isTop: n, isLeft: i, isBottom: a, isRight: o, maxScroll: r, minScroll: e}
}

function NYt(t) {
    return !xB || !t ? !1 : t === document.scrollingElement
}

const LYt = {x: .2, y: .2};

function BYt(t, e, {top: r, left: n, right: i, bottom: a}, o = 10, s = LYt) {
    const {clientHeight: l, clientWidth: f} = t,
        d = NYt(t) ? {top: 0, left: 0, right: f, bottom: l, width: f, height: l} : e, {
            isTop: p,
            isBottom: g,
            isLeft: b,
            isRight: S
        } = Dke(t), T = {x: 0, y: 0}, I = {x: 0, y: 0}, N = {height: d.height * s.y, width: d.width * s.x};
    return !p && r <= d.top + N.height ? (T.y = Wx.Backward, I.y = o * Math.abs((d.top + N.height - r) / N.height)) : !g && a >= d.bottom - N.height && (T.y = Wx.Forward, I.y = o * Math.abs((d.bottom - N.height - a) / N.height)), !S && i >= d.right - N.width ? (T.x = Wx.Forward, I.x = o * Math.abs((d.right - N.width - i) / N.width)) : !b && n <= d.left + N.width && (T.x = Wx.Backward, I.x = o * Math.abs((d.left + N.width - n) / N.width)), {
        direction: T,
        speed: I
    }
}

function $Yt(t) {
    if (t === document.scrollingElement) {
        const {innerWidth: a, innerHeight: o} = window;
        return {top: 0, left: 0, right: a, bottom: o, width: a, height: o}
    }
    const {top: e, left: r, right: n, bottom: i} = t.getBoundingClientRect();
    return {top: e, left: r, right: n, bottom: i, width: t.clientWidth, height: t.clientHeight}
}

function Mke(t) {
    return t.reduce((e, r) => c8(e, $Y(r)), Gv)
}

function Oke(t, e, r = Gv) {
    if (!t || !A3(t)) return r;
    const n = {x: r.x + t.offsetLeft, y: r.y + t.offsetTop};
    return t.offsetParent === e ? n : Oke(t.offsetParent, e, n)
}

function TB(t) {
    const {offsetWidth: e, offsetHeight: r} = t, {x: n, y: i} = Oke(t, null);
    return {width: e, height: r, offsetTop: i, offsetLeft: n}
}

function CB(t) {
    if (C3(t)) {
        const f = window.innerWidth, d = window.innerHeight;
        return {top: 0, left: 0, right: f, bottom: d, width: f, height: d, offsetTop: 0, offsetLeft: 0}
    }
    const {offsetTop: e, offsetLeft: r} = TB(t), {
        width: n,
        height: i,
        top: a,
        bottom: o,
        left: s,
        right: l
    } = t.getBoundingClientRect();
    return {width: n, height: i, top: a, bottom: o, right: l, left: s, offsetTop: e, offsetLeft: r}
}

function OP(t) {
    const {width: e, height: r, offsetTop: n, offsetLeft: i} = TB(t), a = fre(t), o = Mke(a), s = n - o.y, l = i - o.x;
    return {width: e, height: r, top: s, bottom: s + r, right: l + e, left: l, offsetTop: n, offsetLeft: i}
}

function pve(t) {
    return "top" in t
}

function mve(t, e = t.offsetLeft, r = t.offsetTop) {
    return [{x: e, y: r}, {x: e + t.width, y: r}, {x: e, y: r + t.height}, {x: e + t.width, y: r + t.height}]
}

const Pke = ({collisionRect: t, droppableContainers: e}) => {
    let r = 1 / 0, n = null;
    const i = mve(t, t.left, t.top);
    for (const a of e) {
        const {rect: {current: o}} = a;
        if (o) {
            const s = mve(o, pve(o) ? o.left : void 0, pve(o) ? o.top : void 0),
                l = i.reduce((d, p, g) => d + IYt(s[g], p), 0), f = Number((l / 4).toFixed(4));
            f < r && (r = f, n = a.id)
        }
    }
    return n
};

function FYt(t, e) {
    const r = Math.max(e.top, t.offsetTop), n = Math.max(e.left, t.offsetLeft),
        i = Math.min(e.left + e.width, t.offsetLeft + t.width), a = Math.min(e.top + e.height, t.offsetTop + t.height),
        o = i - n, s = a - r;
    if (n < i && r < a) {
        const l = e.width * e.height, f = t.width * t.height, d = o * s, p = d / (l + f - d);
        return Number(p.toFixed(4))
    }
    return 0
}

const UYt = ({collisionRect: t, droppableContainers: e}) => {
    let r = 0, n = null;
    for (const i of e) {
        const {rect: {current: a}} = i;
        if (a) {
            const o = FYt(a, t);
            o > r && (r = o, n = i.id)
        }
    }
    return n
};
var BC;
(function (t) {
    t[t.Pointer = 0] = "Pointer", t[t.DraggableRect = 1] = "DraggableRect"
})(BC || (BC = {}));
var PP;
(function (t) {
    t[t.TreeOrder = 0] = "TreeOrder", t[t.ReversedTreeOrder = 1] = "ReversedTreeOrder"
})(PP || (PP = {}));

function jYt({
                 acceleration: t,
                 activator: e = BC.Pointer,
                 canScroll: r,
                 draggingRect: n,
                 enabled: i,
                 interval: a = 5,
                 order: o = PP.TreeOrder,
                 pointerCoordinates: s,
                 scrollableAncestors: l,
                 scrollableAncestorRects: f,
                 threshold: d
             }) {
    const [p, g] = pYt(), b = W.useRef({x: 1, y: 1}), S = W.useMemo(() => {
        switch (e) {
            case BC.Pointer:
                return s ? {top: s.y, bottom: s.y, left: s.x, right: s.x} : null;
            case BC.DraggableRect:
                return n
        }
        return null
    }, [e, n, s]), T = W.useRef(Gv), I = W.useRef(null), N = W.useCallback(() => {
        const F = I.current;
        if (!F) return;
        const V = b.current.x * T.current.x, Y = b.current.y * T.current.y;
        F.scrollBy(V, Y)
    }, []), P = W.useMemo(() => o === PP.TreeOrder ? [...l].reverse() : l, [o, l]);
    W.useEffect(() => {
        if (!i || !l.length || !S) {
            g();
            return
        }
        for (const F of P) {
            if ((r == null ? void 0 : r(F)) === !1) continue;
            const V = l.indexOf(F), Y = f[V];
            if (!Y) continue;
            const {direction: ee, speed: oe} = BYt(F, Y, S, t, d);
            if (oe.x > 0 || oe.y > 0) {
                g(), I.current = F, p(N, a), b.current = oe, T.current = ee;
                return
            }
        }
        b.current = {x: 0, y: 0}, T.current = {x: 0, y: 0}, g()
    }, [t, N, r, g, i, a, JSON.stringify(S), p, l, P, f, JSON.stringify(d)])
}

function zYt(t, e) {
    const r = e !== null ? t[e] : void 0, n = r ? r.node.current : null;
    return k3(i => {
        var a;
        return e === null ? null : (a = n ?? i) != null ? a : null
    }, [n, e])
}

function VYt(t, e) {
    return W.useMemo(() => t.reduce((r, n) => {
        const {sensor: i} = n, a = i.activators.map(o => ({eventName: o.eventName, handler: e(o.handler, n)}));
        return [...r, ...a]
    }, []), [t, e])
}

function Nke(t) {
    const e = W.useRef(t);
    return DS(() => {
        e.current !== t && (e.current = t)
    }, [t]), e
}

var l8;
(function (t) {
    t[t.Always = 0] = "Always", t[t.BeforeDragging = 1] = "BeforeDragging", t[t.WhileDragging = 2] = "WhileDragging"
})(l8 || (l8 = {}));
var FY;
(function (t) {
    t.Optimized = "optimized"
})(FY || (FY = {}));
const vve = new Map, HYt = {measure: TB, strategy: l8.WhileDragging, frequency: FY.Optimized};

function WYt(t, {dragging: e, dependencies: r, config: n}) {
    const [i, a] = W.useState(!1), {frequency: o, measure: s, strategy: l} = {...HYt, ...n}, f = W.useRef(t),
        d = W.useCallback(() => a(!0), []), p = W.useRef(null), g = S(), b = k3(T => {
            if (g && !e) return vve;
            if (!T || T === vve || f.current !== t || i) {
                for (let I of t) I && (I.rect.current = I.node.current ? s(I.node.current) : null);
                return qYt(t)
            }
            return T
        }, [t, e, g, s, i]);
    return W.useEffect(() => {
        f.current = t
    }, [t]), W.useEffect(() => {
        i && a(!1)
    }, [i]), W.useEffect(function () {
        g || requestAnimationFrame(d)
    }, [e, g]), W.useEffect(function () {
        g || typeof o != "number" || p.current !== null || (p.current = setTimeout(() => {
            d(), p.current = null
        }, o))
    }, [o, g, d, ...r]), {layoutRectMap: b, recomputeLayouts: d, willRecomputeLayouts: i};

    function S() {
        switch (l) {
            case l8.Always:
                return !1;
            case l8.BeforeDragging:
                return e;
            default:
                return !e
        }
    }
}

function qYt(t) {
    const e = new Map;
    if (t) for (const r of t) {
        if (!r) continue;
        const {id: n, rect: i} = r;
        i.current != null && e.set(n, i.current)
    }
    return e
}

function GYt(t) {
    const [e, r] = W.useState(null), n = W.useRef(t), i = W.useCallback(a => {
        const o = pW(a.target);
        o && r(s => s ? (s.set(o, $Y(o)), new Map(s)) : null)
    }, []);
    return W.useEffect(() => {
        const a = n.current;
        if (t !== a) {
            o(a);
            const s = t.map(l => {
                const f = pW(l);
                return f ? (f.addEventListener("scroll", i, {passive: !0}), [f, $Y(f)]) : null
            }).filter(l => l != null);
            r(s.length ? new Map(s) : null), n.current = t
        }
        return () => {
            o(t), o(a)
        };

        function o(s) {
            s.forEach(l => {
                const f = pW(l);
                f == null || f.removeEventListener("scroll", i)
            })
        }
    }, [i, t]), W.useMemo(() => t.length ? e ? Array.from(e.values()).reduce((a, o) => c8(a, o), Gv) : Mke(t) : Gv, [t, e])
}

const KYt = [];

function YYt(t) {
    const e = W.useRef(t),
        r = k3(n => t ? n && t && e.current && t.parentNode === e.current.parentNode ? n : fre(t) : KYt, [t]);
    return W.useEffect(() => {
        e.current = t
    }, [t]), r
}

function XYt(t) {
    W.useEffect(() => {
        if (!xB) return;
        const e = t.map(({sensor: r}) => r.setup == null ? void 0 : r.setup());
        return () => {
            for (const r of e) r == null || r()
        }
    }, t.map(({sensor: e}) => e))
}

function QYt(t, e) {
    return W.useMemo(() => t.reduce((r, {eventName: n, handler: i}) => (r[n] = a => {
        i(a, e)
    }, r), {}), [t, e])
}

const mW = Bke(CB), ZYt = JYt(CB);

function Lke(t, e, r) {
    const n = W.useRef(t);
    return k3(i => t ? r || !i && t || t !== n.current ? A3(t) && t.parentNode == null ? null : e(t) : i ?? null : null, [t, r, e])
}

function Bke(t) {
    return (e, r) => Lke(e, t, r)
}

function JYt(t) {
    const e = [];
    return function (n, i) {
        const a = W.useRef(n);
        return k3(o => n.length ? i || !o && n.length || n !== a.current ? n.map(s => t(s)) : o ?? e : e, [n, i])
    }
}

function $ke(t) {
    if (!t) return null;
    if (t.children.length > 1) return t;
    const e = t.children[0];
    return A3(e) ? e : t
}

function eXt(t) {
    const {width: e, height: r, offsetLeft: n, offsetTop: i} = TB(t);
    return {top: i, bottom: i + r, left: n, right: n + e, width: e, height: r, offsetTop: i, offsetLeft: n}
}

const tXt = Bke(eXt);

function rXt({disabled: t, forceRecompute: e}) {
    const [r, n] = lre(), i = tXt(t ? null : $ke(r.current), e);
    return W.useMemo(() => ({nodeRef: r, rect: i, setRef: n}), [i, r, n])
}

function gve(t, e) {
    return W.useMemo(() => ({sensor: t, options: e ?? {}}), [t, e])
}

function nXt(...t) {
    return W.useMemo(() => [...t].filter(e => e != null), [...t])
}

class $C {
    constructor(e) {
        this.target = e, this.listeners = [], this.removeAll = () => {
            this.listeners.forEach(r => {
                var n;
                return (n = this.target) == null ? void 0 : n.removeEventListener(...r)
            })
        }
    }

    add(e, r, n) {
        var i;
        (i = this.target) == null || i.addEventListener(e, r, n), this.listeners.push([e, r, n])
    }
}

function iXt(t) {
    const {EventTarget: e} = L1(t);
    return t instanceof e ? t : I3(t)
}

function vW(t, e) {
    const r = Math.abs(t.x), n = Math.abs(t.y);
    return typeof e == "number" ? Math.sqrt(r ** 2 + n ** 2) > e : "x" in e && "y" in e ? r > e.x && n > e.y : "x" in e ? r > e.x : "y" in e ? n > e.y : !1
}

var jd;
(function (t) {
    t.Click = "click", t.DragStart = "dragstart", t.Keydown = "keydown", t.ContextMenu = "contextmenu", t.Resize = "resize", t.SelectionChange = "selectionchange", t.VisibilityChange = "visibilitychange"
})(jd || (jd = {}));

function yve(t) {
    t.preventDefault()
}

function aXt(t) {
    t.stopPropagation()
}

var xi;
(function (t) {
    t.Space = "Space", t.Down = "ArrowDown", t.Right = "ArrowRight", t.Left = "ArrowLeft", t.Up = "ArrowUp", t.Esc = "Escape", t.Enter = "Enter"
})(xi || (xi = {}));
const Fke = {start: [xi.Space, xi.Enter], cancel: [xi.Esc], end: [xi.Space, xi.Enter]},
    oXt = (t, {currentCoordinates: e}) => {
        switch (t.code) {
            case xi.Right:
                return {...e, x: e.x + 25};
            case xi.Left:
                return {...e, x: e.x - 25};
            case xi.Down:
                return {...e, y: e.y + 25};
            case xi.Up:
                return {...e, y: e.y - 25}
        }
    };

class dre {
    constructor(e) {
        this.props = e, this.autoScrollEnabled = !1, this.coordinates = Gv;
        const {event: {target: r}} = e;
        this.props = e, this.listeners = new $C(I3(r)), this.windowListeners = new $C(L1(r)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach()
    }

    attach() {
        this.handleStart(), this.windowListeners.add(jd.Resize, this.handleCancel), this.windowListeners.add(jd.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(jd.Keydown, this.handleKeyDown))
    }

    handleStart() {
        const {activeNode: e, onStart: r} = this.props;
        if (!e.node.current) throw new Error("Active draggable node is undefined");
        const n = CB(e.node.current), i = {x: n.left, y: n.top};
        this.coordinates = i, r(i)
    }

    handleKeyDown(e) {
        if (ure(e)) {
            const {coordinates: r} = this, {active: n, context: i, options: a} = this.props, {
                keyboardCodes: o = Fke,
                coordinateGetter: s = oXt,
                scrollBehavior: l = "smooth"
            } = a, {code: f} = e;
            if (o.end.includes(f)) {
                this.handleEnd(e);
                return
            }
            if (o.cancel.includes(f)) {
                this.handleCancel(e);
                return
            }
            const d = s(e, {active: n, context: i.current, currentCoordinates: r});
            if (d) {
                const p = {x: 0, y: 0}, {scrollableAncestors: g} = i.current;
                for (const b of g) {
                    const S = e.code, T = kke(d, r), {
                        isTop: I,
                        isRight: N,
                        isLeft: P,
                        isBottom: F,
                        maxScroll: V,
                        minScroll: Y
                    } = Dke(b), ee = $Yt(b), oe = {
                        x: Math.min(S === xi.Right ? ee.right - ee.width / 2 : ee.right, Math.max(S === xi.Right ? ee.left : ee.left + ee.width / 2, d.x)),
                        y: Math.min(S === xi.Down ? ee.bottom - ee.height / 2 : ee.bottom, Math.max(S === xi.Down ? ee.top : ee.top + ee.height / 2, d.y))
                    }, G = S === xi.Right && !N || S === xi.Left && !P, J = S === xi.Down && !F || S === xi.Up && !I;
                    if (G && oe.x !== d.x) {
                        if (S === xi.Right && b.scrollLeft + T.x <= V.x || S === xi.Left && b.scrollLeft + T.x >= Y.x) {
                            b.scrollBy({left: T.x, behavior: l});
                            return
                        }
                        p.x = S === xi.Right ? b.scrollLeft - V.x : b.scrollLeft - Y.x, b.scrollBy({
                            left: -p.x,
                            behavior: l
                        });
                        break
                    } else if (J && oe.y !== d.y) {
                        if (S === xi.Down && b.scrollTop + T.y <= V.y || S === xi.Up && b.scrollTop + T.y >= Y.y) {
                            b.scrollBy({top: T.y, behavior: l});
                            return
                        }
                        p.y = S === xi.Down ? b.scrollTop - V.y : b.scrollTop - Y.y, b.scrollBy({
                            top: -p.y,
                            behavior: l
                        });
                        break
                    }
                }
                this.handleMove(e, c8(d, p))
            }
        }
    }

    handleMove(e, r) {
        const {onMove: n} = this.props;
        e.preventDefault(), n(r), this.coordinates = r
    }

    handleEnd(e) {
        const {onEnd: r} = this.props;
        e.preventDefault(), this.detach(), r()
    }

    handleCancel(e) {
        const {onCancel: r} = this.props;
        e.preventDefault(), this.detach(), r()
    }

    detach() {
        this.listeners.removeAll(), this.windowListeners.removeAll()
    }
}

dre.activators = [{
    eventName: "onKeyDown", handler: (t, {keyboardCodes: e = Fke, onActivation: r}) => {
        const {code: n} = t.nativeEvent;
        return e.start.includes(n) ? (t.preventDefault(), r == null || r({event: t.nativeEvent}), !0) : !1
    }
}];

function bve(t) {
    return !!(t && "distance" in t)
}

function wve(t) {
    return !!(t && "delay" in t)
}

class hre {
    constructor(e, r, n = iXt(e.event.target)) {
        this.props = e, this.events = r, this.autoScrollEnabled = !0, this.activated = !1, this.timeoutId = null;
        const {event: i} = e, {target: a} = i;
        this.props = e, this.events = r, this.document = I3(a), this.documentListeners = new $C(this.document), this.listeners = new $C(n), this.windowListeners = new $C(L1(a)), this.initialCoordinates = MP(i), this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach()
    }

    attach() {
        const {events: e, props: {options: {activationConstraint: r}}} = this;
        if (this.listeners.add(e.move.name, this.handleMove, {passive: !1}), this.listeners.add(e.end.name, this.handleEnd), this.windowListeners.add(jd.Resize, this.handleCancel), this.windowListeners.add(jd.DragStart, yve), this.windowListeners.add(jd.VisibilityChange, this.handleCancel), this.windowListeners.add(jd.ContextMenu, yve), this.documentListeners.add(jd.Keydown, this.handleKeydown), r) {
            if (bve(r)) return;
            if (wve(r)) {
                this.timeoutId = setTimeout(this.handleStart, r.delay);
                return
            }
        }
        this.handleStart()
    }

    detach() {
        this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null)
    }

    handleStart() {
        const {initialCoordinates: e} = this, {onStart: r} = this.props;
        e && (this.activated = !0, this.documentListeners.add(jd.Click, aXt, {capture: !0}), this.removeTextSelection(), this.documentListeners.add(jd.SelectionChange, this.removeTextSelection), r(e))
    }

    handleMove(e) {
        const {activated: r, initialCoordinates: n, props: i} = this, {
            onMove: a,
            options: {activationConstraint: o}
        } = i;
        if (!n) return;
        const s = MP(e), l = kke(n, s);
        if (!r && o) {
            if (wve(o)) return vW(l, o.tolerance) ? this.handleCancel() : void 0;
            if (bve(o)) return o.tolerance != null && vW(l, o.tolerance) ? this.handleCancel() : vW(l, o.distance) ? this.handleStart() : void 0
        }
        e.cancelable && e.preventDefault(), a(s)
    }

    handleEnd() {
        const {onEnd: e} = this.props;
        this.detach(), e()
    }

    handleCancel() {
        const {onCancel: e} = this.props;
        this.detach(), e()
    }

    handleKeydown(e) {
        e.code === xi.Esc && this.handleCancel()
    }

    removeTextSelection() {
        var e;
        (e = this.document.getSelection()) == null || e.removeAllRanges()
    }
}

const sXt = {move: {name: "pointermove"}, end: {name: "pointerup"}};

class pre extends hre {
    constructor(e) {
        const {event: r} = e, n = I3(r.target);
        super(e, sXt, n)
    }
}

pre.activators = [{
    eventName: "onPointerDown",
    handler: ({nativeEvent: t}, {onActivation: e}) => !t.isPrimary || t.button !== 0 ? !1 : (e == null || e({event: t}), !0)
}];
const cXt = {move: {name: "mousemove"}, end: {name: "mouseup"}};
var UY;
(function (t) {
    t[t.RightClick = 2] = "RightClick"
})(UY || (UY = {}));

class lXt extends hre {
    constructor(e) {
        super(e, cXt, I3(e.event.target))
    }
}

lXt.activators = [{
    eventName: "onMouseDown",
    handler: ({nativeEvent: t}, {onActivation: e}) => t.button === UY.RightClick ? !1 : (e == null || e({event: t}), !0)
}];
const gW = {move: {name: "touchmove"}, end: {name: "touchend"}};

class uXt extends hre {
    constructor(e) {
        super(e, gW)
    }

    static setup() {
        return window.addEventListener(gW.move.name, e, {capture: !1, passive: !1}), function () {
            window.removeEventListener(gW.move.name, e)
        };

        function e() {
        }
    }
}

uXt.activators = [{
    eventName: "onTouchStart", handler: ({nativeEvent: t}, {onActivation: e}) => {
        const {touches: r} = t;
        return r.length > 1 ? !1 : (e == null || e({event: t}), !0)
    }
}];

function Uke(t, {transform: e, ...r}) {
    return t != null && t.length ? t.reduce((n, i) => i({transform: n, ...r}), e) : e
}

const fXt = [{sensor: pre, options: {}}, {sensor: dre, options: {}}], dXt = {current: {}},
    mre = W.createContext({...Gv, scaleX: 1, scaleY: 1}), hXt = W.memo(function ({
                                                                                     id: e,
                                                                                     autoScroll: r = !0,
                                                                                     announcements: n,
                                                                                     children: i,
                                                                                     sensors: a = fXt,
                                                                                     collisionDetection: o = UYt,
                                                                                     measuring: s,
                                                                                     modifiers: l,
                                                                                     screenReaderInstructions: f = _Yt,
                                                                                     ...d
                                                                                 }) {
        var p, g, b, S, T;
        const I = W.useReducer(TYt, void 0, EYt), [N, P] = I, [F, V] = W.useState(() => ({
                type: null,
                event: null
            })), [Y, ee] = W.useState(!1), {draggable: {active: oe, nodes: G, translate: J}, droppable: {containers: ce}} = N,
            re = oe ? G[oe] : null, M = W.useRef({initial: null, translated: null}), D = W.useMemo(() => {
                var Ae;
                return oe != null ? {id: oe, data: (Ae = re == null ? void 0 : re.data) != null ? Ae : dXt, rect: M} : null
            }, [oe, re]), x = W.useRef(null), [A, B] = W.useState(null), [z, j] = W.useState(null), $ = W.useRef(d),
            C = JI("DndDescribedBy", e), R = W.useMemo(() => ce.getEnabled(), [ce]), {
                layoutRectMap: k,
                recomputeLayouts: Q,
                willRecomputeLayouts: fe
            } = WYt(R, {dragging: Y, dependencies: [J.x, J.y], config: s == null ? void 0 : s.droppable}), ye = zYt(G, oe),
            ue = z ? MP(z) : null,
            me = Lke(ye, (p = s == null || (g = s.draggable) == null ? void 0 : g.measure) != null ? p : OP), Se = mW(ye),
            Ce = W.useRef(null), Me = Ce.current, ve = W.useRef({
                active: null,
                activeNode: ye,
                collisionRect: null,
                droppableRects: k,
                draggableNodes: G,
                draggingNodeRect: null,
                droppableContainers: ce,
                over: null,
                scrollableAncestors: [],
                scrollAdjustedTranslate: null,
                translatedRect: null
            }), ne = ce.getNodeFor((b = ve.current.over) == null ? void 0 : b.id),
            be = mW(ye ? ye.ownerDocument.defaultView : null), Ee = mW(ye ? ye.parentElement : null),
            Oe = YYt(oe ? ne ?? ye : null), ze = ZYt(Oe), Be = rXt({disabled: oe == null, forceRecompute: fe}),
            it = (S = Be.rect) != null ? S : me, Ue = it === me ? DYt(me, Me) : Gv, bt = Uke(l, {
                transform: {x: J.x - Ue.x, y: J.y - Ue.y, scaleX: 1, scaleY: 1},
                activatorEvent: z,
                active: D,
                activeNodeRect: Se,
                containerNodeRect: Ee,
                draggingNodeRect: it,
                over: ve.current.over,
                overlayNodeRect: Be.rect,
                scrollableAncestors: Oe,
                scrollableAncestorRects: ze,
                windowRect: be
            }), gt = ue ? c8(ue, J) : null, Ot = GYt(Oe), zt = c8(bt, Ot), _t = it ? hve(it, bt) : null,
            Dt = _t ? hve(_t, Ot) : null,
            rr = D && Dt ? o({active: D, collisionRect: Dt, droppableContainers: R}) : null, [pe, te] = W.useState(null),
            X = RYt(bt, (T = pe == null ? void 0 : pe.rect) != null ? T : null, me),
            H = W.useCallback((Ae, {sensor: De, options: Ze}) => {
                if (!x.current) return;
                const ft = G[x.current];
                if (!ft) return;
                const ht = new De({
                    active: x.current,
                    activeNode: ft,
                    event: Ae.nativeEvent,
                    options: Ze,
                    context: ve,
                    onStart(Rt) {
                        const Gt = x.current;
                        if (!Gt) return;
                        const sn = G[Gt];
                        if (!sn) return;
                        const {onDragStart: Yr} = $.current, br = {active: {id: Gt, data: sn.data, rect: M}};
                        Jh.unstable_batchedUpdates(() => {
                            P({type: ga.DragStart, initialCoordinates: Rt, active: Gt}), V({type: ga.DragStart, event: br})
                        }), Yr == null || Yr(br)
                    },
                    onMove(Rt) {
                        P({type: ga.DragMove, coordinates: Rt})
                    },
                    onEnd: cr(ga.DragEnd),
                    onCancel: cr(ga.DragCancel)
                });
                Jh.unstable_batchedUpdates(() => {
                    B(ht), j(Ae.nativeEvent)
                });

                function cr(Rt) {
                    return async function () {
                        const {active: sn, over: Yr, scrollAdjustedTranslate: br} = ve.current;
                        let hn = null;
                        if (sn && br) {
                            const {cancelDrop: En} = $.current;
                            hn = {
                                active: sn,
                                delta: br,
                                over: Yr
                            }, Rt === ga.DragEnd && typeof En == "function" && await Promise.resolve(En(hn)) && (Rt = ga.DragCancel)
                        }
                        if (x.current = null, Jh.unstable_batchedUpdates(() => {
                            P({type: Rt}), te(null), ee(!1), B(null), j(null), hn && V({type: Rt, event: hn})
                        }), hn) {
                            const {onDragCancel: En, onDragEnd: _r} = $.current, _n = Rt === ga.DragEnd ? _r : En;
                            _n == null || _n(hn)
                        }
                    }
                }
            }, [P, G]), U = W.useCallback((Ae, De) => (Ze, ft) => {
                const ht = Ze.nativeEvent;
                x.current !== null || ht.dndKit || ht.defaultPrevented || Ae(Ze, De.options) === !0 && (ht.dndKit = {capturedBy: De.sensor}, x.current = ft, H(Ze, De))
            }, [H]), q = VYt(a, U);
        XYt(a), DS(() => {
            $.current = d
        }, Object.values(d)), W.useEffect(() => {
            oe != null && ee(!0)
        }, [oe]), W.useEffect(() => {
            D || (Ce.current = null), D && me && !Ce.current && (Ce.current = me)
        }, [me, D]), W.useEffect(() => {
            const {onDragMove: Ae} = $.current, {active: De, over: Ze} = ve.current;
            if (!De) return;
            const ft = {active: De, delta: {x: zt.x, y: zt.y}, over: Ze};
            V({type: ga.DragMove, event: ft}), Ae == null || Ae(ft)
        }, [zt.x, zt.y]), W.useEffect(() => {
            const {active: Ae, droppableContainers: De, scrollAdjustedTranslate: Ze} = ve.current;
            if (!Ae || !x.current || !Ze) return;
            const {onDragOver: ft} = $.current, ht = De.get(rr), cr = ht && ht.rect.current ? {
                id: ht.id,
                rect: ht.rect.current,
                data: ht.data,
                disabled: ht.disabled
            } : null, Rt = {active: Ae, delta: {x: Ze.x, y: Ze.y}, over: cr};
            Jh.unstable_batchedUpdates(() => {
                te(cr), V({type: ga.DragOver, event: Rt}), ft == null || ft(Rt)
            })
        }, [rr]), DS(() => {
            ve.current = {
                active: D,
                activeNode: ye,
                collisionRect: Dt,
                droppableRects: k,
                draggableNodes: G,
                draggingNodeRect: it,
                droppableContainers: ce,
                over: pe,
                scrollableAncestors: Oe,
                scrollAdjustedTranslate: zt,
                translatedRect: _t
            }, M.current = {initial: it, translated: _t}
        }, [D, ye, Dt, G, it, k, ce, pe, Oe, zt, _t]), jYt({
            ...xe(),
            draggingRect: _t,
            pointerCoordinates: gt,
            scrollableAncestors: Oe,
            scrollableAncestorRects: ze
        });
        const le = W.useMemo(() => ({
            active: D,
            activeNode: ye,
            activeNodeRect: me,
            activeNodeClientRect: Se,
            activatorEvent: z,
            activators: q,
            ariaDescribedById: {draggable: C},
            containerNodeRect: Ee,
            dispatch: P,
            dragOverlay: Be,
            draggableNodes: G,
            droppableContainers: ce,
            droppableRects: k,
            over: pe,
            recomputeLayouts: Q,
            scrollableAncestors: Oe,
            scrollableAncestorRects: ze,
            willRecomputeLayouts: fe,
            windowRect: be
        }), [D, ye, Se, me, z, q, Ee, Be, P, G, C, ce, k, pe, Q, Oe, ze, fe, be]);
        return ar.createElement(Rke.Provider, {value: F}, ar.createElement(EB.Provider, {value: le}, ar.createElement(mre.Provider, {value: X}, i)), ar.createElement(AYt, {
            announcements: n,
            hiddenTextDescribedById: C,
            screenReaderInstructions: f
        }));

        function xe() {
            const Ae = (A == null ? void 0 : A.autoScrollEnabled) === !1,
                De = typeof r == "object" ? r.enabled === !1 : r === !1, Ze = !Ae && !De;
            return typeof r == "object" ? {...r, enabled: Ze} : {enabled: Ze}
        }
    }), pXt = W.createContext(null), Sve = "button", mXt = "Droppable";

function vXt({id: t, data: e, disabled: r = !1, attributes: n}) {
    const i = JI(mXt), {
            active: a,
            activeNodeRect: o,
            activatorEvent: s,
            ariaDescribedById: l,
            draggableNodes: f,
            droppableRects: d,
            activators: p,
            over: g
        } = W.useContext(EB), {role: b = Sve, roleDescription: S = "draggable", tabIndex: T = 0} = n ?? {},
        I = (a == null ? void 0 : a.id) === t, N = W.useContext(I ? mre : pXt), [P, F] = lre(), V = QYt(p, t),
        Y = Nke(e);
    W.useEffect(() => (f[t] = {id: t, key: i, node: P, data: Y}, () => {
        const oe = f[t];
        oe && oe.key === i && delete f[t]
    }), [f, t]);
    const ee = W.useMemo(() => ({
        role: b,
        tabIndex: T,
        "aria-pressed": I && b === Sve ? !0 : void 0,
        "aria-roledescription": S,
        "aria-describedby": l.draggable
    }), [b, T, I, S, l.draggable]);
    return {
        active: a,
        activeNodeRect: o,
        activatorEvent: s,
        attributes: ee,
        droppableRects: d,
        isDragging: I,
        listeners: r ? void 0 : V,
        node: P,
        over: g,
        setNodeRef: F,
        transform: N
    }
}

function jke() {
    return W.useContext(EB)
}

const gXt = "Droppable";

function yXt({data: t, disabled: e = !1, id: r}) {
    const n = JI(gXt), {active: i, dispatch: a, over: o} = W.useContext(EB), s = W.useRef(null), [l, f] = lre(),
        d = Nke(t);
    return DS(() => (a({
        type: ga.RegisterDroppable,
        element: {id: r, key: n, disabled: e, node: l, rect: s, data: d}
    }), () => a({type: ga.UnregisterDroppable, key: n, id: r})), [r]), W.useEffect(() => {
        a({type: ga.SetDroppableDisabled, id: r, key: n, disabled: e})
    }, [e]), {active: i, rect: s, isOver: (o == null ? void 0 : o.id) === r, node: l, over: o, setNodeRef: f}
}

function bXt({
                 animate: t,
                 adjustScale: e,
                 activeId: r,
                 draggableNodes: n,
                 duration: i,
                 easing: a,
                 dragSourceOpacity: o,
                 node: s,
                 transform: l
             }) {
    const [f, d] = W.useState(!1);
    return W.useEffect(() => {
        if (!t || !r || !a || !i) {
            t && d(!0);
            return
        }
        requestAnimationFrame(() => {
            var p;
            const g = (p = n[r]) == null ? void 0 : p.node.current;
            if (l && s && g && g.parentNode !== null) {
                const b = $ke(s);
                if (b) {
                    const S = b.getBoundingClientRect(), T = OP(g), I = {x: S.left - T.left, y: S.top - T.top};
                    if (Math.abs(I.x) || Math.abs(I.y)) {
                        const N = {
                            scaleX: e ? T.width * l.scaleX / S.width : 1,
                            scaleY: e ? T.height * l.scaleY / S.height : 1
                        }, P = d1.Transform.toString({x: l.x - I.x, y: l.y - I.y, ...N}), F = g.style.opacity;
                        o != null && (g.style.opacity = `${o}`);
                        const V = s.animate([{transform: d1.Transform.toString(l)}, {transform: P}], {
                            easing: a,
                            duration: i
                        });
                        V.onfinish = () => {
                            s.style.display = "none", d(!0), g && o != null && (g.style.opacity = F)
                        };
                        return
                    }
                }
            }
            d(!0)
        })
    }, [t, r, e, n, i, a, o, s, l]), DS(() => {
        f && d(!1)
    }, [f]), f
}

const wXt = t => ure(t) ? "transform 250ms ease" : void 0, SXt = {duration: 250, easing: "ease", dragSourceOpacity: 0},
    _Xt = ar.memo(({
                       adjustScale: t = !1,
                       children: e,
                       dropAnimation: r = SXt,
                       style: n,
                       transition: i = wXt,
                       modifiers: a,
                       wrapperElement: o = "div",
                       className: s,
                       zIndex: l = 999
                   }) => {
        var f, d;
        const {
                active: p,
                activeNodeRect: g,
                activeNodeClientRect: b,
                containerNodeRect: S,
                draggableNodes: T,
                activatorEvent: I,
                over: N,
                dragOverlay: P,
                scrollableAncestors: F,
                scrollableAncestorRects: V,
                windowRect: Y
            } = jke(), ee = W.useContext(mre), oe = Uke(a, {
                activatorEvent: I,
                active: p,
                activeNodeRect: b,
                containerNodeRect: S,
                draggingNodeRect: P.rect,
                over: N,
                overlayNodeRect: P.rect,
                scrollableAncestors: F,
                scrollableAncestorRects: V,
                transform: ee,
                windowRect: Y
            }), G = p !== null, J = t ? oe : {...oe, scaleX: 1, scaleY: 1}, ce = k3(R => G ? R ?? g : null, [G, g]),
            re = ce ? {
                position: "fixed",
                width: ce.width,
                height: ce.height,
                top: ce.top,
                left: ce.left,
                zIndex: l,
                transform: d1.Transform.toString(J),
                touchAction: "none",
                transformOrigin: t && I ? kYt(I, ce) : void 0,
                transition: typeof i == "function" ? i(I) : i, ...n
            } : void 0, M = G ? {style: re, children: e, className: s, transform: J} : void 0, D = W.useRef(M),
            x = M ?? D.current, {children: A, transform: B, ...z} = x ?? {},
            j = W.useRef((f = p == null ? void 0 : p.id) != null ? f : null), $ = bXt({
                animate: !!(r && j.current && !p),
                adjustScale: t,
                activeId: j.current,
                draggableNodes: T,
                duration: r == null ? void 0 : r.duration,
                easing: r == null ? void 0 : r.easing,
                dragSourceOpacity: r == null ? void 0 : r.dragSourceOpacity,
                node: P.nodeRef.current,
                transform: (d = D.current) == null ? void 0 : d.transform
            }), C = !!(A && (e || r && !$));
        return W.useEffect(() => {
            if ((p == null ? void 0 : p.id) !== j.current) {
                var R;
                j.current = (R = p == null ? void 0 : p.id) != null ? R : null
            }
            p && D.current !== M && (D.current = M)
        }, [p, M]), W.useEffect(() => {
            $ && (D.current = void 0)
        }, [$]), C ? ar.createElement(o, {...z, ref: P.setRef}, A) : null
    });

function xXt(t, e, r) {
    const n = {...t};
    return e.top + t.y <= r.top ? n.y = r.top - e.top : e.bottom + t.y >= r.top + r.height && (n.y = r.top + r.height - e.bottom), e.left + t.x <= r.left ? n.x = r.left - e.left : e.right + t.x >= r.left + r.width && (n.x = r.left + r.width - e.right), n
}

const EXt = ({transform: t, activeNodeRect: e, containerNodeRect: r}) => !e || !r ? t : xXt(t, e, r),
    TXt = ({transform: t}) => ({...t, x: 0});

function zke(t, e, r) {
    const n = t.slice();
    return n.splice(r < 0 ? n.length + r : r, 0, n.splice(e, 1)[0]), n
}

function CXt(t, e) {
    return t.reduce((r, n, i) => {
        const a = e.get(n);
        return a && (r[i] = a), r
    }, Array(t.length))
}

function nD(t) {
    return t !== null && t >= 0
}

const Vke = ({layoutRects: t, activeIndex: e, overIndex: r, index: n}) => {
    const i = zke(t, r, e), a = t[n], o = i[n];
    return !o || !a ? null : {
        x: o.offsetLeft - a.offsetLeft,
        y: o.offsetTop - a.offsetTop,
        scaleX: o.width / a.width,
        scaleY: o.height / a.height
    }
}, iD = {scaleX: 1, scaleY: 1}, AXt = ({activeIndex: t, activeNodeRect: e, index: r, layoutRects: n, overIndex: i}) => {
    var a;
    const o = (a = n[t]) != null ? a : e;
    if (!o) return null;
    if (r === t) {
        const l = n[i];
        return l ? {
            x: 0,
            y: t < i ? l.offsetTop + l.height - (o.offsetTop + o.height) : l.offsetTop - o.offsetTop, ...iD
        } : null
    }
    const s = IXt(n, r, t);
    return r > t && r <= i ? {x: 0, y: -o.height - s, ...iD} : r < t && r >= i ? {x: 0, y: o.height + s, ...iD} : {
        x: 0,
        y: 0, ...iD
    }
};

function IXt(t, e, r) {
    const n = t[e], i = t[e - 1], a = t[e + 1];
    return n ? r < e ? i ? n.offsetTop - (i.offsetTop + i.height) : a ? a.offsetTop - (n.offsetTop + n.height) : 0 : a ? a.offsetTop - (n.offsetTop + n.height) : i ? n.offsetTop - (i.offsetTop + i.height) : 0 : 0
}

const Hke = "Sortable", Wke = ar.createContext({
    activeIndex: -1,
    containerId: Hke,
    disableTransforms: !1,
    items: [],
    overIndex: -1,
    useDragOverlay: !1,
    sortedRects: [],
    strategy: Vke,
    wasDragging: {current: !1}
});

function kXt({children: t, id: e, items: r, strategy: n = Vke}) {
    const {active: i, dragOverlay: a, droppableRects: o, over: s, recomputeLayouts: l, willRecomputeLayouts: f} = jke(),
        d = JI(Hke, e), p = a.rect !== null, g = W.useMemo(() => r.map(oe => typeof oe == "string" ? oe : oe.id), [r]),
        b = i != null, S = W.useRef(!1), T = i ? g.indexOf(i.id) : -1, I = T !== -1, N = s ? g.indexOf(s.id) : -1,
        P = W.useRef(g), F = CXt(g, o), V = !RXt(g, P.current), Y = N !== -1 && T === -1 || V;
    DS(() => {
        V && I && !f && l()
    }, [V, I, l, f]), W.useEffect(() => {
        P.current = g
    }, [g]), W.useEffect(() => {
        const oe = setTimeout(() => {
            S.current = b
        }, 100);
        return () => clearTimeout(oe)
    }, [b]);
    const ee = W.useMemo(() => ({
        activeIndex: T,
        containerId: d,
        disableTransforms: Y,
        items: g,
        overIndex: N,
        useDragOverlay: p,
        sortedRects: F,
        strategy: n,
        wasDragging: S
    }), [T, d, Y, g, N, F, p, n, S]);
    return ar.createElement(Wke.Provider, {value: ee}, t)
}

function RXt(t, e) {
    return t.join() === e.join()
}

const DXt = ({id: t, items: e, activeIndex: r, overIndex: n}) => zke(e, r, n).indexOf(t), MXt = ({
                                                                                                     containerId: t,
                                                                                                     isSorting: e,
                                                                                                     wasDragging: r,
                                                                                                     index: n,
                                                                                                     items: i,
                                                                                                     newIndex: a,
                                                                                                     previousItems: o,
                                                                                                     previousContainerId: s,
                                                                                                     transition: l
                                                                                                 }) => !l || !r || o !== i && n === a ? !1 : e ? !0 : a !== n && t === s,
    OXt = {duration: 200, easing: "ease"}, qke = "transform",
    PXt = d1.Transition.toString({property: qke, duration: 0, easing: "linear"}), NXt = {roleDescription: "sortable"};

function LXt({disabled: t, index: e, node: r, rect: n}) {
    const [i, a] = W.useState(null), o = W.useRef(e);
    return DS(() => {
        if (!t && e !== o.current && r.current) {
            const s = n.current;
            if (s) {
                const l = CB(r.current), f = {
                    x: s.offsetLeft - l.offsetLeft,
                    y: s.offsetTop - l.offsetTop,
                    scaleX: s.width / l.width,
                    scaleY: s.height / l.height
                };
                (f.x || f.y) && a(f)
            }
        }
        e !== o.current && (o.current = e)
    }, [t, e, r, n]), W.useEffect(() => {
        i && requestAnimationFrame(() => {
            a(null)
        })
    }, [i]), i
}

function BXt({
                 animateLayoutChanges: t = MXt,
                 attributes: e,
                 disabled: r,
                 data: n,
                 getNewIndex: i = DXt,
                 id: a,
                 strategy: o,
                 transition: s = OXt
             }) {
    const {
            items: l,
            containerId: f,
            activeIndex: d,
            disableTransforms: p,
            sortedRects: g,
            overIndex: b,
            useDragOverlay: S,
            strategy: T,
            wasDragging: I
        } = W.useContext(Wke), N = l.indexOf(a),
        P = W.useMemo(() => ({sortable: {containerId: f, index: N, items: l}, ...n}), [f, n, N, l]), {
            rect: F,
            node: V,
            setNodeRef: Y
        } = yXt({id: a, data: P}), {
            active: ee,
            activeNodeRect: oe,
            activatorEvent: G,
            attributes: J,
            setNodeRef: ce,
            listeners: re,
            isDragging: M,
            over: D,
            transform: x
        } = vXt({id: a, data: P, attributes: {...NXt, ...e}, disabled: r}), A = dYt(Y, ce), B = !!ee,
        z = B && I.current && !p && nD(d) && nD(b), j = !S && M, $ = j && z ? x : null,
        R = z ? $ ?? (o ?? T)({layoutRects: g, activeNodeRect: oe, activeIndex: d, overIndex: b, index: N}) : null,
        k = nD(d) && nD(b) ? i({id: a, items: l, activeIndex: d, overIndex: b}) : N, Q = W.useRef(l),
        fe = l !== Q.current, ye = W.useRef(k), ue = W.useRef(f), me = t({
            active: ee,
            containerId: f,
            isDragging: M,
            isSorting: B,
            id: a,
            index: N,
            items: l,
            newIndex: ye.current,
            previousItems: Q.current,
            previousContainerId: ue.current,
            transition: s,
            wasDragging: I.current
        }), Se = LXt({disabled: !me, index: N, node: V, rect: F});
    return W.useEffect(() => {
        B && ye.current !== k && (ye.current = k), f !== ue.current && (ue.current = f), l !== Q.current && (Q.current = l)
    }, [B, k, f, l]), {
        active: ee,
        attributes: J,
        activatorEvent: G,
        rect: F,
        index: N,
        isSorting: B,
        isDragging: M,
        listeners: re,
        node: V,
        overIndex: b,
        over: D,
        setNodeRef: A,
        setDroppableNodeRef: Y,
        setDraggableNodeRef: ce,
        transform: Se ?? R,
        transition: Ce()
    };

    function Ce() {
        if (Se || fe && ye.current === N) return PXt;
        if (!(j || !s) && (B || me)) return d1.Transition.toString({...s, property: qke})
    }
}

const $Xt = [xi.Down, xi.Right, xi.Up, xi.Left],
    FXt = (t, {context: {active: e, droppableContainers: r, translatedRect: n, scrollableAncestors: i}}) => {
        if ($Xt.includes(t.code)) {
            if (t.preventDefault(), !e || !n) return;
            const o = [];
            r.getEnabled().forEach(l => {
                if (!l || l != null && l.disabled) return;
                const f = l == null ? void 0 : l.node.current;
                if (!f) return;
                const d = OP(f), p = {...l, rect: {current: d}};
                switch (t.code) {
                    case xi.Down:
                        n.top + n.height <= d.top && o.push(p);
                        break;
                    case xi.Up:
                        n.top >= d.top + d.height && o.push(p);
                        break;
                    case xi.Left:
                        n.left >= d.left + d.width && o.push(p);
                        break;
                    case xi.Right:
                        n.left + n.width <= d.left && o.push(p);
                        break
                }
            });
            const s = Pke({active: e, collisionRect: n, droppableContainers: o});
            if (s) {
                var a;
                const l = (a = r.get(s)) == null ? void 0 : a.node.current;
                if (l) {
                    const d = fre(l).some((S, T) => i[T] !== S), p = OP(l),
                        g = d ? {x: 0, y: 0} : {x: n.width - p.width, y: n.height - p.height};
                    return {x: p.left - g.x, y: p.top - g.y}
                }
            }
        }
    }, Zb = {
        visibility: "private",
        schemaVersion: "1.0.0",
        id: "main",
        name: "Main Watchlist",
        userId: "",
        createdAt: 1,
        updatedAt: 1,
        default: !0,
        pairs: []
    }, ek = pt(T5e, SB, gI, (t, e, r) => {
        const n = r.currentUser, i = t.all.pipe(zn(g => g && au(g) ? g.find(S => S.default) ? g : [Zb, ...g] : [Zb])),
            a = t.all, o = g => Qy([i, n]).pipe(uo(([b, S]) => {
                const T = b.find(I => I.id === g);
                if (T) return Hd(T);
                if (!T && g === Zb.id) {
                    const I = b.find(N => N.default);
                    return I ? Ju(t.actions.findById(I.id)) : Hd(void 0)
                }
                return Ju(t.actions.findById(g, S == null ? void 0 : S.id)).pipe(zn(I => I ?? void 0))
            })), s = Qy([t.all, e.all]).pipe(zn(([g, b]) => {
                if (b.watchlistsActiveId === "main") {
                    const T = g.find(I => I.default);
                    return T || Zb
                }
                const S = g.find(T => T.id == b.watchlistsActiveId);
                return S || (g.find(I => I.default) ?? Zb)
            }), op(), Xa);
        return {
            all: i,
            allRemote: a,
            findById: o,
            addPairToWatchlist: async (g, b) => {
                const S = await _l(t.all);
                if (b) {
                    const T = S.find(I => I.id === b);
                    if (!T) throw new Error(`Watchlist id: ${b} not found`);
                    await t.actions.addPairToWatchlist(T.id, g)
                } else {
                    const T = S.find(I => I.default);
                    T ? await t.actions.addPairToWatchlist(T.id, g) : await t.actions.createWatchlist({
                        visibility: "private",
                        schemaVersion: "1.0.0",
                        name: Zb.name,
                        default: Zb.default,
                        pairs: [g]
                    })
                }
            },
            getAllPairsCount: () => i.pipe(zn(g => g ? g.reduce((b, S) => b + S.pairs.length, 0) : 0)),
            getActiveWatchlist: () => s,
            reorderWatchlistPairs: async (g, b, S) => {
                const T = await _l(t.all);
                if (!T) return;
                const I = T.find(F => F.id === g);
                if (!I || Math.max(b, S) > I.pairs.length) return;
                const N = [...I.pairs], P = N[b];
                P && (N.splice(b, 1), N.splice(S, 0, P)), await t.actions.updatedWatchlist(g, {
                    pairs: N.map(F => ({
                        ...F,
                        type: "dexPair"
                    }))
                })
            }
        }
    }), UXt = pt(fke, ek, (t, e) => {
        const r = t(), n = e.getActiveWatchlist().pipe(j0(a => !!a), zn(a => ({
            id: a.id,
            pairs: a.pairs.map(o => ({chainId: o.chainId, pairId: o.pairId}))
        })), op(), Xa), i = () => {
            const a = n.subscribe({
                next: o => {
                    if (o.pairs.length === 0) {
                        r.subscribe(void 0);
                        return
                    }
                    r.subscribe({ids: o.pairs.map(s => ({id: s.pairId, chainId: s.chainId}))})
                }
            });
            return () => a.unsubscribe()
        };
        return {status: r.status, data: r.data, activeWatchlist: n, connect: i}
    }), sm = ({
                  number: t,
                  prefix: e,
                  suffix: r,
                  min001: n,
                  min01: i,
                  min1: a,
                  significantDigits: o,
                  maxDecimalPrecision: s,
                  addCommas: l,
                  largeNumberSuffix: f,
                  maxZeroes: d,
                  containerProps: p,
                  zeroIndicatorTextProps: g
              }) => {
        const b = Jv({
            number: t,
            min001: n,
            min01: i,
            min1: a,
            significantDigits: o,
            maxDecimalPrecision: s,
            addCommas: l,
            largeNumberSuffix: f
        });
        if (d) {
            const S = b.match(new RegExp(`0\\.(0{${d},})(\\d+)`));
            if (S && S[1] && S[2]) return ie.jsxs(ln, {
                as: "span",
                title: `${e ?? ""}${b}${r ?? ""}`, ...p,
                children: [e, "0.0", ie.jsx(ln, {
                    as: "span",
                    pos: "relative",
                    fontFamily: "mono",
                    fontSize: "0.8em",
                    top: "0.2em",
                    px: "0.2em", ...g,
                    children: S[1].length
                }), S[2], r]
            })
        }
        return b === "<0.01" ? ie.jsxs(ie.Fragment, {children: ["<", e, "0.01", r]}) : b === "<0.1" ? ie.jsxs(ie.Fragment, {children: ["<", e, "0.1", r]}) : b === "<1" ? ie.jsxs(ie.Fragment, {children: ["<", e, "1", r]}) : ie.jsxs(ie.Fragment, {children: [e, b, r]})
    }, jXt = (t, e) => ie.jsx(sm, {...pO, number: t, ...e}),
    Arr = (t, e, r) => ie.jsx(sm, {...MG, number: t, suffix: e ? ` ${e}` : void 0, ...r}), Irr = (t, e) => ie.jsx(sm, {
        number: t,
        min1: !0,
        prefix: "$",
        significantDigits: {lt1: 2, gte1: 0},
        largeNumberSuffix: {
            threshold: "thousand",
            significantDigits: r => r.gte(1e9) ? 2 : r.lt(1e4) || r.gte(1e6) ? 1 : 0
        },
        addCommas: !0, ...e
    }), krr = (t, e) => ie.jsx(sm, {
        number: t,
        prefix: "$",
        significantDigits: r => r.gte(10) ? 0 : 2,
        largeNumberSuffix: {threshold: "ten-thousand", significantDigits: 1},
        maxDecimalPrecision: r => r.lt(1e4) ? 2 : 1,
        addCommas: !0,
        min01: !0, ...e
    }), Rrr = (t, e) => ie.jsx(sm, {
        number: t,
        min1: !0,
        prefix: "$",
        significantDigits: {lt1: 4, gte1: 0},
        largeNumberSuffix: {
            threshold: "thousand",
            significantDigits: r => r.gte(1e9) ? 2 : r.lt(1e4) || r.gte(1e6) ? 1 : 0
        },
        addCommas: !0, ...e
    }), Drr = (t, e) => ie.jsx(sm, {
        number: t,
        min1: !0,
        prefix: "$",
        significantDigits: {lt1: 2, gte1: 0},
        largeNumberSuffix: {
            threshold: "thousand",
            significantDigits: r => r.gte(1e9) ? 2 : r.lt(1e4) || r.gte(1e6) ? 1 : 0
        },
        addCommas: !0, ...e
    }), Mrr = (t, e, r) => ie.jsx(sm, {
        number: t,
        suffix: e ? ` ${e}` : void 0,
        significantDigits: n => n.lt(1) ? 4 : n.lt(1e4) ? 2 : 0,
        largeNumberSuffix: {threshold: "billion", significantDigits: 2},
        addCommas: !0,
        maxZeroes: 5, ...r
    }), Orr = (t, e) => ie.jsx(sm, {
        number: t,
        significantDigits: r => r.gte(10) ? 0 : 2,
        largeNumberSuffix: {threshold: "ten-thousand", significantDigits: 1},
        maxDecimalPrecision: r => r.lt(1e4) ? 2 : 1,
        addCommas: !0,
        min001: !0, ...e
    }), Prr = (t, e) => ie.jsx(sm, {
        number: t,
        significantDigits: 0,
        largeNumberSuffix: {threshold: "thousand", significantDigits: 0},
        maxDecimalPrecision: 0,
        addCommas: !0, ...e
    }), Nrr = (t, e) => ie.jsx(sm, {number: t, significantDigits: 2, maxDecimalPrecision: 2, ...e}),
    Lrr = (t, e) => t === "near" ? e.replace(".near", "").slice(0, 6) : e.slice(-6), zXt = (t, e) => {
        if (t && t[0] && t[1]) {
            const r = t[0], n = t[1];
            return n.toLowerCase().startsWith("0x") && n.length >= 42 || e.isChainAndDEX && !n.startsWith("f:") && n.match(/.+/) || r === "aptos" && !n.startsWith("f:") && n.match(/-/) || (r === "solana" || r === "solanadevnet") && !n.startsWith("f:") && n.length >= 32 || r === "near" && !n.startsWith("f:") && n.match(/-/) || r === "injective" && (n.startsWith("inj1") || n.startsWith("factory-")) || r === "sei" && (n.startsWith("sei1") || n.startsWith("factory-") || n.startsWith("ibc") || n === "usei") || r === "venom" && n.startsWith("0:") || ["multiversx", "sui", "injective", "ton", "algorand", "icp", "flow"].includes(r) && !e.dexes.includes(n) && !n.startsWith("f:") ? {
                platformId: r,
                pairAddress: n
            } : void 0
        } else return
    }, VXt = _.object({previousPaths: _.array(_.string())}), B1 = () => {
        const t = VXt.safeParse(Oo().state), e = t.success ? t.data.previousPaths : Wd, r = ss(e),
            n = W.useCallback(o => [o, ...r.current], [r]), i = W.useCallback(() => r.current.slice(1), [r]),
            a = W.useCallback(o => [o, ...r.current.slice(1)], [r]);
        return {paths: e, latest: e[0], first: e[e.length - 1], addNewPath: n, removeLatest: i, replaceLatest: a}
    }, Lw = "/search", Gke = () => {
        const t = C1(), e = ss(Oo()), {latest: r, addNewPath: n, replaceLatest: i} = B1(), a = ss(r);
        return W.useCallback(o => {
            var g, b, S;
            const s = `${e.current.pathname}${e.current.search}`,
                l = ((g = a.current) == null ? void 0 : g.startsWith(Lw)) ?? !1, f = new URLSearchParams;
            o.query !== "" && f.set("q", o.query), ((b = o.filters) == null ? void 0 : b.moonshot) === !0 && f.set("ms", "1");
            const d = f.size === 0 ? Lw : `${Lw}?${f.toString()}`, p = l ? i(s) : n(s);
            t(d, {
                replace: l || s === Lw,
                state: {
                    ...e.current.state,
                    previousPaths: p,
                    activeSearch: {
                        query: o.query,
                        filters: {moonshot: ((S = o.filters) == null ? void 0 : S.moonshot) === !0}
                    }
                }
            })
        }, [e, a, i, n, t])
    }, HXt = _.object({
        activeSearch: _.object({
            query: _.string(),
            filters: _.object({moonshot: _.boolean().optional()}).optional()
        })
    }), WXt = _.object({q: _.string().optional(), ms: _.preprocess(fO.stringToBoolean, _.boolean().optional())}),
    Brr = () => {
        const t = Oo(), e = HXt.safeParse(t.state);
        if (e.success) return e.data.activeSearch;
        const r = Object.fromEntries(new URLSearchParams(t.search).entries()), n = WXt.safeParse(r);
        if (n.success && n.data.q) return {query: n.data.q, filters: {moonshot: n.data.ms === !0}};
        if (t.pathname === Lw) return {query: ""}
    }, $rr = () => {
        const t = C1(), e = ss(Oo()), {paths: r} = B1(), n = ss(r);
        return W.useCallback(() => {
            const i = n.current.filter(o => o.startsWith(Lw) !== !0), a = i[0];
            t(a ?? "/", {state: {...e.current.state, activeSearch: void 0, previousPaths: i.slice(1)}})
        }, [n, t, e])
    }, qXt = (t, e) => r => {
        const n = r.toString();
        if (n === "") return;
        const i = decodeURIComponent(n), a = pX.parse(i, e ?? {strictNullHandling: !0, ignoreQueryPrefix: !0, comma: !0}),
            o = t.safeParse(a);
        if (o.success) return o.data
    }, GXt = t => e => pX.stringify(e, t ?? {encodeValuesOnly: !0, strictNullHandling: !0, arrayFormat: "comma"}),
    KXt = t => t.filter(e => e !== ""), YXt = t => Array.isArray(t) ? t.map(e => String(e)) : [String(t)],
    en = O0(_.coerce.number().optional(), void 0),
    _ve = O0(_.preprocess(YXt, _.array(_.string()).transform(KXt)).optional(), void 0), XXt = _.object({
        rankBy: O0(_.string().optional(), void 0),
        order: O0(_.union([_.literal("asc"), _.literal("desc")]).optional(), void 0),
        chainIds: _ve,
        dexIds: _ve,
        minLiq: en,
        maxLiq: en,
        minMarketCap: en,
        maxMarketCap: en,
        minFdv: en,
        maxFdv: en,
        minAge: en,
        maxAge: en,
        min24HTxns: en,
        max24HTxns: en,
        min6HTxns: en,
        max6HTxns: en,
        min1HTxns: en,
        max1HTxns: en,
        min5MTxns: en,
        max5MTxns: en,
        min24HBuys: en,
        max24HBuys: en,
        min6HBuys: en,
        max6HBuys: en,
        min1HBuys: en,
        max1HBuys: en,
        min5MBuys: en,
        max5MBuys: en,
        min24HSells: en,
        max24HSells: en,
        min6HSells: en,
        max6HSells: en,
        min1HSells: en,
        max1HSells: en,
        min5MSells: en,
        max5MSells: en,
        min24HVol: en,
        max24HVol: en,
        min6HVol: en,
        max6HVol: en,
        min1HVol: en,
        max1HVol: en,
        min5MVol: en,
        max5MVol: en,
        min24HChg: en,
        max24HChg: en,
        min6HChg: en,
        max6HChg: en,
        min1HChg: en,
        max1HChg: en,
        min5MChg: en,
        max5MChg: en,
        minMoonshotProgress: en,
        maxMoonshotProgress: en
    }), QXt = qXt(XXt), Frr = GXt(), vre = t => {
        var e, r, n, i, a, o, s, l, f, d, p, g, b, S, T, I, N, P, F, V, Y, ee, oe, G, J, ce, re, M, D, x, A, B, z, j, $, C,
            R, k, Q, fe, ye, ue, me, Se, Ce, Me, ve, ne, be, Ee, Oe, ze, Be, it, Ue, bt, gt, Ot, zt, _t, Dt, rr, pe, te, X,
            H, U, q, le, xe, Ae, De, Ze, ft, ht, cr, Rt, Gt, sn, Yr, br, hn, En, _r, _n, Nr, mr, fn, Hn, Cr, An, pn, wr, ke,
            st, ot, xt, Yt, vr, Vr, Ur, fi, In, kn, Ai, Fi, Pt, Wn, Da, Ma, Oa, Za, Po, Ja, qi, Ko, Pa, Dl, df, hf, Yo, Ml,
            us, Ol, Pl, Nl, fs, lh, Ll, Bl, uh, $l, Bn, $n, Eu, pf, Lr, Yc, Va, Xc, fc, No, Ii, Fn;
        if (t) return kf({
            rankBy: (e = t.rankBy) == null ? void 0 : e.key,
            order: (r = t.rankBy) == null ? void 0 : r.order,
            chainIds: (n = t.filters) == null ? void 0 : n.chainIds,
            dexIds: (i = t.filters) == null ? void 0 : i.dexIds,
            minLiq: (o = (a = t.filters) == null ? void 0 : a.liquidity) == null ? void 0 : o.min,
            maxLiq: (l = (s = t.filters) == null ? void 0 : s.liquidity) == null ? void 0 : l.max,
            minMarketCap: (d = (f = t.filters) == null ? void 0 : f.marketCap) == null ? void 0 : d.min,
            maxMarketCap: (g = (p = t.filters) == null ? void 0 : p.marketCap) == null ? void 0 : g.max,
            minFdv: (S = (b = t.filters) == null ? void 0 : b.fdv) == null ? void 0 : S.min,
            maxFdv: (I = (T = t.filters) == null ? void 0 : T.fdv) == null ? void 0 : I.max,
            minAge: (P = (N = t.filters) == null ? void 0 : N.pairAge) == null ? void 0 : P.min,
            maxAge: (V = (F = t.filters) == null ? void 0 : F.pairAge) == null ? void 0 : V.max,
            min24HTxns: (oe = (ee = (Y = t.filters) == null ? void 0 : Y.txns) == null ? void 0 : ee.h24) == null ? void 0 : oe.min,
            max24HTxns: (ce = (J = (G = t.filters) == null ? void 0 : G.txns) == null ? void 0 : J.h24) == null ? void 0 : ce.max,
            min6HTxns: (D = (M = (re = t.filters) == null ? void 0 : re.txns) == null ? void 0 : M.h6) == null ? void 0 : D.min,
            max6HTxns: (B = (A = (x = t.filters) == null ? void 0 : x.txns) == null ? void 0 : A.h6) == null ? void 0 : B.max,
            min1HTxns: ($ = (j = (z = t.filters) == null ? void 0 : z.txns) == null ? void 0 : j.h1) == null ? void 0 : $.min,
            max1HTxns: (k = (R = (C = t.filters) == null ? void 0 : C.txns) == null ? void 0 : R.h1) == null ? void 0 : k.max,
            min5MTxns: (ye = (fe = (Q = t.filters) == null ? void 0 : Q.txns) == null ? void 0 : fe.m5) == null ? void 0 : ye.min,
            max5MTxns: (Se = (me = (ue = t.filters) == null ? void 0 : ue.txns) == null ? void 0 : me.m5) == null ? void 0 : Se.max,
            min24HBuys: (ve = (Me = (Ce = t.filters) == null ? void 0 : Ce.buys) == null ? void 0 : Me.h24) == null ? void 0 : ve.min,
            max24HBuys: (Ee = (be = (ne = t.filters) == null ? void 0 : ne.buys) == null ? void 0 : be.h24) == null ? void 0 : Ee.max,
            min6HBuys: (Be = (ze = (Oe = t.filters) == null ? void 0 : Oe.buys) == null ? void 0 : ze.h6) == null ? void 0 : Be.min,
            max6HBuys: (bt = (Ue = (it = t.filters) == null ? void 0 : it.buys) == null ? void 0 : Ue.h6) == null ? void 0 : bt.max,
            min1HBuys: (zt = (Ot = (gt = t.filters) == null ? void 0 : gt.buys) == null ? void 0 : Ot.h1) == null ? void 0 : zt.min,
            max1HBuys: (rr = (Dt = (_t = t.filters) == null ? void 0 : _t.buys) == null ? void 0 : Dt.h1) == null ? void 0 : rr.max,
            min5MBuys: (X = (te = (pe = t.filters) == null ? void 0 : pe.buys) == null ? void 0 : te.m5) == null ? void 0 : X.min,
            max5MBuys: (q = (U = (H = t.filters) == null ? void 0 : H.buys) == null ? void 0 : U.m5) == null ? void 0 : q.max,
            min24HSells: (Ae = (xe = (le = t.filters) == null ? void 0 : le.sells) == null ? void 0 : xe.h24) == null ? void 0 : Ae.min,
            max24HSells: (ft = (Ze = (De = t.filters) == null ? void 0 : De.sells) == null ? void 0 : Ze.h24) == null ? void 0 : ft.max,
            min6HSells: (Rt = (cr = (ht = t.filters) == null ? void 0 : ht.sells) == null ? void 0 : cr.h6) == null ? void 0 : Rt.min,
            max6HSells: (Yr = (sn = (Gt = t.filters) == null ? void 0 : Gt.sells) == null ? void 0 : sn.h6) == null ? void 0 : Yr.max,
            min1HSells: (En = (hn = (br = t.filters) == null ? void 0 : br.sells) == null ? void 0 : hn.h1) == null ? void 0 : En.min,
            max1HSells: (Nr = (_n = (_r = t.filters) == null ? void 0 : _r.sells) == null ? void 0 : _n.h1) == null ? void 0 : Nr.max,
            min5MSells: (Hn = (fn = (mr = t.filters) == null ? void 0 : mr.sells) == null ? void 0 : fn.m5) == null ? void 0 : Hn.min,
            max5MSells: (pn = (An = (Cr = t.filters) == null ? void 0 : Cr.sells) == null ? void 0 : An.m5) == null ? void 0 : pn.max,
            min24HVol: (st = (ke = (wr = t.filters) == null ? void 0 : wr.volume) == null ? void 0 : ke.h24) == null ? void 0 : st.min,
            max24HVol: (Yt = (xt = (ot = t.filters) == null ? void 0 : ot.volume) == null ? void 0 : xt.h24) == null ? void 0 : Yt.max,
            min6HVol: (Ur = (Vr = (vr = t.filters) == null ? void 0 : vr.volume) == null ? void 0 : Vr.h6) == null ? void 0 : Ur.min,
            max6HVol: (kn = (In = (fi = t.filters) == null ? void 0 : fi.volume) == null ? void 0 : In.h6) == null ? void 0 : kn.max,
            min1HVol: (Pt = (Fi = (Ai = t.filters) == null ? void 0 : Ai.volume) == null ? void 0 : Fi.h1) == null ? void 0 : Pt.min,
            max1HVol: (Ma = (Da = (Wn = t.filters) == null ? void 0 : Wn.volume) == null ? void 0 : Da.h1) == null ? void 0 : Ma.max,
            min5MVol: (Po = (Za = (Oa = t.filters) == null ? void 0 : Oa.volume) == null ? void 0 : Za.m5) == null ? void 0 : Po.min,
            max5MVol: (Ko = (qi = (Ja = t.filters) == null ? void 0 : Ja.volume) == null ? void 0 : qi.m5) == null ? void 0 : Ko.max,
            min24HChg: (df = (Dl = (Pa = t.filters) == null ? void 0 : Pa.priceChange) == null ? void 0 : Dl.h24) == null ? void 0 : df.min,
            max24HChg: (Ml = (Yo = (hf = t.filters) == null ? void 0 : hf.priceChange) == null ? void 0 : Yo.h24) == null ? void 0 : Ml.max,
            min6HChg: (Pl = (Ol = (us = t.filters) == null ? void 0 : us.priceChange) == null ? void 0 : Ol.h6) == null ? void 0 : Pl.min,
            max6HChg: (lh = (fs = (Nl = t.filters) == null ? void 0 : Nl.priceChange) == null ? void 0 : fs.h6) == null ? void 0 : lh.max,
            min1HChg: (uh = (Bl = (Ll = t.filters) == null ? void 0 : Ll.priceChange) == null ? void 0 : Bl.h1) == null ? void 0 : uh.min,
            max1HChg: ($n = (Bn = ($l = t.filters) == null ? void 0 : $l.priceChange) == null ? void 0 : Bn.h1) == null ? void 0 : $n.max,
            min5MChg: (Lr = (pf = (Eu = t.filters) == null ? void 0 : Eu.priceChange) == null ? void 0 : pf.m5) == null ? void 0 : Lr.min,
            max5MChg: (Xc = (Va = (Yc = t.filters) == null ? void 0 : Yc.priceChange) == null ? void 0 : Va.m5) == null ? void 0 : Xc.max,
            minMoonshotProgress: (No = (fc = t.filters) == null ? void 0 : fc.moonshotProgress) == null ? void 0 : No.min,
            maxMoonshotProgress: (Fn = (Ii = t.filters) == null ? void 0 : Ii.moonshotProgress) == null ? void 0 : Fn.max
        })
    }, Urr = t => {
        if (!t) return;
        const e = vre(t);
        return XP(e, ["chainIds"])
    }, jrr = t => {
        if (!t) return;
        const e = vre(t);
        return XP(e, ["chainIds", "dexIds"])
    }, zrr = t => {
        if (!t) return;
        const e = vre(t);
        return XP(e, ["rankBy", "order"])
    }, ZXt = t => {
        let e;
        t.rankBy && (e = {key: t.rankBy, order: "desc"}), t.order && (e = {key: "txns", ...e, order: t.order});
        const r = {};
        t.chainIds && Wr(r, "chainIds", t.chainIds), t.dexIds && Wr(r, "dexIds", t.dexIds), t.minLiq && Wr(r, "liquidity.min", t.minLiq), t.maxLiq && Wr(r, "liquidity.max", t.maxLiq), t.minMarketCap && Wr(r, "marketCap.min", t.minMarketCap), t.maxMarketCap && Wr(r, "marketCap.max", t.maxMarketCap), t.minFdv && Wr(r, "fdv.min", t.minFdv), t.maxFdv && Wr(r, "fdv.max", t.maxFdv), t.minAge && Wr(r, "pairAge.min", t.minAge), t.maxAge && Wr(r, "pairAge.max", t.maxAge), t.min24HTxns && Wr(r, "txns.h24.min", t.min24HTxns), t.max24HTxns && Wr(r, "txns.h24.max", t.max24HTxns), t.min6HTxns && Wr(r, "txns.h6.min", t.min6HTxns), t.max6HTxns && Wr(r, "txns.h6.max", t.max6HTxns), t.min1HTxns && Wr(r, "txns.h1.min", t.min1HTxns), t.max1HTxns && Wr(r, "txns.h1.max", t.max1HTxns), t.min5MTxns && Wr(r, "txns.m5.min", t.min5MTxns), t.max5MTxns && Wr(r, "txns.m5.max", t.max5MTxns), t.min24HBuys && Wr(r, "buys.h24.min", t.min24HBuys), t.max24HBuys && Wr(r, "buys.h24.max", t.max24HBuys), t.min6HBuys && Wr(r, "buys.h6.min", t.min6HBuys), t.max6HBuys && Wr(r, "buys.h6.max", t.max6HBuys), t.min1HBuys && Wr(r, "buys.h1.min", t.min1HBuys), t.max1HBuys && Wr(r, "buys.h1.max", t.max1HBuys), t.min5MBuys && Wr(r, "buys.m5.min", t.min5MBuys), t.max5MBuys && Wr(r, "buys.m5.max", t.max5MBuys), t.min24HSells && Wr(r, "sells.h24.min", t.min24HSells), t.max24HSells && Wr(r, "sells.h24.max", t.max24HSells), t.min6HSells && Wr(r, "sells.h6.min", t.min6HSells), t.max6HSells && Wr(r, "sells.h6.max", t.max6HSells), t.min1HSells && Wr(r, "sells.h1.min", t.min1HSells), t.max1HSells && Wr(r, "sells.h1.max", t.max1HSells), t.min5MSells && Wr(r, "sells.m5.min", t.min5MSells), t.max5MSells && Wr(r, "sells.m5.max", t.max5MSells), t.min24HVol && Wr(r, "volume.h24.min", t.min24HVol), t.max24HVol && Wr(r, "volume.h24.max", t.max24HVol), t.min6HVol && Wr(r, "volume.h6.min", t.min6HVol), t.max6HVol && Wr(r, "volume.h6.max", t.max6HVol), t.min1HVol && Wr(r, "volume.h1.min", t.min1HVol), t.max1HVol && Wr(r, "volume.h1.max", t.max1HVol), t.min5MVol && Wr(r, "volume.m5.min", t.min5MVol), t.max5MVol && Wr(r, "volume.m5.max", t.max5MVol), t.min24HChg && Wr(r, "priceChange.h24.min", t.min24HChg), t.max24HChg && Wr(r, "priceChange.h24.max", t.max24HChg), t.min6HChg && Wr(r, "priceChange.h6.min", t.min6HChg), t.max6HChg && Wr(r, "priceChange.h6.max", t.max6HChg), t.min1HChg && Wr(r, "priceChange.h1.min", t.min1HChg), t.max1HChg && Wr(r, "priceChange.h1.max", t.max1HChg), t.min5MChg && Wr(r, "priceChange.m5.min", t.min5MChg), t.max5MChg && Wr(r, "priceChange.m5.max", t.max5MChg), t.minMoonshotProgress && Wr(r, "moonshotProgress.min", t.minMoonshotProgress), t.maxMoonshotProgress && Wr(r, "moonshotProgress.max", t.maxMoonshotProgress), t.max5MChg && Wr(r, "batata", t.max5MChg);
        let n;
        return e && (n = {...n, rankBy: e}), Object.keys(r).length > 0 && (n = {...n, filters: r}), n
    }, Vrr = () => {
        const t = Oo(), {paths: e} = B1(), r = e.filter(o => o.startsWith(Lw) === !1)[0],
            i = (r ? new URL(`${window.location.origin}${r}`).search : void 0) ?? t.search;
        return W.useMemo(() => {
            const o = QXt(new URLSearchParams(i));
            return o ? ZXt(o) : void 0
        }, [i])
    }, Md = {"5m": "m5", "1h": "h1", "6h": "h6", "24h": "h24"}, NP = {m5: "5m", h1: "1h", h6: "6h", h24: "24h"}, Sl = "h24",
    jY = "h24", Od = t => ["5m", "1h", "6h", "24h"].includes(t),
    aD = t => t.startsWith("f:") ? t.replace(/^f:/, "") : t, oD = t => {
        if (t.match(/^page-\d+\/?$/) !== null) return Number.parseInt(t.replace("page-", ""), 10)
    }, Kke = (t, e) => {
        const r = e.replace(/^\//, "").replace(/\/$/, "").split("?")[0];
        let n = r === "" || r == null ? void 0 : r.split("/");
        if (Array.isArray(n) && n[0] === "builds" && (n = n.slice(2)), !n || Array.isArray(n) && n.length === 0) return {
            id: "home",
            page: 1,
            timeframe: Sl
        };
        const i = typeof n == "string" ? [n] : n;
        if (i.length === 1 && i[0] === "app-util") return {id: "appUtil"};
        if (i.length === 1 && i[0] === "troubleshooting") return {id: "troubleshooting"};
        if (i.length === 1 && i[0] === "a-ads") return {id: "a-ads"};
        if (i.length === 1 && i[0] === "search") return {id: "home", page: 1, timeframe: Sl};
        const a = oD((i == null ? void 0 : i[0]) ?? ""), o = oD((i == null ? void 0 : i[1]) ?? ""),
            s = oD((i == null ? void 0 : i[2]) ?? ""), l = oD((i == null ? void 0 : i[3]) ?? "");
        if (au(i) && i.length === 1) {
            if (Od(i[0])) return {id: "home", page: 1, timeframe: Md[i[0]]};
            if (a !== void 0) return {id: "home", page: a, timeframe: Sl}
        }
        if (Zg(i) && i.length === 2 && Od(i[0]) && o !== void 0) return {id: "home", page: o, timeframe: Md[i[0]]};
        if (i[0] === "watchlist") {
            if (i.length === 1) return {id: "watchlist", timeframe: Sl};
            if (Zg(i) && i.length === 2 && Od(i[1])) return {id: "watchlist", timeframe: Md[i[1]]};
            if (i.length === 2) return {id: "watchlist", watchlistId: i[1], timeframe: Sl};
            if (L5(i) && i.length === 3 && Od(i[2])) return {id: "watchlist", timeframe: Md[i[2]], watchlistId: i[1]}
        }
        if (i[0] === "moonshot") {
            if (i.length === 1) return {id: "moonshot", page: 1};
            if (i.length === 2 && o !== void 0) return {id: "moonshot", page: o};
            if (i.length === 2 && i[1] === "top") return {id: "moonshotTop", page: 1};
            if (i.length === 3 && i[1] === "top" && s !== void 0) return {id: "moonshotTop", page: s};
            if (i.length === 2 && i[1] === "rising") return {id: "moonshotRising", page: 1};
            if (i.length === 3 && i[1] === "rising" && s !== void 0) return {id: "moonshotRising", page: s};
            if (i.length === 2 && i[1] === "new") return {id: "moonshotNew", page: 1};
            if (i.length === 3 && i[1] === "new" && s !== void 0) return {id: "moonshotNew", page: s};
            if (i.length === 2 && i[1] === "finalized") return {id: "moonshotFinalized", page: 1};
            if (i.length === 3 && i[1] === "finalized" && s !== void 0) return {id: "moonshotFinalized", page: s};
            if (i.length === 2 && i[1] === "my-tokens") return {id: "moonshotMyTokens", page: 1};
            if (i.length === 3 && i[1] === "my-tokens" && s !== void 0) return {id: "moonshotMyTokens", page: s};
            if (i.length === 2 && i[1] === "portfolio") return {id: "moonshotMyPortfolio", page: 1};
            if (i.length === 3 && i[1] === "portfolio" && s !== void 0) return {id: "moonshotMyPortfolio", page: s};
            if (i.length === 2 && i[1] === "launch") return {id: "moonshotLaunch"}
        }
        if (i[0] === "new-pairs") {
            if (i.length === 1) return {id: "newPairs", page: 1, timeframe: jY};
            if (Zg(i) && i.length === 2 && Od(i[1])) return {id: "newPairs", page: 1, timeframe: Md[i[1]]};
            if (Zg(i) && i.length === 2 && o !== void 0) return {id: "newPairs", page: o, timeframe: jY};
            if (L5(i) && i.length === 3 && Od(i[1]) && s !== void 0) return {id: "newPairs", page: s, timeframe: Md[i[1]]}
        }
        if (i[0] === "nanos") {
            if (i.length === 1) return {id: "nanos", page: 1};
            if (Zg(i) && i.length === 2 && o !== void 0) return {id: "nanos", page: o}
        }
        if (i[0] === "gainers" || i[0] === "losers") {
            if (i.length === 1) return {id: i[0], page: 1, timeframe: Sl};
            if (Zg(i) && i.length === 2 && Od(i[1])) return {id: i[0], page: 1, timeframe: Md[i[1]]};
            if (Zg(i) && i.length === 2 && o !== void 0) return {id: i[0], page: o, timeframe: Sl};
            if (L5(i) && i.length === 3 && Od(i[1]) && s !== void 0) return {id: i[0], page: s, timeframe: Md[i[1]]}
        }
        if (i[0] === "multicharts") {
            if (i.length === 1) return {id: "multicharts"};
            if (i.length === 2) return {id: "multicharts", multichartId: i[1]}
        }
        const f = t.find(d => d.slug === i[0]);
        if (f) {
            if (au(i) && i.length === 1) return {id: "platform", platformId: i[0], page: 1, timeframe: Sl};
            if (Zg(i) && i.length === 2) {
                if (Od(i[1])) return {id: "platform", platformId: i[0], page: 1, timeframe: Md[i[1]]};
                if (o) return {id: "platform", platformId: i[0], page: o, timeframe: Sl};
                const d = zXt(i, f);
                return d ? {id: "pairDetail", ...d} : {
                    id: "platform/dex",
                    platformId: i[0],
                    dexId: aD(i[1]),
                    page: 1,
                    timeframe: Sl
                }
            }
            if (L5(i) && i.length === 3 && Od(i[1]) && s) return {
                id: "platform",
                platformId: i[0],
                page: s,
                timeframe: Md[i[1]]
            };
            if (L5(i) && i.length === 3 && o === void 0 && !i[1].toLowerCase().startsWith("0x")) {
                if (Od(i[2])) return {id: "platform/dex", platformId: i[0], dexId: aD(i[1]), timeframe: Md[i[2]], page: 1};
                if (s !== void 0) return {id: "platform/dex", platformId: i[0], dexId: aD(i[1]), page: s, timeframe: Sl}
            }
            if (dze(i) && i.length === 4 && Od(i[2]) && l !== void 0) return {
                id: "platform/dex",
                platformId: i[0],
                dexId: aD(i[1]),
                page: l,
                timeframe: Md[i[2]]
            }
        }
        if (i[0] === "news") {
            if (i.length === 1) return {id: "news"};
            if (i.length === 2) return {id: "news", categorySlug: i[1]}
        }
        if (i[0] === "portfolio") {
            if (i.length === 1) return {id: "portfolio"};
            if (i.length === 2 && i[0] === "portfolio") return {id: "portfolio", address: i[1]}
        }
    },
    JXt = ["moonshot", "moonshotTop", "moonshotRising", "moonshotNew", "moonshotMyTokens", "moonshotMyPortfolio", "moonshotFinalized", "moonshotLaunch"],
    LP = t => JXt.findIndex(e => e === t.id) !== -1,
    eQt = ["moonshot", "moonshotTop", "moonshotRising", "moonshotNew", "moonshotFinalized"],
    Hrr = t => eQt.findIndex(e => e === t.id) !== -1, tQt = t => {
        if (typeof document < "u") {
            const e = Kke(t, document.location.pathname);
            (e == null ? void 0 : e.id) === "pairDetail" && history.replaceState(null, "")
        }
    }, [R3, rQt] = LN("ParsedCatchallRouteContext"),
    nQt = ["gainers", "losers", "newPairs", "moonshot", "moonshotTop", "moonshotRising", "moonshotNew", "moonshotFinalized"],
    Wrr = t => {
        const e = t.page ?? 1, r = e === 1, n = t.customScreenerId === "newPairs" ? jY : Sl, i = t.timeframe ?? n,
            a = i === n;
        if (!t.customScreenerId) {
            const o = [];
            return t.platformId && o.push(t.platformId), t.platformId && t.dexId && o.push(t.dexId), a || o.push(NP[i]), r || o.push(`page-${e}`), `/${o.join("/")}`
        }
        if (nQt.includes(t.customScreenerId)) {
            const o = [];
            return t.customScreenerId === "newPairs" && o.push("new-pairs"), t.customScreenerId === "gainers" && o.push("gainers"), t.customScreenerId === "losers" && o.push("losers"), t.customScreenerId.startsWith("moonshot") && o.push("moonshot"), t.customScreenerId === "moonshotTop" && o.push("top"), t.customScreenerId === "moonshotRising" && o.push("rising"), t.customScreenerId === "moonshotNew" && o.push("new"), t.customScreenerId === "moonshotFinalized" && o.push("finalized"), a || o.push(NP[i]), r || o.push(`page-${e}`), `/${o.join("/")}`
        }
        throw new Error("Unknown screener path")
    }, gre = t => `/${t.platformId}/${t.pairAddress.toLowerCase()}`, qrr = t => {
        const e = t.timeframe ?? Sl, r = e === Sl, n = [];
        return n.push("watchlist"), t.id && n.push(t.id), r || n.push(NP[e]), `/${n.join("/")}`
    }, Grr = t => {
        const e = t.timeframe ?? Sl, r = e === Sl, n = [];
        return n.push("portfolio"), t.address && n.push(t.address), r || n.push(NP[e]), `/${n.join("/")}`
    }, Krr = t => {
        const e = t.page ?? 1;
        switch (t.routeId) {
            case"moonshot":
            default:
                return `/moonshot${e > 1 ? `/page-${e}` : ""}`;
            case"moonshotTop":
                return `/moonshot/top${e > 1 ? `/page-${e}` : ""}`;
            case"moonshotRising":
                return `/moonshot/rising${e > 1 ? `/page-${e}` : ""}`;
            case"moonshotNew":
                return `/moonshot/new${e > 1 ? `/page-${e}` : ""}`;
            case"moonshotMyTokens":
                return `/moonshot/my-tokens${e > 1 ? `/page-${e}` : ""}`;
            case"moonshotMyPortfolio":
                return `/moonshot/portfolio${e > 1 ? `/page-${e}` : ""}`;
            case"moonshotFinalized":
                return `/moonshot/finalized${e > 1 ? `/page-${e}` : ""}`
        }
    }, iQt = _.object({
        activeScreenerPairPlatformId: _.string(),
        activeScreenerPairDexId: _.string(),
        activeScreenerPairAddress: _.string()
    }), Yrr = () => {
        const t = iQt.safeParse(Oo().state);
        if (t.success) return {
            platformId: t.data.activeScreenerPairPlatformId,
            dexId: t.data.activeScreenerPairDexId,
            pairAddress: t.data.activeScreenerPairAddress
        }
    }, Xrr = () => {
        const t = C1(), e = Oo(), r = new URLSearchParams(e.search).toString(), {addNewPath: n} = B1();
        return i => {
            const a = {
                state: {
                    previousPath: e.pathname,
                    previousPaths: n(`${e.pathname}${e.search}`),
                    previousSearch: r,
                    activeScreenerPairPlatformId: i.platformId,
                    activeScreenerPairDexId: i.dexId,
                    activeScreenerPairAddress: i.pairAddress
                }
            };
            t(gre({platformId: i.platformId, pairAddress: i.pairAddress}), a)
        }
    }, Qrr = () => {
        const t = C1(), {latest: e, removeLatest: r} = B1();
        return W.useCallback(() => e && t(e, {state: {previousPaths: r()}}), [t, e, r])
    }, aQt = _.object({
        activePairPlatformId: _.string(),
        activePairAddress: _.string(),
        activePairDexId: _.string().optional()
    }), oQt = () => {
        const t = aQt.safeParse(Oo().state);
        if (t.success) return {
            platformId: t.data.activePairPlatformId,
            dexId: t.data.activePairDexId,
            pairAddress: t.data.activePairAddress
        }
    }, Zrr = () => {
        const t = C1(), e = Oo(), r = new URLSearchParams(e.search).toString(), {addNewPath: n} = B1();
        return i => {
            const a = {
                state: {
                    previousPath: e.pathname,
                    previousPaths: n(`${e.pathname}${e.search}`),
                    previousSearch: r,
                    activePairPlatformId: i.platformId,
                    activePairDexId: i.dexId,
                    activePairAddress: i.pairAddress
                }
            };
            t(gre({platformId: i.platformId, pairAddress: i.pairAddress}), a)
        }
    }, sQt = () => {
        const t = C1(), {latest: e, removeLatest: r} = B1();
        return W.useCallback(() => e && t(e, {state: {previousPaths: r()}}), [e, t, r])
    }, cQt = _.object({activePairAddress: _.string()}), Jrr = () => {
        const t = cQt.safeParse(Oo().state);
        if (t.success) return t.data.activePairAddress
    };

function lQt(t) {
    return (t && t.id === "platform/dex" && t.platformId === "solana" && t.dexId === "null") ?? !1
}

function uQt() {
    return R3(lQt)
}

const fQt = ({value: t, empty: e, colorScheme: r}) => {
        const n = t != null, i = n && t > 0, a = n && t < 0;
        return ie.jsxs("span", {
            className: fv("ds-change-perc", {
                "ds-change-perc-pos": i,
                "ds-change-perc-neg": a,
                "ds-change-perc-accent": r === "accent"
            }),
            children: [n && ie.jsx(ie.Fragment, {
                children: Jv({
                    number: t,
                    suffix: "%",
                    significantDigits: o => o.eq(0) ? 0 : o.abs().lt(100) ? 2 : 0,
                    maxDecimalPrecision: 2,
                    addCommas: !0,
                    largeNumberSuffix: {threshold: "hundred-thousand", significantDigits: 0}
                })
            }), !n && e]
        })
    }, dQt = ["h1", "h24"], Yke = ar.forwardRef(({pair: t, containerProps: e, dragHandleProps: r}, n) => {
        const i = jWt(t.chainId);
        return ie.jsxs(Gn, {
            ref: n,
            display: "flex",
            alignItems: "stretch", ...e,
            children: [ie.jsx(cu, {
                variant: "unstyled",
                minW: "22px",
                ml: 1,
                mr: 1,
                pt: "3px",
                h: "auto",
                borderRadius: "none",
                "aria-label": "Drag to re-order",
                icon: ie.jsx(Wi, {as: PKt}),
                cursor: "move",
                _focus: {boxShadow: "none"}, ...r
            }), ie.jsxs(ZI, {
                flex: 1,
                to: gre({platformId: t.chainId, pairAddress: t.pairAddress}),
                display: "block",
                pr: 3,
                py: 1.5,
                fontSize: {base: "md", lg: "11px"},
                color: "blue.175",
                _hover: {textDecor: "none"},
                children: [ie.jsxs(ln, {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: {base: "flex-start", lg: "space-between"},
                    children: [ie.jsx(ln, {
                        as: "span",
                        fontSize: "sm",
                        fontWeight: "semibold",
                        title: `${t.baseToken.name} - ${t.baseToken.symbol} / ${t.quoteTokenSymbol} (${i})`,
                        wordBreak: "break-all",
                        noOfLines: 1,
                        children: t.baseToken.symbol
                    }), ie.jsx(ln, {
                        as: "span",
                        fontSize: {base: "md", lg: "12px"},
                        fontWeight: "semibold",
                        color: "blue.175",
                        ml: {base: 3, lg: 0},
                        children: t.priceUsd && jXt(t.priceUsd)
                    })]
                }), ie.jsx(dL, {
                    whiteSpace: "nowrap",
                    overflow: "hidden",
                    justify: {lg: "space-between"},
                    children: dQt.map(a => ie.jsxs(Gn, {
                        minW: "60px",
                        w: {base: "50%", lg: "auto"},
                        textAlign: {base: a === "h24" ? "right" : void 0},
                        children: [ie.jsxs(ln, {
                            as: "span",
                            color: "blue.500",
                            mr: 1,
                            children: [i_e[a].shorthand, ":"]
                        }), t.priceChange[a] !== void 0 && ie.jsx(fQt, {value: t.priceChange[a]}), t.priceChange[a] === void 0 && ie.jsx(ln, {
                            as: "span",
                            color: "blue.500",
                            children: "N/A"
                        })]
                    }, a))
                })]
            })]
        })
    }), hQt = ({id: t, pair: e}) => {
        const {attributes: r, listeners: n, setNodeRef: i, transform: a, transition: o, isDragging: s} = BXt({id: t}),
            l = {transform: d1.Transform.toString(a), transition: o};
        return ie.jsx(Gn, {
            ref: i,
            style: l,
            _hover: s ? void 0 : {"@media (hover: hover)": {bg: "blue.950"}},
            visibility: s ? "hidden" : void 0,
            children: ie.jsx(Yke, {
                pair: e,
                dragHandleProps: {color: "blue.850", _hover: {color: "blue.600"}, sx: {touchAction: "none"}, ...r, ...n}
            })
        })
    }, pQt = () => {
        const t = aa(UXt), [e, r] = W.useState(XT);
        return yZ(() => Qy([t.activeWatchlist, t.data]).pipe(Zy(([n, i]) => {
            r(a => {
                switch (a.kind) {
                    case"AsyncPendingWithData":
                    case"AsyncSuccess":
                        return a.value.activeWatchlist.id !== n.id && n.pairs.length > 0 ? XT : n.pairs.length === 0 ? Rj({
                            activeWatchlist: n,
                            data: []
                        }) : Rj({activeWatchlist: n, data: i});
                    case"AsyncPending":
                        return Rj({activeWatchlist: n, data: i});
                    default:
                        return XT
                }
            })
        })), [t]), W.useEffect(() => t.connect(), [t]), {data: e}
    }, xve = ({children: t}) => ie.jsx(ln, {
        as: "span",
        display: "block",
        mt: 3,
        px: 3,
        fontSize: {base: "sm", lg: "11px"},
        color: "gray.650",
        children: t
    }), Xke = (t, e) => t.find(r => r.chainId === e.chainId && r.pairAddress.toLowerCase() === e.pairId.toLowerCase()),
    mQt = (t, e) => t.map(r => Xke(e, r)).filter(r => !!r), vQt = ({activeList: t, pairs: e}) => {
        const r = aa(XE), n = NJ(), i = aa(ek), [a, o] = W.useState(), s = W.useCallback(p => {
            r.track({event: "watchlist:nav:dnd"});
            const [g, b] = p.active.id.split(":");
            g !== void 0 && b !== void 0 && o({chainId: g, pairId: b})
        }, [r]), l = W.useCallback(async p => {
            if (o(void 0), !(!t || !p.over) && p.active.id !== p.over.id) {
                const g = t.pairs.findIndex(S => {
                    const [T, I] = p.active.id.split(":");
                    return S.chainId === T && S.pairId === I
                }), b = t.pairs.findIndex(S => {
                    if (!p.over) return !1;
                    const [T, I] = p.over.id.split(":");
                    return S.chainId === T && S.pairId === I
                });
                try {
                    await i.reorderWatchlistPairs(t.id, g, b)
                } catch (S) {
                    n({status: "error", title: "Failed reordering list", description: $f(S).message})
                }
            }
        }, [i, t]), f = a ? Xke(e, a) : void 0, d = mQt(t.pairs, e);
        return {draggedPair: f, dragStart: s, dragEnd: l, orderedPairs: d}
    }, gQt = t => {
        const {draggedPair: e, dragEnd: r, dragStart: n, orderedPairs: i} = vQt(t), {activeList: a} = t,
            o = nXt(gve(pre), gve(dre, {coordinateGetter: FXt}));
        return ie.jsxs(hXt, {
            sensors: o,
            collisionDetection: Pke,
            onDragStart: n,
            onDragEnd: r,
            modifiers: [TXt, EXt],
            children: [ie.jsx(kXt, {
                items: (a == null ? void 0 : a.pairs.map(s => ({id: `${s.chainId}:${s.pairId}`}))) ?? [],
                strategy: AXt,
                children: ie.jsx(Dy, {
                    alignItems: "stretch",
                    spacing: 0,
                    sx: {"> a:not(:first-of-type)": {borderTopWidth: 1, borderColor: "gray.925"}},
                    userSelect: "none",
                    children: i.map(s => ie.jsx(hQt, {
                        id: `${s.chainId}:${s.pairAddress}`,
                        pair: s
                    }, `${s.chainId}:${s.pairAddress}`))
                })
            }), ie.jsx(_Xt, {
                children: e && ie.jsx(Yke, {
                    pair: e,
                    containerProps: {
                        zIndex: "10",
                        bg: "blue.900",
                        outline: {base: "1px solid", lg: "none"},
                        outlineColor: "blue.700"
                    },
                    dragHandleProps: {color: "blue.300"}
                })
            })]
        })
    }, yQt = () => {
        const {data: t} = pQt();
        return Py({
            value: t,
            onFailure: () => ie.jsx(xve, {children: "Error loading watchlist"}),
            onPending: () => ie.jsx(_B, {label: null, size: "xs", mt: 3, mx: 3}),
            onSuccess: ({activeWatchlist: e, data: r}) => ie.jsxs(Gn, {
                mt: {base: 2, lg: 0},
                mb: {lg: r.length ? 4 : void 0},
                children: [r.length === 0 && ie.jsx(xve, {children: "Nothing in this list yet..."}), r.length > 0 && ie.jsx(gQt, {
                    activeList: e,
                    pairs: r
                })]
            })
        })
    }, enr = t => t.length > 10 ? t.slice(0, 5) + "..." + t.slice(-4) : t,
    Eve = (t, e) => t && nbe(t, {length: e, omission: "…"});
Kn.clone({DECIMAL_PLACES: 50});
const tnr = (t, e) => {
    const r = Js(t), n = Js(e);
    return r.multipliedBy(100).dividedBy(n)
}, bQt = ({
              modalProps: t,
              message: e,
              confirmButtonProps: r,
              onConfirm: n,
              onCancel: i
          }) => ie.jsxs(dI, {
    motionPreset: "none",
    isCentered: !0, ...t,
    blockScrollOnMount: !1,
    isOpen: !0,
    children: [ie.jsx(pI, {}), ie.jsxs(hI, {
        children: [ie.jsx(vI, {}), ie.jsx(mI, {
            p: 0,
            children: ie.jsx(ln, {px: 5, pt: "60px", pb: "40px", textAlign: "center", children: e})
        }), ie.jsxs(u5e, {
            children: [ie.jsx(Hc, {
                onClick: () => {
                    n(), t.onClose()
                }, colorScheme: "red", mr: 3, ...r, children: "Confirm"
            }), ie.jsx(Hc, {onClick: i, variant: "outline", children: "Cancel"})]
        })]
    })]
}), wQt = () => {
    const t = aa(ek);
    return ZE(() => t.all, [t.all])
}, SQt = () => {
    const t = aa(ek);
    return ZE(() => t.allRemote, [t.allRemote])
}, _Qt = ({onClose: t}) => {
    const e = aa(XE),
        r = NJ(), {colorMode: n} = S1(), [i, a] = W.useState(null), [o, s] = W.useState(null), [l, f] = W.useState(!1),
        p = aa(T5e).actions, g = Py({value: wQt(), onPending: () => [], onFailure: () => [], onSuccess: V => V}),
        b = SQt(), S = Py({value: b, onPending: () => [], onFailure: () => [], onSuccess: V => V}), T = async V => {
            e.track({event: "watchlist:createList"}), f(!0);
            try {
                await p.createWatchlist({
                    schemaVersion: "1.0.0",
                    name: V,
                    default: !1,
                    pairs: [],
                    visibility: "private"
                }), a(null), r({status: "success", title: "List created!"})
            } catch (Y) {
                r({status: "error", title: "Failed creating list", description: $f(Y).message})
            }
            f(!1)
        }, I = V => {
            if (!l) {
                if (V.preventDefault(), !i || !i.trim()) {
                    r({status: "error", title: "List must have a valid name"});
                    return
                }
                if (g.find(Y => Y.name.trim() === i.trim())) {
                    r({status: "error", title: "There's already a watchlist with that name"});
                    return
                }
                T(i)
            }
        }, N = async (V, Y) => {
            const ee = S.find(oe => oe.id === V);
            try {
                ee ? await p.renameWatchlist(V, Y) : await p.createWatchlist({
                    visibility: "private",
                    schemaVersion: "1.0.0",
                    name: Y,
                    default: !0,
                    pairs: []
                }), a(null)
            } catch (oe) {
                r({status: "error", title: "Failed renaming list", description: $f(oe).message})
            }
        }, P = V => {
            V && V.preventDefault(), !((o == null ? void 0 : o.action) !== "edit" || !(o != null && o.name) || !o.name.trim()) && (N(o.id, o.name), s(null))
        }, F = async V => {
            e.track({event: "deleteWatchlist"});
            try {
                await p.deleteWatchlist(V)
            } catch (Y) {
                r({status: "error", title: "Failed deleting list", description: $f(Y).message})
            }
            s(null)
        };
    return ie.jsxs(ie.Fragment, {
        children: [ie.jsxs(dI, {
            size: "3xl",
            onClose: t,
            scrollBehavior: "inside",
            closeOnEsc: !o,
            motionPreset: "none",
            blockScrollOnMount: !1,
            isOpen: !0,
            children: [ie.jsx(pI, {}), ie.jsxs(hI, {
                children: [ie.jsx(vI, {}), ie.jsx(f5e, {
                    children: ie.jsx(i1, {
                        size: "md",
                        children: "Manage My Lists"
                    })
                }), ie.jsxs(mI, {
                    p: 0,
                    sx: {pt: "0 !important"},
                    children: [ie.jsx(Gn, {
                        pos: "sticky",
                        top: 0,
                        zIndex: "sticky",
                        bg: hS("white", "gray.875"),
                        p: 5,
                        borderBottomWidth: 1,
                        borderBottomColor: hS("gray.75", "gray.800"),
                        children: ie.jsxs(Gn, {
                            as: "form",
                            onSubmit: I,
                            display: "flex",
                            alignItems: "center",
                            children: [ie.jsx(LA, {
                                value: i ?? "",
                                onChange: V => a(V.target.value),
                                placeholder: "New List",
                                fontSize: {base: "16px", lg: "1em"},
                                maxLength: 60,
                                autoFocus: !0,
                                _placeholder: {fontSize: "md"}
                            }), ie.jsx(Hc, {
                                isLoading: l,
                                type: "submit",
                                ml: 2,
                                flexShrink: 0,
                                colorScheme: "green",
                                leftIcon: ie.jsx(Wi, {as: $Kt}),
                                children: "Create list"
                            })]
                        })
                    }), ie.jsx(Dy, {
                        spacing: 3, align: "stretch", p: 5, children: g.map(V => ie.jsxs(Gn, {
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "space-between",
                            borderWidth: 1,
                            borderColor: Ms("gray.50", "gray.925", n),
                            p: 3,
                            minH: "75px",
                            bg: Ms("gray.50", "gray.925", n),
                            borderRadius: "md",
                            children: [ie.jsxs(Gn, {
                                flex: 1,
                                mr: 5,
                                children: [(!o || o.action !== "edit" || o.action === "edit" && o.id !== V.id) && ie.jsxs(ie.Fragment, {
                                    children: [ie.jsx(ln, {
                                        as: "span",
                                        display: "block",
                                        wordBreak: "break-word",
                                        children: V.name
                                    }), ie.jsxs(ln, {
                                        as: "span",
                                        display: "block",
                                        mt: 2,
                                        fontSize: "sm",
                                        color: Ms("gray.400", "gray.500", n),
                                        children: [V.pairs.length === 0 && "Empty", V.pairs.length === 1 && "1 pair", V.pairs.length > 1 && `${V.pairs.length} pairs`, V.pairs.length > 0 && V.updatedAt && ie.jsxs(ie.Fragment, {children: [", updated ", YVe(V.updatedAt), " ago"]})]
                                    })]
                                }), o && o.action === "edit" && o.id === V.id && ie.jsx(Gn, {
                                    as: "form",
                                    onSubmit: P,
                                    children: ie.jsx(LA, {
                                        value: o.name,
                                        onChange: Y => s({action: "edit", id: o.id, name: Y.target.value}),
                                        onKeyDown: Y => {
                                            Y.key === "Escape" && s(null)
                                        },
                                        fontSize: {base: "16px", lg: "1em"},
                                        maxLength: 60,
                                        autoFocus: !0
                                    })
                                })]
                            }), !((o == null ? void 0 : o.action) === "edit" && o.id === V.id) && ie.jsxs(Gn, {
                                display: "flex",
                                alignItems: "center",
                                children: [ie.jsx(cu, {
                                    onClick: () => s({action: "edit", id: V.id, name: V.name}),
                                    variant: "link",
                                    minW: "auto",
                                    p: 2,
                                    pos: "relative",
                                    top: "1px",
                                    title: "Rename list",
                                    "aria-label": "Rename list",
                                    icon: ie.jsx(Wi, {as: BKt}),
                                    _hover: {color: Ms("accent.500", "accent.400", n)}
                                }), !V.default && ie.jsx(cu, {
                                    onClick: () => s({
                                        action: "delete",
                                        id: V.id,
                                        name: V.name
                                    }),
                                    ml: 1,
                                    variant: "link",
                                    minW: "auto",
                                    p: 2,
                                    title: "Delete list",
                                    "aria-label": "Delete list",
                                    icon: ie.jsx(Wi, {as: jKt}),
                                    _hover: {color: Ms("red.500", "red.400", n)}
                                })]
                            }), o && o.action === "edit" && o.id === V.id && ie.jsxs(Gn, {
                                display: "flex",
                                alignItems: "center",
                                children: [ie.jsx(cu, {
                                    onClick: () => s(null),
                                    variant: "link",
                                    minW: "auto",
                                    p: 2,
                                    pos: "relative",
                                    top: "1px",
                                    title: "Cancel",
                                    "aria-label": "Cancel",
                                    icon: ie.jsx(Wi, {as: bke})
                                }), ie.jsx(cu, {
                                    onClick: () => P(),
                                    ml: 1,
                                    variant: "link",
                                    minW: "auto",
                                    p: 2,
                                    title: "Confirm",
                                    "aria-label": "Confirm",
                                    icon: ie.jsx(Wi, {as: RKt}),
                                    _hover: {color: "green.500"}
                                })]
                            })]
                        }, V.id))
                    })]
                })]
            })]
        }), o && o.action === "delete" && ie.jsx(bQt, {
            modalProps: {onClose: () => s(null)},
            message: `Are you sure you want to delete the list "${o.name}"?`,
            onConfirm: () => F(o.id),
            onCancel: () => s(null)
        })]
    })
}, xQt = ({onOpenManager: t}) => {
    const [e, r] = W.useState({isOpen: !1});
    return ie.jsxs(ie.Fragment, {
        children: [ie.jsx(nee, {
            children: ie.jsx(X6e, {
                onClick: () => {
                    t ? t() : r({isOpen: !0})
                },
                closeOnSelect: !0,
                children: ie.jsxs(ln, {
                    as: "span",
                    w: "100%",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    children: [ie.jsx(Wi, {boxSize: "16px", as: OKt, mr: 2}), ie.jsx(ln, {
                        as: "span",
                        children: "Manage my lists"
                    })]
                })
            })
        }), e.isOpen && ie.jsx(_Qt, {onClose: () => r({isOpen: !1})})]
    })
}, EQt = () => {
    const t = aa(SB), e = aa(ek), r = BA({lg: !0}, {ssr: !1}) ?? !1,
        n = ZE(() => Qy([t.all, e.all, e.getActiveWatchlist()]).pipe(zn(([a, o, s]) => ({
            activeList: s,
            isLargeScreen: r,
            lists: o,
            size: a.watchlistsSize
        }))), [t, e, r]);
    return {
        changeActiveList: W.useCallback(a => {
            const o = _.string().safeParse(a);
            o.success && t.setActiveWatchlist(o.data)
        }, [t]), state: n
    }
}, TQt = () => {
    const t = EQt();
    return Py({
        value: t.state, onFailure: () => null, onPending: () => ie.jsx(_B, {}), onSuccess: e => {
            const {changeActiveList: r} = t, {activeList: n, isLargeScreen: i, lists: a, size: o} = e;
            return ie.jsx(Gn, {
                display: "flex",
                children: ie.jsxs(G6e, {
                    strategy: "fixed",
                    placement: i ? "right-start" : void 0,
                    children: [ie.jsx(J6e, {
                        as: Hc,
                        variant: "unstyled",
                        size: i ? o !== "expanded" ? "xs" : "sm" : "lg",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "flex-start",
                        bg: "transparent",
                        color: "blue.300",
                        textAlign: "left",
                        fontWeight: "normal",
                        pl: 3,
                        minH: {base: "auto", lg: "26px"},
                        h: {base: "24px", lg: "auto"},
                        borderRadius: "none",
                        w: "100%",
                        rightIcon: ie.jsx(Wi, {as: DKt}),
                        _hover: {bg: "blue.950", color: "blue.200"},
                        _active: {bg: "blue.900", color: "white"},
                        _focus: {boxShadow: "none"},
                        sx: {"> span": {flex: "initial"}},
                        children: Eve(n == null ? void 0 : n.name, 15)
                    }), ie.jsx(GS, {
                        children: ie.jsxs(Q6e, {
                            zIndex: "overlay",
                            overflowX: "hidden",
                            overflowY: "auto",
                            maxH: "300px",
                            children: [ie.jsx(Z6e, {
                                onChange: r,
                                value: n == null ? void 0 : n.id,
                                children: a.map(s => ie.jsx(iee, {value: s.id, children: Eve(s.name, 30)}, s.id))
                            }), ie.jsx(e5e, {}), ie.jsx(xQt, {})]
                        })
                    })]
                })
            })
        }
    })
}, CQt = () => {
    const t = aa(XE), e = aa(SB), r = BA({lg: !0}, {ssr: !1}) ?? !1, n = ZE(() => e.all.pipe(zn(o => {
        const s = o.watchlistsSize, l = s !== "minimized" || !r;
        return {
            areWatchlistPairsDisplayed: l,
            isMinimizeButtonDisabled: s === "minimized",
            isWatchlistExpanded: s === "expanded",
            isWatchlistPickerDisplayed: l,
            size: s
        }
    })), [e, r]), i = W.useCallback(() => {
        e.setWatchlistSize("minimized"), t.track({event: "watchlist:nav:minimize"})
    }, [t, e]), a = W.useCallback(() => {
        if (n.kind !== "AsyncSuccess") return;
        const {size: o} = n.value;
        o === "default" ? (t.track({event: "watchlist:nav:expand"}), e.setWatchlistSize("expanded")) : (o === "expanded" || o === "minimized") && e.setWatchlistSize("default")
    }, [t, n, e]);
    return {state: n, minimize: i, toggleExpand: a}
}, AQt = {default: xKt, expanded: EKt, minimized: TKt}, IQt = () => {
    const t = CQt();
    return Py({
        value: t.state, onFailure: () => null, onPending: () => ie.jsx(fYt, {}), onSuccess: e => {
            const {minimize: r, toggleExpand: n} = t, {
                areWatchlistPairsDisplayed: i,
                isMinimizeButtonDisabled: a,
                isWatchlistExpanded: o,
                isWatchlistPickerDisplayed: s,
                size: l
            } = e;
            return ie.jsxs(Gn, {
                pos: "relative", children: [ie.jsxs(Gn, {
                    pos: {lg: "sticky"}, top: {lg: 0}, bg: "blue.1000", zIndex: {lg: "sticky"}, children: [ie.jsxs(Gn, {
                        display: "flex",
                        _hover: {bg: "blue.950"},
                        children: [ie.jsxs(ZI, {
                            to: "/watchlist",
                            bg: "transparent",
                            flex: 1,
                            display: "flex",
                            alignItems: "center",
                            fontSize: {base: "lg", lg: "xs"},
                            fontWeight: "semibold",
                            textTransform: "uppercase",
                            color: "white",
                            px: 3,
                            py: {base: 2, lg: "10px"},
                            _hover: {textDecor: "none"},
                            children: [ie.jsx(Wi, {as: lYt, boxSize: "16px", mr: 1}), "Watchlist"]
                        }), ie.jsx(cu, {
                            onClick: r,
                            display: {base: "none", lg: "flex"},
                            minW: "26px",
                            variant: "unstyled",
                            icon: ie.jsx(Wi, {as: NKt, boxSize: "16px"}),
                            "aria-label": "Minimize watchlist",
                            title: "Minimize watchlist",
                            h: "auto",
                            borderRadius: "none",
                            color: "blue.600",
                            _hover: {color: "white"},
                            _focus: {boxShadow: "none"},
                            isDisabled: a,
                            sx: {"&:disabled, &:disabled:hover": {opacity: .075, color: "white", cursor: "inherit"}}
                        }), ie.jsx(cu, {
                            onClick: n,
                            display: {base: "none", lg: "flex"},
                            minW: "30px",
                            variant: "unstyled",
                            icon: ie.jsx(Wi, {as: AQt[l], boxSize: "16px"}),
                            "aria-label": o ? "Collapse watchlist" : "Expand watchlist",
                            title: o ? "Collapse watchlist" : "Expand watchlist",
                            h: "auto",
                            borderRadius: "none",
                            color: "blue.600",
                            _hover: {color: "white"},
                            _focus: {boxShadow: "none"}
                        })]
                    }), s ? ie.jsx(TQt, {}) : null]
                }), i ? ie.jsx(yQt, {}) : null]
            })
        }
    })
}, kQt = Wpt(IQt, {id: "nav-watchlist", FallbackComponent: uYt}), sD = t => ({
    flex: {lg: t.collapseNav ? void 0 : 1},
    variant: "unstyled",
    display: "flex",
    minW: {base: "50px", lg: "auto"},
    h: "auto",
    py: {base: 3, lg: 2},
    color: "white",
    borderRadius: {base: "md", lg: "none"},
    _hover: {"@media (hover: hover)": {bg: "blue.950"}},
    _focus: {boxShadow: "none"}
}), RQt = ({onToggleColorMode: t}) => {
    const {settings: e} = lg(), {colorMode: r, toggleColorMode: n} = S1(),
        i = r === "light" ? "Lights off" : "Lights on", a = () => {
            n(), t()
        };
    return ie.jsx(ie.Fragment, {
        children: ie.jsxs(fL, {
            direction: {
                base: "row",
                lg: e.ui.collapseNav ? "column" : void 0
            },
            spacing: {base: 4, lg: 0},
            justifyContent: "center",
            children: [ie.jsx(cu, {
                as: Bf,
                icon: ie.jsx(Wi, {as: wKt, boxSize: {base: "20px", lg: "18px"}}),
                "aria-label": "Twitter",
                title: "Follow us on Twitter",
                href: "https://twitter.com/dexscreener",
                target: "_blank",
                rel: "noopener noreferrer", ...sD({collapseNav: e.ui.collapseNav})
            }), ie.jsx(cu, {
                as: Bf,
                icon: ie.jsx(Wi, {as: bKt, boxSize: "20px"}),
                "aria-label": "Telegram",
                title: "Join us on Telegram",
                href: VKt,
                target: "_blank",
                rel: "noopener noreferrer", ...sD({collapseNav: e.ui.collapseNav})
            }), ie.jsx(cu, {
                as: Bf,
                icon: ie.jsx(Wi, {as: yKt, boxSize: "20px"}),
                "aria-label": "Telegram",
                title: "Join us on Discord",
                href: wke,
                target: "_blank",
                rel: "noopener noreferrer", ...sD({collapseNav: e.ui.collapseNav})
            }), ie.jsx(cu, {
                "aria-label": i,
                title: i,
                icon: ie.jsx(Wi, {as: r === "light" ? LKt : UKt, boxSize: "17px"}),
                onClick: a, ...sD({collapseNav: e.ui.collapseNav})
            })]
        })
    })
}, DQt = ({isNavOpen: t}) => {
    const e = R3(oye), r = aa(k2e);
    if (t) return ie.jsx(bke, {});
    switch (e == null ? void 0 : e.id) {
        case"watchlist":
            return ie.jsx(yke, {});
        case"multicharts":
            return ie.jsx(Tke, {});
        case"newPairs":
            return ie.jsx(gke, {});
        case"losers":
        case"gainers":
            return ie.jsx(p5e, {});
        case"platform/dex":
        case"platform":
            return ie.jsx("img", {
                className: "ds-nav-header-chain-icon",
                src: r(e.platformId),
                alt: e.platformId,
                loading: "lazy"
            });
        default:
            return ie.jsx(CKt, {})
    }
}, MQt = ({isMobileNavOpen: t, onToggleIsMobileNavOpen: e}) => {
    const {settings: r, setUiSettings: n} = lg(), {headerHeight: i} = QI(), a = Gke(), o = R3(f => f), s = ss(o),
        l = W.useCallback(() => {
            a({query: "", filters: {moonshot: s.current && LP(s.current)}})
        }, [s, a]);
    return ie.jsxs(Gn, {
        pos: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: {base: "space-between", lg: r.ui.collapseNav ? "center" : void 0},
        h: {base: `${i}px`, lg: r.ui.collapseNav ? "auto" : void 0},
        pl: {base: 3, lg: r.ui.collapseNav ? 0 : 3},
        children: [ie.jsx(ZI, {
            to: "/",
            _hover: {textDecoration: "none", opacity: .9},
            children: ie.jsxs(i1, {
                as: "h1",
                display: "flex",
                alignItems: "center",
                mt: {lg: r.ui.collapseNav ? "36px" : void 0},
                color: "white",
                fontSize: "19px",
                children: [ie.jsx(Wi, {
                    as: mke,
                    pos: "relative",
                    top: "2px",
                    mr: {base: "3px", lg: r.ui.collapseNav ? 0 : void 0},
                    color: "white",
                    boxSize: "30px"
                }), ie.jsxs(ln, {
                    as: "span",
                    display: {base: "none", lg: r.ui.collapseNav ? "none" : "initial"},
                    children: [ie.jsx(ln, {as: "span", fontWeight: "semibold", children: "DEX"}), ie.jsx(ln, {
                        ml: "2px",
                        as: "span",
                        fontWeight: "normal",
                        children: "SCREENER"
                    })]
                })]
            })
        }), ie.jsx(Ake, {
            buttonProps: {
                w: "100%",
                maxW: "160px",
                ml: 2,
                padding: 2,
                sx: {display: "none", "@media(min-width: 360px)": {display: {base: "flex", lg: "none"}}}
            }
        }), ie.jsx(aee, {
            label: r.ui.collapseNav ? "Expand menu" : "Collapse menu",
            placement: "right",
            gutter: 3,
            children: ie.jsx(cu, {
                onClick: () => n({collapseNav: !r.ui.collapseNav}),
                display: {base: "none", lg: "flex"},
                pos: "absolute",
                top: 0,
                right: 0,
                bg: r.ui.collapseNav ? "gray.850" : void 0,
                color: "blue.600",
                minW: r.ui.collapseNav ? "100%" : "22px",
                w: "30px",
                h: "27px",
                "aria-label": r.ui.collapseNav ? "Expand menu" : "Collapse menu",
                icon: ie.jsx(Wi, {as: r.ui.collapseNav ? _Kt : SKt, boxSize: "16px"}),
                variant: "unstyled",
                borderRadius: "none",
                _hover: {color: "white"},
                _focus: {boxShadow: "none"}
            }, r.ui.collapseNav ? 1 : 0)
        }), ie.jsxs(Gn, {
            display: {base: "flex", lg: "none"},
            alignItems: "stretch",
            h: "100%",
            children: [ie.jsx(cu, {
                onClick: l,
                "aria-label": "Search",
                icon: ie.jsx(Wi, {as: vke, pos: "relative", top: "2px"}),
                variant: "unstyled",
                h: "100%",
                borderRadius: 0,
                color: "white",
                w: "40px",
                mr: 1,
                _focus: {boxShadow: "none"}
            }), ie.jsx(Hc, {
                onClick: e,
                leftIcon: ie.jsx(DQt, {isNavOpen: t}),
                variant: "unstyled",
                display: "flex",
                alignItems: "center",
                h: "100%",
                borderRadius: 0,
                color: "white",
                textTransform: "uppercase",
                bg: "gray.900",
                _focus: {boxShadow: "none"},
                sx: {w: "105px", "@media (min-width: 375px)": {w: "140px"}},
                children: t ? "Close" : "Explore"
            })]
        })]
    })
}, OQt = () => {
    const t = Gke(), e = R3(o => o), r = ss(e), n = W.useCallback(() => {
        t({query: "", filters: {moonshot: r.current && LP(r.current)}})
    }, [r, t]), i = W.useCallback(o => {
        document.querySelector(".chakra-modal__overlay") || o.target instanceof HTMLElement && ["INPUT", "TEXTAREA"].includes(o.target.tagName) || o.key === "/" && (o.stopPropagation(), o.preventDefault(), t({
            query: "",
            filters: {moonshot: r.current && LP(r.current)}
        }))
    }, [r, t]);
    W.useEffect(() => (document.addEventListener("keydown", i), () => document.removeEventListener("keydown", i)), [i]);
    const {settings: a} = lg();
    return ie.jsx(Gn, {
        mx: {base: 2, lg: a.ui.collapseNav ? 2 : 3},
        children: ie.jsxs(Hc, {
            w: "100%",
            minW: "auto",
            onClick: n,
            display: "flex",
            justifyContent: {lg: a.ui.collapseNav ? "center" : "flex-start"},
            flexShrink: 0,
            variant: "unstyled",
            bg: "blue.900",
            color: "blue.200",
            pl: {base: 4, lg: a.ui.collapseNav ? 0 : void 0},
            pr: {base: 5, lg: a.ui.collapseNav ? 0 : 2},
            h: "36px",
            textAlign: "left",
            _hover: {bg: "blue.850", color: "blue.100"},
            _focus: {boxShadow: "none"},
            children: [ie.jsx(Wi, {as: vke, boxSize: "16px", pos: "relative", top: "-1px"}), ie.jsxs(ln, {
                as: "span",
                w: "100%",
                display: {base: "flex", lg: a.ui.collapseNav ? "none" : void 0},
                children: [ie.jsx(ln, {as: "span", ml: 2, children: "Search"}), ie.jsx(ln, {
                    display: {
                        base: "none",
                        lg: "initial"
                    },
                    as: "span",
                    ml: "auto",
                    borderWidth: 1,
                    borderColor: "blue.600",
                    borderRadius: "sm",
                    fontFamily: "mono",
                    fontSize: "xs",
                    px: "5px",
                    py: "1px",
                    color: "blue.500",
                    children: "/"
                })]
            })]
        })
    })
};
let Qke = () => null;
{
    const t = Us(() => na(() => import("../chunks/nav-login-kKJgs1jO.js"), __vite__mapDeps([10, 1, 11, 12, 8, 13, 14])));
    Qke = () => ie.jsx(W.Suspense, {fallback: null, children: ie.jsx(t, {})})
}
const PQt = () => {
        const t = aa(SB), {pathname: e} = Oo(), {settings: r} = lg(), {navWidth: n} = QI(),
            i = BA({base: !0, lg: !1}, "NON_EXISTING_BREAKPOINT"),
            a = AE(T => T.isMobileNavOpen), {setIsMobileNavOpen: o} = AE(T => T.actions),
            s = ZE(() => t.all.pipe(zn(T => T.watchlistsSize)), [t], void 0);
        W.useEffect(() => {
            a && o(!1)
        }, [e]);
        const l = () => {
            a && o(!1)
        }, f = QIe({
            thumbColor: "blue.700",
            thumbHoverColor: "blue.600",
            thumbBorderRadius: "10px",
            thumbBorderWidth: "1px",
            thumbBorderColor: "blue.900",
            trackBg: "blue.900",
            cornerBg: "black",
            scrollbarWidth: "9px",
            scrollbarWidthFirefox: "thin"
        }), d = Ske(), p = DP(), g = p && !i, b = W.useRef(null);
        W.useEffect(() => {
            var T;
            i && a && ((T = b.current) == null || T.scrollTo({top: 0, left: 0, behavior: "auto"}))
        }, [i, a]);
        const S = d ? `${d}px` : "100vh";
        return ie.jsxs(Gn, {
            flexShrink: 0,
            as: "nav",
            zIndex: "overlay",
            pos: {base: a ? "fixed" : "initial", lg: "initial"},
            w: {base: "100vw", lg: `${n}px`},
            h: {base: a ? S : "auto", lg: S},
            bg: "blue.1000",
            display: "flex",
            flexDir: "column",
            overflow: "hidden",
            borderRightWidth: 1,
            borderRightColor: "blue.900",
            sx: {a: {_focus: {boxShadow: "none"}}},
            children: [ie.jsx(Gn, {
                flexShrink: 0,
                children: ie.jsx(MQt, {isMobileNavOpen: a, onToggleIsMobileNavOpen: () => o(!a)})
            }), ie.jsx(Gn, {
                display: {base: a ? "initial" : "none", lg: "initial"},
                mt: r.ui.collapseNav ? 2 : {base: 2, lg: 0},
                mb: 2,
                flexShrink: 0,
                children: ie.jsx(OQt, {})
            }), ie.jsxs(Gn, {
                overflowY: {base: "auto", lg: "hidden"},
                sx: f,
                display: {base: a ? "flex" : "none", lg: "flex"},
                flex: 1,
                flexDirection: "column",
                borderTopWidth: 1,
                borderColor: "blue.950",
                ref: b,
                children: [ie.jsx(Gn, {
                    order: {base: 1, lg: 0},
                    flex: {
                        lg: Py({
                            value: s,
                            onPending: () => 1,
                            onFailure: () => 1,
                            onSuccess: T => r.ui.collapseNav ? 1 : T === "expanded" ? 0 : 1
                        })
                    },
                    flexDir: "column",
                    overflowY: {lg: "auto"},
                    sx: f,
                    children: Py({
                        value: s,
                        onPending: () => ie.jsx(uW, {}),
                        onFailure: () => ie.jsx(uW, {}),
                        onSuccess: T => r.ui.collapseNav === !1 && T === "expanded" ? null : ie.jsx(uW, {})
                    })
                }), g && Py({
                    value: s,
                    onPending: JC,
                    onFailure: JC,
                    onSuccess: T => ie.jsx(Gn, {
                        order: {base: 2, lg: 1},
                        flexShrink: 1,
                        flexGrow: T === "expanded" ? 1 : void 0,
                        display: {lg: r.ui.collapseNav ? "none" : void 0},
                        minH: {lg: T === "default" ? "120px" : void 0},
                        maxH: {lg: T !== "expanded" ? "36vh" : "100%"},
                        overflowY: {lg: "auto"},
                        mb: {base: "30px", lg: 0},
                        pb: {base: "30px", lg: 0},
                        borderTopWidth: T === "expanded" ? 0 : 1,
                        borderColor: "blue.950",
                        sx: f,
                        children: ie.jsx(kQt, {})
                    })
                }), ie.jsx(Gn, {
                    display: r.ui.collapseNav ? "none" : "flex",
                    order: {base: 0, lg: 2},
                    flexShrink: 0,
                    position: {base: "sticky", lg: "initial"},
                    top: {base: "0", lg: "initial"},
                    children: p && ie.jsx(Qke, {})
                })]
            }), ie.jsx(Gn, {
                display: {base: a ? "initial" : "none", lg: "initial"},
                w: {base: a ? "100vw" : "initial", lg: "initial"},
                bg: "blue.1000",
                flexShrink: 0,
                borderTopWidth: 1,
                borderTopColor: "blue.950",
                children: ie.jsx(RQt, {onToggleColorMode: l})
            })]
        })
    }, NQt = pt(Qut, t => () => {
        const e = W.useMemo(() => t({
            initialValue: typeof window < "u" ? window.navigator.onLine : !1,
            target: typeof window < "u" ? window : new EventTarget
        }), []), r = z_e(e.isConnected, e.isConnected.getValue());
        return W.useEffect(() => () => e.dispose(), [e]), {isConnected: r}
    }), LQt = pt(NQt, t => {
        const e = W.createContext({isConnected: !1, isConnectedRef: {current: !1}});
        return {
            Provider: ({children: n}) => {
                const {isConnected: i} = t(), a = W.useRef(i);
                W.useEffect(() => {
                    a.current = i
                }, [i]);
                const o = {isConnected: i, isConnectedRef: a};
                return ie.jsx(e.Provider, {value: o, children: n})
            }, useNetworkConnectionManager: () => W.useContext(e)
        }
    }), {Provider: BQt, useNetworkConnectionManager: rnr} = LQt({}), $Qt = $i(),
    Tve = W.memo(() => (aa($Qt).DS_WEB_PLAUSIBLE_ENABLED, null)), FQt = t => ({
        ssr: !0, type: "cookie", get: () => t0t(t.cookie, t.cookieName) ?? t.defaultColorMode, set: e => {
            const r = Gpt(t.cookieName, e, {maxAge: 31536e3, path: "/"});
            document.cookie = r
        }
    }), UQt = t => ({
        ssr: !0,
        type: "cookie",
        get: () => t.getSearchParams().get("theme") === "dark" ? "dark" : "light",
        set: ZC
    }), jQt = ({topOffset: t, containerProps: e, cardProps: r, loaderProps: n}) => {
        const {footerHeight: i} = QI();
        return ie.jsx(KJ, {
            w: "100%",
            h: `calc(100vh - ${t ?? 0}px - ${i}px)`, ...e,
            children: ie.jsx(ore, {p: 10, ...r, children: ie.jsx(_B, {size: "md", ...n})})
        })
    };
let Zke = JC, Jke = JC;
const zQt = W.memo(() => {
    const {headerHeight: t} = QI();
    return ie.jsx(jQt, {containerProps: {height: {base: `calc(100vh - ${t}px)`, lg: "100vh"}}})
});

function qc(t, e = ie.jsx(zQt, {})) {
    return W.memo(r => ie.jsx(W.Suspense, {fallback: e, children: ie.jsx(t, {...r})}))
}

{
    const t = qc(Us(() => na(() => import("../chunks/Multicharts-FhK5Hzrb.js"), __vite__mapDeps([15, 16, 17, 18, 8, 19, 20, 7, 21, 22, 23, 24, 25, 26, 27, 28, 29, 1]))));
    Zke = r => DP() ? ie.jsx(t, {activeMultichartId: r.activeMultichartId}) : null;
    const e = qc(Us(() => na(() => import("../chunks/WatchlistPage-3mREoNe9.js"), __vite__mapDeps([30, 20, 31, 17, 18, 8, 19, 7, 32, 33, 6, 9, 23, 24, 1, 11, 34, 35, 36, 37, 13, 38, 39, 40, 21, 22, 25, 26, 27, 28, 29]))));
    Jke = ({timeframe: r, id: n}) => DP() ? ie.jsx(e, {timeframe: r, id: n}) : null
}
const VQt = qc(Us(() => na(() => import("../chunks/a-ads-xVVCI7LE.js"), __vite__mapDeps([41, 18, 1])))),
    HQt = qc(Us(async () => na(() => import("../chunks/404-5UO2BlT5.js"), __vite__mapDeps([42, 1])))),
    WQt = qc(Us(async () => {
        const {HomePage: t} = await na(() => import("../chunks/home-page-xyokd2PU.js"), __vite__mapDeps([43, 32, 33, 8, 17, 18, 19, 20, 7, 6, 9, 23, 24, 1, 11, 34, 35, 37, 13, 38, 39, 44, 31, 36, 40, 45]));
        return {default: t}
    })), qQt = qc(Us(async () => {
        const {NewPairsPage: t} = await na(() => import("../chunks/new-pairs-page-R-GApbMv.js"), __vite__mapDeps([46, 32, 33, 8, 17, 18, 19, 20, 7, 6, 9, 23, 24, 1, 11, 34, 35, 37, 13, 38, 39, 21, 22, 31, 36, 40, 45, 47]));
        return {default: t}
    })), GQt = qc(Us(async () => {
        const {GainersLosersPage: t} = await na(() => import("../chunks/gainers-losers-page-x6ElMps-.js"), __vite__mapDeps([48, 32, 33, 8, 17, 18, 19, 20, 7, 6, 9, 23, 24, 1, 11, 34, 35, 37, 13, 38, 39, 21, 22, 31, 36, 40, 47]));
        return {default: t}
    })),
    KQt = qc(Us(() => na(() => import("../chunks/NewsPage-4XHHLNQ6.js"), __vite__mapDeps([49, 20, 34, 50, 24, 19, 28, 51, 1])))),
    YQt = qc(Us(async () => {
        const {PairDetailPage: t} = await na(() => import("../chunks/PairDetailPage-rCbrBpH5.js"), __vite__mapDeps([52, 1, 32, 33, 8, 17, 18, 19, 20, 7, 6, 9, 23, 24, 11, 34, 35]));
        return {default: t}
    })), Cve = qc(Us(async () => {
        const {PlatformOrDexPage: t} = await na(() => import("../chunks/platform-or-dex-page-zJRhj_TH.js"), __vite__mapDeps([53, 32, 33, 8, 17, 18, 19, 20, 7, 6, 9, 23, 24, 1, 11, 34, 35, 21, 22, 37, 13, 38, 39, 44, 31, 36, 40, 45]));
        return {default: t}
    })),
    XQt = qc(Us(() => na(() => import("../chunks/PortfolioPage-McSFDin9.js"), __vite__mapDeps([54, 55, 39, 19, 11, 6, 7, 8, 9, 17, 18, 20, 36, 32, 33, 23, 24, 1, 34, 35, 21, 22, 50])))),
    QQt = qc(Us(() => na(() => import("../chunks/NanosPage-VTvVPLSg.js"), __vite__mapDeps([56, 1])))),
    ZQt = qc(Us(async () => {
        const {AMMPairDetailModal: t} = await na(() => import("../chunks/AMMPairDetailModal-saMxeh85.js"), __vite__mapDeps([36, 32, 33, 8, 17, 18, 19, 20, 7, 6, 9, 23, 24, 1, 11, 34, 35]));
        return {default: t}
    })), JQt = qc(Us(() => na(() => import("../chunks/app-util-IA2lIN2H.js"), __vite__mapDeps([57, 1])))),
    eZt = qc(Us(async () => {
        const {TroubleshootingPage: t} = await na(() => import("../chunks/troubleshooting-page-8szwPTKY.js"), __vite__mapDeps([58, 35, 8, 9, 16, 38, 39, 19, 1]));
        return {default: t}
    })), tZt = qc(Us(async () => {
        const {ActivePairSearchModal: t} = await na(() => import("../chunks/active-pair-search-modal-vjk4pelz.js"), __vite__mapDeps([59, 26, 17, 18, 8, 19, 20, 7, 27, 28, 1]));
        return {default: t}
    }), null), rZt = qc(Us(async () => {
        const {MoonshotPages: t} = await na(() => import("../chunks/moonshot-L6AjMFUk.js"), __vite__mapDeps([60, 27, 19, 61, 1, 32, 33, 8, 17, 18, 20, 7, 6, 9, 23, 24, 11, 34, 35, 29, 22, 13, 37, 38, 39, 55, 36, 51, 47]));
        return {default: t}
    })), nZt = W.memo(() => {
        const t = R3(oye), e = oQt(), r = sQt(), n = DP();
        return t ? ie.jsxs(ie.Fragment, {
            children: [t.id === "home" && ie.jsx(WQt, {
                page: t.page,
                initialData: t.data,
                timeframe: t.timeframe
            }), LP(t) && ie.jsx(rZt, {route: t}), t.id === "watchlist" && ie.jsx(Jke, {
                timeframe: t.timeframe,
                id: t.watchlistId
            }), t.id === "newPairs" && ie.jsx(qQt, {
                page: t.page,
                initialData: t.data,
                timeframe: t.timeframe
            }), (t.id === "gainers" || t.id === "losers") && ie.jsx(GQt, {
                page: t.page,
                initialData: t.data,
                timeframe: t.timeframe,
                type: t.id
            }), t.id === "news" && ie.jsx(KQt, {initialData: t.data}), t.id === "portfolio" && ie.jsx(XQt, {address: t.address}), t.id === "nanos" && ie.jsx(QQt, {}), t.id === "multicharts" && ie.jsx(Zke, {activeMultichartId: t.multichartId}), t.id === "platform" && ie.jsx(Cve, {
                platformId: t.platformId,
                dexId: null,
                page: t.page,
                initialData: t.data,
                timeframe: t.timeframe
            }), t.id === "platform/dex" && ie.jsx(Cve, {
                platformId: t.platformId,
                dexId: t.dexId,
                page: t.page,
                initialData: t.data,
                timeframe: t.timeframe
            }), t.id === "pairDetail" && ie.jsx(YQt, {
                initialData: t.data,
                platformId: t.platformId,
                pairAddress: t.pairAddress
            }), t.id !== "pairDetail" && e && ie.jsx(ZQt, {
                chainId: e.platformId,
                dexId: e.dexId,
                pairAddress: e.pairAddress,
                onClose: () => r()
            }), t.id === "appUtil" && ie.jsx(JQt, {}), t.id === "troubleshooting" && ie.jsx(eZt, {}), t.id === "a-ads" && ie.jsx(VQt, {}), n && ie.jsx(tZt, {})]
        }) : ie.jsx(HQt, {})
    }), iZt = () => {
        const t = aa(XE);
        W.useEffect(() => {
            if ("serviceWorker" in navigator) {
                navigator.serviceWorker.register("/service-worker.js", {scope: "/"}).catch(i => {
                    console.error("Failed registering service worker", i)
                });
                const n = () => {
                    t.track({event: "pwa:install"})
                };
                return window.addEventListener("appinstalled", n), () => window.removeEventListener("appinstalled", n)
            }
        }, [t]), W.useEffect(() => {
            window.matchMedia("(display-mode: standalone)").matches && t.track({event: "pwa:launch"})
        }, [t]);
        const e = R3(n => n == null ? void 0 : n.id), {pathname: r} = Oo();
        return W.useEffect(() => {
            t.track({event: "screen", data: {path: r, screenName: e ?? r, referrer: document.referrer}}, ["firebase"])
        }, [t, r, e]), W.useEffect(() => {
            (new URLSearchParams(window.location.search).get("embed") === "1" || window !== window.top) && t.track({event: "embed"})
        }, [t]), null
    }, aZt = () => {
        const {colorMode: t} = S1();
        return ie.jsxs(B5e, {
            defer: !1,
            children: [ie.jsx("html", {"data-theme": t}), ie.jsx("body", {className: `chakra-ui-${t}`})]
        })
    }, oZt = _.object({config: _.object({initialColorMode: hZ})}), sZt = $i(), cZt = t => {
        const e = AE(Y => Y.embedSettings), {initializeState: r} = AE(Y => Y.actions);
        W.useEffect(() => {
            r()
        }, [r]);
        const {pathname: n, search: i} = Oo(), a = W.useMemo(() => FQt({
                cookie: t.cookie,
                cookieName: D_e,
                defaultColorMode: oZt.parse(Zme).config.initialColorMode
            }), [t.cookie]), o = W.useMemo(() => UQt({getSearchParams: () => new URLSearchParams(i)}), [i]),
            s = W.useMemo(() => e.isEmbed ? o : a, [e, o, a]), l = aa(sZt), f = W.useMemo(() => {
                let Y = `${l.DS_WEB_URL}${n.toLowerCase()}`;
                return Y !== "/" && (Y = Y.replace(/\/$/, "")), Y
            }, [l.DS_WEB_URL, n]), d = {
                "@context": "http://schema.org",
                "@type": "Organization",
                url: "https://dexscreener.com",
                logo: "https://dexscreener.com/icon-512x512.png",
                name: "DEX Screener",
                sameAs: ["https://twitter.com/dexscreener", "https://www.linkedin.com/company/dex-screener"]
            }, {chains: p, dexes: g, dexSlugs: b, chainSlugs: S} = am(), T = ss(p), I = W.useMemo(() => ({
                findBySlug: async Y => Gte(T.current, Y), start: async () => {
                }, getAll: async () => T.current, getSlugs: async () => S, isChainId: async Y => S.includes(Y)
            }), [S, T]), N = ss(g), P = W.useMemo(() => ({
                findBySlug: async Y => Yte(N.current, Y), start: async () => {
                }, getAll: async () => N.current
            }), [N]), F = W.useMemo(() => ({[a_e.key]: b, [W2e.key]: I, [q2e.key]: P}), [I, P, b]);
        return uQt() ? ie.jsxs(ie.Fragment, {children: ["token not found", ie.jsx(Tve, {})]}) : ie.jsx(I_e, {
            value: F, children: ie.jsx(pIt, {
                theme: Zme, colorModeManager: s, children: ie.jsx(R_e, {
                    id: "root", FallbackComponent: KKt, children: ie.jsx(BQt, {
                        children: ie.jsx(ZGt, {
                            children: ie.jsx(tKt, {
                                children: ie.jsxs(lKt, {
                                    children: [ie.jsx(aZt, {}), ie.jsxs(B5e, {
                                        defer: !1,
                                        children: [ie.jsx("title", {children: "DEX Screener"}), ie.jsx("link", {
                                            rel: "preconnect",
                                            href: "https://fonts.gstatic.com",
                                            crossorigin: !0
                                        }), ie.jsx("link", {rel: "canonical", href: f}), ie.jsx("link", {
                                            rel: "icon",
                                            type: "image/png",
                                            href: "/favicon.png"
                                        }), ie.jsx("link", {
                                            rel: "apple-touch-icon",
                                            href: "/img/apple-touch-icon.png"
                                        }), e.dsApp && ie.jsx("style", {
                                            children: `
                        body {
                          -webkit-touch-callout: none;
                          -webkit-user-select: none;
                          -khtml-user-select: none;
                          -moz-user-select: none;
                          -ms-user-select: none;
                          user-select: none;
                        }
                      `
                                        }), ie.jsx("meta", {
                                            name: "viewport",
                                            content: e.dsApp ? "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" : "width=device-width, initial-scale=1.0"
                                        }), ie.jsx("meta", {
                                            name: "description",
                                            content: "Realtime price charts and trading history on DEXes across Ethereum, BSC, Polygon, Avalanche, Fantom, Harmony, Cronos, Arbitrum, Optimism and more."
                                        }), ie.jsx("meta", {
                                            name: "theme-color",
                                            content: "#000"
                                        }), ie.jsx("meta", {
                                            name: "twitter:site",
                                            content: "@dexscreener"
                                        }), ie.jsx("meta", {
                                            name: "twitter:creator",
                                            content: "@dexscreener"
                                        }), ie.jsx("meta", {
                                            name: "twitter:url",
                                            content: f
                                        }), ie.jsx("meta", {
                                            name: "twitter:app:name:iphone",
                                            content: "DEX Screener"
                                        }), ie.jsx("meta", {
                                            name: "twitter:app:id:iphone",
                                            content: "1631840457"
                                        }), ie.jsx("meta", {
                                            name: "twitter:app:name:googleplay",
                                            content: "DEX Screener"
                                        }), ie.jsx("meta", {
                                            name: "twitter:app:id:googleplay",
                                            content: "com.dexscreener"
                                        }), ie.jsx("meta", {
                                            property: "fb:app_id",
                                            content: "885029892778558"
                                        }), ie.jsx("meta", {
                                            property: "og:site_name",
                                            content: "DEX Screener"
                                        }), ie.jsx("meta", {
                                            property: "og:type",
                                            content: "website"
                                        }), ie.jsx("meta", {
                                            property: "og:url",
                                            content: f
                                        }), ie.jsx("meta", {
                                            property: "og:image",
                                            content: "/img/apple-touch-icon.png"
                                        }), ie.jsx("meta", {
                                            name: "robots",
                                            content: "max-image-preview:large"
                                        }), ie.jsx("link", {
                                            rel: "manifest",
                                            href: "/manifest.json"
                                        }), ie.jsx("script", {type: "application/ld+json", children: JSON.stringify(d)})]
                                    }), ie.jsx(Tve, {}), ie.jsx(iZt, {}), ie.jsxs(Gn, {
                                        display: "flex",
                                        flexDir: {base: "column", lg: "row"},
                                        height: "100vh",
                                        maxHeight: "100dvh",
                                        overflowY: "hidden",
                                        pos: "fixed",
                                        w: "100vw",
                                        top: 0,
                                        children: [(!e.isEmbed || e.nav) && ie.jsx(PQt, {}), ie.jsxs(Gn, {
                                            as: "main",
                                            flex: 1,
                                            height: "100%",
                                            overflowY: "hidden",
                                            position: "relative",
                                            display: "flex",
                                            flexDirection: "column",
                                            children: [ie.jsx(nZt, {}), e.isEmbed && !e.nav && e.branding && ie.jsx(vKt, {})]
                                        })]
                                    })]
                                })
                            })
                        })
                    })
                })
            })
        })
    }, ki = {
        ..._.object({__DS_ENV: wlt}).parse(window).__DS_ENV,
        DS_DATA_RETRY_MAX_ATTEMPTS: 2,
        DS_DATA_LOG_SAMPLING_THRESHOLD: -1,
        DS_DATA_TIME_TO_STALE_IN_MS: 3e4
    }, Ps = Tlt({
        name: ki.DS_WEB_WORKER_LOG_APP_NAME,
        maxLevel: "info",
        stdoutEnabled: ki.DS_WEB_WORKER_LOG_STDOUT_ENABLED,
        httpClient: {fetch},
        endpoint: ki.DS_WEB_WORKER_LOG_STDOUT_ENABLED ? ki.DS_WEB_WORKER_LOG_ENDPOINT : void 0
    }), lZt = hpt, uZt = mpt, fZt = vpt, dZt = hWt({[sr.key]: Ps, [$i.key]: ki}), hZt = dWt({[sr.key]: Ps, [$i.key]: ki}),
    pZt = fWt({[sr.key]: Ps, [$i.key]: ki}), mZt = pWt({[sr.key]: Ps, [$i.key]: ki}),
    vZt = gWt({[sr.key]: Ps, [$i.key]: ki}), gZt = EWt({[sr.key]: Ps, [$i.key]: ki}),
    yZt = SWt({[sr.key]: Ps, [$i.key]: ki}), bZt = xWt({[sr.key]: Ps, [$i.key]: ki}),
    wZt = bWt({[sr.key]: Ps, [$i.key]: ki}), SZt = wWt({[sr.key]: Ps, [$i.key]: ki}),
    _Zt = vWt({[sr.key]: Ps, [$i.key]: ki}), xZt = yWt({[sr.key]: Ps, [$i.key]: ki}),
    EZt = mWt({[sr.key]: Ps, [$i.key]: ki}), TZt = _Wt({[sr.key]: Ps, [$i.key]: ki}), CZt = _Ot({}), BP = [];
ki.DS_WEB_PLAUSIBLE_ENABLED && BP.push(jPt({}));
ki.DS_WEB_FIREBASE_ANALYTICS_ENABLED && BP.push(FPt({[sr.key]: Ps, [$i.key]: ki}));
const AZt = DOt(), IZt = {
        [$i.key]: ki,
        [sr.key]: Ps,
        [Tp.key]: AZt,
        [A_e.key]: YPt({[sr.key]: Ps, [BG.key]: BP}),
        [k5e.key]: window.localStorage,
        [I5e.key]: window,
        [TWt.key]: window,
        [RN.key]: ddt,
        [XO.key]: ki.DS_WEB_DEX_SCREENER_WSS_HOST,
        [s_e.key]: ki.DS_WEB_PAIR_DETAILS_SERVER_HOST,
        [u_e.key]: ki.DS_WEB_DEX_TRENDING_SERVER_HOST,
        [uee.key]: zPt({}),
        [VPt.key]: GPt({[XO.key]: ki.DS_WEB_DEX_SCREENER_WSS_HOST, [sr.key]: Ps}),
        [Gut.key]: NPt({}),
        [oee.key]: pZt,
        [w5e.key]: dZt,
        [b5e.key]: hZt,
        [QMt.key]: mZt,
        [JMt.key]: vZt,
        [x5e.key]: gZt,
        [_5e.key]: bZt,
        [eOt.key]: wZt,
        [ZMt.key]: _Zt,
        [S5e.key]: xZt,
        [pOt.key]: SZt,
        [rOt.key]: yZt,
        [mOt.key]: EZt,
        [C5e.key]: TZt,
        [vOt.key]: CZt,
        [m_e.key]: ki.DS_WEB_CFW_ADS_HOST,
        [L_e.key]: ki.DS_WEB_SCREENSHOTS_HOST,
        [C_e.key]: ki.DS_WEB_NEWS_SERVER_HOST,
        [c_e.key]: ki.DS_WEB_BALANCE_SERVER_HOST,
        [Kge.key]: ki.DS_WEB_ASSETS_HOST,
        [f_e.key]: ki.DS_WEB_HYPE_SERVER_HOST,
        [h_e.key]: ki.DS_WEB_MOONSHOT_SERVER_HOST,
        [BG.key]: BP,
        [g_e.key]: Ps,
        [dpt.key]: lZt,
        [ppt.key]: uZt,
        [v_e.key]: fZt,
        [A5e.key]: 6e4
    }, kZt = () => {
        const t = Oo(), e = B1().first ?? `${t.pathname}${t.search}`, {chains: r} = am(), n = n2().current,
            i = (n == null ? void 0 : n.route) ?? Kke(r, e);
        return ie.jsx(rQt, {value: i, children: ie.jsx(cZt, {cookie: document.cookie})})
    }, RZt = () => {
        const {chains: t} = am();
        return W.useState(() => {
            tQt(t)
        }), ie.jsx(CPt, {children: ie.jsx(kZt, {})})
    }, DZt = () => {
        const t = n2().current, e = (t == null ? void 0 : t.isBrandingEnabled) ?? !0,
            r = (t == null ? void 0 : t.isDsApp) ?? !1;
        return ie.jsx(LWt, {
            isBrandingEnabled: e,
            isDsApp: r,
            initialSearch: window.location.search,
            children: ie.jsx(RZt, {})
        })
    }, MZt = E4e({key: "custom"}), OZt = () => ie.jsx(WWt, {
        children: ie.jsx(L5e, {
            children: ie.jsx(Iwt, {
                value: MZt,
                children: ie.jsx(RIe, {
                    value: void 0,
                    children: ie.jsx(I_e, {
                        value: IZt,
                        children: ie.jsx(UWt, {children: ie.jsx(FDt, {children: ie.jsx(DZt, {})})})
                    })
                })
            })
        })
    }), PZt = () => {
        const t = document.getElementById("root");
        t && MW(t, ie.jsx(OZt, {}))
    }, NZt = Object.freeze(Object.defineProperty({
        __proto__: null,
        onRenderClient: PZt
    }, Symbol.toStringTag, {value: "Module"})),
    LZt = Object.freeze(Object.defineProperty({__proto__: null, default: JC}, Symbol.toStringTag, {value: "Module"})),
    BZt = [{
        configName: "onRenderClient",
        importPath: "/renderer/+onRenderClient.tsx",
        isValueFile: !0,
        exportValues: NZt
    }, {configName: "Page", importPath: "/pages/catch-all/+Page.tsx", isValueFile: !0, exportValues: LZt}], $Zt = {
        onBeforeRenderEnv: {definedAt: {isComputed: !0}, valueSerialized: "null"},
        dataEnv: {definedAt: {isComputed: !0}, valueSerialized: "null"}
    }, nnr = Object.freeze(Object.defineProperty({
        __proto__: null,
        configValuesImported: BZt,
        configValuesSerialized: $Zt
    }, Symbol.toStringTag, {value: "Module"}));
export {
    pt as $,
    aa as A,
    ppt as B,
    vS as C,
    JO as D,
    wI as E,
    tg as F,
    GKt as G,
    ZI as H,
    QI as I,
    Gn as J,
    FDt as K,
    dee as L,
    Us as M,
    UWe as N,
    KJ as O,
    yrr as P,
    NJ as Q,
    F3e as R,
    _I as S,
    ln as T,
    dL as U,
    Dy as V,
    B3e as W,
    $3e as X,
    L3e as Y,
    Hc as Z,
    SI as _,
    rNt as a,
    zn as a$,
    VPt as a0,
    Jn as a1,
    m5t as a2,
    on as a3,
    ARt as a4,
    Kn as a5,
    q3e as a6,
    G6e as a7,
    J6e as a8,
    Wi as a9,
    rrr as aA,
    vL as aB,
    aer as aC,
    $i as aD,
    Os as aE,
    Sr as aF,
    ss as aG,
    zNt as aH,
    fE as aI,
    cNt as aJ,
    Ler as aK,
    dNt as aL,
    Vrr as aM,
    C1 as aN,
    vre as aO,
    Wrr as aP,
    Frr as aQ,
    Bf as aR,
    Wtr as aS,
    ar as aT,
    utr as aU,
    BA as aV,
    lg as aW,
    DKt as aX,
    DP as aY,
    qGt as aZ,
    UXt as a_,
    Btr as aa,
    GS as ab,
    Q6e as ac,
    Z6e as ad,
    iee as ae,
    cu as af,
    bke as ag,
    Rv as ah,
    ct as ai,
    itr as aj,
    n2 as ak,
    yu as al,
    hu as am,
    Xv as an,
    S1 as ao,
    z_e as ap,
    bD as aq,
    dI as ar,
    pI as as,
    hI as at,
    vI as au,
    f5e as av,
    i1 as aw,
    mI as ax,
    AKt as ay,
    Ms as az,
    iTe as b,
    m1e as b$,
    Qy as b0,
    tZ as b1,
    gI as b2,
    Kh as b3,
    Hd as b4,
    $f as b5,
    fL as b6,
    hS as b7,
    $rr as b8,
    Gke as b9,
    Z4 as bA,
    H3e as bB,
    _1 as bC,
    mi as bD,
    Hle as bE,
    Mtr as bF,
    Ptr as bG,
    Uy as bH,
    TIt as bI,
    rf as bJ,
    HDt as bK,
    u5e as bL,
    prr as bM,
    tye as bN,
    v8 as bO,
    Ftr as bP,
    gke as bQ,
    her as bR,
    ytr as bS,
    am as bT,
    bC as bU,
    X1e as bV,
    _Jt as bW,
    k2e as bX,
    bI as bY,
    mtr as bZ,
    yGe as b_,
    Brr as ba,
    B5e as bb,
    dq as bc,
    ZX as bd,
    _Ye as be,
    JKe as bf,
    rd as bg,
    tI as bh,
    Cp as bi,
    W3e as bj,
    rnr as bk,
    ZQ as bl,
    v2e as bm,
    XE as bn,
    _ as bo,
    K5e as bp,
    Per as bq,
    XO as br,
    PPt as bs,
    sr as bt,
    pX as bu,
    lee as bv,
    MS as bw,
    QW as bx,
    T0t as by,
    pqe as bz,
    dE as c,
    Irr as c$,
    hZe as c0,
    S1e as c1,
    L5 as c2,
    yZ as c3,
    uo as c4,
    ZVe as c5,
    Ju as c6,
    Zy as c7,
    v0t as c8,
    HJt as c9,
    YMt as cA,
    cv as cB,
    DC as cC,
    QVt as cD,
    Mer as cE,
    LPt as cF,
    JVt as cG,
    HIt as cH,
    rE as cI,
    Ry as cJ,
    iu as cK,
    Kf as cL,
    Lwt as cM,
    lSt as cN,
    ore as cO,
    RRt as cP,
    brr as cQ,
    gre as cR,
    MDt as cS,
    Drr as cT,
    Ter as cU,
    qWt as cV,
    jXt as cW,
    Arr as cX,
    fQt as cY,
    Rrr as cZ,
    sm as c_,
    Dye as ca,
    jQt as cb,
    _B as cc,
    jJt as cd,
    zfe as ce,
    GJ as cf,
    WKt as cg,
    Kte as ch,
    XP as ci,
    Zer as cj,
    Wd as ck,
    jWt as cl,
    Xer as cm,
    Urr as cn,
    jrr as co,
    AJt as cp,
    _l as cq,
    b5e as cr,
    htr as cs,
    ZE as ct,
    Py as cu,
    RKt as cv,
    gKt as cw,
    YZt as cx,
    aee as cy,
    lrr as cz,
    bLt as d,
    Dtr as d$,
    enr as d0,
    PN as d1,
    MJt as d2,
    DJt as d3,
    Utr as d4,
    oJt as d5,
    kJt as d6,
    vye as d7,
    K1e as d8,
    XT as d9,
    err as dA,
    Xrr as dB,
    Ltr as dC,
    Orr as dD,
    atr as dE,
    zKt as dF,
    XZt as dG,
    Yrr as dH,
    Qrr as dI,
    zut as dJ,
    $Kt as dK,
    Ytr as dL,
    mrr as dM,
    bQt as dN,
    ia as dO,
    PE as dP,
    JMt as dQ,
    I4 as dR,
    py as dS,
    Xa as dT,
    Zrr as dU,
    Otr as dV,
    zWt as dW,
    Qft as dX,
    PRt as dY,
    PJ as dZ,
    _tr as d_,
    KZt as da,
    Rj as db,
    y0t as dc,
    Jrr as dd,
    vke as de,
    aE as df,
    LA as dg,
    Rtr as dh,
    wer as di,
    ber as dj,
    ler as dk,
    Ttr as dl,
    per as dm,
    ger as dn,
    ir as dp,
    qa as dq,
    JWt as dr,
    Oo as ds,
    SJt as dt,
    Etr as du,
    HKe as dv,
    PJt as dw,
    Ner as dx,
    QJt as dy,
    Itr as dz,
    jer as e,
    Yer as e$,
    vtr as e0,
    gtr as e1,
    Xtr as e2,
    jKt as e3,
    ktr as e4,
    X6e as e5,
    Crr as e6,
    wQt as e7,
    Gte as e8,
    BKt as e9,
    YVe as eA,
    orr as eB,
    wtr as eC,
    AE as eD,
    hrr as eE,
    za as eF,
    T4e as eG,
    mOt as eH,
    LN as eI,
    eer as eJ,
    ier as eK,
    Dv as eL,
    Der as eM,
    tn as eN,
    YX as eO,
    rtr as eP,
    xze as eQ,
    uer as eR,
    yer as eS,
    rJt as eT,
    dbe as eU,
    fv as eV,
    kKt as eW,
    IKt as eX,
    xrr as eY,
    _rr as eZ,
    au as e_,
    OKt as ea,
    Atr as eb,
    M_e as ec,
    yue as ed,
    ek as ee,
    srr as ef,
    V_e as eg,
    SB as eh,
    qrr as ei,
    _Qt as ej,
    T5e as ek,
    Zb as el,
    xWe as em,
    _We as en,
    op as eo,
    zrr as ep,
    Trr as eq,
    rOt as er,
    BJt as es,
    mn as et,
    LQt as eu,
    Grr as ev,
    VIt as ew,
    XJt as ex,
    i_e as ey,
    nrr as ez,
    yS as f,
    yKt as f$,
    Qer as f0,
    ZWt as f1,
    iHe as f2,
    Cn as f3,
    trr as f4,
    crr as f5,
    e5e as f6,
    r_e as f7,
    NN as f8,
    Kv as f9,
    ltr as fA,
    jIt as fB,
    aHe as fC,
    yB as fD,
    xer as fE,
    Htr as fF,
    m5e as fG,
    Yht as fH,
    WW as fI,
    qW as fJ,
    eJt as fK,
    eHe as fL,
    lue as fM,
    due as fN,
    hue as fO,
    fue as fP,
    h7 as fQ,
    pZ as fR,
    UJt as fS,
    kle as fT,
    _er as fU,
    Cer as fV,
    qtr as fW,
    str as fX,
    otr as fY,
    ser as fZ,
    bKt as f_,
    ma as fa,
    Jh as fb,
    Uwt as fc,
    Ztr as fd,
    NKt as fe,
    BWt as ff,
    jM as fg,
    kr as fh,
    $P as fi,
    cJt as fj,
    TRt as fk,
    vA as fl,
    i3 as fm,
    E1 as fn,
    qw as fo,
    JJt as fp,
    Khe as fq,
    G3e as fr,
    $It as fs,
    n3 as ft,
    mS as fu,
    a3 as fv,
    _Dt as fw,
    Tp as fx,
    fqt as fy,
    ctr as fz,
    Tr as g,
    J2e as g$,
    Jv as g0,
    Ier as g1,
    Eer as g2,
    Vtr as g3,
    vrr as g4,
    fer as g5,
    j0 as g6,
    fke as g7,
    AIt as g8,
    Krr as g9,
    jZe as gA,
    $Qe as gB,
    RJt as gC,
    XQe as gD,
    upt as gE,
    fpt as gF,
    dpt as gG,
    QVe as gH,
    PZe as gI,
    Ly as gJ,
    p_e as gK,
    l1e as gL,
    VJt as gM,
    zJt as gN,
    Mv as gO,
    ZW as gP,
    SQt as gQ,
    lYt as gR,
    nee as gS,
    Eve as gT,
    xQt as gU,
    ptr as gV,
    dtr as gW,
    Gr as gX,
    Bs as gY,
    Ci as gZ,
    US as g_,
    urr as ga,
    rSt as gb,
    mer as gc,
    Rer as gd,
    cer as ge,
    krr as gf,
    Err as gg,
    Ser as gh,
    X2e as gi,
    R3 as gj,
    der as gk,
    ker as gl,
    Aer as gm,
    grr as gn,
    Qtr as go,
    mZ as gp,
    oer as gq,
    m2e as gr,
    g0t as gs,
    JC as gt,
    Hrr as gu,
    Kge as gv,
    ii as gw,
    Nn as gx,
    SX as gy,
    g8 as gz,
    zer as h,
    pWe as h$,
    dht as h0,
    pht as h1,
    vht as h2,
    yht as h3,
    Q2e as h4,
    Z2e as h5,
    OJt as h6,
    IJt as h7,
    yX as h8,
    xX as h9,
    Uhe as hA,
    o3e as hB,
    Jde as hC,
    Zde as hD,
    Tv as hE,
    GTt as hF,
    lo as hG,
    kJ as hH,
    uf as hI,
    cCt as hJ,
    zy as hK,
    JAt as hL,
    h3e as hM,
    Dpe as hN,
    gMt as hO,
    pMt as hP,
    QMt as hQ,
    rZe as hR,
    ZMt as hS,
    eOt as hT,
    Xt as hU,
    kt as hV,
    Gu as hW,
    qq as hX,
    Fut as hY,
    TWt as hZ,
    vOt as h_,
    bv as ha,
    tWe as hb,
    TX as hc,
    iS as hd,
    zM as he,
    z8 as hf,
    EJt as hg,
    QQ as hh,
    IEe as hi,
    nE as hj,
    dEe as hk,
    n3e as hl,
    fJ as hm,
    jv as hn,
    Ta as ho,
    the as hp,
    vp as hq,
    MA as hr,
    i3e as hs,
    lCt as ht,
    Ks as hu,
    oI as hv,
    ECt as hw,
    ZAt as hx,
    $8t as hy,
    B8t as hz,
    eP as i,
    Nrr as i$,
    YW as i0,
    Mye as i1,
    AX as i2,
    Gut as i3,
    CJt as i4,
    GZt as i5,
    Rze as i6,
    NJt as i7,
    iJt as i8,
    nJt as i9,
    FJt as iA,
    xke as iB,
    ftr as iC,
    oye as iD,
    ner as iE,
    Gtr as iF,
    wrr as iG,
    ZZt as iH,
    ttr as iI,
    bJt as iJ,
    TKt as iK,
    xKt as iL,
    EKt as iM,
    R_e as iN,
    Ker as iO,
    Mrr as iP,
    xtr as iQ,
    ztr as iR,
    aJt as iS,
    Ctr as iT,
    Jtr as iU,
    jDt as iV,
    ntr as iW,
    nSt as iX,
    VZe as iY,
    UDt as iZ,
    Js as i_,
    q8t as ia,
    EIt as ib,
    YJt as ic,
    wC as id,
    V6e as ie,
    z6e as ig,
    f7t as ih,
    jRt as ii,
    ter as ij,
    d7t as ik,
    zc as il,
    tp as im,
    FRt as io,
    pOt as ip,
    Srr as iq,
    Oer as ir,
    $Jt as is,
    $tr as it,
    Odt as iu,
    MRt as iv,
    etr as iw,
    LJt as ix,
    JZt as iy,
    $ye as iz,
    wLt as j,
    TJt as j0,
    UM as j1,
    rer as j2,
    vWe as j3,
    fze as j4,
    wJt as j5,
    sJt as j6,
    frr as j7,
    jtr as j8,
    ver as j9,
    J3e as jA,
    cI as jB,
    X3e as jC,
    _0 as jD,
    nM as jE,
    rM as jF,
    a5e as jG,
    nkt as jH,
    sDt as jI,
    ikt as jJ,
    LQ as jK,
    WJt as jL,
    Qce as jM,
    uJt as jN,
    nnr as jO,
    xJt as ja,
    uw as jb,
    Jer as jc,
    V8 as jd,
    Zft as je,
    Ntr as jf,
    MKt as jg,
    WZt as jh,
    Lrr as ji,
    btr as jj,
    tnr as jk,
    Str as jl,
    irr as jm,
    Wpt as jn,
    Prr as jo,
    QZt as jp,
    arr as jq,
    drr as jr,
    Ktr as js,
    _Kt as jt,
    SKt as ju,
    VKt as jv,
    AIe as jw,
    s0t as jx,
    IWt as jy,
    OWt as jz,
    Her as k,
    Ver as l,
    xLt as m,
    Ber as n,
    Wer as o,
    eTe as p,
    ZPt as q,
    Kw as r,
    qer as s,
    iNt as t,
    Fer as u,
    $er as v,
    Q5e as w,
    W as x,
    ie as y,
    ZC as z
};

function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = ["assets/chunks/index.esm-bcL8Zxqs.js", "assets/chunks/preload-helper-Jimfoxkq.js", "assets/chunks/index.esm-iIE-CZzH.js", "assets/chunks/index.esm-JifkhCEc.js", "assets/chunks/index.esm-P1WENdMj.js", "assets/chunks/price-alerts-overview-modal-9gklq1eR.js", "assets/chunks/price-alerts-button-wO0K_R9K.js", "assets/chunks/embed-feature-disabled-modal-cf8WSzVA.js", "assets/chunks/span-PjwCQCyI.js", "assets/chunks/use-observable-memo-4HV4LjFn.js", "assets/chunks/nav-login-kKJgs1jO.js", "assets/chunks/index.esm-Iy9nVT7U.js", "assets/chunks/index.esm-F6wuoNhz.js", "assets/chunks/upperFirst-ovMuif-N.js", "assets/static/nav-login.llgnnYHi.css", "assets/chunks/Multicharts-FhK5Hzrb.js", "assets/chunks/get-pairs-use-case-rPkVPhFl.js", "assets/chunks/dex-search.service-TIwqq6Pl.js", "assets/chunks/display-a-ads-ad-ILDyNSYs.js", "assets/chunks/catchError-X-LkCcQN.js", "assets/chunks/ads-provider-o8FM7uFz.js", "assets/chunks/breakable-subnav-RBkQpev0.js", "assets/chunks/merge-refs-HhAXPaGn.js", "assets/chunks/conditional-wrap-xdVdGWwF.js", "assets/chunks/util-hGGZbKlM.js", "assets/chunks/pair-search-modal-r97Fz3uT.js", "assets/chunks/controlled-pair-search-modal-QbGRquvf.js", "assets/chunks/logo-z6UjBaPp.js", "assets/chunks/chunk-ZPFGWTBB-eA1Xb1kz.js", "assets/chunks/chunk-CWVAJCXJ-8FWqrA86.js", "assets/chunks/WatchlistPage-3mREoNe9.js", "assets/chunks/dex-screener-oUQbNmDY.js", "assets/chunks/dex-pair-details-alTbHiVf.js", "assets/chunks/delayed-N7hotTnG.js", "assets/chunks/time-ago-g6wnypmd.js", "assets/chunks/live-time-ago-yOw-Yvyn.js", "assets/chunks/AMMPairDetailModal-saMxeh85.js", "assets/chunks/dex-screener-context-N0fQQf9I.js", "assets/chunks/useDEXScreenerPubSubConnection-Pp2vuNR8.js", "assets/chunks/use-websocket-client-g0aNRF5B.js", "assets/static/dex-screener.h_ZGsmXn.css", "assets/chunks/a-ads-xVVCI7LE.js", "assets/chunks/404-5UO2BlT5.js", "assets/chunks/home-page-xyokd2PU.js", "assets/chunks/screener-presets-util-h3UJOobQ.js", "assets/chunks/screener-control-presets-group-u3L1CHcq.js", "assets/chunks/new-pairs-page-R-GApbMv.js", "assets/chunks/screener-control-value-selector-_qTqCQVz.js", "assets/chunks/gainers-losers-page-x6ElMps-.js", "assets/chunks/NewsPage-4XHHLNQ6.js", "assets/chunks/useLocation-0PITJySO.js", "assets/chunks/chunk-QINAG4RG-Jo5ZTGnd.js", "assets/chunks/PairDetailPage-rCbrBpH5.js", "assets/chunks/platform-or-dex-page-zJRhj_TH.js", "assets/chunks/PortfolioPage-McSFDin9.js", "assets/chunks/portfolio-screener-provider-hb_tjDw7.js", "assets/chunks/NanosPage-VTvVPLSg.js", "assets/chunks/app-util-IA2lIN2H.js", "assets/chunks/troubleshooting-page-8szwPTKY.js", "assets/chunks/active-pair-search-modal-vjk4pelz.js", "assets/chunks/moonshot-L6AjMFUk.js", "assets/chunks/moonshot-wallet-adapter-lhT5xr0B.js"]
    }
    return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
